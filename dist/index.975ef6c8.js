// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"farZc":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "890e741a975ef6c8";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    if (HMR_USE_SSE) ws = new EventSource("/__parcel_hmr");
    else try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    if (ws instanceof WebSocket) {
        ws.onerror = function(e) {
            if (e.message) console.error(e.message);
        };
        ws.onclose = function() {
            console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
        };
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"1xC6H":[function(require,module,exports) {
var Refresh = require("6d18d6bd340e7473");
var ErrorOverlay = require("74ad5ea14201648c");
Refresh.injectIntoGlobalHook(window);
window.$RefreshReg$ = function() {};
window.$RefreshSig$ = function() {
    return function(type) {
        return type;
    };
};
ErrorOverlay.setEditorHandler(function editorHandler(errorLocation) {
    let file = `${errorLocation.fileName}:${errorLocation.lineNumber || 1}:${errorLocation.colNumber || 1}`;
    fetch(`/__parcel_launch_editor?file=${encodeURIComponent(file)}`);
});
ErrorOverlay.startReportingRuntimeErrors({
    onError: function() {}
});
window.addEventListener("parcelhmraccept", ()=>{
    ErrorOverlay.dismissRuntimeErrors();
});

},{"6d18d6bd340e7473":"786KC","74ad5ea14201648c":"1dldy"}],"786KC":[function(require,module,exports) {
"use strict";
module.exports = require("96622d495519d4e");

},{"96622d495519d4e":"hdge7"}],"hdge7":[function(require,module,exports) {
/** @license React v0.9.0
 * react-refresh-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
(function() {
    "use strict";
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 0xeac7;
    var REACT_PORTAL_TYPE = 0xeaca;
    var REACT_FRAGMENT_TYPE = 0xeacb;
    var REACT_STRICT_MODE_TYPE = 0xeacc;
    var REACT_PROFILER_TYPE = 0xead2;
    var REACT_PROVIDER_TYPE = 0xeacd;
    var REACT_CONTEXT_TYPE = 0xeace;
    var REACT_FORWARD_REF_TYPE = 0xead0;
    var REACT_SUSPENSE_TYPE = 0xead1;
    var REACT_SUSPENSE_LIST_TYPE = 0xead8;
    var REACT_MEMO_TYPE = 0xead3;
    var REACT_LAZY_TYPE = 0xead4;
    var REACT_BLOCK_TYPE = 0xead9;
    var REACT_SERVER_BLOCK_TYPE = 0xeada;
    var REACT_FUNDAMENTAL_TYPE = 0xead5;
    var REACT_SCOPE_TYPE = 0xead7;
    var REACT_OPAQUE_ID_TYPE = 0xeae0;
    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
    var REACT_OFFSCREEN_TYPE = 0xeae2;
    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;
    if (typeof Symbol === "function" && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor("react.element");
        REACT_PORTAL_TYPE = symbolFor("react.portal");
        REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
        REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
        REACT_PROFILER_TYPE = symbolFor("react.profiler");
        REACT_PROVIDER_TYPE = symbolFor("react.provider");
        REACT_CONTEXT_TYPE = symbolFor("react.context");
        REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
        REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
        REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
        REACT_MEMO_TYPE = symbolFor("react.memo");
        REACT_LAZY_TYPE = symbolFor("react.lazy");
        REACT_BLOCK_TYPE = symbolFor("react.block");
        REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
        REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
        REACT_SCOPE_TYPE = symbolFor("react.scope");
        REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
        REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
        REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
    }
    var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map; // We never remove these associations.
    // It's OK to reference families, but use WeakMap/Set for types.
    var allFamiliesByID = new Map();
    var allFamiliesByType = new PossiblyWeakMap();
    var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families
    // that have actually been edited here. This keeps checks fast.
    // $FlowIssue
    var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.
    // It is an array of [Family, NextType] tuples.
    var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.
    var helpersByRendererID = new Map();
    var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.
    var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.
    var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.
    // It needs to be weak because we do this even for roots that failed to mount.
    // If there is no WeakMap, we won't attempt to do retrying.
    // $FlowIssue
    var rootElements = typeof WeakMap === "function" ? new WeakMap() : null;
    var isPerformingRefresh = false;
    function computeFullKey(signature) {
        if (signature.fullKey !== null) return signature.fullKey;
        var fullKey = signature.ownKey;
        var hooks;
        try {
            hooks = signature.getCustomHooks();
        } catch (err) {
            // This can happen in an edge case, e.g. if expression like Foo.useSomething
            // depends on Foo which is lazily initialized during rendering.
            // In that case just assume we'll have to remount.
            signature.forceReset = true;
            signature.fullKey = fullKey;
            return fullKey;
        }
        for(var i = 0; i < hooks.length; i++){
            var hook = hooks[i];
            if (typeof hook !== "function") {
                // Something's wrong. Assume we need to remount.
                signature.forceReset = true;
                signature.fullKey = fullKey;
                return fullKey;
            }
            var nestedHookSignature = allSignaturesByType.get(hook);
            if (nestedHookSignature === undefined) continue;
            var nestedHookKey = computeFullKey(nestedHookSignature);
            if (nestedHookSignature.forceReset) signature.forceReset = true;
            fullKey += "\n---\n" + nestedHookKey;
        }
        signature.fullKey = fullKey;
        return fullKey;
    }
    function haveEqualSignatures(prevType, nextType) {
        var prevSignature = allSignaturesByType.get(prevType);
        var nextSignature = allSignaturesByType.get(nextType);
        if (prevSignature === undefined && nextSignature === undefined) return true;
        if (prevSignature === undefined || nextSignature === undefined) return false;
        if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) return false;
        if (nextSignature.forceReset) return false;
        return true;
    }
    function isReactClass(type) {
        return type.prototype && type.prototype.isReactComponent;
    }
    function canPreserveStateBetween(prevType, nextType) {
        if (isReactClass(prevType) || isReactClass(nextType)) return false;
        if (haveEqualSignatures(prevType, nextType)) return true;
        return false;
    }
    function resolveFamily(type) {
        // Only check updated types to keep lookups fast.
        return updatedFamiliesByType.get(type);
    } // If we didn't care about IE11, we could use new Map/Set(iterable).
    function cloneMap(map) {
        var clone = new Map();
        map.forEach(function(value, key) {
            clone.set(key, value);
        });
        return clone;
    }
    function cloneSet(set) {
        var clone = new Set();
        set.forEach(function(value) {
            clone.add(value);
        });
        return clone;
    }
    function performReactRefresh() {
        if (pendingUpdates.length === 0) return null;
        if (isPerformingRefresh) return null;
        isPerformingRefresh = true;
        try {
            var staleFamilies = new Set();
            var updatedFamilies = new Set();
            var updates = pendingUpdates;
            pendingUpdates = [];
            updates.forEach(function(_ref) {
                var family = _ref[0], nextType = _ref[1];
                // Now that we got a real edit, we can create associations
                // that will be read by the React reconciler.
                var prevType = family.current;
                updatedFamiliesByType.set(prevType, family);
                updatedFamiliesByType.set(nextType, family);
                family.current = nextType; // Determine whether this should be a re-render or a re-mount.
                if (canPreserveStateBetween(prevType, nextType)) updatedFamilies.add(family);
                else staleFamilies.add(family);
            }); // TODO: rename these fields to something more meaningful.
            var update = {
                updatedFamilies: updatedFamilies,
                // Families that will re-render preserving state
                staleFamilies: staleFamilies // Families that will be remounted
            };
            helpersByRendererID.forEach(function(helpers) {
                // Even if there are no roots, set the handler on first update.
                // This ensures that if *new* roots are mounted, they'll use the resolve handler.
                helpers.setRefreshHandler(resolveFamily);
            });
            var didError = false;
            var firstError = null; // We snapshot maps and sets that are mutated during commits.
            // If we don't do this, there is a risk they will be mutated while
            // we iterate over them. For example, trying to recover a failed root
            // may cause another root to be added to the failed list -- an infinite loop.
            var failedRootsSnapshot = cloneSet(failedRoots);
            var mountedRootsSnapshot = cloneSet(mountedRoots);
            var helpersByRootSnapshot = cloneMap(helpersByRoot);
            failedRootsSnapshot.forEach(function(root) {
                var helpers = helpersByRootSnapshot.get(root);
                if (helpers === undefined) throw new Error("Could not find helpers for a root. This is a bug in React Refresh.");
                failedRoots.has(root);
                if (rootElements === null) return;
                if (!rootElements.has(root)) return;
                var element = rootElements.get(root);
                try {
                    helpers.scheduleRoot(root, element);
                } catch (err) {
                    if (!didError) {
                        didError = true;
                        firstError = err;
                    } // Keep trying other roots.
                }
            });
            mountedRootsSnapshot.forEach(function(root) {
                var helpers = helpersByRootSnapshot.get(root);
                if (helpers === undefined) throw new Error("Could not find helpers for a root. This is a bug in React Refresh.");
                mountedRoots.has(root);
                try {
                    helpers.scheduleRefresh(root, update);
                } catch (err) {
                    if (!didError) {
                        didError = true;
                        firstError = err;
                    } // Keep trying other roots.
                }
            });
            if (didError) throw firstError;
            return update;
        } finally{
            isPerformingRefresh = false;
        }
    }
    function register(type, id) {
        if (type === null) return;
        if (typeof type !== "function" && typeof type !== "object") return;
         // This can happen in an edge case, e.g. if we register
        // return value of a HOC but it returns a cached component.
        // Ignore anything but the first registration for each type.
        if (allFamiliesByType.has(type)) return;
         // Create family or remember to update it.
        // None of this bookkeeping affects reconciliation
        // until the first performReactRefresh() call above.
        var family = allFamiliesByID.get(id);
        if (family === undefined) {
            family = {
                current: type
            };
            allFamiliesByID.set(id, family);
        } else pendingUpdates.push([
            family,
            type
        ]);
        allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.
        if (typeof type === "object" && type !== null) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                register(type.render, id + "$render");
                break;
            case REACT_MEMO_TYPE:
                register(type.type, id + "$type");
                break;
        }
    }
    function setSignature(type, key) {
        var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;
        allSignaturesByType.set(type, {
            forceReset: forceReset,
            ownKey: key,
            fullKey: null,
            getCustomHooks: getCustomHooks || function() {
                return [];
            }
        });
    } // This is lazily called during first render for a type.
    // It captures Hook list at that time so inline requires don't break comparisons.
    function collectCustomHooksForSignature(type) {
        var signature = allSignaturesByType.get(type);
        if (signature !== undefined) computeFullKey(signature);
    }
    function getFamilyByID(id) {
        return allFamiliesByID.get(id);
    }
    function getFamilyByType(type) {
        return allFamiliesByType.get(type);
    }
    function findAffectedHostInstances(families) {
        var affectedInstances = new Set();
        mountedRoots.forEach(function(root) {
            var helpers = helpersByRoot.get(root);
            if (helpers === undefined) throw new Error("Could not find helpers for a root. This is a bug in React Refresh.");
            var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);
            instancesForRoot.forEach(function(inst) {
                affectedInstances.add(inst);
            });
        });
        return affectedInstances;
    }
    function injectIntoGlobalHook(globalObject) {
        // For React Native, the global hook will be set up by require('react-devtools-core').
        // That code will run before us. So we need to monkeypatch functions on existing hook.
        // For React Web, the global hook will be set up by the extension.
        // This will also run before us.
        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook === undefined) {
            // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.
            // Note that in this case it's important that renderer code runs *after* this method call.
            // Otherwise, the renderer will think that there is no global hook, and won't do the injection.
            var nextID = 0;
            globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
                renderers: new Map(),
                supportsFiber: true,
                inject: function(injected) {
                    return nextID++;
                },
                onScheduleFiberRoot: function(id, root, children) {},
                onCommitFiberRoot: function(id, root, maybePriorityLevel, didError) {},
                onCommitFiberUnmount: function() {}
            };
        } // Here, we just want to get a reference to scheduleRefresh.
        var oldInject = hook.inject;
        hook.inject = function(injected) {
            var id = oldInject.apply(this, arguments);
            if (typeof injected.scheduleRefresh === "function" && typeof injected.setRefreshHandler === "function") // This version supports React Refresh.
            helpersByRendererID.set(id, injected);
            return id;
        }; // Do the same for any already injected roots.
        // This is useful if ReactDOM has already been initialized.
        // https://github.com/facebook/react/issues/17626
        hook.renderers.forEach(function(injected, id) {
            if (typeof injected.scheduleRefresh === "function" && typeof injected.setRefreshHandler === "function") // This version supports React Refresh.
            helpersByRendererID.set(id, injected);
        }); // We also want to track currently mounted roots.
        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;
        var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function() {};
        hook.onScheduleFiberRoot = function(id, root, children) {
            if (!isPerformingRefresh) {
                // If it was intentionally scheduled, don't attempt to restore.
                // This includes intentionally scheduled unmounts.
                failedRoots.delete(root);
                if (rootElements !== null) rootElements.set(root, children);
            }
            return oldOnScheduleFiberRoot.apply(this, arguments);
        };
        hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {
            var helpers = helpersByRendererID.get(id);
            if (helpers === undefined) return;
            helpersByRoot.set(root, helpers);
            var current = root.current;
            var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.
            // This logic is copy-pasted from similar logic in the DevTools backend.
            // If this breaks with some refactoring, you'll want to update DevTools too.
            if (alternate !== null) {
                var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;
                var isMounted = current.memoizedState != null && current.memoizedState.element != null;
                if (!wasMounted && isMounted) {
                    // Mount a new root.
                    mountedRoots.add(root);
                    failedRoots.delete(root);
                } else if (wasMounted && isMounted) ;
                else if (wasMounted && !isMounted) {
                    // Unmount an existing root.
                    mountedRoots.delete(root);
                    if (didError) // We'll remount it on future edits.
                    failedRoots.add(root);
                    else helpersByRoot.delete(root);
                } else if (!wasMounted && !isMounted) {
                    if (didError) // We'll remount it on future edits.
                    failedRoots.add(root);
                }
            } else // Mount a new root.
            mountedRoots.add(root);
            return oldOnCommitFiberRoot.apply(this, arguments);
        };
    }
    function hasUnrecoverableErrors() {
        // TODO: delete this after removing dependency in RN.
        return false;
    } // Exposed for testing.
    function _getMountedRootCount() {
        return mountedRoots.size;
    } // This is a wrapper over more primitive functions for setting signature.
    // Signatures let us decide whether the Hook order has changed on refresh.
    //
    // This function is intended to be used as a transform target, e.g.:
    // var _s = createSignatureFunctionForTransform()
    //
    // function Hello() {
    //   const [foo, setFoo] = useState(0);
    //   const value = useCustomHook();
    //   _s(); /* Second call triggers collecting the custom Hook list.
    //          * This doesn't happen during the module evaluation because we
    //          * don't want to change the module order with inline requires.
    //          * Next calls are noops. */
    //   return <h1>Hi</h1>;
    // }
    //
    // /* First call specifies the signature: */
    // _s(
    //   Hello,
    //   'useState{[foo, setFoo]}(0)',
    //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
    // );
    function createSignatureFunctionForTransform() {
        // We'll fill in the signature in two steps.
        // First, we'll know the signature itself. This happens outside the component.
        // Then, we'll know the references to custom Hooks. This happens inside the component.
        // After that, the returned function will be a fast path no-op.
        var status = "needsSignature";
        var savedType;
        var hasCustomHooks;
        return function(type, key, forceReset, getCustomHooks) {
            switch(status){
                case "needsSignature":
                    if (type !== undefined) {
                        // If we received an argument, this is the initial registration call.
                        savedType = type;
                        hasCustomHooks = typeof getCustomHooks === "function";
                        setSignature(type, key, forceReset, getCustomHooks); // The next call we expect is from inside a function, to fill in the custom Hooks.
                        status = "needsCustomHooks";
                    }
                    break;
                case "needsCustomHooks":
                    if (hasCustomHooks) collectCustomHooksForSignature(savedType);
                    status = "resolved";
                    break;
            }
            return type;
        };
    }
    function isLikelyComponentType(type) {
        switch(typeof type){
            case "function":
                // First, deal with classes.
                if (type.prototype != null) {
                    if (type.prototype.isReactComponent) // React class.
                    return true;
                    var ownNames = Object.getOwnPropertyNames(type.prototype);
                    if (ownNames.length > 1 || ownNames[0] !== "constructor") // This looks like a class.
                    return false;
                     // eslint-disable-next-line no-proto
                    if (type.prototype.__proto__ !== Object.prototype) // It has a superclass.
                    return false;
                     // Pass through.
                // This looks like a regular function with empty prototype.
                } // For plain functions and arrows, use name as a heuristic.
                var name = type.name || type.displayName;
                return typeof name === "string" && /^[A-Z]/.test(name);
            case "object":
                if (type != null) switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_MEMO_TYPE:
                        // Definitely React components.
                        return true;
                    default:
                        return false;
                }
                return false;
            default:
                return false;
        }
    }
    exports._getMountedRootCount = _getMountedRootCount;
    exports.collectCustomHooksForSignature = collectCustomHooksForSignature;
    exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;
    exports.findAffectedHostInstances = findAffectedHostInstances;
    exports.getFamilyByID = getFamilyByID;
    exports.getFamilyByType = getFamilyByType;
    exports.hasUnrecoverableErrors = hasUnrecoverableErrors;
    exports.injectIntoGlobalHook = injectIntoGlobalHook;
    exports.isLikelyComponentType = isLikelyComponentType;
    exports.performReactRefresh = performReactRefresh;
    exports.register = register;
    exports.setSignature = setSignature;
})();

},{}],"1dldy":[function(require,module,exports) {
var process = require("d1546958eb39fdcf");
!function(e, t) {
    module.exports = t();
}(window, function() {
    return function(e) {
        var t = {};
        function r(n) {
            if (t[n]) return t[n].exports;
            var o = t[n] = {
                i: n,
                l: !1,
                exports: {}
            };
            return e[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports;
        }
        return r.m = e, r.c = t, r.d = function(e, t, n) {
            r.o(e, t) || Object.defineProperty(e, t, {
                enumerable: !0,
                get: n
            });
        }, r.r = function(e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            });
        }, r.t = function(e, t) {
            if (1 & t && (e = r(e)), 8 & t) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var n = Object.create(null);
            if (r.r(n), Object.defineProperty(n, "default", {
                enumerable: !0,
                value: e
            }), 2 & t && "string" != typeof e) for(var o in e)r.d(n, o, (function(t) {
                return e[t];
            }).bind(null, o));
            return n;
        }, r.n = function(e) {
            var t = e && e.__esModule ? function() {
                return e.default;
            } : function() {
                return e;
            };
            return r.d(t, "a", t), t;
        }, r.o = function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t);
        }, r.p = "", r(r.s = 15);
    }([
        function(e, t, r) {
            e.exports = r(8);
        },
        function(e, t) {
            t.getArg = function(e, t, r) {
                if (t in e) return e[t];
                if (3 === arguments.length) return r;
                throw new Error('"' + t + '" is a required argument.');
            };
            var r = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/, n = /^data:.+\,.+$/;
            function o(e) {
                var t = e.match(r);
                return t ? {
                    scheme: t[1],
                    auth: t[2],
                    host: t[3],
                    port: t[4],
                    path: t[5]
                } : null;
            }
            function a(e) {
                var t = "";
                return e.scheme && (t += e.scheme + ":"), t += "//", e.auth && (t += e.auth + "@"), e.host && (t += e.host), e.port && (t += ":" + e.port), e.path && (t += e.path), t;
            }
            function i(e) {
                var r = e, n = o(e);
                if (n) {
                    if (!n.path) return e;
                    r = n.path;
                }
                for(var i, l = t.isAbsolute(r), u = r.split(/\/+/), c = 0, s = u.length - 1; s >= 0; s--)"." === (i = u[s]) ? u.splice(s, 1) : ".." === i ? c++ : c > 0 && ("" === i ? (u.splice(s + 1, c), c = 0) : (u.splice(s, 2), c--));
                return "" === (r = u.join("/")) && (r = l ? "/" : "."), n ? (n.path = r, a(n)) : r;
            }
            t.urlParse = o, t.urlGenerate = a, t.normalize = i, t.join = function(e, t) {
                "" === e && (e = "."), "" === t && (t = ".");
                var r = o(t), l = o(e);
                if (l && (e = l.path || "/"), r && !r.scheme) return l && (r.scheme = l.scheme), a(r);
                if (r || t.match(n)) return t;
                if (l && !l.host && !l.path) return l.host = t, a(l);
                var u = "/" === t.charAt(0) ? t : i(e.replace(/\/+$/, "") + "/" + t);
                return l ? (l.path = u, a(l)) : u;
            }, t.isAbsolute = function(e) {
                return "/" === e.charAt(0) || !!e.match(r);
            }, t.relative = function(e, t) {
                "" === e && (e = "."), e = e.replace(/\/$/, "");
                for(var r = 0; 0 !== t.indexOf(e + "/");){
                    var n = e.lastIndexOf("/");
                    if (n < 0) return t;
                    if ((e = e.slice(0, n)).match(/^([^\/]+:\/)?\/*$/)) return t;
                    ++r;
                }
                return Array(r + 1).join("../") + t.substr(e.length + 1);
            };
            var l = !("__proto__" in Object.create(null));
            function u(e) {
                return e;
            }
            function c(e) {
                if (!e) return !1;
                var t = e.length;
                if (t < 9) return !1;
                if (95 !== e.charCodeAt(t - 1) || 95 !== e.charCodeAt(t - 2) || 111 !== e.charCodeAt(t - 3) || 116 !== e.charCodeAt(t - 4) || 111 !== e.charCodeAt(t - 5) || 114 !== e.charCodeAt(t - 6) || 112 !== e.charCodeAt(t - 7) || 95 !== e.charCodeAt(t - 8) || 95 !== e.charCodeAt(t - 9)) return !1;
                for(var r = t - 10; r >= 0; r--)if (36 !== e.charCodeAt(r)) return !1;
                return !0;
            }
            function s(e, t) {
                return e === t ? 0 : e > t ? 1 : -1;
            }
            t.toSetString = l ? u : function(e) {
                return c(e) ? "$" + e : e;
            }, t.fromSetString = l ? u : function(e) {
                return c(e) ? e.slice(1) : e;
            }, t.compareByOriginalPositions = function(e, t, r) {
                var n = e.source - t.source;
                return 0 !== n ? n : 0 !== (n = e.originalLine - t.originalLine) ? n : 0 !== (n = e.originalColumn - t.originalColumn) || r ? n : 0 !== (n = e.generatedColumn - t.generatedColumn) ? n : 0 !== (n = e.generatedLine - t.generatedLine) ? n : e.name - t.name;
            }, t.compareByGeneratedPositionsDeflated = function(e, t, r) {
                var n = e.generatedLine - t.generatedLine;
                return 0 !== n ? n : 0 !== (n = e.generatedColumn - t.generatedColumn) || r ? n : 0 !== (n = e.source - t.source) ? n : 0 !== (n = e.originalLine - t.originalLine) ? n : 0 !== (n = e.originalColumn - t.originalColumn) ? n : e.name - t.name;
            }, t.compareByGeneratedPositionsInflated = function(e, t) {
                var r = e.generatedLine - t.generatedLine;
                return 0 !== r ? r : 0 !== (r = e.generatedColumn - t.generatedColumn) ? r : 0 !== (r = s(e.source, t.source)) ? r : 0 !== (r = e.originalLine - t.originalLine) ? r : 0 !== (r = e.originalColumn - t.originalColumn) ? r : s(e.name, t.name);
            };
        },
        function(e, t) {
            function r(e, t) {
                for(var r = 0, n = e.length - 1; n >= 0; n--){
                    var o = e[n];
                    "." === o ? e.splice(n, 1) : ".." === o ? (e.splice(n, 1), r++) : r && (e.splice(n, 1), r--);
                }
                if (t) for(; r--; r)e.unshift("..");
                return e;
            }
            function n(e, t) {
                if (e.filter) return e.filter(t);
                for(var r = [], n = 0; n < e.length; n++)t(e[n], n, e) && r.push(e[n]);
                return r;
            }
            t.resolve = function() {
                for(var e = "", t = !1, o = arguments.length - 1; o >= -1 && !t; o--){
                    var a = o >= 0 ? arguments[o] : process.cwd();
                    if ("string" != typeof a) throw new TypeError("Arguments to path.resolve must be strings");
                    a && (e = a + "/" + e, t = "/" === a.charAt(0));
                }
                return (t ? "/" : "") + (e = r(n(e.split("/"), function(e) {
                    return !!e;
                }), !t).join("/")) || ".";
            }, t.normalize = function(e) {
                var a = t.isAbsolute(e), i = "/" === o(e, -1);
                return (e = r(n(e.split("/"), function(e) {
                    return !!e;
                }), !a).join("/")) || a || (e = "."), e && i && (e += "/"), (a ? "/" : "") + e;
            }, t.isAbsolute = function(e) {
                return "/" === e.charAt(0);
            }, t.join = function() {
                var e = Array.prototype.slice.call(arguments, 0);
                return t.normalize(n(e, function(e, t) {
                    if ("string" != typeof e) throw new TypeError("Arguments to path.join must be strings");
                    return e;
                }).join("/"));
            }, t.relative = function(e, r) {
                function n(e) {
                    for(var t = 0; t < e.length && "" === e[t]; t++);
                    for(var r = e.length - 1; r >= 0 && "" === e[r]; r--);
                    return t > r ? [] : e.slice(t, r - t + 1);
                }
                e = t.resolve(e).substr(1), r = t.resolve(r).substr(1);
                for(var o = n(e.split("/")), a = n(r.split("/")), i = Math.min(o.length, a.length), l = i, u = 0; u < i; u++)if (o[u] !== a[u]) {
                    l = u;
                    break;
                }
                var c = [];
                for(u = l; u < o.length; u++)c.push("..");
                return (c = c.concat(a.slice(l))).join("/");
            }, t.sep = "/", t.delimiter = ":", t.dirname = function(e) {
                if ("string" != typeof e && (e += ""), 0 === e.length) return ".";
                for(var t = e.charCodeAt(0), r = 47 === t, n = -1, o = !0, a = e.length - 1; a >= 1; --a)if (47 === (t = e.charCodeAt(a))) {
                    if (!o) {
                        n = a;
                        break;
                    }
                } else o = !1;
                return -1 === n ? r ? "/" : "." : r && 1 === n ? "/" : e.slice(0, n);
            }, t.basename = function(e, t) {
                var r = function(e) {
                    "string" != typeof e && (e += "");
                    var t, r = 0, n = -1, o = !0;
                    for(t = e.length - 1; t >= 0; --t)if (47 === e.charCodeAt(t)) {
                        if (!o) {
                            r = t + 1;
                            break;
                        }
                    } else -1 === n && (o = !1, n = t + 1);
                    return -1 === n ? "" : e.slice(r, n);
                }(e);
                return t && r.substr(-1 * t.length) === t && (r = r.substr(0, r.length - t.length)), r;
            }, t.extname = function(e) {
                "string" != typeof e && (e += "");
                for(var t = -1, r = 0, n = -1, o = !0, a = 0, i = e.length - 1; i >= 0; --i){
                    var l = e.charCodeAt(i);
                    if (47 !== l) -1 === n && (o = !1, n = i + 1), 46 === l ? -1 === t ? t = i : 1 !== a && (a = 1) : -1 !== t && (a = -1);
                    else if (!o) {
                        r = i + 1;
                        break;
                    }
                }
                return -1 === t || -1 === n || 0 === a || 1 === a && t === n - 1 && t === r + 1 ? "" : e.slice(t, n);
            };
            var o = "b" === "ab".substr(-1) ? function(e, t, r) {
                return e.substr(t, r);
            } : function(e, t, r) {
                return t < 0 && (t = e.length + t), e.substr(t, r);
            };
        },
        function(e, t, r) {
            t.SourceMapGenerator = r(4).SourceMapGenerator, t.SourceMapConsumer = r(11).SourceMapConsumer, t.SourceNode = r(14).SourceNode;
        },
        function(e, t, r) {
            var n = r(5), o = r(1), a = r(6).ArraySet, i = r(10).MappingList;
            function l(e) {
                e || (e = {}), this._file = o.getArg(e, "file", null), this._sourceRoot = o.getArg(e, "sourceRoot", null), this._skipValidation = o.getArg(e, "skipValidation", !1), this._sources = new a, this._names = new a, this._mappings = new i, this._sourcesContents = null;
            }
            l.prototype._version = 3, l.fromSourceMap = function(e) {
                var t = e.sourceRoot, r = new l({
                    file: e.file,
                    sourceRoot: t
                });
                return e.eachMapping(function(e) {
                    var n = {
                        generated: {
                            line: e.generatedLine,
                            column: e.generatedColumn
                        }
                    };
                    null != e.source && (n.source = e.source, null != t && (n.source = o.relative(t, n.source)), n.original = {
                        line: e.originalLine,
                        column: e.originalColumn
                    }, null != e.name && (n.name = e.name)), r.addMapping(n);
                }), e.sources.forEach(function(t) {
                    var n = e.sourceContentFor(t);
                    null != n && r.setSourceContent(t, n);
                }), r;
            }, l.prototype.addMapping = function(e) {
                var t = o.getArg(e, "generated"), r = o.getArg(e, "original", null), n = o.getArg(e, "source", null), a = o.getArg(e, "name", null);
                this._skipValidation || this._validateMapping(t, r, n, a), null != n && (n = String(n), this._sources.has(n) || this._sources.add(n)), null != a && (a = String(a), this._names.has(a) || this._names.add(a)), this._mappings.add({
                    generatedLine: t.line,
                    generatedColumn: t.column,
                    originalLine: null != r && r.line,
                    originalColumn: null != r && r.column,
                    source: n,
                    name: a
                });
            }, l.prototype.setSourceContent = function(e, t) {
                var r = e;
                null != this._sourceRoot && (r = o.relative(this._sourceRoot, r)), null != t ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[o.toSetString(r)] = t) : this._sourcesContents && (delete this._sourcesContents[o.toSetString(r)], 0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null));
            }, l.prototype.applySourceMap = function(e, t, r) {
                var n = t;
                if (null == t) {
                    if (null == e.file) throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
                    n = e.file;
                }
                var i = this._sourceRoot;
                null != i && (n = o.relative(i, n));
                var l = new a, u = new a;
                this._mappings.unsortedForEach(function(t) {
                    if (t.source === n && null != t.originalLine) {
                        var a = e.originalPositionFor({
                            line: t.originalLine,
                            column: t.originalColumn
                        });
                        null != a.source && (t.source = a.source, null != r && (t.source = o.join(r, t.source)), null != i && (t.source = o.relative(i, t.source)), t.originalLine = a.line, t.originalColumn = a.column, null != a.name && (t.name = a.name));
                    }
                    var c = t.source;
                    null == c || l.has(c) || l.add(c);
                    var s = t.name;
                    null == s || u.has(s) || u.add(s);
                }, this), this._sources = l, this._names = u, e.sources.forEach(function(t) {
                    var n = e.sourceContentFor(t);
                    null != n && (null != r && (t = o.join(r, t)), null != i && (t = o.relative(i, t)), this.setSourceContent(t, n));
                }, this);
            }, l.prototype._validateMapping = function(e, t, r, n) {
                if (t && "number" != typeof t.line && "number" != typeof t.column) throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
                if ((!(e && "line" in e && "column" in e && e.line > 0 && e.column >= 0) || t || r || n) && !(e && "line" in e && "column" in e && t && "line" in t && "column" in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && r)) throw new Error("Invalid mapping: " + JSON.stringify({
                    generated: e,
                    source: r,
                    original: t,
                    name: n
                }));
            }, l.prototype._serializeMappings = function() {
                for(var e, t, r, a, i = 0, l = 1, u = 0, c = 0, s = 0, f = 0, d = "", p = this._mappings.toArray(), h = 0, g = p.length; h < g; h++){
                    if (e = "", (t = p[h]).generatedLine !== l) for(i = 0; t.generatedLine !== l;)e += ";", l++;
                    else if (h > 0) {
                        if (!o.compareByGeneratedPositionsInflated(t, p[h - 1])) continue;
                        e += ",";
                    }
                    e += n.encode(t.generatedColumn - i), i = t.generatedColumn, null != t.source && (a = this._sources.indexOf(t.source), e += n.encode(a - f), f = a, e += n.encode(t.originalLine - 1 - c), c = t.originalLine - 1, e += n.encode(t.originalColumn - u), u = t.originalColumn, null != t.name && (r = this._names.indexOf(t.name), e += n.encode(r - s), s = r)), d += e;
                }
                return d;
            }, l.prototype._generateSourcesContent = function(e, t) {
                return e.map(function(e) {
                    if (!this._sourcesContents) return null;
                    null != t && (e = o.relative(t, e));
                    var r = o.toSetString(e);
                    return Object.prototype.hasOwnProperty.call(this._sourcesContents, r) ? this._sourcesContents[r] : null;
                }, this);
            }, l.prototype.toJSON = function() {
                var e = {
                    version: this._version,
                    sources: this._sources.toArray(),
                    names: this._names.toArray(),
                    mappings: this._serializeMappings()
                };
                return null != this._file && (e.file = this._file), null != this._sourceRoot && (e.sourceRoot = this._sourceRoot), this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)), e;
            }, l.prototype.toString = function() {
                return JSON.stringify(this.toJSON());
            }, t.SourceMapGenerator = l;
        },
        function(e, t, r) {
            var n = r(9);
            t.encode = function(e) {
                var t, r = "", o = function(e) {
                    return e < 0 ? 1 + (-e << 1) : 0 + (e << 1);
                }(e);
                do t = 31 & o, (o >>>= 5) > 0 && (t |= 32), r += n.encode(t);
                while (o > 0);
                return r;
            }, t.decode = function(e, t, r) {
                var o, a, i, l, u = e.length, c = 0, s = 0;
                do {
                    if (t >= u) throw new Error("Expected more digits in base 64 VLQ value.");
                    if (-1 === (a = n.decode(e.charCodeAt(t++)))) throw new Error("Invalid base64 digit: " + e.charAt(t - 1));
                    o = !!(32 & a), c += (a &= 31) << s, s += 5;
                }while (o);
                r.value = (l = (i = c) >> 1, 1 == (1 & i) ? -l : l), r.rest = t;
            };
        },
        function(e, t, r) {
            var n = r(1), o = Object.prototype.hasOwnProperty, a = "undefined" != typeof Map;
            function i() {
                this._array = [], this._set = a ? new Map : Object.create(null);
            }
            i.fromArray = function(e, t) {
                for(var r = new i, n = 0, o = e.length; n < o; n++)r.add(e[n], t);
                return r;
            }, i.prototype.size = function() {
                return a ? this._set.size : Object.getOwnPropertyNames(this._set).length;
            }, i.prototype.add = function(e, t) {
                var r = a ? e : n.toSetString(e), i = a ? this.has(e) : o.call(this._set, r), l = this._array.length;
                i && !t || this._array.push(e), i || (a ? this._set.set(e, l) : this._set[r] = l);
            }, i.prototype.has = function(e) {
                if (a) return this._set.has(e);
                var t = n.toSetString(e);
                return o.call(this._set, t);
            }, i.prototype.indexOf = function(e) {
                if (a) {
                    var t = this._set.get(e);
                    if (t >= 0) return t;
                } else {
                    var r = n.toSetString(e);
                    if (o.call(this._set, r)) return this._set[r];
                }
                throw new Error('"' + e + '" is not in the set.');
            }, i.prototype.at = function(e) {
                if (e >= 0 && e < this._array.length) return this._array[e];
                throw new Error("No element indexed by " + e);
            }, i.prototype.toArray = function() {
                return this._array.slice();
            }, t.ArraySet = i;
        },
        function(e, t, r) {
            "use strict";
            function n(e) {
                return Array.isArray(e) || (e = [
                    e
                ]), Promise.all(e.map(function(e) {
                    return e.then(function(e) {
                        return {
                            isFulfilled: !0,
                            isRejected: !1,
                            value: e
                        };
                    }).catch(function(e) {
                        return {
                            isFulfilled: !1,
                            isRejected: !0,
                            reason: e
                        };
                    });
                }));
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.settle = n, t.default = n;
        },
        function(e, t, r) {
            var n = function(e) {
                "use strict";
                var t, r = Object.prototype, n = r.hasOwnProperty, o = "function" == typeof Symbol ? Symbol : {}, a = o.iterator || "@@iterator", i = o.asyncIterator || "@@asyncIterator", l = o.toStringTag || "@@toStringTag";
                function u(e, t, r) {
                    return Object.defineProperty(e, t, {
                        value: r,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }), e[t];
                }
                try {
                    u({}, "");
                } catch (e) {
                    u = function(e, t, r) {
                        return e[t] = r;
                    };
                }
                function c(e, t, r, n) {
                    var o = t && t.prototype instanceof m ? t : m, a = Object.create(o.prototype), i = new T(n || []);
                    return a._invoke = function(e, t, r) {
                        var n = f;
                        return function(o, a) {
                            if (n === p) throw new Error("Generator is already running");
                            if (n === h) {
                                if ("throw" === o) throw a;
                                return L();
                            }
                            for(r.method = o, r.arg = a;;){
                                var i = r.delegate;
                                if (i) {
                                    var l = _(i, r);
                                    if (l) {
                                        if (l === g) continue;
                                        return l;
                                    }
                                }
                                if ("next" === r.method) r.sent = r._sent = r.arg;
                                else if ("throw" === r.method) {
                                    if (n === f) throw n = h, r.arg;
                                    r.dispatchException(r.arg);
                                } else "return" === r.method && r.abrupt("return", r.arg);
                                n = p;
                                var u = s(e, t, r);
                                if ("normal" === u.type) {
                                    if (n = r.done ? h : d, u.arg === g) continue;
                                    return {
                                        value: u.arg,
                                        done: r.done
                                    };
                                }
                                "throw" === u.type && (n = h, r.method = "throw", r.arg = u.arg);
                            }
                        };
                    }(e, r, i), a;
                }
                function s(e, t, r) {
                    try {
                        return {
                            type: "normal",
                            arg: e.call(t, r)
                        };
                    } catch (e) {
                        return {
                            type: "throw",
                            arg: e
                        };
                    }
                }
                e.wrap = c;
                var f = "suspendedStart", d = "suspendedYield", p = "executing", h = "completed", g = {};
                function m() {}
                function v() {}
                function y() {}
                var b = {};
                b[a] = function() {
                    return this;
                };
                var w = Object.getPrototypeOf, k = w && w(w(P([])));
                k && k !== r && n.call(k, a) && (b = k);
                var E = y.prototype = m.prototype = Object.create(b);
                function S(e) {
                    [
                        "next",
                        "throw",
                        "return"
                    ].forEach(function(t) {
                        u(e, t, function(e) {
                            return this._invoke(t, e);
                        });
                    });
                }
                function x(e, t) {
                    var r;
                    this._invoke = function(o, a) {
                        function i() {
                            return new t(function(r, i) {
                                !function r(o, a, i, l) {
                                    var u = s(e[o], e, a);
                                    if ("throw" !== u.type) {
                                        var c = u.arg, f = c.value;
                                        return f && "object" == typeof f && n.call(f, "__await") ? t.resolve(f.__await).then(function(e) {
                                            r("next", e, i, l);
                                        }, function(e) {
                                            r("throw", e, i, l);
                                        }) : t.resolve(f).then(function(e) {
                                            c.value = e, i(c);
                                        }, function(e) {
                                            return r("throw", e, i, l);
                                        });
                                    }
                                    l(u.arg);
                                }(o, a, r, i);
                            });
                        }
                        return r = r ? r.then(i, i) : i();
                    };
                }
                function _(e, r) {
                    var n = e.iterator[r.method];
                    if (n === t) {
                        if (r.delegate = null, "throw" === r.method) {
                            if (e.iterator.return && (r.method = "return", r.arg = t, _(e, r), "throw" === r.method)) return g;
                            r.method = "throw", r.arg = new TypeError("The iterator does not provide a 'throw' method");
                        }
                        return g;
                    }
                    var o = s(n, e.iterator, r.arg);
                    if ("throw" === o.type) return r.method = "throw", r.arg = o.arg, r.delegate = null, g;
                    var a = o.arg;
                    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, g) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, g);
                }
                function C(e) {
                    var t = {
                        tryLoc: e[0]
                    };
                    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t);
                }
                function O(e) {
                    var t = e.completion || {};
                    t.type = "normal", delete t.arg, e.completion = t;
                }
                function T(e) {
                    this.tryEntries = [
                        {
                            tryLoc: "root"
                        }
                    ], e.forEach(C, this), this.reset(!0);
                }
                function P(e) {
                    if (e) {
                        var r = e[a];
                        if (r) return r.call(e);
                        if ("function" == typeof e.next) return e;
                        if (!isNaN(e.length)) {
                            var o = -1, i = function r() {
                                for(; ++o < e.length;)if (n.call(e, o)) return r.value = e[o], r.done = !1, r;
                                return r.value = t, r.done = !0, r;
                            };
                            return i.next = i;
                        }
                    }
                    return {
                        next: L
                    };
                }
                function L() {
                    return {
                        value: t,
                        done: !0
                    };
                }
                return v.prototype = E.constructor = y, y.constructor = v, v.displayName = u(y, l, "GeneratorFunction"), e.isGeneratorFunction = function(e) {
                    var t = "function" == typeof e && e.constructor;
                    return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name));
                }, e.mark = function(e) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e.__proto__ = y, u(e, l, "GeneratorFunction")), e.prototype = Object.create(E), e;
                }, e.awrap = function(e) {
                    return {
                        __await: e
                    };
                }, S(x.prototype), x.prototype[i] = function() {
                    return this;
                }, e.AsyncIterator = x, e.async = function(t, r, n, o, a) {
                    void 0 === a && (a = Promise);
                    var i = new x(c(t, r, n, o), a);
                    return e.isGeneratorFunction(r) ? i : i.next().then(function(e) {
                        return e.done ? e.value : i.next();
                    });
                }, S(E), u(E, l, "Generator"), E[a] = function() {
                    return this;
                }, E.toString = function() {
                    return "[object Generator]";
                }, e.keys = function(e) {
                    var t = [];
                    for(var r in e)t.push(r);
                    return t.reverse(), function r() {
                        for(; t.length;){
                            var n = t.pop();
                            if (n in e) return r.value = n, r.done = !1, r;
                        }
                        return r.done = !0, r;
                    };
                }, e.values = P, T.prototype = {
                    constructor: T,
                    reset: function(e) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(O), !e) for(var r in this)"t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
                    },
                    stop: function() {
                        this.done = !0;
                        var e = this.tryEntries[0].completion;
                        if ("throw" === e.type) throw e.arg;
                        return this.rval;
                    },
                    dispatchException: function(e) {
                        if (this.done) throw e;
                        var r = this;
                        function o(n, o) {
                            return l.type = "throw", l.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
                        }
                        for(var a = this.tryEntries.length - 1; a >= 0; --a){
                            var i = this.tryEntries[a], l = i.completion;
                            if ("root" === i.tryLoc) return o("end");
                            if (i.tryLoc <= this.prev) {
                                var u = n.call(i, "catchLoc"), c = n.call(i, "finallyLoc");
                                if (u && c) {
                                    if (this.prev < i.catchLoc) return o(i.catchLoc, !0);
                                    if (this.prev < i.finallyLoc) return o(i.finallyLoc);
                                } else if (u) {
                                    if (this.prev < i.catchLoc) return o(i.catchLoc, !0);
                                } else {
                                    if (!c) throw new Error("try statement without catch or finally");
                                    if (this.prev < i.finallyLoc) return o(i.finallyLoc);
                                }
                            }
                        }
                    },
                    abrupt: function(e, t) {
                        for(var r = this.tryEntries.length - 1; r >= 0; --r){
                            var o = this.tryEntries[r];
                            if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
                                var a = o;
                                break;
                            }
                        }
                        a && ("break" === e || "continue" === e) && a.tryLoc <= t && t <= a.finallyLoc && (a = null);
                        var i = a ? a.completion : {};
                        return i.type = e, i.arg = t, a ? (this.method = "next", this.next = a.finallyLoc, g) : this.complete(i);
                    },
                    complete: function(e, t) {
                        if ("throw" === e.type) throw e.arg;
                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g;
                    },
                    finish: function(e) {
                        for(var t = this.tryEntries.length - 1; t >= 0; --t){
                            var r = this.tryEntries[t];
                            if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), O(r), g;
                        }
                    },
                    catch: function(e) {
                        for(var t = this.tryEntries.length - 1; t >= 0; --t){
                            var r = this.tryEntries[t];
                            if (r.tryLoc === e) {
                                var n = r.completion;
                                if ("throw" === n.type) {
                                    var o = n.arg;
                                    O(r);
                                }
                                return o;
                            }
                        }
                        throw new Error("illegal catch attempt");
                    },
                    delegateYield: function(e, r, n) {
                        return this.delegate = {
                            iterator: P(e),
                            resultName: r,
                            nextLoc: n
                        }, "next" === this.method && (this.arg = t), g;
                    }
                }, e;
            }(e.exports);
            try {
                regeneratorRuntime = n;
            } catch (e) {
                Function("r", "regeneratorRuntime = r")(n);
            }
        },
        function(e, t) {
            var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
            t.encode = function(e) {
                if (0 <= e && e < r.length) return r[e];
                throw new TypeError("Must be between 0 and 63: " + e);
            }, t.decode = function(e) {
                return 65 <= e && e <= 90 ? e - 65 : 97 <= e && e <= 122 ? e - 97 + 26 : 48 <= e && e <= 57 ? e - 48 + 52 : 43 == e ? 62 : 47 == e ? 63 : -1;
            };
        },
        function(e, t, r) {
            var n = r(1);
            function o() {
                this._array = [], this._sorted = !0, this._last = {
                    generatedLine: -1,
                    generatedColumn: 0
                };
            }
            o.prototype.unsortedForEach = function(e, t) {
                this._array.forEach(e, t);
            }, o.prototype.add = function(e) {
                var t, r, o, a, i, l;
                t = this._last, r = e, o = t.generatedLine, a = r.generatedLine, i = t.generatedColumn, l = r.generatedColumn, a > o || a == o && l >= i || n.compareByGeneratedPositionsInflated(t, r) <= 0 ? (this._last = e, this._array.push(e)) : (this._sorted = !1, this._array.push(e));
            }, o.prototype.toArray = function() {
                return this._sorted || (this._array.sort(n.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
            }, t.MappingList = o;
        },
        function(e, t, r) {
            var n = r(1), o = r(12), a = r(6).ArraySet, i = r(5), l = r(13).quickSort;
            function u(e) {
                var t = e;
                return "string" == typeof e && (t = JSON.parse(e.replace(/^\)\]\}'/, ""))), null != t.sections ? new f(t) : new c(t);
            }
            function c(e) {
                var t = e;
                "string" == typeof e && (t = JSON.parse(e.replace(/^\)\]\}'/, "")));
                var r = n.getArg(t, "version"), o = n.getArg(t, "sources"), i = n.getArg(t, "names", []), l = n.getArg(t, "sourceRoot", null), u = n.getArg(t, "sourcesContent", null), c = n.getArg(t, "mappings"), s = n.getArg(t, "file", null);
                if (r != this._version) throw new Error("Unsupported version: " + r);
                o = o.map(String).map(n.normalize).map(function(e) {
                    return l && n.isAbsolute(l) && n.isAbsolute(e) ? n.relative(l, e) : e;
                }), this._names = a.fromArray(i.map(String), !0), this._sources = a.fromArray(o, !0), this.sourceRoot = l, this.sourcesContent = u, this._mappings = c, this.file = s;
            }
            function s() {
                this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
            }
            function f(e) {
                var t = e;
                "string" == typeof e && (t = JSON.parse(e.replace(/^\)\]\}'/, "")));
                var r = n.getArg(t, "version"), o = n.getArg(t, "sections");
                if (r != this._version) throw new Error("Unsupported version: " + r);
                this._sources = new a, this._names = new a;
                var i = {
                    line: -1,
                    column: 0
                };
                this._sections = o.map(function(e) {
                    if (e.url) throw new Error("Support for url field in sections not implemented.");
                    var t = n.getArg(e, "offset"), r = n.getArg(t, "line"), o = n.getArg(t, "column");
                    if (r < i.line || r === i.line && o < i.column) throw new Error("Section offsets must be ordered and non-overlapping.");
                    return i = t, {
                        generatedOffset: {
                            generatedLine: r + 1,
                            generatedColumn: o + 1
                        },
                        consumer: new u(n.getArg(e, "map"))
                    };
                });
            }
            u.fromSourceMap = function(e) {
                return c.fromSourceMap(e);
            }, u.prototype._version = 3, u.prototype.__generatedMappings = null, Object.defineProperty(u.prototype, "_generatedMappings", {
                get: function() {
                    return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
                }
            }), u.prototype.__originalMappings = null, Object.defineProperty(u.prototype, "_originalMappings", {
                get: function() {
                    return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
                }
            }), u.prototype._charIsMappingSeparator = function(e, t) {
                var r = e.charAt(t);
                return ";" === r || "," === r;
            }, u.prototype._parseMappings = function(e, t) {
                throw new Error("Subclasses must implement _parseMappings");
            }, u.GENERATED_ORDER = 1, u.ORIGINAL_ORDER = 2, u.GREATEST_LOWER_BOUND = 1, u.LEAST_UPPER_BOUND = 2, u.prototype.eachMapping = function(e, t, r) {
                var o, a = t || null;
                switch(r || u.GENERATED_ORDER){
                    case u.GENERATED_ORDER:
                        o = this._generatedMappings;
                        break;
                    case u.ORIGINAL_ORDER:
                        o = this._originalMappings;
                        break;
                    default:
                        throw new Error("Unknown order of iteration.");
                }
                var i = this.sourceRoot;
                o.map(function(e) {
                    var t = null === e.source ? null : this._sources.at(e.source);
                    return null != t && null != i && (t = n.join(i, t)), {
                        source: t,
                        generatedLine: e.generatedLine,
                        generatedColumn: e.generatedColumn,
                        originalLine: e.originalLine,
                        originalColumn: e.originalColumn,
                        name: null === e.name ? null : this._names.at(e.name)
                    };
                }, this).forEach(e, a);
            }, u.prototype.allGeneratedPositionsFor = function(e) {
                var t = n.getArg(e, "line"), r = {
                    source: n.getArg(e, "source"),
                    originalLine: t,
                    originalColumn: n.getArg(e, "column", 0)
                };
                if (null != this.sourceRoot && (r.source = n.relative(this.sourceRoot, r.source)), !this._sources.has(r.source)) return [];
                r.source = this._sources.indexOf(r.source);
                var a = [], i = this._findMapping(r, this._originalMappings, "originalLine", "originalColumn", n.compareByOriginalPositions, o.LEAST_UPPER_BOUND);
                if (i >= 0) {
                    var l = this._originalMappings[i];
                    if (void 0 === e.column) for(var u = l.originalLine; l && l.originalLine === u;)a.push({
                        line: n.getArg(l, "generatedLine", null),
                        column: n.getArg(l, "generatedColumn", null),
                        lastColumn: n.getArg(l, "lastGeneratedColumn", null)
                    }), l = this._originalMappings[++i];
                    else for(var c = l.originalColumn; l && l.originalLine === t && l.originalColumn == c;)a.push({
                        line: n.getArg(l, "generatedLine", null),
                        column: n.getArg(l, "generatedColumn", null),
                        lastColumn: n.getArg(l, "lastGeneratedColumn", null)
                    }), l = this._originalMappings[++i];
                }
                return a;
            }, t.SourceMapConsumer = u, c.prototype = Object.create(u.prototype), c.prototype.consumer = u, c.fromSourceMap = function(e) {
                var t = Object.create(c.prototype), r = t._names = a.fromArray(e._names.toArray(), !0), o = t._sources = a.fromArray(e._sources.toArray(), !0);
                t.sourceRoot = e._sourceRoot, t.sourcesContent = e._generateSourcesContent(t._sources.toArray(), t.sourceRoot), t.file = e._file;
                for(var i = e._mappings.toArray().slice(), u = t.__generatedMappings = [], f = t.__originalMappings = [], d = 0, p = i.length; d < p; d++){
                    var h = i[d], g = new s;
                    g.generatedLine = h.generatedLine, g.generatedColumn = h.generatedColumn, h.source && (g.source = o.indexOf(h.source), g.originalLine = h.originalLine, g.originalColumn = h.originalColumn, h.name && (g.name = r.indexOf(h.name)), f.push(g)), u.push(g);
                }
                return l(t.__originalMappings, n.compareByOriginalPositions), t;
            }, c.prototype._version = 3, Object.defineProperty(c.prototype, "sources", {
                get: function() {
                    return this._sources.toArray().map(function(e) {
                        return null != this.sourceRoot ? n.join(this.sourceRoot, e) : e;
                    }, this);
                }
            }), c.prototype._parseMappings = function(e, t) {
                for(var r, o, a, u, c, f = 1, d = 0, p = 0, h = 0, g = 0, m = 0, v = e.length, y = 0, b = {}, w = {}, k = [], E = []; y < v;)if (";" === e.charAt(y)) f++, y++, d = 0;
                else if ("," === e.charAt(y)) y++;
                else {
                    for((r = new s).generatedLine = f, u = y; u < v && !this._charIsMappingSeparator(e, u); u++);
                    if (a = b[o = e.slice(y, u)]) y += o.length;
                    else {
                        for(a = []; y < u;)i.decode(e, y, w), c = w.value, y = w.rest, a.push(c);
                        if (2 === a.length) throw new Error("Found a source, but no line and column");
                        if (3 === a.length) throw new Error("Found a source and line, but no column");
                        b[o] = a;
                    }
                    r.generatedColumn = d + a[0], d = r.generatedColumn, a.length > 1 && (r.source = g + a[1], g += a[1], r.originalLine = p + a[2], p = r.originalLine, r.originalLine += 1, r.originalColumn = h + a[3], h = r.originalColumn, a.length > 4 && (r.name = m + a[4], m += a[4])), E.push(r), "number" == typeof r.originalLine && k.push(r);
                }
                l(E, n.compareByGeneratedPositionsDeflated), this.__generatedMappings = E, l(k, n.compareByOriginalPositions), this.__originalMappings = k;
            }, c.prototype._findMapping = function(e, t, r, n, a, i) {
                if (e[r] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + e[r]);
                if (e[n] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + e[n]);
                return o.search(e, t, a, i);
            }, c.prototype.computeColumnSpans = function() {
                for(var e = 0; e < this._generatedMappings.length; ++e){
                    var t = this._generatedMappings[e];
                    if (e + 1 < this._generatedMappings.length) {
                        var r = this._generatedMappings[e + 1];
                        if (t.generatedLine === r.generatedLine) {
                            t.lastGeneratedColumn = r.generatedColumn - 1;
                            continue;
                        }
                    }
                    t.lastGeneratedColumn = 1 / 0;
                }
            }, c.prototype.originalPositionFor = function(e) {
                var t = {
                    generatedLine: n.getArg(e, "line"),
                    generatedColumn: n.getArg(e, "column")
                }, r = this._findMapping(t, this._generatedMappings, "generatedLine", "generatedColumn", n.compareByGeneratedPositionsDeflated, n.getArg(e, "bias", u.GREATEST_LOWER_BOUND));
                if (r >= 0) {
                    var o = this._generatedMappings[r];
                    if (o.generatedLine === t.generatedLine) {
                        var a = n.getArg(o, "source", null);
                        null !== a && (a = this._sources.at(a), null != this.sourceRoot && (a = n.join(this.sourceRoot, a)));
                        var i = n.getArg(o, "name", null);
                        return null !== i && (i = this._names.at(i)), {
                            source: a,
                            line: n.getArg(o, "originalLine", null),
                            column: n.getArg(o, "originalColumn", null),
                            name: i
                        };
                    }
                }
                return {
                    source: null,
                    line: null,
                    column: null,
                    name: null
                };
            }, c.prototype.hasContentsOfAllSources = function() {
                return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e) {
                    return null == e;
                });
            }, c.prototype.sourceContentFor = function(e, t) {
                if (!this.sourcesContent) return null;
                if (null != this.sourceRoot && (e = n.relative(this.sourceRoot, e)), this._sources.has(e)) return this.sourcesContent[this._sources.indexOf(e)];
                var r;
                if (null != this.sourceRoot && (r = n.urlParse(this.sourceRoot))) {
                    var o = e.replace(/^file:\/\//, "");
                    if ("file" == r.scheme && this._sources.has(o)) return this.sourcesContent[this._sources.indexOf(o)];
                    if ((!r.path || "/" == r.path) && this._sources.has("/" + e)) return this.sourcesContent[this._sources.indexOf("/" + e)];
                }
                if (t) return null;
                throw new Error('"' + e + '" is not in the SourceMap.');
            }, c.prototype.generatedPositionFor = function(e) {
                var t = n.getArg(e, "source");
                if (null != this.sourceRoot && (t = n.relative(this.sourceRoot, t)), !this._sources.has(t)) return {
                    line: null,
                    column: null,
                    lastColumn: null
                };
                var r = {
                    source: t = this._sources.indexOf(t),
                    originalLine: n.getArg(e, "line"),
                    originalColumn: n.getArg(e, "column")
                }, o = this._findMapping(r, this._originalMappings, "originalLine", "originalColumn", n.compareByOriginalPositions, n.getArg(e, "bias", u.GREATEST_LOWER_BOUND));
                if (o >= 0) {
                    var a = this._originalMappings[o];
                    if (a.source === r.source) return {
                        line: n.getArg(a, "generatedLine", null),
                        column: n.getArg(a, "generatedColumn", null),
                        lastColumn: n.getArg(a, "lastGeneratedColumn", null)
                    };
                }
                return {
                    line: null,
                    column: null,
                    lastColumn: null
                };
            }, t.BasicSourceMapConsumer = c, f.prototype = Object.create(u.prototype), f.prototype.constructor = u, f.prototype._version = 3, Object.defineProperty(f.prototype, "sources", {
                get: function() {
                    for(var e = [], t = 0; t < this._sections.length; t++)for(var r = 0; r < this._sections[t].consumer.sources.length; r++)e.push(this._sections[t].consumer.sources[r]);
                    return e;
                }
            }), f.prototype.originalPositionFor = function(e) {
                var t = {
                    generatedLine: n.getArg(e, "line"),
                    generatedColumn: n.getArg(e, "column")
                }, r = o.search(t, this._sections, function(e, t) {
                    var r = e.generatedLine - t.generatedOffset.generatedLine;
                    return r || e.generatedColumn - t.generatedOffset.generatedColumn;
                }), a = this._sections[r];
                return a ? a.consumer.originalPositionFor({
                    line: t.generatedLine - (a.generatedOffset.generatedLine - 1),
                    column: t.generatedColumn - (a.generatedOffset.generatedLine === t.generatedLine ? a.generatedOffset.generatedColumn - 1 : 0),
                    bias: e.bias
                }) : {
                    source: null,
                    line: null,
                    column: null,
                    name: null
                };
            }, f.prototype.hasContentsOfAllSources = function() {
                return this._sections.every(function(e) {
                    return e.consumer.hasContentsOfAllSources();
                });
            }, f.prototype.sourceContentFor = function(e, t) {
                for(var r = 0; r < this._sections.length; r++){
                    var n = this._sections[r].consumer.sourceContentFor(e, !0);
                    if (n) return n;
                }
                if (t) return null;
                throw new Error('"' + e + '" is not in the SourceMap.');
            }, f.prototype.generatedPositionFor = function(e) {
                for(var t = 0; t < this._sections.length; t++){
                    var r = this._sections[t];
                    if (-1 !== r.consumer.sources.indexOf(n.getArg(e, "source"))) {
                        var o = r.consumer.generatedPositionFor(e);
                        if (o) return {
                            line: o.line + (r.generatedOffset.generatedLine - 1),
                            column: o.column + (r.generatedOffset.generatedLine === o.line ? r.generatedOffset.generatedColumn - 1 : 0)
                        };
                    }
                }
                return {
                    line: null,
                    column: null
                };
            }, f.prototype._parseMappings = function(e, t) {
                this.__generatedMappings = [], this.__originalMappings = [];
                for(var r = 0; r < this._sections.length; r++)for(var o = this._sections[r], a = o.consumer._generatedMappings, i = 0; i < a.length; i++){
                    var u = a[i], c = o.consumer._sources.at(u.source);
                    null !== o.consumer.sourceRoot && (c = n.join(o.consumer.sourceRoot, c)), this._sources.add(c), c = this._sources.indexOf(c);
                    var s = o.consumer._names.at(u.name);
                    this._names.add(s), s = this._names.indexOf(s);
                    var f = {
                        source: c,
                        generatedLine: u.generatedLine + (o.generatedOffset.generatedLine - 1),
                        generatedColumn: u.generatedColumn + (o.generatedOffset.generatedLine === u.generatedLine ? o.generatedOffset.generatedColumn - 1 : 0),
                        originalLine: u.originalLine,
                        originalColumn: u.originalColumn,
                        name: s
                    };
                    this.__generatedMappings.push(f), "number" == typeof f.originalLine && this.__originalMappings.push(f);
                }
                l(this.__generatedMappings, n.compareByGeneratedPositionsDeflated), l(this.__originalMappings, n.compareByOriginalPositions);
            }, t.IndexedSourceMapConsumer = f;
        },
        function(e, t) {
            t.GREATEST_LOWER_BOUND = 1, t.LEAST_UPPER_BOUND = 2, t.search = function(e, r, n, o) {
                if (0 === r.length) return -1;
                var a = function e(r, n, o, a, i, l) {
                    var u = Math.floor((n - r) / 2) + r, c = i(o, a[u], !0);
                    return 0 === c ? u : c > 0 ? n - u > 1 ? e(u, n, o, a, i, l) : l == t.LEAST_UPPER_BOUND ? n < a.length ? n : -1 : u : u - r > 1 ? e(r, u, o, a, i, l) : l == t.LEAST_UPPER_BOUND ? u : r < 0 ? -1 : r;
                }(-1, r.length, e, r, n, o || t.GREATEST_LOWER_BOUND);
                if (a < 0) return -1;
                for(; a - 1 >= 0 && 0 === n(r[a], r[a - 1], !0);)--a;
                return a;
            };
        },
        function(e, t) {
            function r(e, t, r) {
                var n = e[t];
                e[t] = e[r], e[r] = n;
            }
            function n(e, t, o, a) {
                if (o < a) {
                    var i = o - 1;
                    r(e, (s = o, f = a, Math.round(s + Math.random() * (f - s))), a);
                    for(var l = e[a], u = o; u < a; u++)t(e[u], l) <= 0 && r(e, i += 1, u);
                    r(e, i + 1, u);
                    var c = i + 1;
                    n(e, t, o, c - 1), n(e, t, c + 1, a);
                }
                var s, f;
            }
            t.quickSort = function(e, t) {
                n(e, t, 0, e.length - 1);
            };
        },
        function(e, t, r) {
            var n = r(4).SourceMapGenerator, o = r(1), a = /(\r?\n)/, i = "$$$isSourceNode$$$";
            function l(e, t, r, n, o) {
                this.children = [], this.sourceContents = {}, this.line = null == e ? null : e, this.column = null == t ? null : t, this.source = null == r ? null : r, this.name = null == o ? null : o, this[i] = !0, null != n && this.add(n);
            }
            l.fromStringWithSourceMap = function(e, t, r) {
                var n = new l, i = e.split(a), u = 0, c = function() {
                    return e() + (e() || "");
                    function e() {
                        return u < i.length ? i[u++] : void 0;
                    }
                }, s = 1, f = 0, d = null;
                return t.eachMapping(function(e) {
                    if (null !== d) {
                        if (!(s < e.generatedLine)) {
                            var t = (r = i[u]).substr(0, e.generatedColumn - f);
                            return i[u] = r.substr(e.generatedColumn - f), f = e.generatedColumn, p(d, t), void (d = e);
                        }
                        p(d, c()), s++, f = 0;
                    }
                    for(; s < e.generatedLine;)n.add(c()), s++;
                    if (f < e.generatedColumn) {
                        var r = i[u];
                        n.add(r.substr(0, e.generatedColumn)), i[u] = r.substr(e.generatedColumn), f = e.generatedColumn;
                    }
                    d = e;
                }, this), u < i.length && (d && p(d, c()), n.add(i.splice(u).join(""))), t.sources.forEach(function(e) {
                    var a = t.sourceContentFor(e);
                    null != a && (null != r && (e = o.join(r, e)), n.setSourceContent(e, a));
                }), n;
                function p(e, t) {
                    if (null === e || void 0 === e.source) n.add(t);
                    else {
                        var a = r ? o.join(r, e.source) : e.source;
                        n.add(new l(e.originalLine, e.originalColumn, a, t, e.name));
                    }
                }
            }, l.prototype.add = function(e) {
                if (Array.isArray(e)) e.forEach(function(e) {
                    this.add(e);
                }, this);
                else {
                    if (!e[i] && "string" != typeof e) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e);
                    e && this.children.push(e);
                }
                return this;
            }, l.prototype.prepend = function(e) {
                if (Array.isArray(e)) for(var t = e.length - 1; t >= 0; t--)this.prepend(e[t]);
                else {
                    if (!e[i] && "string" != typeof e) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e);
                    this.children.unshift(e);
                }
                return this;
            }, l.prototype.walk = function(e) {
                for(var t, r = 0, n = this.children.length; r < n; r++)(t = this.children[r])[i] ? t.walk(e) : "" !== t && e(t, {
                    source: this.source,
                    line: this.line,
                    column: this.column,
                    name: this.name
                });
            }, l.prototype.join = function(e) {
                var t, r, n = this.children.length;
                if (n > 0) {
                    for(t = [], r = 0; r < n - 1; r++)t.push(this.children[r]), t.push(e);
                    t.push(this.children[r]), this.children = t;
                }
                return this;
            }, l.prototype.replaceRight = function(e, t) {
                var r = this.children[this.children.length - 1];
                return r[i] ? r.replaceRight(e, t) : "string" == typeof r ? this.children[this.children.length - 1] = r.replace(e, t) : this.children.push("".replace(e, t)), this;
            }, l.prototype.setSourceContent = function(e, t) {
                this.sourceContents[o.toSetString(e)] = t;
            }, l.prototype.walkSourceContents = function(e) {
                for(var t = 0, r = this.children.length; t < r; t++)this.children[t][i] && this.children[t].walkSourceContents(e);
                var n = Object.keys(this.sourceContents);
                for(t = 0, r = n.length; t < r; t++)e(o.fromSetString(n[t]), this.sourceContents[n[t]]);
            }, l.prototype.toString = function() {
                var e = "";
                return this.walk(function(t) {
                    e += t;
                }), e;
            }, l.prototype.toStringWithSourceMap = function(e) {
                var t = {
                    code: "",
                    line: 1,
                    column: 0
                }, r = new n(e), o = !1, a = null, i = null, l = null, u = null;
                return this.walk(function(e, n) {
                    t.code += e, null !== n.source && null !== n.line && null !== n.column ? (a === n.source && i === n.line && l === n.column && u === n.name || r.addMapping({
                        source: n.source,
                        original: {
                            line: n.line,
                            column: n.column
                        },
                        generated: {
                            line: t.line,
                            column: t.column
                        },
                        name: n.name
                    }), a = n.source, i = n.line, l = n.column, u = n.name, o = !0) : o && (r.addMapping({
                        generated: {
                            line: t.line,
                            column: t.column
                        }
                    }), a = null, o = !1);
                    for(var c = 0, s = e.length; c < s; c++)10 === e.charCodeAt(c) ? (t.line++, t.column = 0, c + 1 === s ? (a = null, o = !1) : o && r.addMapping({
                        source: n.source,
                        original: {
                            line: n.line,
                            column: n.column
                        },
                        generated: {
                            line: t.line,
                            column: t.column
                        },
                        name: n.name
                    })) : t.column++;
                }), this.walkSourceContents(function(e, t) {
                    r.setSourceContent(e, t);
                }), {
                    code: t.code,
                    map: r
                };
            }, t.SourceNode = l;
        },
        function(e, t, r) {
            "use strict";
            r.r(t), r.d(t, "setEditorHandler", function() {
                return ue;
            }), r.d(t, "reportBuildError", function() {
                return ce;
            }), r.d(t, "reportRuntimeError", function() {
                return se;
            }), r.d(t, "dismissBuildError", function() {
                return fe;
            }), r.d(t, "startReportingRuntimeErrors", function() {
                return de;
            }), r.d(t, "dismissRuntimeErrors", function() {
                return he;
            }), r.d(t, "stopReportingRuntimeErrors", function() {
                return ge;
            });
            var n = null;
            function o(e, t) {
                if (t.error) {
                    var r = t.error;
                    r instanceof Error ? e(r) : e(new Error(r));
                }
            }
            function a(e, t) {
                null === n && (n = o.bind(void 0, t), e.addEventListener("error", n));
            }
            var i = null;
            function l(e, t) {
                if (null == t || null == t.reason) return e(new Error("Unknown"));
                var r = t.reason;
                return r instanceof Error ? e(r) : e(new Error(r));
            }
            function u(e, t) {
                null === i && (i = l.bind(void 0, t), e.addEventListener("unhandledrejection", i));
            }
            var c = !1, s = 10, f = 50;
            var d = [], p = function() {
                "undefined" != typeof console && (console.reactStack = function(e) {
                    return d.push(e);
                }, console.reactStackEnd = function(e) {
                    return d.pop();
                });
            }, h = function() {
                "undefined" != typeof console && (console.reactStack = void 0, console.reactStackEnd = void 0);
            }, g = function(e, t) {
                if ("undefined" != typeof console) {
                    var r = console[e];
                    "function" == typeof r && (console[e] = function() {
                        try {
                            var e = arguments[0];
                            "string" == typeof e && d.length > 0 && t(e, d[d.length - 1]);
                        } catch (e) {
                            setTimeout(function() {
                                throw e;
                            });
                        }
                        return r.apply(this, arguments);
                    });
                }
            };
            function m(e, t) {
                return (m = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e;
                })(e, t);
            }
            function v(e, t, r) {
                return (v = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (e) {
                        return !1;
                    }
                }() ? Reflect.construct : function(e, t, r) {
                    var n = [
                        null
                    ];
                    n.push.apply(n, t);
                    var o = new (Function.bind.apply(e, n));
                    return r && m(o, r.prototype), o;
                }).apply(null, arguments);
            }
            function y(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for(var r = 0, n = new Array(t); r < t; r++)n[r] = e[r];
                return n;
            }
            function b(e) {
                return function(e) {
                    if (Array.isArray(e)) return y(e);
                }(e) || function(e) {
                    if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);
                }(e) || function(e, t) {
                    if (e) {
                        if ("string" == typeof e) return y(e, t);
                        var r = Object.prototype.toString.call(e).slice(8, -1);
                        return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? y(e, t) : void 0;
                    }
                }(e) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
            }
            function w(e, t) {
                for(var r = 0; r < t.length; r++){
                    var n = t[r];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
                }
            }
            function k(e, t, r) {
                return t && w(e.prototype, t), r && w(e, r), e;
            }
            function E(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
            }
            var S = function e(t, r) {
                var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                E(this, e), this.lineNumber = t, this.content = r, this.highlight = n;
            }, x = function() {
                function e() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, l = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, u = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, c = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, s = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : null;
                    E(this, e), t && 0 === t.indexOf("Object.") && (t = t.slice(7)), "friendlySyntaxErrorLabel" !== t && "exports.__esModule" !== t && "<anonymous>" !== t && t || (t = null), this.functionName = t, this.fileName = r, this.lineNumber = n, this.columnNumber = o, this._originalFunctionName = i, this._originalFileName = l, this._originalLineNumber = u, this._originalColumnNumber = c, this._scriptCode = a, this._originalScriptCode = s;
                }
                return k(e, [
                    {
                        key: "getFunctionName",
                        value: function() {
                            return this.functionName || "(anonymous function)";
                        }
                    },
                    {
                        key: "getSource",
                        value: function() {
                            var e = "";
                            return null != this.fileName && (e += this.fileName + ":"), null != this.lineNumber && (e += this.lineNumber + ":"), null != this.columnNumber && (e += this.columnNumber + ":"), e.slice(0, -1);
                        }
                    },
                    {
                        key: "toString",
                        value: function() {
                            var e = this.getFunctionName(), t = this.getSource();
                            return "".concat(e).concat(t ? " (".concat(t, ")") : "");
                        }
                    }
                ]), e;
            }(), _ = /\(?(.+?)(?::(\d+))?(?::(\d+))?\)?$/;
            function C(e) {
                return _.exec(e).slice(1).map(function(e) {
                    var t = Number(e);
                    return isNaN(t) ? e : t;
                });
            }
            var O = /^\s*(at|in)\s.+(:\d+)/, T = /(^|@)\S+:\d+|.+line\s+\d+\s+>\s+(eval|Function).+/;
            function P(e) {
                return e.filter(function(e) {
                    return O.test(e) || T.test(e);
                }).map(function(e) {
                    if (T.test(e)) {
                        var t = !1;
                        / > (eval|Function)/.test(e) && (e = e.replace(/ line (\d+)(?: > eval line \d+)* > (eval|Function):\d+:\d+/g, ":$1"), t = !0);
                        var r = e.split(/[@]/g), n = r.pop();
                        return v(x, [
                            r.join("@") || (t ? "eval" : null)
                        ].concat(b(C(n))));
                    }
                    -1 !== e.indexOf("(eval ") && (e = e.replace(/(\(eval at [^()]*)|(\),.*$)/g, "")), -1 !== e.indexOf("(at ") && (e = e.replace(/\(at /, "("));
                    var o = e.trim().split(/\s+/g).slice(1), a = o.pop();
                    return v(x, [
                        o.join(" ") || null
                    ].concat(b(C(a))));
                });
            }
            function L(e) {
                if (null == e) throw new Error("You cannot pass a null object.");
                if ("string" == typeof e) return P(e.split("\n"));
                if (Array.isArray(e)) return P(e);
                if ("string" == typeof e.stack) return P(e.stack.split("\n"));
                throw new Error("The error you provided does not contain a stack trace.");
            }
            var R = r(0), A = r.n(R);
            function N(e, t, r, n, o, a, i) {
                try {
                    var l = e[a](i), u = l.value;
                } catch (e) {
                    return void r(e);
                }
                l.done ? t(u) : Promise.resolve(u).then(n, o);
            }
            function j(e) {
                return function() {
                    var t = this, r = arguments;
                    return new Promise(function(n, o) {
                        var a = e.apply(t, r);
                        function i(e) {
                            N(a, n, o, i, l, "next", e);
                        }
                        function l(e) {
                            N(a, n, o, i, l, "throw", e);
                        }
                        i(void 0);
                    });
                };
            }
            var M = r(3), I = function() {
                function e(t) {
                    E(this, e), this.__source_map = t;
                }
                return k(e, [
                    {
                        key: "getOriginalPosition",
                        value: function(e, t) {
                            var r = this.__source_map.originalPositionFor({
                                line: e,
                                column: t
                            });
                            return {
                                line: r.line,
                                column: r.column,
                                source: r.source
                            };
                        }
                    },
                    {
                        key: "getGeneratedPosition",
                        value: function(e, t, r) {
                            var n = this.__source_map.generatedPositionFor({
                                source: e,
                                line: t,
                                column: r
                            });
                            return {
                                line: n.line,
                                column: n.column
                            };
                        }
                    },
                    {
                        key: "getSource",
                        value: function(e) {
                            return this.__source_map.sourceContentFor(e);
                        }
                    },
                    {
                        key: "getSources",
                        value: function() {
                            return this.__source_map.sources;
                        }
                    }
                ]), e;
            }();
            function D(e, t) {
                for(var r = /\/\/[#@] ?sourceMappingURL=([^\s'"]+)\s*$/gm, n = null;;){
                    var o = r.exec(t);
                    if (null == o) break;
                    n = o;
                }
                return n && n[1] ? Promise.resolve(n[1].toString()) : Promise.reject("Cannot find a source map directive for ".concat(e, "."));
            }
            function z(e, t) {
                return q.apply(this, arguments);
            }
            function q() {
                return (q = j(A.a.mark(function e(t, r) {
                    var n, o, a, i, l, u;
                    return A.a.wrap(function(e) {
                        for(;;)switch(e.prev = e.next){
                            case 0:
                                return e.next = 2, D(t, r);
                            case 2:
                                if (0 !== (n = e.sent).indexOf("data:")) {
                                    e.next = 14;
                                    break;
                                }
                                if (o = /^data:application\/json;([\w=:"-]+;)*base64,/, a = n.match(o)) {
                                    e.next = 8;
                                    break;
                                }
                                throw new Error("Sorry, non-base64 inline source-map encoding is not supported.");
                            case 8:
                                return n = n.substring(a[0].length), n = window.atob(n), n = JSON.parse(n), e.abrupt("return", new I(new M.SourceMapConsumer(n)));
                            case 14:
                                return i = t.lastIndexOf("/"), l = t.substring(0, i + 1) + n, e.next = 18, fetch(l).then(function(e) {
                                    return e.json();
                                });
                            case 18:
                                return u = e.sent, e.abrupt("return", new I(new M.SourceMapConsumer(u)));
                            case 20:
                            case "end":
                                return e.stop();
                        }
                    }, e);
                }))).apply(this, arguments);
            }
            function F(e, t, r) {
                "string" == typeof r && (r = r.split("\n"));
                for(var n = [], o = Math.max(0, e - 1 - t); o <= Math.min(r.length - 1, e - 1 + t); ++o)n.push(new S(o + 1, r[o], o === e - 1));
                return n;
            }
            var U = r(7);
            function B(e) {
                return H.apply(this, arguments);
            }
            function H() {
                return (H = j(A.a.mark(function e(t) {
                    var r, n, o, a = arguments;
                    return A.a.wrap(function(e) {
                        for(;;)switch(e.prev = e.next){
                            case 0:
                                return r = a.length > 1 && void 0 !== a[1] ? a[1] : 3, n = {}, o = [], t.forEach(function(e) {
                                    var t = e.fileName;
                                    null != t && -1 === o.indexOf(t) && o.push(t);
                                }), e.next = 6, Object(U.settle)(o.map(function() {
                                    var e = j(A.a.mark(function e(t) {
                                        var r, o, a;
                                        return A.a.wrap(function(e) {
                                            for(;;)switch(e.prev = e.next){
                                                case 0:
                                                    return r = 0 === t.indexOf("webpack-internal:") ? "/__get-internal-source?fileName=".concat(encodeURIComponent(t)) : t, e.next = 3, fetch(r).then(function(e) {
                                                        return e.text();
                                                    });
                                                case 3:
                                                    return o = e.sent, e.next = 6, z(t, o);
                                                case 6:
                                                    a = e.sent, n[t] = {
                                                        fileSource: o,
                                                        map: a
                                                    };
                                                case 8:
                                                case "end":
                                                    return e.stop();
                                            }
                                        }, e);
                                    }));
                                    return function(t) {
                                        return e.apply(this, arguments);
                                    };
                                }()));
                            case 6:
                                return e.abrupt("return", t.map(function(e) {
                                    var t = e.functionName, o = e.fileName, a = e.lineNumber, i = e.columnNumber, l = n[o] || {}, u = l.map, c = l.fileSource;
                                    if (null == u || null == a) return e;
                                    var s = u.getOriginalPosition(a, i), f = s.source, d = s.line, p = s.column, h = null == f ? [] : u.getSource(f);
                                    return new x(t, o, a, i, F(a, r, c), t, f, d, p, F(d, r, h));
                                }));
                            case 7:
                            case "end":
                                return e.stop();
                        }
                    }, e);
                }))).apply(this, arguments);
            }
            var $ = r(2), V = r.n($);
            function W(e, t) {
                var r = -1, n = -1;
                do ++r, n = t.indexOf(e, n + 1);
                while (-1 !== n);
                return r;
            }
            function G(e, t) {
                return Q.apply(this, arguments);
            }
            function Q() {
                return (Q = j(A.a.mark(function e(t, r) {
                    var n, o, a, i, l = arguments;
                    return A.a.wrap(function(e) {
                        for(;;)switch(e.prev = e.next){
                            case 0:
                                if (n = l.length > 2 && void 0 !== l[2] ? l[2] : 3, o = "object" == typeof t ? t.contents : null, a = "object" == typeof t ? t.uri : t, null != o) {
                                    e.next = 7;
                                    break;
                                }
                                return e.next = 6, fetch(a).then(function(e) {
                                    return e.text();
                                });
                            case 6:
                                o = e.sent;
                            case 7:
                                return e.next = 9, z(a, o);
                            case 9:
                                return i = e.sent, e.abrupt("return", r.map(function(e) {
                                    var t = e.functionName, r = e.lineNumber, l = e.columnNumber;
                                    if (null != e._originalLineNumber) return e;
                                    var u = e.fileName;
                                    if (u && (u = V.a.normalize(u.replace(/[\\]+/g, "/"))), null == u) return e;
                                    var c = u, s = i.getSources().map(function(e) {
                                        return e.replace(/[\\]+/g, "/");
                                    }).filter(function(e) {
                                        var t = (e = V.a.normalize(e)).lastIndexOf(c);
                                        return -1 !== t && t === e.length - c.length;
                                    }).map(function(e) {
                                        return {
                                            token: e,
                                            seps: W(V.a.sep, V.a.normalize(e)),
                                            penalties: W("node_modules", e) + W("~", e)
                                        };
                                    }).sort(function(e, t) {
                                        var r = Math.sign(e.seps - t.seps);
                                        return 0 !== r ? r : Math.sign(e.penalties - t.penalties);
                                    });
                                    if (s.length < 1 || null == r) return new x(null, null, null, null, null, t, c, r, l, null);
                                    var f = s[0].token, d = i.getGeneratedPosition(f, r, l), p = d.line, h = d.column, g = i.getSource(f);
                                    return new x(t, a, p, h || null, F(p, n, o || []), t, c, r, l, F(r, n, g));
                                }));
                            case 11:
                            case "end":
                                return e.stop();
                        }
                    }, e);
                }))).apply(this, arguments);
            }
            var Y = function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3, r = L(e);
                return (e.__unmap_source ? G(e.__unmap_source, r, t) : B(r, t)).then(function(e) {
                    return 0 === e.map(function(e) {
                        return e._originalFileName;
                    }).filter(function(e) {
                        return null != e && -1 === e.indexOf("node_modules");
                    }).length ? null : e.filter(function(e) {
                        var t = e.functionName;
                        return null == t || -1 === t.indexOf("__stack_frame_overlay_proxy_console__");
                    });
                });
            }, X = function(e) {
                return function(t) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    Y(t, r, 3).then(function(n) {
                        null != n && e({
                            error: t,
                            unhandledRejection: r,
                            contextSize: 3,
                            stackFrames: n
                        });
                    }).catch(function(e) {
                        console.log("Could not get the stack frames of error:", e);
                    });
                };
            };
            function K(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "/static/js/bundle.js", r = X(e);
                return a(window, function(e) {
                    return r(e, !1);
                }), u(window, function(e) {
                    return r(e, !0);
                }), function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f;
                    if (!c) try {
                        s = Error.stackTraceLimit, Error.stackTraceLimit = e, c = !0;
                    } catch (e) {}
                }(), p(), g("error", function(e, n) {
                    var o = function(e, t) {
                        for(var r, n, o = function(e) {
                            return e.split("\n").filter(function(e) {
                                return !e.match(/^\s*in/);
                            }).join("\n");
                        }(e), a = "", i = 0; i < t.length; ++i){
                            var l = t[i], u = l.fileName, c = l.lineNumber;
                            if (null != u && null != c && !(u === r && "number" == typeof c && "number" == typeof n && Math.abs(c - n) < 3)) {
                                r = u, n = c;
                                var s = t[i].name;
                                a += "in ".concat(s = s || "(anonymous function)", " (at ").concat(u, ":").concat(c, ")\n");
                            }
                        }
                        return {
                            message: o,
                            stack: a
                        };
                    }(e, n);
                    r({
                        message: o.message,
                        stack: o.stack,
                        __unmap_source: t
                    }, !1);
                }), function() {
                    var e;
                    !function() {
                        if (c) try {
                            Error.stackTraceLimit = s, c = !1;
                        } catch (e) {}
                    }(), e = window, null !== i && (e.removeEventListener("unhandledrejection", i), i = null), function(e) {
                        null !== n && (e.removeEventListener("error", n), n = null);
                    }(window), h();
                };
            }
            var J = {
                position: "fixed",
                top: "0",
                left: "0",
                width: "100%",
                height: "100%",
                border: "none",
                "z-index": 2147483647
            };
            var Z = '/*! For license information please see iframe-bundle.js.LICENSE.txt */\n!function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=208)}([function(e,t,r){"use strict";e.exports=r(183)},function(e,t,r){var n=r(8),o=r(35).f,a=r(18),i=r(21),l=r(38),u=r(60),c=r(64);e.exports=function(e,t){var r,s,f,d,p,h=e.target,g=e.global,v=e.stat;if(r=g?n:v?n[h]||l(h,{}):(n[h]||{}).prototype)for(s in t){if(d=t[s],f=e.noTargetGet?(p=o(r,s))&&p.value:r[s],!c(g?s:h+(v?".":"#")+s,e.forced)&&void 0!==f){if(typeof d===typeof f)continue;u(d,f)}(e.sham||f&&f.sham)&&a(d,"sham",!0),i(r,s,d,e)}}},function(e,t,r){var n=r(13);e.exports=function(e){if(!n(e))throw TypeError(String(e)+" is not an object");return e}},function(e,t){e.exports=!1},function(e,t,r){var n=r(2),o=r(66),a=r(26),i=r(7),l=r(45),u=r(69),c=function(e,t){this.stopped=e,this.result=t};e.exports=function(e,t,r){var s,f,d,p,h,g,v,m=r&&r.that,y=!(!r||!r.AS_ENTRIES),b=!(!r||!r.IS_ITERATOR),w=!(!r||!r.INTERRUPTED),k=i(t,m,1+y+w),E=function(e){return s&&u(s),new c(!0,e)},x=function(e){return y?(n(e),w?k(e[0],e[1],E):k(e[0],e[1])):w?k(e,E):k(e)};if(b)s=e;else{if("function"!=typeof(f=l(e)))throw TypeError("Target is not iterable");if(o(f)){for(d=0,p=a(e.length);p>d;d++)if((h=x(e[d]))&&h instanceof c)return h;return new c(!1)}s=f.call(e)}for(g=s.next;!(v=g.call(s)).done;){try{h=x(v.value)}catch(e){throw u(s),e}if("object"==typeof h&&h&&h instanceof c)return h}return new c(!1)}},function(e,t){e.exports=function(e){if("function"!=typeof e)throw TypeError(String(e)+" is not a function");return e}},function(e,t,r){var n=r(8),o=r(40),a=r(11),i=r(31),l=r(44),u=r(67),c=o("wks"),s=n.Symbol,f=u?s:s&&s.withoutSetter||i;e.exports=function(e){return a(c,e)||(l&&a(s,e)?c[e]=s[e]:c[e]=f("Symbol."+e)),c[e]}},function(e,t,r){var n=r(5);e.exports=function(e,t,r){if(n(e),void 0===t)return e;switch(r){case 0:return function(){return e.call(t)};case 1:return function(r){return e.call(t,r)};case 2:return function(r,n){return e.call(t,r,n)};case 3:return function(r,n,o){return e.call(t,r,n,o)}}return function(){return e.apply(t,arguments)}}},function(e,t,r){(function(t){var r=function(e){return e&&e.Math==Math&&e};e.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof t&&t)||function(){return this}()||Function("return this")()}).call(this,r(34))},function(e,t,r){var n=r(61),o=r(11),a=r(82),i=r(14).f;e.exports=function(e){var t=n.Symbol||(n.Symbol={});o(t,e)||i(t,e,{value:a.f(e)})}},function(e,t,r){var n=r(61),o=r(8),a=function(e){return"function"==typeof e?e:void 0};e.exports=function(e,t){return arguments.length<2?a(n[e])||a(o[e]):n[e]&&n[e][t]||o[e]&&o[e][t]}},function(e,t){var r={}.hasOwnProperty;e.exports=function(e,t){return r.call(e,t)}},function(e,t){e.exports=function(e){try{return!!e()}catch(e){return!0}}},function(e,t){e.exports=function(e){return"object"===typeof e?null!==e:"function"===typeof e}},function(e,t,r){var n=r(16),o=r(57),a=r(2),i=r(29),l=Object.defineProperty;t.f=n?l:function(e,t,r){if(a(e),t=i(t,!0),a(r),o)try{return l(e,t,r)}catch(e){}if("get"in r||"set"in r)throw TypeError("Accessors not supported");return"value"in r&&(e[t]=r.value),e}},function(e,t,r){var n=r(3),o=r(48);e.exports=n?o:function(e){return Map.prototype.entries.call(e)}},function(e,t,r){var n=r(12);e.exports=!n((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(e,t,r){var n=r(2),o=r(5),a=r(6)("species");e.exports=function(e,t){var r,i=n(e).constructor;return void 0===i||void 0==(r=n(i)[a])?t:o(r)}},function(e,t,r){var n=r(16),o=r(14),a=r(23);e.exports=n?function(e,t,r){return o.f(e,t,a(1,r))}:function(e,t,r){return e[t]=r,e}},function(e,t,r){var n=r(3),o=r(48);e.exports=n?o:function(e){return Set.prototype.values.call(e)}},function(e,t,r){var n=r(56),o=r(37);e.exports=function(e){return n(o(e))}},function(e,t,r){var n=r(8),o=r(18),a=r(11),i=r(38),l=r(59),u=r(24),c=u.get,s=u.enforce,f=String(String).split("String");(e.exports=function(e,t,r,l){var u,c=!!l&&!!l.unsafe,d=!!l&&!!l.enumerable,p=!!l&&!!l.noTargetGet;"function"==typeof r&&("string"!=typeof t||a(r,"name")||o(r,"name",t),(u=s(r)).source||(u.source=f.join("string"==typeof t?t:""))),e!==n?(c?!p&&e[t]&&(d=!0):delete e[t],d?e[t]=r:o(e,t,r)):d?e[t]=r:i(t,r)})(Function.prototype,"toString",(function(){return"function"==typeof this&&c(this).source||l(this)}))},function(e,t,r){var n=r(14).f,o=r(11),a=r(6)("toStringTag");e.exports=function(e,t,r){e&&!o(e=r?e:e.prototype,a)&&n(e,a,{configurable:!0,value:t})}},function(e,t){e.exports=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}}},function(e,t,r){var n,o,a,i=r(92),l=r(8),u=r(13),c=r(18),s=r(11),f=r(39),d=r(30),p=r(25),h=l.WeakMap;if(i){var g=f.state||(f.state=new h),v=g.get,m=g.has,y=g.set;n=function(e,t){return t.facade=e,y.call(g,e,t),t},o=function(e){return v.call(g,e)||{}},a=function(e){return m.call(g,e)}}else{var b=d("state");p[b]=!0,n=function(e,t){return t.facade=e,c(e,b,t),t},o=function(e){return s(e,b)?e[b]:{}},a=function(e){return s(e,b)}}e.exports={set:n,get:o,has:a,enforce:function(e){return a(e)?o(e):n(e,{})},getterFor:function(e){return function(t){var r;if(!u(t)||(r=o(t)).type!==e)throw TypeError("Incompatible receiver, "+e+" required");return r}}}},function(e,t){e.exports={}},function(e,t,r){var n=r(42),o=Math.min;e.exports=function(e){return e>0?o(n(e),9007199254740991):0}},function(e,t){e.exports={}},function(e,t,r){var n=r(37);e.exports=function(e){return Object(n(e))}},function(e,t,r){var n=r(13);e.exports=function(e,t){if(!n(e))return e;var r,o;if(t&&"function"==typeof(r=e.toString)&&!n(o=r.call(e)))return o;if("function"==typeof(r=e.valueOf)&&!n(o=r.call(e)))return o;if(!t&&"function"==typeof(r=e.toString)&&!n(o=r.call(e)))return o;throw TypeError("Can\'t convert object to primitive value")}},function(e,t,r){var n=r(40),o=r(31),a=n("keys");e.exports=function(e){return a[e]||(a[e]=o(e))}},function(e,t){var r=0,n=Math.random();e.exports=function(e){return"Symbol("+String(void 0===e?"":e)+")_"+(++r+n).toString(36)}},function(e,t,r){var n,o=r(2),a=r(99),i=r(43),l=r(25),u=r(100),c=r(58),s=r(30),f=s("IE_PROTO"),d=function(){},p=function(e){return"<script>"+e+"</"+"script>"},h=function(){try{n=document.domain&&new ActiveXObject("htmlfile")}catch(e){}var e,t;h=n?function(e){e.write(p("")),e.close();var t=e.parentWindow.Object;return e=null,t}(n):((t=c("iframe")).style.display="none",u.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(p("document.F=Object")),e.close(),e.F);for(var r=i.length;r--;)delete h.prototype[i[r]];return h()};l[f]=!0,e.exports=Object.create||function(e,t){var r;return null!==e?(d.prototype=o(e),r=new d,d.prototype=null,r[f]=e):r=h(),void 0===t?r:a(r,t)}},function(e,t,r){"use strict";var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}();var o=[[{color:"0, 0, 0",class:"ansi-black"},{color:"187, 0, 0",class:"ansi-red"},{color:"0, 187, 0",class:"ansi-green"},{color:"187, 187, 0",class:"ansi-yellow"},{color:"0, 0, 187",class:"ansi-blue"},{color:"187, 0, 187",class:"ansi-magenta"},{color:"0, 187, 187",class:"ansi-cyan"},{color:"255,255,255",class:"ansi-white"}],[{color:"85, 85, 85",class:"ansi-bright-black"},{color:"255, 85, 85",class:"ansi-bright-red"},{color:"0, 255, 0",class:"ansi-bright-green"},{color:"255, 255, 85",class:"ansi-bright-yellow"},{color:"85, 85, 255",class:"ansi-bright-blue"},{color:"255, 85, 255",class:"ansi-bright-magenta"},{color:"85, 255, 255",class:"ansi-bright-cyan"},{color:"255, 255, 255",class:"ansi-bright-white"}]],a=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.fg=this.bg=this.fg_truecolor=this.bg_truecolor=null,this.bright=0}return n(e,null,[{key:"escapeForHtml",value:function(t){return(new e).escapeForHtml(t)}},{key:"linkify",value:function(t){return(new e).linkify(t)}},{key:"ansiToHtml",value:function(t,r){return(new e).ansiToHtml(t,r)}},{key:"ansiToJson",value:function(t,r){return(new e).ansiToJson(t,r)}},{key:"ansiToText",value:function(t){return(new e).ansiToText(t)}}]),n(e,[{key:"setupPalette",value:function(){this.PALETTE_COLORS=[];for(var e=0;e<2;++e)for(var t=0;t<8;++t)this.PALETTE_COLORS.push(o[e][t].color);for(var r=[0,95,135,175,215,255],n=function(e,t,n){return r[e]+", "+r[t]+", "+r[n]},a=0;a<6;++a)for(var i=0;i<6;++i)for(var l=0;l<6;++l)this.PALETTE_COLORS.push(n(a,i,l));for(var u=8,c=0;c<24;++c,u+=10)this.PALETTE_COLORS.push(n(u,u,u))}},{key:"escapeForHtml",value:function(e){return e.replace(/[&<>]/gm,(function(e){return"&"==e?"&amp;":"<"==e?"&lt;":">"==e?"&gt;":""}))}},{key:"linkify",value:function(e){return e.replace(/(https?:\\/\\/[^\\s]+)/gm,(function(e){return\'<a href="\'+e+\'">\'+e+"</a>"}))}},{key:"ansiToHtml",value:function(e,t){return this.process(e,t,!0)}},{key:"ansiToJson",value:function(e,t){return(t=t||{}).json=!0,t.clearLine=!1,this.process(e,t,!0)}},{key:"ansiToText",value:function(e){return this.process(e,{},!1)}},{key:"process",value:function(e,t,r){var n=this,o=e.split(/\\033\\[/),a=o.shift();void 0!==t&&null!==t||(t={}),t.clearLine=/\\r/.test(e);var i=o.map((function(e){return n.processChunk(e,t,r)}));if(t&&t.json){var l=this.processChunkJson("");return l.content=a,l.clearLine=t.clearLine,i.unshift(l),t.remove_empty&&(i=i.filter((function(e){return!e.isEmpty()}))),i}return i.unshift(a),i.join("")}},{key:"processChunkJson",value:function(e,t,r){var n=(t="undefined"==typeof t?{}:t).use_classes="undefined"!=typeof t.use_classes&&t.use_classes,a=t.key=n?"class":"color",i={content:e,fg:null,bg:null,fg_truecolor:null,bg_truecolor:null,clearLine:t.clearLine,decoration:null,was_processed:!1,isEmpty:function(){return!i.content}},l=e.match(/^([!\\x3c-\\x3f]*)([\\d;]*)([\\x20-\\x2c]*[\\x40-\\x7e])([\\s\\S]*)/m);if(!l)return i;i.content=l[4];var u=l[2].split(";");if(""!==l[1]||"m"!==l[3])return i;if(!r)return i;var c=this;for(c.decoration=null;u.length>0;){var s=u.shift(),f=parseInt(s);if(isNaN(f)||0===f)c.fg=c.bg=c.decoration=null;else if(1===f)c.decoration="bold";else if(2===f)c.decoration="dim";else if(3==f)c.decoration="italic";else if(4==f)c.decoration="underline";else if(5==f)c.decoration="blink";else if(7===f)c.decoration="reverse";else if(8===f)c.decoration="hidden";else if(9===f)c.decoration="strikethrough";else if(39==f)c.fg=null;else if(49==f)c.bg=null;else if(f>=30&&f<38)c.fg=o[0][f%10][a];else if(f>=90&&f<98)c.fg=o[1][f%10][a];else if(f>=40&&f<48)c.bg=o[0][f%10][a];else if(f>=100&&f<108)c.bg=o[1][f%10][a];else if(38===f||48===f){var d=38===f;if(u.length>=1){var p=u.shift();if("5"===p&&u.length>=1){var h=parseInt(u.shift());if(h>=0&&h<=255)if(n){var g=h>=16?"ansi-palette-"+h:o[h>7?1:0][h%8].class;d?c.fg=g:c.bg=g}else this.PALETTE_COLORS||c.setupPalette(),d?c.fg=this.PALETTE_COLORS[h]:c.bg=this.PALETTE_COLORS[h]}else if("2"===p&&u.length>=3){var v=parseInt(u.shift()),m=parseInt(u.shift()),y=parseInt(u.shift());if(v>=0&&v<=255&&m>=0&&m<=255&&y>=0&&y<=255){var b=v+", "+m+", "+y;n?d?(c.fg="ansi-truecolor",c.fg_truecolor=b):(c.bg="ansi-truecolor",c.bg_truecolor=b):d?c.fg=b:c.bg=b}}}}}if(null===c.fg&&null===c.bg&&null===c.decoration)return i;return i.fg=c.fg,i.bg=c.bg,i.fg_truecolor=c.fg_truecolor,i.bg_truecolor=c.bg_truecolor,i.decoration=c.decoration,i.was_processed=!0,i}},{key:"processChunk",value:function(e,t,r){var n=this;t=t||{};var o=this.processChunkJson(e,t,r);if(t.json)return o;if(o.isEmpty())return"";if(!o.was_processed)return o.content;var a=t.use_classes,i=[],l=[],u={},c=function(e){var t=[],r=void 0;for(r in e)e.hasOwnProperty(r)&&t.push("data-"+r+\'="\'+n.escapeForHtml(e[r])+\'"\');return t.length>0?" "+t.join(" "):""};return o.fg&&(a?(l.push(o.fg+"-fg"),null!==o.fg_truecolor&&(u["ansi-truecolor-fg"]=o.fg_truecolor,o.fg_truecolor=null)):i.push("color:rgb("+o.fg+")")),o.bg&&(a?(l.push(o.bg+"-bg"),null!==o.bg_truecolor&&(u["ansi-truecolor-bg"]=o.bg_truecolor,o.bg_truecolor=null)):i.push("background-color:rgb("+o.bg+")")),o.decoration&&(a?l.push("ansi-"+o.decoration):"bold"===o.decoration?i.push("font-weight:bold"):"dim"===o.decoration?i.push("opacity:0.5"):"italic"===o.decoration?i.push("font-style:italic"):"reverse"===o.decoration?i.push("filter:invert(100%)"):"hidden"===o.decoration?i.push("visibility:hidden"):"strikethrough"===o.decoration?i.push("text-decoration:line-through"):i.push("text-decoration:"+o.decoration)),a?\'<span class="\'+l.join(" ")+\'"\'+c(u)+">"+o.content+"</span>":\'<span style="\'+i.join(";")+\'"\'+c(u)+">"+o.content+"</span>"}}]),e}();e.exports=a},function(e,t){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(e){"object"===typeof window&&(r=window)}e.exports=r},function(e,t,r){var n=r(16),o=r(55),a=r(23),i=r(20),l=r(29),u=r(11),c=r(57),s=Object.getOwnPropertyDescriptor;t.f=n?s:function(e,t){if(e=i(e),t=l(t,!0),c)try{return s(e,t)}catch(e){}if(u(e,t))return a(!o.f.call(e,t),e[t])}},function(e,t){var r={}.toString;e.exports=function(e){return r.call(e).slice(8,-1)}},function(e,t){e.exports=function(e){if(void 0==e)throw TypeError("Can\'t call method on "+e);return e}},function(e,t,r){var n=r(8),o=r(18);e.exports=function(e,t){try{o(n,e,t)}catch(r){n[e]=t}return t}},function(e,t,r){var n=r(8),o=r(38),a="__core-js_shared__",i=n[a]||o(a,{});e.exports=i},function(e,t,r){var n=r(3),o=r(39);(e.exports=function(e,t){return o[e]||(o[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.8.3",mode:n?"pure":"global",copyright:"\xa9 2021 Denis Pushkarev (zloirock.ru)"})},function(e,t,r){var n=r(62),o=r(43).concat("length","prototype");t.f=Object.getOwnPropertyNames||function(e){return n(e,o)}},function(e,t){var r=Math.ceil,n=Math.floor;e.exports=function(e){return isNaN(e=+e)?0:(e>0?n:r)(e)}},function(e,t){e.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(e,t,r){var n=r(12);e.exports=!!Object.getOwnPropertySymbols&&!n((function(){return!String(Symbol())}))},function(e,t,r){var n=r(68),o=r(27),a=r(6)("iterator");e.exports=function(e){if(void 0!=e)return e[a]||e["@@iterator"]||o[n(e)]}},function(e,t,r){var n={};n[r(6)("toStringTag")]="z",e.exports="[object z]"===String(n)},function(e,t,r){"use strict";var n=r(1),o=r(102),a=r(76),i=r(72),l=r(22),u=r(18),c=r(21),s=r(6),f=r(3),d=r(27),p=r(75),h=p.IteratorPrototype,g=p.BUGGY_SAFARI_ITERATORS,v=s("iterator"),m="keys",y="values",b="entries",w=function(){return this};e.exports=function(e,t,r,s,p,k,E){o(r,t,s);var x,S,_,T=function(e){if(e===p&&N)return N;if(!g&&e in P)return P[e];switch(e){case m:case y:case b:return function(){return new r(this,e)}}return function(){return new r(this)}},C=t+" Iterator",O=!1,P=e.prototype,R=P[v]||P["@@iterator"]||p&&P[p],N=!g&&R||T(p),L="Array"==t&&P.entries||R;if(L&&(x=a(L.call(new e)),h!==Object.prototype&&x.next&&(f||a(x)===h||(i?i(x,h):"function"!=typeof x[v]&&u(x,v,w)),l(x,C,!0,!0),f&&(d[C]=w))),p==y&&R&&R.name!==y&&(O=!0,N=function(){return R.call(this)}),f&&!E||P[v]===N||u(P,v,N),d[t]=N,p)if(S={values:T(y),keys:k?N:T(m),entries:T(b)},E)for(_ in S)(g||O||!(_ in P))&&c(P,_,S[_]);else n({target:t,proto:!0,forced:g||O},S);return S}},function(e,t,r){var n=r(2),o=r(45);e.exports=function(e){var t=o(e);if("function"!=typeof t)throw TypeError(String(e)+" is not iterable");return n(t.call(e))}},function(e,t,r){var n=r(36);e.exports=Array.isArray||function(e){return"Array"==n(e)}},function(e,t,r){"use strict";var n=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable;function i(e){if(null===e||void 0===e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var t={},r=0;r<10;r++)t["_"+String.fromCharCode(r)]=r;if("0123456789"!==Object.getOwnPropertyNames(t).map((function(e){return t[e]})).join(""))return!1;var n={};return"abcdefghijklmnopqrst".split("").forEach((function(e){n[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},n)).join("")}catch(e){return!1}}()?Object.assign:function(e,t){for(var r,l,u=i(e),c=1;c<arguments.length;c++){for(var s in r=Object(arguments[c]))o.call(r,s)&&(u[s]=r[s]);if(n){l=n(r);for(var f=0;f<l.length;f++)a.call(r,l[f])&&(u[l[f]]=r[l[f]])}}return u}},function(e,t){var r,n,o=e.exports={};function a(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function l(e){if(r===setTimeout)return setTimeout(e,0);if((r===a||!r)&&setTimeout)return r=setTimeout,setTimeout(e,0);try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}!function(){try{r="function"===typeof setTimeout?setTimeout:a}catch(e){r=a}try{n="function"===typeof clearTimeout?clearTimeout:i}catch(e){n=i}}();var u,c=[],s=!1,f=-1;function d(){s&&u&&(s=!1,u.length?c=u.concat(c):f=-1,c.length&&p())}function p(){if(!s){var e=l(d);s=!0;for(var t=c.length;t;){for(u=c,c=[];++f<t;)u&&u[f].run();f=-1,t=c.length}u=null,s=!1,function(e){if(n===clearTimeout)return clearTimeout(e);if((n===i||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}(e)}}function h(e,t){this.fun=e,this.array=t}function g(){}o.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];c.push(new h(e,t)),1!==c.length||s||l(p)},h.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=g,o.addListener=g,o.once=g,o.off=g,o.removeListener=g,o.removeAllListeners=g,o.emit=g,o.prependListener=g,o.prependOnceListener=g,o.listeners=function(e){return[]},o.binding=function(e){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(e){throw new Error("process.chdir is not supported")},o.umask=function(){return 0}},function(e,t,r){var n=r(191);e.exports=function(e,t){var r;if("undefined"===typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(r=n(e))||t&&e&&"number"===typeof e.length){r&&(e=r);var o=0,a=function(){};return{s:a,n:function(){return o>=e.length?{done:!0}:{done:!1,value:e[o++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,l=!0,u=!1;return{s:function(){r=e[Symbol.iterator]()},n:function(){var e=r.next();return l=e.done,e},e:function(e){u=!0,i=e},f:function(){try{l||null==r.return||r.return()}finally{if(u)throw i}}}}},function(e,t,r){"use strict";!function e(){if("undefined"!==typeof{}&&"function"===typeof{}.checkDCE)try{({}).checkDCE(e)}catch(e){console.error(e)}}(),e.exports=r(184)},function(e,t,r){"use strict";var n=r(1),o=r(8),a=r(64),i=r(21),l=r(65),u=r(4),c=r(70),s=r(13),f=r(12),d=r(71),p=r(22),h=r(97);e.exports=function(e,t,r){var g=-1!==e.indexOf("Map"),v=-1!==e.indexOf("Weak"),m=g?"set":"add",y=o[e],b=y&&y.prototype,w=y,k={},E=function(e){var t=b[e];i(b,e,"add"==e?function(e){return t.call(this,0===e?0:e),this}:"delete"==e?function(e){return!(v&&!s(e))&&t.call(this,0===e?0:e)}:"get"==e?function(e){return v&&!s(e)?void 0:t.call(this,0===e?0:e)}:"has"==e?function(e){return!(v&&!s(e))&&t.call(this,0===e?0:e)}:function(e,r){return t.call(this,0===e?0:e,r),this})};if(a(e,"function"!=typeof y||!(v||b.forEach&&!f((function(){(new y).entries().next()})))))w=r.getConstructor(t,e,g,m),l.REQUIRED=!0;else if(a(e,!0)){var x=new w,S=x[m](v?{}:-0,1)!=x,_=f((function(){x.has(1)})),T=d((function(e){new y(e)})),C=!v&&f((function(){for(var e=new y,t=5;t--;)e[m](t,t);return!e.has(-0)}));T||((w=t((function(t,r){c(t,w,e);var n=h(new y,t,w);return void 0!=r&&u(r,n[m],{that:n,AS_ENTRIES:g}),n}))).prototype=b,b.constructor=w),(_||C)&&(E("delete"),E("has"),g&&E("get")),(C||S)&&E(m),v&&b.clear&&delete b.clear}return k[e]=w,n({global:!0,forced:w!=y},k),p(w,e),v||r.setStrong(w,e,g),w}},function(e,t,r){"use strict";var n={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,a=o&&!n.call({1:2},1);t.f=a?function(e){var t=o(this,e);return!!t&&t.enumerable}:n},function(e,t,r){var n=r(12),o=r(36),a="".split;e.exports=n((function(){return!Object("z").propertyIsEnumerable(0)}))?function(e){return"String"==o(e)?a.call(e,""):Object(e)}:Object},function(e,t,r){var n=r(16),o=r(12),a=r(58);e.exports=!n&&!o((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(e,t,r){var n=r(8),o=r(13),a=n.document,i=o(a)&&o(a.createElement);e.exports=function(e){return i?a.createElement(e):{}}},function(e,t,r){var n=r(39),o=Function.toString;"function"!=typeof n.inspectSource&&(n.inspectSource=function(e){return o.call(e)}),e.exports=n.inspectSource},function(e,t,r){var n=r(11),o=r(93),a=r(35),i=r(14);e.exports=function(e,t){for(var r=o(t),l=i.f,u=a.f,c=0;c<r.length;c++){var s=r[c];n(e,s)||l(e,s,u(t,s))}}},function(e,t,r){var n=r(8);e.exports=n},function(e,t,r){var n=r(11),o=r(20),a=r(94).indexOf,i=r(25);e.exports=function(e,t){var r,l=o(e),u=0,c=[];for(r in l)!n(i,r)&&n(l,r)&&c.push(r);for(;t.length>u;)n(l,r=t[u++])&&(~a(c,r)||c.push(r));return c}},function(e,t){t.f=Object.getOwnPropertySymbols},function(e,t,r){var n=r(12),o=/#|\\.prototype\\./,a=function(e,t){var r=l[i(e)];return r==c||r!=u&&("function"==typeof t?n(t):!!t)},i=a.normalize=function(e){return String(e).replace(o,".").toLowerCase()},l=a.data={},u=a.NATIVE="N",c=a.POLYFILL="P";e.exports=a},function(e,t,r){var n=r(25),o=r(13),a=r(11),i=r(14).f,l=r(31),u=r(96),c=l("meta"),s=0,f=Object.isExtensible||function(){return!0},d=function(e){i(e,c,{value:{objectID:"O"+ ++s,weakData:{}}})},p=e.exports={REQUIRED:!1,fastKey:function(e,t){if(!o(e))return"symbol"==typeof e?e:("string"==typeof e?"S":"P")+e;if(!a(e,c)){if(!f(e))return"F";if(!t)return"E";d(e)}return e[c].objectID},getWeakData:function(e,t){if(!a(e,c)){if(!f(e))return!0;if(!t)return!1;d(e)}return e[c].weakData},onFreeze:function(e){return u&&p.REQUIRED&&f(e)&&!a(e,c)&&d(e),e}};n[c]=!0},function(e,t,r){var n=r(6),o=r(27),a=n("iterator"),i=Array.prototype;e.exports=function(e){return void 0!==e&&(o.Array===e||i[a]===e)}},function(e,t,r){var n=r(44);e.exports=n&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(e,t,r){var n=r(46),o=r(36),a=r(6)("toStringTag"),i="Arguments"==o(function(){return arguments}());e.exports=n?o:function(e){var t,r,n;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(r=function(e,t){try{return e[t]}catch(e){}}(t=Object(e),a))?r:i?o(t):"Object"==(n=o(t))&&"function"==typeof t.callee?"Arguments":n}},function(e,t,r){var n=r(2);e.exports=function(e){var t=e.return;if(void 0!==t)return n(t.call(e)).value}},function(e,t){e.exports=function(e,t,r){if(!(e instanceof t))throw TypeError("Incorrect "+(r?r+" ":"")+"invocation");return e}},function(e,t,r){var n=r(6)("iterator"),o=!1;try{var a=0,i={next:function(){return{done:!!a++}},return:function(){o=!0}};i[n]=function(){return this},Array.from(i,(function(){throw 2}))}catch(e){}e.exports=function(e,t){if(!t&&!o)return!1;var r=!1;try{var a={};a[n]=function(){return{next:function(){return{done:r=!0}}}},e(a)}catch(e){}return r}},function(e,t,r){var n=r(2),o=r(98);e.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,r={};try{(e=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(r,[]),t=r instanceof Array}catch(e){}return function(r,a){return n(r),o(a),t?e.call(r,a):r.__proto__=a,r}}():void 0)},function(e,t,r){"use strict";var n=r(14).f,o=r(32),a=r(101),i=r(7),l=r(70),u=r(4),c=r(47),s=r(104),f=r(16),d=r(65).fastKey,p=r(24),h=p.set,g=p.getterFor;e.exports={getConstructor:function(e,t,r,c){var s=e((function(e,n){l(e,s,t),h(e,{type:t,index:o(null),first:void 0,last:void 0,size:0}),f||(e.size=0),void 0!=n&&u(n,e[c],{that:e,AS_ENTRIES:r})})),p=g(t),v=function(e,t,r){var n,o,a=p(e),i=m(e,t);return i?i.value=r:(a.last=i={index:o=d(t,!0),key:t,value:r,previous:n=a.last,next:void 0,removed:!1},a.first||(a.first=i),n&&(n.next=i),f?a.size++:e.size++,"F"!==o&&(a.index[o]=i)),e},m=function(e,t){var r,n=p(e),o=d(t);if("F"!==o)return n.index[o];for(r=n.first;r;r=r.next)if(r.key==t)return r};return a(s.prototype,{clear:function(){for(var e=p(this),t=e.index,r=e.first;r;)r.removed=!0,r.previous&&(r.previous=r.previous.next=void 0),delete t[r.index],r=r.next;e.first=e.last=void 0,f?e.size=0:this.size=0},delete:function(e){var t=this,r=p(t),n=m(t,e);if(n){var o=n.next,a=n.previous;delete r.index[n.index],n.removed=!0,a&&(a.next=o),o&&(o.previous=a),r.first==n&&(r.first=o),r.last==n&&(r.last=a),f?r.size--:t.size--}return!!n},forEach:function(e){for(var t,r=p(this),n=i(e,arguments.length>1?arguments[1]:void 0,3);t=t?t.next:r.first;)for(n(t.value,t.key,this);t&&t.removed;)t=t.previous},has:function(e){return!!m(this,e)}}),a(s.prototype,r?{get:function(e){var t=m(this,e);return t&&t.value},set:function(e,t){return v(this,0===e?0:e,t)}}:{add:function(e){return v(this,e=0===e?0:e,e)}}),f&&n(s.prototype,"size",{get:function(){return p(this).size}}),s},setStrong:function(e,t,r){var n=t+" Iterator",o=g(t),a=g(n);c(e,t,(function(e,t){h(this,{type:n,target:e,state:o(e),kind:t,last:void 0})}),(function(){for(var e=a(this),t=e.kind,r=e.last;r&&r.removed;)r=r.previous;return e.target&&(e.last=r=r?r.next:e.state.first)?"keys"==t?{value:r.key,done:!1}:"values"==t?{value:r.value,done:!1}:{value:[r.key,r.value],done:!1}:(e.target=void 0,{value:void 0,done:!0})}),r?"entries":"values",!r,!0),s(t)}}},function(e,t,r){var n=r(62),o=r(43);e.exports=Object.keys||function(e){return n(e,o)}},function(e,t,r){"use strict";var n,o,a,i=r(12),l=r(76),u=r(18),c=r(11),s=r(6),f=r(3),d=s("iterator"),p=!1;[].keys&&("next"in(a=[].keys())?(o=l(l(a)))!==Object.prototype&&(n=o):p=!0);var h=void 0==n||i((function(){var e={};return n[d].call(e)!==e}));h&&(n={}),f&&!h||c(n,d)||u(n,d,(function(){return this})),e.exports={IteratorPrototype:n,BUGGY_SAFARI_ITERATORS:p}},function(e,t,r){var n=r(11),o=r(28),a=r(30),i=r(103),l=a("IE_PROTO"),u=Object.prototype;e.exports=i?Object.getPrototypeOf:function(e){return e=o(e),n(e,l)?e[l]:"function"==typeof e.constructor&&e instanceof e.constructor?e.constructor.prototype:e instanceof Object?u:null}},function(e,t,r){var n=r(46),o=r(21),a=r(105);n||o(Object.prototype,"toString",a,{unsafe:!0})},function(e,t,r){"use strict";var n=r(107).charAt,o=r(24),a=r(47),i="String Iterator",l=o.set,u=o.getterFor(i);a(String,"String",(function(e){l(this,{type:i,string:String(e),index:0})}),(function(){var e,t=u(this),r=t.string,o=t.index;return o>=r.length?{value:void 0,done:!0}:(e=n(r,o),t.index+=e.length,{value:e,done:!1})}))},function(e,t,r){"use strict";var n=r(2),o=r(5);e.exports=function(){for(var e,t=n(this),r=o(t.delete),a=!0,i=0,l=arguments.length;i<l;i++)e=r.call(t,arguments[i]),a=a&&e;return!!a}},function(e,t,r){"use strict";var n=r(5),o=r(7),a=r(4);e.exports=function(e){var t,r,i,l,u=arguments.length,c=u>1?arguments[1]:void 0;return n(this),(t=void 0!==c)&&n(c),void 0==e?new this:(r=[],t?(i=0,l=o(c,u>2?arguments[2]:void 0,2),a(e,(function(e){r.push(l(e,i++))}))):a(e,r.push,{that:r}),new this(r))}},function(e,t,r){"use strict";e.exports=function(){for(var e=arguments.length,t=new Array(e);e--;)t[e]=arguments[e];return new this(t)}},function(e,t,r){var n=r(6);t.f=n},function(e,t,r){var n=r(13),o=r(49),a=r(6)("species");e.exports=function(e,t){var r;return o(e)&&("function"!=typeof(r=e.constructor)||r!==Array&&!o(r.prototype)?n(r)&&null===(r=r[a])&&(r=void 0):r=void 0),new(void 0===r?Array:r)(0===t?0:t)}},function(e,t,r){"use strict";var n=r(29),o=r(14),a=r(23);e.exports=function(e,t,r){var i=n(t);i in e?o.f(e,i,a(0,r)):e[i]=r}},function(e,t,r){var n,o,a=r(8),i=r(168),l=a.process,u=l&&l.versions,c=u&&u.v8;c?o=(n=c.split("."))[0]+n[1]:i&&(!(n=i.match(/Edge\\/(\\d+)/))||n[1]>=74)&&(n=i.match(/Chrome\\/(\\d+)/))&&(o=n[1]),e.exports=o&&+o},function(e,t,r){"use strict";var n=r(178);function o(){}var a=null,i={};function l(e){if("object"!==typeof this)throw new TypeError("Promises must be constructed via new");if("function"!==typeof e)throw new TypeError("Promise constructor\'s argument is not a function");this._U=0,this._V=0,this._W=null,this._X=null,e!==o&&p(e,this)}function u(e,t){for(;3===e._V;)e=e._W;if(l._Y&&l._Y(e),0===e._V)return 0===e._U?(e._U=1,void(e._X=t)):1===e._U?(e._U=2,void(e._X=[e._X,t])):void e._X.push(t);!function(e,t){n((function(){var r=1===e._V?t.onFulfilled:t.onRejected;if(null!==r){var n=function(e,t){try{return e(t)}catch(e){return a=e,i}}(r,e._W);n===i?s(t.promise,a):c(t.promise,n)}else 1===e._V?c(t.promise,e._W):s(t.promise,e._W)}))}(e,t)}function c(e,t){if(t===e)return s(e,new TypeError("A promise cannot be resolved with itself."));if(t&&("object"===typeof t||"function"===typeof t)){var r=function(e){try{return e.then}catch(e){return a=e,i}}(t);if(r===i)return s(e,a);if(r===e.then&&t instanceof l)return e._V=3,e._W=t,void f(e);if("function"===typeof r)return void p(r.bind(t),e)}e._V=1,e._W=t,f(e)}function s(e,t){e._V=2,e._W=t,l._Z&&l._Z(e,t),f(e)}function f(e){if(1===e._U&&(u(e,e._X),e._X=null),2===e._U){for(var t=0;t<e._X.length;t++)u(e,e._X[t]);e._X=null}}function d(e,t,r){this.onFulfilled="function"===typeof e?e:null,this.onRejected="function"===typeof t?t:null,this.promise=r}function p(e,t){var r=!1,n=function(e,t,r){try{e(t,r)}catch(e){return a=e,i}}(e,(function(e){r||(r=!0,c(t,e))}),(function(e){r||(r=!0,s(t,e))}));r||n!==i||(r=!0,s(t,a))}e.exports=l,l._Y=null,l._Z=null,l._0=o,l.prototype.then=function(e,t){if(this.constructor!==l)return function(e,t,r){return new e.constructor((function(n,a){var i=new l(o);i.then(n,a),u(e,new d(t,r,i))}))}(this,e,t);var r=new l(o);return u(this,new d(e,t,r)),r}},function(e,t,r){var n=r(204),o={};for(var a in n)n.hasOwnProperty(a)&&(o[n[a]]=a);var i=e.exports={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};for(var l in i)if(i.hasOwnProperty(l)){if(!("channels"in i[l]))throw new Error("missing channels property: "+l);if(!("labels"in i[l]))throw new Error("missing channel labels property: "+l);if(i[l].labels.length!==i[l].channels)throw new Error("channel and label counts mismatch: "+l);var u=i[l].channels,c=i[l].labels;delete i[l].channels,delete i[l].labels,Object.defineProperty(i[l],"channels",{value:u}),Object.defineProperty(i[l],"labels",{value:c})}i.rgb.hsl=function(e){var t,r,n=e[0]/255,o=e[1]/255,a=e[2]/255,i=Math.min(n,o,a),l=Math.max(n,o,a),u=l-i;return l===i?t=0:n===l?t=(o-a)/u:o===l?t=2+(a-n)/u:a===l&&(t=4+(n-o)/u),(t=Math.min(60*t,360))<0&&(t+=360),r=(i+l)/2,[t,100*(l===i?0:r<=.5?u/(l+i):u/(2-l-i)),100*r]},i.rgb.hsv=function(e){var t,r,n,o,a,i=e[0]/255,l=e[1]/255,u=e[2]/255,c=Math.max(i,l,u),s=c-Math.min(i,l,u),f=function(e){return(c-e)/6/s+.5};return 0===s?o=a=0:(a=s/c,t=f(i),r=f(l),n=f(u),i===c?o=n-r:l===c?o=1/3+t-n:u===c&&(o=2/3+r-t),o<0?o+=1:o>1&&(o-=1)),[360*o,100*a,100*c]},i.rgb.hwb=function(e){var t=e[0],r=e[1],n=e[2];return[i.rgb.hsl(e)[0],100*(1/255*Math.min(t,Math.min(r,n))),100*(n=1-1/255*Math.max(t,Math.max(r,n)))]},i.rgb.cmyk=function(e){var t,r=e[0]/255,n=e[1]/255,o=e[2]/255;return[100*((1-r-(t=Math.min(1-r,1-n,1-o)))/(1-t)||0),100*((1-n-t)/(1-t)||0),100*((1-o-t)/(1-t)||0),100*t]},i.rgb.keyword=function(e){var t=o[e];if(t)return t;var r,a,i,l=1/0;for(var u in n)if(n.hasOwnProperty(u)){var c=n[u],s=(a=e,i=c,Math.pow(a[0]-i[0],2)+Math.pow(a[1]-i[1],2)+Math.pow(a[2]-i[2],2));s<l&&(l=s,r=u)}return r},i.keyword.rgb=function(e){return n[e]},i.rgb.xyz=function(e){var t=e[0]/255,r=e[1]/255,n=e[2]/255;return[100*(.4124*(t=t>.04045?Math.pow((t+.055)/1.055,2.4):t/12.92)+.3576*(r=r>.04045?Math.pow((r+.055)/1.055,2.4):r/12.92)+.1805*(n=n>.04045?Math.pow((n+.055)/1.055,2.4):n/12.92)),100*(.2126*t+.7152*r+.0722*n),100*(.0193*t+.1192*r+.9505*n)]},i.rgb.lab=function(e){var t=i.rgb.xyz(e),r=t[0],n=t[1],o=t[2];return n/=100,o/=108.883,r=(r/=95.047)>.008856?Math.pow(r,1/3):7.787*r+16/116,[116*(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116)-16,500*(r-n),200*(n-(o=o>.008856?Math.pow(o,1/3):7.787*o+16/116))]},i.hsl.rgb=function(e){var t,r,n,o,a,i=e[0]/360,l=e[1]/100,u=e[2]/100;if(0===l)return[a=255*u,a,a];t=2*u-(r=u<.5?u*(1+l):u+l-u*l),o=[0,0,0];for(var c=0;c<3;c++)(n=i+1/3*-(c-1))<0&&n++,n>1&&n--,a=6*n<1?t+6*(r-t)*n:2*n<1?r:3*n<2?t+(r-t)*(2/3-n)*6:t,o[c]=255*a;return o},i.hsl.hsv=function(e){var t=e[0],r=e[1]/100,n=e[2]/100,o=r,a=Math.max(n,.01);return r*=(n*=2)<=1?n:2-n,o*=a<=1?a:2-a,[t,100*(0===n?2*o/(a+o):2*r/(n+r)),100*((n+r)/2)]},i.hsv.rgb=function(e){var t=e[0]/60,r=e[1]/100,n=e[2]/100,o=Math.floor(t)%6,a=t-Math.floor(t),i=255*n*(1-r),l=255*n*(1-r*a),u=255*n*(1-r*(1-a));switch(n*=255,o){case 0:return[n,u,i];case 1:return[l,n,i];case 2:return[i,n,u];case 3:return[i,l,n];case 4:return[u,i,n];case 5:return[n,i,l]}},i.hsv.hsl=function(e){var t,r,n,o=e[0],a=e[1]/100,i=e[2]/100,l=Math.max(i,.01);return n=(2-a)*i,r=a*l,[o,100*(r=(r/=(t=(2-a)*l)<=1?t:2-t)||0),100*(n/=2)]},i.hwb.rgb=function(e){var t,r,n,o,a,i,l,u=e[0]/360,c=e[1]/100,s=e[2]/100,f=c+s;switch(f>1&&(c/=f,s/=f),n=6*u-(t=Math.floor(6*u)),0!==(1&t)&&(n=1-n),o=c+n*((r=1-s)-c),t){default:case 6:case 0:a=r,i=o,l=c;break;case 1:a=o,i=r,l=c;break;case 2:a=c,i=r,l=o;break;case 3:a=c,i=o,l=r;break;case 4:a=o,i=c,l=r;break;case 5:a=r,i=c,l=o}return[255*a,255*i,255*l]},i.cmyk.rgb=function(e){var t=e[0]/100,r=e[1]/100,n=e[2]/100,o=e[3]/100;return[255*(1-Math.min(1,t*(1-o)+o)),255*(1-Math.min(1,r*(1-o)+o)),255*(1-Math.min(1,n*(1-o)+o))]},i.xyz.rgb=function(e){var t,r,n,o=e[0]/100,a=e[1]/100,i=e[2]/100;return r=-.9689*o+1.8758*a+.0415*i,n=.0557*o+-.204*a+1.057*i,t=(t=3.2406*o+-1.5372*a+-.4986*i)>.0031308?1.055*Math.pow(t,1/2.4)-.055:12.92*t,r=r>.0031308?1.055*Math.pow(r,1/2.4)-.055:12.92*r,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:12.92*n,[255*(t=Math.min(Math.max(0,t),1)),255*(r=Math.min(Math.max(0,r),1)),255*(n=Math.min(Math.max(0,n),1))]},i.xyz.lab=function(e){var t=e[0],r=e[1],n=e[2];return r/=100,n/=108.883,t=(t/=95.047)>.008856?Math.pow(t,1/3):7.787*t+16/116,[116*(r=r>.008856?Math.pow(r,1/3):7.787*r+16/116)-16,500*(t-r),200*(r-(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116))]},i.lab.xyz=function(e){var t,r,n,o=e[0];t=e[1]/500+(r=(o+16)/116),n=r-e[2]/200;var a=Math.pow(r,3),i=Math.pow(t,3),l=Math.pow(n,3);return r=a>.008856?a:(r-16/116)/7.787,t=i>.008856?i:(t-16/116)/7.787,n=l>.008856?l:(n-16/116)/7.787,[t*=95.047,r*=100,n*=108.883]},i.lab.lch=function(e){var t,r=e[0],n=e[1],o=e[2];return(t=360*Math.atan2(o,n)/2/Math.PI)<0&&(t+=360),[r,Math.sqrt(n*n+o*o),t]},i.lch.lab=function(e){var t,r=e[0],n=e[1];return t=e[2]/360*2*Math.PI,[r,n*Math.cos(t),n*Math.sin(t)]},i.rgb.ansi16=function(e){var t=e[0],r=e[1],n=e[2],o=1 in arguments?arguments[1]:i.rgb.hsv(e)[2];if(0===(o=Math.round(o/50)))return 30;var a=30+(Math.round(n/255)<<2|Math.round(r/255)<<1|Math.round(t/255));return 2===o&&(a+=60),a},i.hsv.ansi16=function(e){return i.rgb.ansi16(i.hsv.rgb(e),e[2])},i.rgb.ansi256=function(e){var t=e[0],r=e[1],n=e[2];return t===r&&r===n?t<8?16:t>248?231:Math.round((t-8)/247*24)+232:16+36*Math.round(t/255*5)+6*Math.round(r/255*5)+Math.round(n/255*5)},i.ansi16.rgb=function(e){var t=e%10;if(0===t||7===t)return e>50&&(t+=3.5),[t=t/10.5*255,t,t];var r=.5*(1+~~(e>50));return[(1&t)*r*255,(t>>1&1)*r*255,(t>>2&1)*r*255]},i.ansi256.rgb=function(e){if(e>=232){var t=10*(e-232)+8;return[t,t,t]}var r;return e-=16,[Math.floor(e/36)/5*255,Math.floor((r=e%36)/6)/5*255,r%6/5*255]},i.rgb.hex=function(e){var t=(((255&Math.round(e[0]))<<16)+((255&Math.round(e[1]))<<8)+(255&Math.round(e[2]))).toString(16).toUpperCase();return"000000".substring(t.length)+t},i.hex.rgb=function(e){var t=e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!t)return[0,0,0];var r=t[0];3===t[0].length&&(r=r.split("").map((function(e){return e+e})).join(""));var n=parseInt(r,16);return[n>>16&255,n>>8&255,255&n]},i.rgb.hcg=function(e){var t,r=e[0]/255,n=e[1]/255,o=e[2]/255,a=Math.max(Math.max(r,n),o),i=Math.min(Math.min(r,n),o),l=a-i;return t=l<=0?0:a===r?(n-o)/l%6:a===n?2+(o-r)/l:4+(r-n)/l+4,t/=6,[360*(t%=1),100*l,100*(l<1?i/(1-l):0)]},i.hsl.hcg=function(e){var t=e[1]/100,r=e[2]/100,n=1,o=0;return(n=r<.5?2*t*r:2*t*(1-r))<1&&(o=(r-.5*n)/(1-n)),[e[0],100*n,100*o]},i.hsv.hcg=function(e){var t=e[1]/100,r=e[2]/100,n=t*r,o=0;return n<1&&(o=(r-n)/(1-n)),[e[0],100*n,100*o]},i.hcg.rgb=function(e){var t=e[0]/360,r=e[1]/100,n=e[2]/100;if(0===r)return[255*n,255*n,255*n];var o,a=[0,0,0],i=t%1*6,l=i%1,u=1-l;switch(Math.floor(i)){case 0:a[0]=1,a[1]=l,a[2]=0;break;case 1:a[0]=u,a[1]=1,a[2]=0;break;case 2:a[0]=0,a[1]=1,a[2]=l;break;case 3:a[0]=0,a[1]=u,a[2]=1;break;case 4:a[0]=l,a[1]=0,a[2]=1;break;default:a[0]=1,a[1]=0,a[2]=u}return o=(1-r)*n,[255*(r*a[0]+o),255*(r*a[1]+o),255*(r*a[2]+o)]},i.hcg.hsv=function(e){var t=e[1]/100,r=t+e[2]/100*(1-t),n=0;return r>0&&(n=t/r),[e[0],100*n,100*r]},i.hcg.hsl=function(e){var t=e[1]/100,r=e[2]/100*(1-t)+.5*t,n=0;return r>0&&r<.5?n=t/(2*r):r>=.5&&r<1&&(n=t/(2*(1-r))),[e[0],100*n,100*r]},i.hcg.hwb=function(e){var t=e[1]/100,r=t+e[2]/100*(1-t);return[e[0],100*(r-t),100*(1-r)]},i.hwb.hcg=function(e){var t=e[1]/100,r=1-e[2]/100,n=r-t,o=0;return n<1&&(o=(r-n)/(1-n)),[e[0],100*n,100*o]},i.apple.rgb=function(e){return[e[0]/65535*255,e[1]/65535*255,e[2]/65535*255]},i.rgb.apple=function(e){return[e[0]/255*65535,e[1]/255*65535,e[2]/255*65535]},i.gray.rgb=function(e){return[e[0]/100*255,e[0]/100*255,e[0]/100*255]},i.gray.hsl=i.gray.hsv=function(e){return[0,0,e[0]]},i.gray.hwb=function(e){return[0,100,e[0]]},i.gray.cmyk=function(e){return[0,0,0,e[0]]},i.gray.lab=function(e){return[e[0],0,0]},i.gray.hex=function(e){var t=255&Math.round(e[0]/100*255),r=((t<<16)+(t<<8)+t).toString(16).toUpperCase();return"000000".substring(r.length)+r},i.rgb.gray=function(e){return[(e[0]+e[1]+e[2])/3/255*100]}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(187);t.XmlEntities=n.XmlEntities;var o=r(188);t.Html4Entities=o.Html4Entities;var a=r(189);t.Html5Entities=a.Html5Entities,t.AllHtmlEntities=a.Html5Entities},function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0}),t.codeFrameColumns=c,t.default=function(t,r,n){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!a){a=!0;var i="Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";if(e.emitWarning)e.emitWarning(i,"DeprecationWarning");else{var l=new Error(i);l.name="DeprecationWarning",console.warn(new Error(i))}}var u={start:{column:n=Math.max(n,0),line:r}};return c(t,u,o)};var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==typeof e&&"function"!==typeof e)return{default:e};var t=o();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var i=n?Object.getOwnPropertyDescriptor(e,a):null;i&&(i.get||i.set)?Object.defineProperty(r,a,i):r[a]=e[a]}r.default=e,t&&t.set(e,r);return r}(r(190));function o(){if("function"!==typeof WeakMap)return null;var e=new WeakMap;return o=function(){return e},e}var a=!1;function i(e){return{gutter:e.grey,marker:e.red.bold,message:e.red.bold}}var l=/\\r\\n|[\\n\\r\\u2028\\u2029]/;function u(e,t,r){var n=Object.assign({column:0,line:-1},e.start),o=Object.assign({},n,e.end),a=r||{},i=a.linesAbove,l=void 0===i?2:i,u=a.linesBelow,c=void 0===u?3:u,s=n.line,f=n.column,d=o.line,p=o.column,h=Math.max(s-(l+1),0),g=Math.min(t.length,d+c);-1===s&&(h=0),-1===d&&(g=t.length);var v=d-s,m={};if(v)for(var y=0;y<=v;y++){var b=y+s;if(f)if(0===y){var w=t[b-1].length;m[b]=[f,w-f+1]}else if(y===v)m[b]=[0,p];else{var k=t[b-y].length;m[b]=[0,k]}else m[b]=!0}else m[s]=f===p?!f||[f,0]:[f,p-f];return{start:h,end:g,markerLines:m}}function c(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=(r.highlightCode||r.forceColor)&&(0,n.shouldHighlight)(r),a=(0,n.getChalk)(r),c=i(a),s=function(e,t){return o?e(t):t},f=e.split(l),d=u(t,f,r),p=d.start,h=d.end,g=d.markerLines,v=t.start&&"number"===typeof t.start.column,m=String(h).length,y=o?(0,n.default)(e,r):e,b=y.split(l).slice(p,h).map((function(e,t){var n=p+1+t,o=" ".concat(n).slice(-m),a=" ".concat(o," | "),i=g[n],l=!g[n+1];if(i){var u="";if(Array.isArray(i)){var f=e.slice(0,Math.max(i[0]-1,0)).replace(/[^\\t]/g," "),d=i[1]||1;u=["\\n ",s(c.gutter,a.replace(/\\d/g," ")),f,s(c.marker,"^").repeat(d)].join(""),l&&r.message&&(u+=" "+s(c.message,r.message))}return[s(c.marker,">"),s(c.gutter,a),e,u].join("")}return" ".concat(s(c.gutter,a)).concat(e)})).join("\\n");return r.message&&!v&&(b="".concat(" ".repeat(m+1)).concat(r.message,"\\n").concat(b)),o?a.reset(b):b}}).call(this,r(51))},function(e,t,r){"use strict";r(91),r(77),r(106),r(78),r(108),r(109),r(110),r(111),r(112),r(113),r(114),r(115),r(117),r(118),r(119),r(120),r(121),r(122),r(123),r(124),r(125),r(126),r(128),r(129),r(130),r(131),r(132),r(133),r(134),r(135),r(136),r(137),r(138),r(139),r(140),r(141),r(142),r(143),r(144),r(145),r(149),r(181).polyfill()},function(e,t,r){"use strict";var n=r(54),o=r(73);e.exports=n("Map",(function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}}),o)},function(e,t,r){var n=r(8),o=r(59),a=n.WeakMap;e.exports="function"===typeof a&&/native code/.test(o(a))},function(e,t,r){var n=r(10),o=r(41),a=r(63),i=r(2);e.exports=n("Reflect","ownKeys")||function(e){var t=o.f(i(e)),r=a.f;return r?t.concat(r(e)):t}},function(e,t,r){var n=r(20),o=r(26),a=r(95),i=function(e){return function(t,r,i){var l,u=n(t),c=o(u.length),s=a(i,c);if(e&&r!=r){for(;c>s;)if((l=u[s++])!=l)return!0}else for(;c>s;s++)if((e||s in u)&&u[s]===r)return e||s||0;return!e&&-1}};e.exports={includes:i(!0),indexOf:i(!1)}},function(e,t,r){var n=r(42),o=Math.max,a=Math.min;e.exports=function(e,t){var r=n(e);return r<0?o(r+t,0):a(r,t)}},function(e,t,r){var n=r(12);e.exports=!n((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(e,t,r){var n=r(13),o=r(72);e.exports=function(e,t,r){var a,i;return o&&"function"==typeof(a=t.constructor)&&a!==r&&n(i=a.prototype)&&i!==r.prototype&&o(e,i),e}},function(e,t,r){var n=r(13);e.exports=function(e){if(!n(e)&&null!==e)throw TypeError("Can\'t set "+String(e)+" as a prototype");return e}},function(e,t,r){var n=r(16),o=r(14),a=r(2),i=r(74);e.exports=n?Object.defineProperties:function(e,t){a(e);for(var r,n=i(t),l=n.length,u=0;l>u;)o.f(e,r=n[u++],t[r]);return e}},function(e,t,r){var n=r(10);e.exports=n("document","documentElement")},function(e,t,r){var n=r(21);e.exports=function(e,t,r){for(var o in t)n(e,o,t[o],r);return e}},function(e,t,r){"use strict";var n=r(75).IteratorPrototype,o=r(32),a=r(23),i=r(22),l=r(27),u=function(){return this};e.exports=function(e,t,r){var c=t+" Iterator";return e.prototype=o(n,{next:a(1,r)}),i(e,c,!1,!0),l[c]=u,e}},function(e,t,r){var n=r(12);e.exports=!n((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype}))},function(e,t,r){"use strict";var n=r(10),o=r(14),a=r(6),i=r(16),l=a("species");e.exports=function(e){var t=n(e),r=o.f;i&&t&&!t[l]&&r(t,l,{configurable:!0,get:function(){return this}})}},function(e,t,r){"use strict";var n=r(46),o=r(68);e.exports=n?{}.toString:function(){return"[object "+o(this)+"]"}},function(e,t,r){"use strict";var n=r(54),o=r(73);e.exports=n("Set",(function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}}),o)},function(e,t,r){var n=r(42),o=r(37),a=function(e){return function(t,r){var a,i,l=String(o(t)),u=n(r),c=l.length;return u<0||u>=c?e?"":void 0:(a=l.charCodeAt(u))<55296||a>56319||u+1===c||(i=l.charCodeAt(u+1))<56320||i>57343?e?l.charAt(u):a:e?l.slice(u,u+2):i-56320+(a-55296<<10)+65536}};e.exports={codeAt:a(!1),charAt:a(!0)}},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(79);n({target:"Map",proto:!0,real:!0,forced:o},{deleteAll:function(){return a.apply(this,arguments)}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(7),l=r(15),u=r(4);n({target:"Map",proto:!0,real:!0,forced:o},{every:function(e){var t=a(this),r=l(t),n=i(e,arguments.length>1?arguments[1]:void 0,3);return!u(r,(function(e,r,o){if(!n(r,e,t))return o()}),{AS_ENTRIES:!0,IS_ITERATOR:!0,INTERRUPTED:!0}).stopped}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(10),i=r(2),l=r(5),u=r(7),c=r(17),s=r(15),f=r(4);n({target:"Map",proto:!0,real:!0,forced:o},{filter:function(e){var t=i(this),r=s(t),n=u(e,arguments.length>1?arguments[1]:void 0,3),o=new(c(t,a("Map"))),d=l(o.set);return f(r,(function(e,r){n(r,e,t)&&d.call(o,e,r)}),{AS_ENTRIES:!0,IS_ITERATOR:!0}),o}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(7),l=r(15),u=r(4);n({target:"Map",proto:!0,real:!0,forced:o},{find:function(e){var t=a(this),r=l(t),n=i(e,arguments.length>1?arguments[1]:void 0,3);return u(r,(function(e,r,o){if(n(r,e,t))return o(r)}),{AS_ENTRIES:!0,IS_ITERATOR:!0,INTERRUPTED:!0}).result}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(7),l=r(15),u=r(4);n({target:"Map",proto:!0,real:!0,forced:o},{findKey:function(e){var t=a(this),r=l(t),n=i(e,arguments.length>1?arguments[1]:void 0,3);return u(r,(function(e,r,o){if(n(r,e,t))return o(e)}),{AS_ENTRIES:!0,IS_ITERATOR:!0,INTERRUPTED:!0}).result}})},function(e,t,r){r(1)({target:"Map",stat:!0},{from:r(80)})},function(e,t,r){"use strict";var n=r(1),o=r(4),a=r(5);n({target:"Map",stat:!0},{groupBy:function(e,t){var r=new this;a(t);var n=a(r.has),i=a(r.get),l=a(r.set);return o(e,(function(e){var o=t(e);n.call(r,o)?i.call(r,o).push(e):l.call(r,o,[e])})),r}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(15),l=r(116),u=r(4);n({target:"Map",proto:!0,real:!0,forced:o},{includes:function(e){return u(i(a(this)),(function(t,r,n){if(l(r,e))return n()}),{AS_ENTRIES:!0,IS_ITERATOR:!0,INTERRUPTED:!0}).stopped}})},function(e,t){e.exports=function(e,t){return e===t||e!=e&&t!=t}},function(e,t,r){"use strict";var n=r(1),o=r(4),a=r(5);n({target:"Map",stat:!0},{keyBy:function(e,t){var r=new this;a(t);var n=a(r.set);return o(e,(function(e){n.call(r,t(e),e)})),r}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(15),l=r(4);n({target:"Map",proto:!0,real:!0,forced:o},{keyOf:function(e){return l(i(a(this)),(function(t,r,n){if(r===e)return n(t)}),{AS_ENTRIES:!0,IS_ITERATOR:!0,INTERRUPTED:!0}).result}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(10),i=r(2),l=r(5),u=r(7),c=r(17),s=r(15),f=r(4);n({target:"Map",proto:!0,real:!0,forced:o},{mapKeys:function(e){var t=i(this),r=s(t),n=u(e,arguments.length>1?arguments[1]:void 0,3),o=new(c(t,a("Map"))),d=l(o.set);return f(r,(function(e,r){d.call(o,n(r,e,t),r)}),{AS_ENTRIES:!0,IS_ITERATOR:!0}),o}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(10),i=r(2),l=r(5),u=r(7),c=r(17),s=r(15),f=r(4);n({target:"Map",proto:!0,real:!0,forced:o},{mapValues:function(e){var t=i(this),r=s(t),n=u(e,arguments.length>1?arguments[1]:void 0,3),o=new(c(t,a("Map"))),d=l(o.set);return f(r,(function(e,r){d.call(o,e,n(r,e,t))}),{AS_ENTRIES:!0,IS_ITERATOR:!0}),o}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(5),l=r(4);n({target:"Map",proto:!0,real:!0,forced:o},{merge:function(e){for(var t=a(this),r=i(t.set),n=0;n<arguments.length;)l(arguments[n++],r,{that:t,AS_ENTRIES:!0});return t}})},function(e,t,r){r(1)({target:"Map",stat:!0},{of:r(81)})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(5),l=r(15),u=r(4);n({target:"Map",proto:!0,real:!0,forced:o},{reduce:function(e){var t=a(this),r=l(t),n=arguments.length<2,o=n?void 0:arguments[1];if(i(e),u(r,(function(r,a){n?(n=!1,o=a):o=e(o,a,r,t)}),{AS_ENTRIES:!0,IS_ITERATOR:!0}),n)throw TypeError("Reduce of empty map with no initial value");return o}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(7),l=r(15),u=r(4);n({target:"Map",proto:!0,real:!0,forced:o},{some:function(e){var t=a(this),r=l(t),n=i(e,arguments.length>1?arguments[1]:void 0,3);return u(r,(function(e,r,o){if(n(r,e,t))return o()}),{AS_ENTRIES:!0,IS_ITERATOR:!0,INTERRUPTED:!0}).stopped}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(5);n({target:"Map",proto:!0,real:!0,forced:o},{update:function(e,t){var r=a(this),n=arguments.length;i(t);var o=r.has(e);if(!o&&n<3)throw TypeError("Updating absent value");var l=o?r.get(e):i(n>2?arguments[2]:void 0)(e,r);return r.set(e,t(l,e,r)),r}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(127);n({target:"Set",proto:!0,real:!0,forced:o},{addAll:function(){return a.apply(this,arguments)}})},function(e,t,r){"use strict";var n=r(2),o=r(5);e.exports=function(){for(var e=n(this),t=o(e.add),r=0,a=arguments.length;r<a;r++)t.call(e,arguments[r]);return e}},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(79);n({target:"Set",proto:!0,real:!0,forced:o},{deleteAll:function(){return a.apply(this,arguments)}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(10),i=r(2),l=r(5),u=r(17),c=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{difference:function(e){var t=i(this),r=new(u(t,a("Set")))(t),n=l(r.delete);return c(e,(function(e){n.call(r,e)})),r}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(7),l=r(19),u=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{every:function(e){var t=a(this),r=l(t),n=i(e,arguments.length>1?arguments[1]:void 0,3);return!u(r,(function(e,r){if(!n(e,e,t))return r()}),{IS_ITERATOR:!0,INTERRUPTED:!0}).stopped}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(10),i=r(2),l=r(5),u=r(7),c=r(17),s=r(19),f=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{filter:function(e){var t=i(this),r=s(t),n=u(e,arguments.length>1?arguments[1]:void 0,3),o=new(c(t,a("Set"))),d=l(o.add);return f(r,(function(e){n(e,e,t)&&d.call(o,e)}),{IS_ITERATOR:!0}),o}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(7),l=r(19),u=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{find:function(e){var t=a(this),r=l(t),n=i(e,arguments.length>1?arguments[1]:void 0,3);return u(r,(function(e,r){if(n(e,e,t))return r(e)}),{IS_ITERATOR:!0,INTERRUPTED:!0}).result}})},function(e,t,r){r(1)({target:"Set",stat:!0},{from:r(80)})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(10),i=r(2),l=r(5),u=r(17),c=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{intersection:function(e){var t=i(this),r=new(u(t,a("Set"))),n=l(t.has),o=l(r.add);return c(e,(function(e){n.call(t,e)&&o.call(r,e)})),r}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(5),l=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{isDisjointFrom:function(e){var t=a(this),r=i(t.has);return!l(e,(function(e,n){if(!0===r.call(t,e))return n()}),{INTERRUPTED:!0}).stopped}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(10),i=r(2),l=r(5),u=r(48),c=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{isSubsetOf:function(e){var t=u(this),r=i(e),n=r.has;return"function"!=typeof n&&(r=new(a("Set"))(e),n=l(r.has)),!c(t,(function(e,t){if(!1===n.call(r,e))return t()}),{IS_ITERATOR:!0,INTERRUPTED:!0}).stopped}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(5),l=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{isSupersetOf:function(e){var t=a(this),r=i(t.has);return!l(e,(function(e,n){if(!1===r.call(t,e))return n()}),{INTERRUPTED:!0}).stopped}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(19),l=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{join:function(e){var t=a(this),r=i(t),n=void 0===e?",":String(e),o=[];return l(r,o.push,{that:o,IS_ITERATOR:!0}),o.join(n)}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(10),i=r(2),l=r(5),u=r(7),c=r(17),s=r(19),f=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{map:function(e){var t=i(this),r=s(t),n=u(e,arguments.length>1?arguments[1]:void 0,3),o=new(c(t,a("Set"))),d=l(o.add);return f(r,(function(e){d.call(o,n(e,e,t))}),{IS_ITERATOR:!0}),o}})},function(e,t,r){r(1)({target:"Set",stat:!0},{of:r(81)})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(5),l=r(19),u=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{reduce:function(e){var t=a(this),r=l(t),n=arguments.length<2,o=n?void 0:arguments[1];if(i(e),u(r,(function(r){n?(n=!1,o=r):o=e(o,r,r,t)}),{IS_ITERATOR:!0}),n)throw TypeError("Reduce of empty set with no initial value");return o}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(2),i=r(7),l=r(19),u=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{some:function(e){var t=a(this),r=l(t),n=i(e,arguments.length>1?arguments[1]:void 0,3);return u(r,(function(e,r){if(n(e,e,t))return r()}),{IS_ITERATOR:!0,INTERRUPTED:!0}).stopped}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(10),i=r(2),l=r(5),u=r(17),c=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{symmetricDifference:function(e){var t=i(this),r=new(u(t,a("Set")))(t),n=l(r.delete),o=l(r.add);return c(e,(function(e){n.call(r,e)||o.call(r,e)})),r}})},function(e,t,r){"use strict";var n=r(1),o=r(3),a=r(10),i=r(2),l=r(5),u=r(17),c=r(4);n({target:"Set",proto:!0,real:!0,forced:o},{union:function(e){var t=i(this),r=new(u(t,a("Set")))(t);return c(e,l(r.add),{that:r}),r}})},function(e,t,r){var n=r(8),o=r(146),a=r(147),i=r(18),l=r(6),u=l("iterator"),c=l("toStringTag"),s=a.values;for(var f in o){var d=n[f],p=d&&d.prototype;if(p){if(p[u]!==s)try{i(p,u,s)}catch(e){p[u]=s}if(p[c]||i(p,c,f),o[f])for(var h in a)if(p[h]!==a[h])try{i(p,h,a[h])}catch(e){p[h]=a[h]}}}},function(e,t){e.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(e,t,r){"use strict";var n=r(20),o=r(148),a=r(27),i=r(24),l=r(47),u="Array Iterator",c=i.set,s=i.getterFor(u);e.exports=l(Array,"Array",(function(e,t){c(this,{type:u,target:n(e),index:0,kind:t})}),(function(){var e=s(this),t=e.target,r=e.kind,n=e.index++;return!t||n>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==r?{value:n,done:!1}:"values"==r?{value:t[n],done:!1}:{value:[n,t[n]],done:!1}}),"values"),a.Arguments=a.Array,o("keys"),o("values"),o("entries")},function(e,t,r){var n=r(6),o=r(32),a=r(14),i=n("unscopables"),l=Array.prototype;void 0==l[i]&&a.f(l,i,{configurable:!0,value:o(null)}),e.exports=function(e){l[i][e]=!0}},function(e,t,r){"use strict";r(150),r(153),r(154),r(155),r(156),r(157),r(158),r(159),r(160),r(161),r(162),r(163),r(164),r(165),r(166),r(169),r(172),r(173),r(77),r(78),r(174),r(175),r(176),"undefined"===typeof Promise&&(r(177).enable(),self.Promise=r(179)),"undefined"!==typeof window&&r(180),Object.assign=r(50)},function(e,t,r){"use strict";var n=r(1),o=r(8),a=r(10),i=r(3),l=r(16),u=r(44),c=r(67),s=r(12),f=r(11),d=r(49),p=r(13),h=r(2),g=r(28),v=r(20),m=r(29),y=r(23),b=r(32),w=r(74),k=r(41),E=r(151),x=r(63),S=r(35),_=r(14),T=r(55),C=r(18),O=r(21),P=r(40),R=r(30),N=r(25),L=r(31),A=r(6),I=r(82),j=r(9),M=r(22),D=r(24),q=r(152).forEach,z=R("hidden"),U="Symbol",F=A("toPrimitive"),B=D.set,V=D.getterFor(U),H=Object.prototype,W=o.Symbol,$=a("JSON","stringify"),G=S.f,Q=_.f,Y=E.f,K=T.f,X=P("symbols"),J=P("op-symbols"),Z=P("string-to-symbol-registry"),ee=P("symbol-to-string-registry"),te=P("wks"),re=o.QObject,ne=!re||!re.prototype||!re.prototype.findChild,oe=l&&s((function(){return 7!=b(Q({},"a",{get:function(){return Q(this,"a",{value:7}).a}})).a}))?function(e,t,r){var n=G(H,t);n&&delete H[t],Q(e,t,r),n&&e!==H&&Q(H,t,n)}:Q,ae=function(e,t){var r=X[e]=b(W.prototype);return B(r,{type:U,tag:e,description:t}),l||(r.description=t),r},ie=c?function(e){return"symbol"==typeof e}:function(e){return Object(e)instanceof W},le=function(e,t,r){e===H&&le(J,t,r),h(e);var n=m(t,!0);return h(r),f(X,n)?(r.enumerable?(f(e,z)&&e[z][n]&&(e[z][n]=!1),r=b(r,{enumerable:y(0,!1)})):(f(e,z)||Q(e,z,y(1,{})),e[z][n]=!0),oe(e,n,r)):Q(e,n,r)},ue=function(e,t){h(e);var r=v(t),n=w(r).concat(de(r));return q(n,(function(t){l&&!ce.call(r,t)||le(e,t,r[t])})),e},ce=function(e){var t=m(e,!0),r=K.call(this,t);return!(this===H&&f(X,t)&&!f(J,t))&&(!(r||!f(this,t)||!f(X,t)||f(this,z)&&this[z][t])||r)},se=function(e,t){var r=v(e),n=m(t,!0);if(r!==H||!f(X,n)||f(J,n)){var o=G(r,n);return!o||!f(X,n)||f(r,z)&&r[z][n]||(o.enumerable=!0),o}},fe=function(e){var t=Y(v(e)),r=[];return q(t,(function(e){f(X,e)||f(N,e)||r.push(e)})),r},de=function(e){var t=e===H,r=Y(t?J:v(e)),n=[];return q(r,(function(e){!f(X,e)||t&&!f(H,e)||n.push(X[e])})),n};(u||(O((W=function(){if(this instanceof W)throw TypeError("Symbol is not a constructor");var e=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,t=L(e),r=function e(r){this===H&&e.call(J,r),f(this,z)&&f(this[z],t)&&(this[z][t]=!1),oe(this,t,y(1,r))};return l&&ne&&oe(H,t,{configurable:!0,set:r}),ae(t,e)}).prototype,"toString",(function(){return V(this).tag})),O(W,"withoutSetter",(function(e){return ae(L(e),e)})),T.f=ce,_.f=le,S.f=se,k.f=E.f=fe,x.f=de,I.f=function(e){return ae(A(e),e)},l&&(Q(W.prototype,"description",{configurable:!0,get:function(){return V(this).description}}),i||O(H,"propertyIsEnumerable",ce,{unsafe:!0}))),n({global:!0,wrap:!0,forced:!u,sham:!u},{Symbol:W}),q(w(te),(function(e){j(e)})),n({target:U,stat:!0,forced:!u},{for:function(e){var t=String(e);if(f(Z,t))return Z[t];var r=W(t);return Z[t]=r,ee[r]=t,r},keyFor:function(e){if(!ie(e))throw TypeError(e+" is not a symbol");if(f(ee,e))return ee[e]},useSetter:function(){ne=!0},useSimple:function(){ne=!1}}),n({target:"Object",stat:!0,forced:!u,sham:!l},{create:function(e,t){return void 0===t?b(e):ue(b(e),t)},defineProperty:le,defineProperties:ue,getOwnPropertyDescriptor:se}),n({target:"Object",stat:!0,forced:!u},{getOwnPropertyNames:fe,getOwnPropertySymbols:de}),n({target:"Object",stat:!0,forced:s((function(){x.f(1)}))},{getOwnPropertySymbols:function(e){return x.f(g(e))}}),$)&&n({target:"JSON",stat:!0,forced:!u||s((function(){var e=W();return"[null]"!=$([e])||"{}"!=$({a:e})||"{}"!=$(Object(e))}))},{stringify:function(e,t,r){for(var n,o=[e],a=1;arguments.length>a;)o.push(arguments[a++]);if(n=t,(p(t)||void 0!==e)&&!ie(e))return d(t)||(t=function(e,t){if("function"==typeof n&&(t=n.call(this,e,t)),!ie(t))return t}),o[1]=t,$.apply(null,o)}});W.prototype[F]||C(W.prototype,F,W.prototype.valueOf),M(W,U),N[z]=!0},function(e,t,r){var n=r(20),o=r(41).f,a={}.toString,i="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];e.exports.f=function(e){return i&&"[object Window]"==a.call(e)?function(e){try{return o(e)}catch(e){return i.slice()}}(e):o(n(e))}},function(e,t,r){var n=r(7),o=r(56),a=r(28),i=r(26),l=r(83),u=[].push,c=function(e){var t=1==e,r=2==e,c=3==e,s=4==e,f=6==e,d=7==e,p=5==e||f;return function(h,g,v,m){for(var y,b,w=a(h),k=o(w),E=n(g,v,3),x=i(k.length),S=0,_=m||l,T=t?_(h,x):r||d?_(h,0):void 0;x>S;S++)if((p||S in k)&&(b=E(y=k[S],S,w),e))if(t)T[S]=b;else if(b)switch(e){case 3:return!0;case 5:return y;case 6:return S;case 2:u.call(T,y)}else switch(e){case 4:return!1;case 7:u.call(T,y)}return f?-1:c||s?s:T}};e.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6),filterOut:c(7)}},function(e,t,r){"use strict";var n=r(1),o=r(16),a=r(8),i=r(11),l=r(13),u=r(14).f,c=r(60),s=a.Symbol;if(o&&"function"==typeof s&&(!("description"in s.prototype)||void 0!==s().description)){var f={},d=function(){var e=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),t=this instanceof d?new s(e):void 0===e?s():s(e);return""===e&&(f[t]=!0),t};c(d,s);var p=d.prototype=s.prototype;p.constructor=d;var h=p.toString,g="Symbol(test)"==String(s("test")),v=/^Symbol\\((.*)\\)[^)]+$/;u(p,"description",{configurable:!0,get:function(){var e=l(this)?this.valueOf():this,t=h.call(e);if(i(f,e))return"";var r=g?t.slice(7,-1):t.replace(v,"$1");return""===r?void 0:r}}),n({global:!0,forced:!0},{Symbol:d})}},function(e,t,r){r(9)("asyncIterator")},function(e,t,r){r(9)("hasInstance")},function(e,t,r){r(9)("isConcatSpreadable")},function(e,t,r){r(9)("iterator")},function(e,t,r){r(9)("match")},function(e,t,r){r(9)("replace")},function(e,t,r){r(9)("search")},function(e,t,r){r(9)("species")},function(e,t,r){r(9)("split")},function(e,t,r){r(9)("toPrimitive")},function(e,t,r){r(9)("toStringTag")},function(e,t,r){r(9)("unscopables")},function(e,t,r){"use strict";var n=r(1),o=r(12),a=r(49),i=r(13),l=r(28),u=r(26),c=r(84),s=r(83),f=r(167),d=r(6),p=r(85),h=d("isConcatSpreadable"),g=9007199254740991,v="Maximum allowed index exceeded",m=p>=51||!o((function(){var e=[];return e[h]=!1,e.concat()[0]!==e})),y=f("concat"),b=function(e){if(!i(e))return!1;var t=e[h];return void 0!==t?!!t:a(e)};n({target:"Array",proto:!0,forced:!m||!y},{concat:function(e){var t,r,n,o,a,i=l(this),f=s(i,0),d=0;for(t=-1,n=arguments.length;t<n;t++)if(b(a=-1===t?i:arguments[t])){if(d+(o=u(a.length))>g)throw TypeError(v);for(r=0;r<o;r++,d++)r in a&&c(f,d,a[r])}else{if(d>=g)throw TypeError(v);c(f,d++,a)}return f.length=d,f}})},function(e,t,r){var n=r(12),o=r(6),a=r(85),i=o("species");e.exports=function(e){return a>=51||!n((function(){var t=[];return(t.constructor={})[i]=function(){return{foo:1}},1!==t[e](Boolean).foo}))}},function(e,t,r){var n=r(10);e.exports=n("navigator","userAgent")||""},function(e,t,r){var n=r(1),o=r(170);n({target:"Array",stat:!0,forced:!r(71)((function(e){Array.from(e)}))},{from:o})},function(e,t,r){"use strict";var n=r(7),o=r(28),a=r(171),i=r(66),l=r(26),u=r(84),c=r(45);e.exports=function(e){var t,r,s,f,d,p,h=o(e),g="function"==typeof this?this:Array,v=arguments.length,m=v>1?arguments[1]:void 0,y=void 0!==m,b=c(h),w=0;if(y&&(m=n(m,v>2?arguments[2]:void 0,2)),void 0==b||g==Array&&i(b))for(r=new g(t=l(h.length));t>w;w++)p=y?m(h[w],w):h[w],u(r,w,p);else for(d=(f=b.call(h)).next,r=new g;!(s=d.call(f)).done;w++)p=y?a(f,m,[s.value,w],!0):s.value,u(r,w,p);return r.length=w,r}},function(e,t,r){var n=r(2),o=r(69);e.exports=function(e,t,r,a){try{return a?t(n(r)[0],r[1]):t(r)}catch(t){throw o(e),t}}},function(e,t,r){var n=r(8);r(22)(n.JSON,"JSON",!0)},function(e,t,r){r(22)(Math,"Math",!0)},function(e,t,r){r(9)("dispose")},function(e,t,r){r(9)("observable")},function(e,t,r){r(9)("patternMatch")},function(e,t,r){"use strict";var n=r(86),o=[ReferenceError,TypeError,RangeError],a=!1;function i(){a=!1,n._Y=null,n._Z=null}function l(e,t){return t.some((function(t){return e instanceof t}))}t.disable=i,t.enable=function(e){e=e||{},a&&i();a=!0;var t=0,r=0,u={};function c(t){(e.allRejections||l(u[t].error,e.whitelist||o))&&(u[t].displayId=r++,e.onUnhandled?(u[t].logged=!0,e.onUnhandled(u[t].displayId,u[t].error)):(u[t].logged=!0,function(e,t){console.warn("Possible Unhandled Promise Rejection (id: "+e+"):"),((t&&(t.stack||t))+"").split("\\n").forEach((function(e){console.warn("  "+e)}))}(u[t].displayId,u[t].error)))}n._Y=function(t){2===t._V&&u[t._1]&&(u[t._1].logged?function(t){u[t].logged&&(e.onHandled?e.onHandled(u[t].displayId,u[t].error):u[t].onUnhandled||(console.warn("Promise Rejection Handled (id: "+u[t].displayId+"):"),console.warn(\'  This means you can ignore any previous messages of the form "Possible Unhandled Promise Rejection" with id \'+u[t].displayId+".")))}(t._1):clearTimeout(u[t._1].timeout),delete u[t._1])},n._Z=function(e,r){0===e._U&&(e._1=t++,u[e._1]={displayId:null,error:r,timeout:setTimeout(c.bind(null,e._1),l(r,o)?100:2e3),logged:!1})}}},function(e,t,r){"use strict";(function(t){function r(e){o.length||(n(),!0),o[o.length]=e}e.exports=r;var n,o=[],a=0;function i(){for(;a<o.length;){var e=a;if(a+=1,o[e].call(),a>1024){for(var t=0,r=o.length-a;t<r;t++)o[t]=o[t+a];o.length-=a,a=0}}o.length=0,a=0,!1}var l,u,c,s="undefined"!==typeof t?t:self,f=s.MutationObserver||s.WebKitMutationObserver;function d(e){return function(){var t=setTimeout(n,0),r=setInterval(n,50);function n(){clearTimeout(t),clearInterval(r),e()}}}"function"===typeof f?(l=1,u=new f(i),c=document.createTextNode(""),u.observe(c,{characterData:!0}),n=function(){l=-l,c.data=l}):n=d(i),r.requestFlush=n,r.makeRequestCallFromTimer=d}).call(this,r(34))},function(e,t,r){"use strict";var n=r(86);e.exports=n;var o=s(!0),a=s(!1),i=s(null),l=s(void 0),u=s(0),c=s("");function s(e){var t=new n(n._0);return t._V=1,t._W=e,t}n.resolve=function(e){if(e instanceof n)return e;if(null===e)return i;if(void 0===e)return l;if(!0===e)return o;if(!1===e)return a;if(0===e)return u;if(""===e)return c;if("object"===typeof e||"function"===typeof e)try{var t=e.then;if("function"===typeof t)return new n(t.bind(e))}catch(e){return new n((function(t,r){r(e)}))}return s(e)};var f=function(e){return"function"===typeof Array.from?(f=Array.from,Array.from(e)):(f=function(e){return Array.prototype.slice.call(e)},Array.prototype.slice.call(e))};n.all=function(e){var t=f(e);return new n((function(e,r){if(0===t.length)return e([]);var o=t.length;function a(i,l){if(l&&("object"===typeof l||"function"===typeof l)){if(l instanceof n&&l.then===n.prototype.then){for(;3===l._V;)l=l._W;return 1===l._V?a(i,l._W):(2===l._V&&r(l._W),void l.then((function(e){a(i,e)}),r))}var u=l.then;if("function"===typeof u)return void new n(u.bind(l)).then((function(e){a(i,e)}),r)}t[i]=l,0===--o&&e(t)}for(var i=0;i<t.length;i++)a(i,t[i])}))},n.reject=function(e){return new n((function(t,r){r(e)}))},n.race=function(e){return new n((function(t,r){f(e).forEach((function(e){n.resolve(e).then(t,r)}))}))},n.prototype.catch=function(e){return this.then(null,e)}},function(e,t,r){"use strict";r.r(t),r.d(t,"Headers",(function(){return h})),r.d(t,"Request",(function(){return k})),r.d(t,"Response",(function(){return x})),r.d(t,"DOMException",(function(){return _})),r.d(t,"fetch",(function(){return T}));var n="undefined"!==typeof globalThis&&globalThis||"undefined"!==typeof self&&self||"undefined"!==typeof n&&n,o="URLSearchParams"in n,a="Symbol"in n&&"iterator"in Symbol,i="FileReader"in n&&"Blob"in n&&function(){try{return new Blob,!0}catch(e){return!1}}(),l="FormData"in n,u="ArrayBuffer"in n;if(u)var c=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],s=ArrayBuffer.isView||function(e){return e&&c.indexOf(Object.prototype.toString.call(e))>-1};function f(e){if("string"!==typeof e&&(e=String(e)),/[^a-z0-9\\-#$%&\'*+.^_`|~!]/i.test(e)||""===e)throw new TypeError("Invalid character in header field name");return e.toLowerCase()}function d(e){return"string"!==typeof e&&(e=String(e)),e}function p(e){var t={next:function(){var t=e.shift();return{done:void 0===t,value:t}}};return a&&(t[Symbol.iterator]=function(){return t}),t}function h(e){this.map={},e instanceof h?e.forEach((function(e,t){this.append(t,e)}),this):Array.isArray(e)?e.forEach((function(e){this.append(e[0],e[1])}),this):e&&Object.getOwnPropertyNames(e).forEach((function(t){this.append(t,e[t])}),this)}function g(e){if(e.bodyUsed)return Promise.reject(new TypeError("Already read"));e.bodyUsed=!0}function v(e){return new Promise((function(t,r){e.onload=function(){t(e.result)},e.onerror=function(){r(e.error)}}))}function m(e){var t=new FileReader,r=v(t);return t.readAsArrayBuffer(e),r}function y(e){if(e.slice)return e.slice(0);var t=new Uint8Array(e.byteLength);return t.set(new Uint8Array(e)),t.buffer}function b(){return this.bodyUsed=!1,this._initBody=function(e){var t;this.bodyUsed=this.bodyUsed,this._bodyInit=e,e?"string"===typeof e?this._bodyText=e:i&&Blob.prototype.isPrototypeOf(e)?this._bodyBlob=e:l&&FormData.prototype.isPrototypeOf(e)?this._bodyFormData=e:o&&URLSearchParams.prototype.isPrototypeOf(e)?this._bodyText=e.toString():u&&i&&((t=e)&&DataView.prototype.isPrototypeOf(t))?(this._bodyArrayBuffer=y(e.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):u&&(ArrayBuffer.prototype.isPrototypeOf(e)||s(e))?this._bodyArrayBuffer=y(e):this._bodyText=e=Object.prototype.toString.call(e):this._bodyText="",this.headers.get("content-type")||("string"===typeof e?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):o&&URLSearchParams.prototype.isPrototypeOf(e)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},i&&(this.blob=function(){var e=g(this);if(e)return e;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){if(this._bodyArrayBuffer){var e=g(this);return e||(ArrayBuffer.isView(this._bodyArrayBuffer)?Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset,this._bodyArrayBuffer.byteOffset+this._bodyArrayBuffer.byteLength)):Promise.resolve(this._bodyArrayBuffer))}return this.blob().then(m)}),this.text=function(){var e,t,r,n=g(this);if(n)return n;if(this._bodyBlob)return e=this._bodyBlob,t=new FileReader,r=v(t),t.readAsText(e),r;if(this._bodyArrayBuffer)return Promise.resolve(function(e){for(var t=new Uint8Array(e),r=new Array(t.length),n=0;n<t.length;n++)r[n]=String.fromCharCode(t[n]);return r.join("")}(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},l&&(this.formData=function(){return this.text().then(E)}),this.json=function(){return this.text().then(JSON.parse)},this}h.prototype.append=function(e,t){e=f(e),t=d(t);var r=this.map[e];this.map[e]=r?r+", "+t:t},h.prototype.delete=function(e){delete this.map[f(e)]},h.prototype.get=function(e){return e=f(e),this.has(e)?this.map[e]:null},h.prototype.has=function(e){return this.map.hasOwnProperty(f(e))},h.prototype.set=function(e,t){this.map[f(e)]=d(t)},h.prototype.forEach=function(e,t){for(var r in this.map)this.map.hasOwnProperty(r)&&e.call(t,this.map[r],r,this)},h.prototype.keys=function(){var e=[];return this.forEach((function(t,r){e.push(r)})),p(e)},h.prototype.values=function(){var e=[];return this.forEach((function(t){e.push(t)})),p(e)},h.prototype.entries=function(){var e=[];return this.forEach((function(t,r){e.push([r,t])})),p(e)},a&&(h.prototype[Symbol.iterator]=h.prototype.entries);var w=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function k(e,t){if(!(this instanceof k))throw new TypeError(\'Please use the "new" operator, this DOM object constructor cannot be called as a function.\');var r,n,o=(t=t||{}).body;if(e instanceof k){if(e.bodyUsed)throw new TypeError("Already read");this.url=e.url,this.credentials=e.credentials,t.headers||(this.headers=new h(e.headers)),this.method=e.method,this.mode=e.mode,this.signal=e.signal,o||null==e._bodyInit||(o=e._bodyInit,e.bodyUsed=!0)}else this.url=String(e);if(this.credentials=t.credentials||this.credentials||"same-origin",!t.headers&&this.headers||(this.headers=new h(t.headers)),this.method=(r=t.method||this.method||"GET",n=r.toUpperCase(),w.indexOf(n)>-1?n:r),this.mode=t.mode||this.mode||null,this.signal=t.signal||this.signal,this.referrer=null,("GET"===this.method||"HEAD"===this.method)&&o)throw new TypeError("Body not allowed for GET or HEAD requests");if(this._initBody(o),("GET"===this.method||"HEAD"===this.method)&&("no-store"===t.cache||"no-cache"===t.cache)){var a=/([?&])_=[^&]*/;if(a.test(this.url))this.url=this.url.replace(a,"$1_="+(new Date).getTime());else{this.url+=(/\\?/.test(this.url)?"&":"?")+"_="+(new Date).getTime()}}}function E(e){var t=new FormData;return e.trim().split("&").forEach((function(e){if(e){var r=e.split("="),n=r.shift().replace(/\\+/g," "),o=r.join("=").replace(/\\+/g," ");t.append(decodeURIComponent(n),decodeURIComponent(o))}})),t}function x(e,t){if(!(this instanceof x))throw new TypeError(\'Please use the "new" operator, this DOM object constructor cannot be called as a function.\');t||(t={}),this.type="default",this.status=void 0===t.status?200:t.status,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in t?t.statusText:"",this.headers=new h(t.headers),this.url=t.url||"",this._initBody(e)}k.prototype.clone=function(){return new k(this,{body:this._bodyInit})},b.call(k.prototype),b.call(x.prototype),x.prototype.clone=function(){return new x(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new h(this.headers),url:this.url})},x.error=function(){var e=new x(null,{status:0,statusText:""});return e.type="error",e};var S=[301,302,303,307,308];x.redirect=function(e,t){if(-1===S.indexOf(t))throw new RangeError("Invalid status code");return new x(null,{status:t,headers:{location:e}})};var _=n.DOMException;try{new _}catch(e){(_=function(e,t){this.message=e,this.name=t;var r=Error(e);this.stack=r.stack}).prototype=Object.create(Error.prototype),_.prototype.constructor=_}function T(e,t){return new Promise((function(r,o){var a=new k(e,t);if(a.signal&&a.signal.aborted)return o(new _("Aborted","AbortError"));var l=new XMLHttpRequest;function c(){l.abort()}l.onload=function(){var e,t,n={status:l.status,statusText:l.statusText,headers:(e=l.getAllResponseHeaders()||"",t=new h,e.replace(/\\r?\\n[\\t ]+/g," ").split("\\r").map((function(e){return 0===e.indexOf("\\n")?e.substr(1,e.length):e})).forEach((function(e){var r=e.split(":"),n=r.shift().trim();if(n){var o=r.join(":").trim();t.append(n,o)}})),t)};n.url="responseURL"in l?l.responseURL:n.headers.get("X-Request-URL");var o="response"in l?l.response:l.responseText;setTimeout((function(){r(new x(o,n))}),0)},l.onerror=function(){setTimeout((function(){o(new TypeError("Network request failed"))}),0)},l.ontimeout=function(){setTimeout((function(){o(new TypeError("Network request failed"))}),0)},l.onabort=function(){setTimeout((function(){o(new _("Aborted","AbortError"))}),0)},l.open(a.method,function(e){try{return""===e&&n.location.href?n.location.href:e}catch(t){return e}}(a.url),!0),"include"===a.credentials?l.withCredentials=!0:"omit"===a.credentials&&(l.withCredentials=!1),"responseType"in l&&(i?l.responseType="blob":u&&a.headers.get("Content-Type")&&-1!==a.headers.get("Content-Type").indexOf("application/octet-stream")&&(l.responseType="arraybuffer")),!t||"object"!==typeof t.headers||t.headers instanceof h?a.headers.forEach((function(e,t){l.setRequestHeader(t,e)})):Object.getOwnPropertyNames(t.headers).forEach((function(e){l.setRequestHeader(e,d(t.headers[e]))})),a.signal&&(a.signal.addEventListener("abort",c),l.onreadystatechange=function(){4===l.readyState&&a.signal.removeEventListener("abort",c)}),l.send("undefined"===typeof a._bodyInit?null:a._bodyInit)}))}T.polyfill=!0,n.fetch||(n.fetch=T,n.Headers=h,n.Request=k,n.Response=x)},function(e,t,r){(function(t){for(var n=r(182),o="undefined"===typeof window?t:window,a=["moz","webkit"],i="AnimationFrame",l=o["request"+i],u=o["cancel"+i]||o["cancelRequest"+i],c=0;!l&&c<a.length;c++)l=o[a[c]+"Request"+i],u=o[a[c]+"Cancel"+i]||o[a[c]+"CancelRequest"+i];if(!l||!u){var s=0,f=0,d=[];l=function(e){if(0===d.length){var t=n(),r=Math.max(0,16.666666666666668-(t-s));s=r+t,setTimeout((function(){var e=d.slice(0);d.length=0;for(var t=0;t<e.length;t++)if(!e[t].cancelled)try{e[t].callback(s)}catch(e){setTimeout((function(){throw e}),0)}}),Math.round(r))}return d.push({handle:++f,callback:e,cancelled:!1}),f},u=function(e){for(var t=0;t<d.length;t++)d[t].handle===e&&(d[t].cancelled=!0)}}e.exports=function(e){return l.call(o,e)},e.exports.cancel=function(){u.apply(o,arguments)},e.exports.polyfill=function(e){e||(e=o),e.requestAnimationFrame=l,e.cancelAnimationFrame=u}}).call(this,r(34))},function(e,t,r){(function(t){(function(){var r,n,o,a,i,l;"undefined"!==typeof performance&&null!==performance&&performance.now?e.exports=function(){return performance.now()}:"undefined"!==typeof t&&null!==t&&t.hrtime?(e.exports=function(){return(r()-i)/1e6},n=t.hrtime,a=(r=function(){var e;return 1e9*(e=n())[0]+e[1]})(),l=1e9*t.uptime(),i=a-l):Date.now?(e.exports=function(){return Date.now()-o},o=Date.now()):(e.exports=function(){return(new Date).getTime()-o},o=(new Date).getTime())}).call(this)}).call(this,r(51))},function(e,t,r){"use strict";var n=r(50),o=60103,a=60106;t.Fragment=60107,t.StrictMode=60108,t.Profiler=60114;var i=60109,l=60110,u=60112;t.Suspense=60113;var c=60115,s=60116;if("function"===typeof Symbol&&Symbol.for){var f=Symbol.for;o=f("react.element"),a=f("react.portal"),t.Fragment=f("react.fragment"),t.StrictMode=f("react.strict_mode"),t.Profiler=f("react.profiler"),i=f("react.provider"),l=f("react.context"),u=f("react.forward_ref"),t.Suspense=f("react.suspense"),c=f("react.memo"),s=f("react.lazy")}var d="function"===typeof Symbol&&Symbol.iterator;function p(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,r=1;r<arguments.length;r++)t+="&args[]="+encodeURIComponent(arguments[r]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var h={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g={};function v(e,t,r){this.props=e,this.context=t,this.refs=g,this.updater=r||h}function m(){}function y(e,t,r){this.props=e,this.context=t,this.refs=g,this.updater=r||h}v.prototype.isReactComponent={},v.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error(p(85));this.updater.enqueueSetState(this,e,t,"setState")},v.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},m.prototype=v.prototype;var b=y.prototype=new m;b.constructor=y,n(b,v.prototype),b.isPureReactComponent=!0;var w={current:null},k=Object.prototype.hasOwnProperty,E={key:!0,ref:!0,__self:!0,__source:!0};function x(e,t,r){var n,a={},i=null,l=null;if(null!=t)for(n in void 0!==t.ref&&(l=t.ref),void 0!==t.key&&(i=""+t.key),t)k.call(t,n)&&!E.hasOwnProperty(n)&&(a[n]=t[n]);var u=arguments.length-2;if(1===u)a.children=r;else if(1<u){for(var c=Array(u),s=0;s<u;s++)c[s]=arguments[s+2];a.children=c}if(e&&e.defaultProps)for(n in u=e.defaultProps)void 0===a[n]&&(a[n]=u[n]);return{$$typeof:o,type:e,key:i,ref:l,props:a,_owner:w.current}}function S(e){return"object"===typeof e&&null!==e&&e.$$typeof===o}var _=/\\/+/g;function T(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function C(e,t,r,n,i){var l=typeof e;"undefined"!==l&&"boolean"!==l||(e=null);var u=!1;if(null===e)u=!0;else switch(l){case"string":case"number":u=!0;break;case"object":switch(e.$$typeof){case o:case a:u=!0}}if(u)return i=i(u=e),e=""===n?"."+T(u,0):n,Array.isArray(i)?(r="",null!=e&&(r=e.replace(_,"$&/")+"/"),C(i,t,r,"",(function(e){return e}))):null!=i&&(S(i)&&(i=function(e,t){return{$$typeof:o,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,r+(!i.key||u&&u.key===i.key?"":(""+i.key).replace(_,"$&/")+"/")+e)),t.push(i)),1;if(u=0,n=""===n?".":n+":",Array.isArray(e))for(var c=0;c<e.length;c++){var s=n+T(l=e[c],c);u+=C(l,t,r,s,i)}else if("function"===typeof(s=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=d&&e[d]||e["@@iterator"])?e:null}(e)))for(e=s.call(e),c=0;!(l=e.next()).done;)u+=C(l=l.value,t,r,s=n+T(l,c++),i);else if("object"===l)throw t=""+e,Error(p(31,"[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t));return u}function O(e,t,r){if(null==e)return e;var n=[],o=0;return C(e,n,"","",(function(e){return t.call(r,e,o++)})),n}function P(e){if(-1===e._status){var t=e._result;t=t(),e._status=0,e._result=t,t.then((function(t){0===e._status&&(t=t.default,e._status=1,e._result=t)}),(function(t){0===e._status&&(e._status=2,e._result=t)}))}if(1===e._status)return e._result;throw e._result}var R={current:null};function N(){var e=R.current;if(null===e)throw Error(p(321));return e}var L={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:w,IsSomeRendererActing:{current:!1},assign:n};t.Children={map:O,forEach:function(e,t,r){O(e,(function(){t.apply(this,arguments)}),r)},count:function(e){var t=0;return O(e,(function(){t++})),t},toArray:function(e){return O(e,(function(e){return e}))||[]},only:function(e){if(!S(e))throw Error(p(143));return e}},t.Component=v,t.PureComponent=y,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=L,t.cloneElement=function(e,t,r){if(null===e||void 0===e)throw Error(p(267,e));var a=n({},e.props),i=e.key,l=e.ref,u=e._owner;if(null!=t){if(void 0!==t.ref&&(l=t.ref,u=w.current),void 0!==t.key&&(i=""+t.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(s in t)k.call(t,s)&&!E.hasOwnProperty(s)&&(a[s]=void 0===t[s]&&void 0!==c?c[s]:t[s])}var s=arguments.length-2;if(1===s)a.children=r;else if(1<s){c=Array(s);for(var f=0;f<s;f++)c[f]=arguments[f+2];a.children=c}return{$$typeof:o,type:e.type,key:i,ref:l,props:a,_owner:u}},t.createContext=function(e,t){return void 0===t&&(t=null),(e={$$typeof:l,_calculateChangedBits:t,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:i,_context:e},e.Consumer=e},t.createElement=x,t.createFactory=function(e){var t=x.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=S,t.lazy=function(e){return{$$typeof:s,_payload:{_status:-1,_result:e},_init:P}},t.memo=function(e,t){return{$$typeof:c,type:e,compare:void 0===t?null:t}},t.useCallback=function(e,t){return N().useCallback(e,t)},t.useContext=function(e,t){return N().useContext(e,t)},t.useDebugValue=function(){},t.useEffect=function(e,t){return N().useEffect(e,t)},t.useImperativeHandle=function(e,t,r){return N().useImperativeHandle(e,t,r)},t.useLayoutEffect=function(e,t){return N().useLayoutEffect(e,t)},t.useMemo=function(e,t){return N().useMemo(e,t)},t.useReducer=function(e,t,r){return N().useReducer(e,t,r)},t.useRef=function(e){return N().useRef(e)},t.useState=function(e){return N().useState(e)},t.version="17.0.1"},function(e,t,r){"use strict";var n=r(0),o=r(50),a=r(185);function i(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,r=1;r<arguments.length;r++)t+="&args[]="+encodeURIComponent(arguments[r]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!n)throw Error(i(227));var l=new Set,u={};function c(e,t){s(e,t),s(e+"Capture",t)}function s(e,t){for(u[e]=t,e=0;e<t.length;e++)l.add(t[e])}var f=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),d=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,p=Object.prototype.hasOwnProperty,h={},g={};function v(e,t,r,n,o,a,i){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=n,this.attributeNamespace=o,this.mustUseProperty=r,this.propertyName=e,this.type=t,this.sanitizeURL=a,this.removeEmptyString=i}var m={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){m[e]=new v(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];m[t]=new v(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){m[e]=new v(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){m[e]=new v(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){m[e]=new v(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){m[e]=new v(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){m[e]=new v(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){m[e]=new v(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){m[e]=new v(e,5,!1,e.toLowerCase(),null,!1,!1)}));var y=/[\\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function w(e,t,r,n){var o=m.hasOwnProperty(t)?m[t]:null;(null!==o?0===o.type:!n&&(2<t.length&&("o"===t[0]||"O"===t[0])&&("n"===t[1]||"N"===t[1])))||(function(e,t,r,n){if(null===t||"undefined"===typeof t||function(e,t,r,n){if(null!==r&&0===r.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!n&&(null!==r?!r.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,r,n))return!0;if(n)return!1;if(null!==r)switch(r.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,r,o,n)&&(r=null),n||null===o?function(e){return!!p.call(g,e)||!p.call(h,e)&&(d.test(e)?g[e]=!0:(h[e]=!0,!1))}(t)&&(null===r?e.removeAttribute(t):e.setAttribute(t,""+r)):o.mustUseProperty?e[o.propertyName]=null===r?3!==o.type&&"":r:(t=o.attributeName,n=o.attributeNamespace,null===r?e.removeAttribute(t):(r=3===(o=o.type)||4===o&&!0===r?"":""+r,n?e.setAttributeNS(n,t,r):e.setAttribute(t,r))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(y,b);m[t]=new v(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(y,b);m[t]=new v(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(y,b);m[t]=new v(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){m[e]=new v(e,1,!1,e.toLowerCase(),null,!1,!1)})),m.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){m[e]=new v(e,1,!1,e.toLowerCase(),null,!0,!0)}));var k=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,E=60103,x=60106,S=60107,_=60108,T=60114,C=60109,O=60110,P=60112,R=60113,N=60120,L=60115,A=60116,I=60121,j=60128,M=60129,D=60130,q=60131;if("function"===typeof Symbol&&Symbol.for){var z=Symbol.for;E=z("react.element"),x=z("react.portal"),S=z("react.fragment"),_=z("react.strict_mode"),T=z("react.profiler"),C=z("react.provider"),O=z("react.context"),P=z("react.forward_ref"),R=z("react.suspense"),N=z("react.suspense_list"),L=z("react.memo"),A=z("react.lazy"),I=z("react.block"),z("react.scope"),j=z("react.opaque.id"),M=z("react.debug_trace_mode"),D=z("react.offscreen"),q=z("react.legacy_hidden")}var U,F="function"===typeof Symbol&&Symbol.iterator;function B(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=F&&e[F]||e["@@iterator"])?e:null}function V(e){if(void 0===U)try{throw Error()}catch(e){var t=e.stack.trim().match(/\\n( *(at )?)/);U=t&&t[1]||""}return"\\n"+U+e}var H=!1;function W(e,t){if(!e||H)return"";H=!0;var r=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(e){var n=e}Reflect.construct(e,[],t)}else{try{t.call()}catch(e){n=e}e.call(t.prototype)}else{try{throw Error()}catch(e){n=e}e()}}catch(e){if(e&&n&&"string"===typeof e.stack){for(var o=e.stack.split("\\n"),a=n.stack.split("\\n"),i=o.length-1,l=a.length-1;1<=i&&0<=l&&o[i]!==a[l];)l--;for(;1<=i&&0<=l;i--,l--)if(o[i]!==a[l]){if(1!==i||1!==l)do{if(i--,0>--l||o[i]!==a[l])return"\\n"+o[i].replace(" at new "," at ")}while(1<=i&&0<=l);break}}}finally{H=!1,Error.prepareStackTrace=r}return(e=e?e.displayName||e.name:"")?V(e):""}function $(e){switch(e.tag){case 5:return V(e.type);case 16:return V("Lazy");case 13:return V("Suspense");case 19:return V("SuspenseList");case 0:case 2:case 15:return e=W(e.type,!1);case 11:return e=W(e.type.render,!1);case 22:return e=W(e.type._render,!1);case 1:return e=W(e.type,!0);default:return""}}function G(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case S:return"Fragment";case x:return"Portal";case T:return"Profiler";case _:return"StrictMode";case R:return"Suspense";case N:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case O:return(e.displayName||"Context")+".Consumer";case C:return(e._context.displayName||"Context")+".Provider";case P:var t=e.render;return t=t.displayName||t.name||"",e.displayName||(""!==t?"ForwardRef("+t+")":"ForwardRef");case L:return G(e.type);case I:return G(e._render);case A:t=e._payload,e=e._init;try{return G(e(t))}catch(e){}}return null}function Q(e){switch(typeof e){case"boolean":case"number":case"object":case"string":case"undefined":return e;default:return""}}function Y(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function K(e){e._valueTracker||(e._valueTracker=function(e){var t=Y(e)?"checked":"value",r=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),n=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof r&&"function"===typeof r.get&&"function"===typeof r.set){var o=r.get,a=r.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return o.call(this)},set:function(e){n=""+e,a.call(this,e)}}),Object.defineProperty(e,t,{enumerable:r.enumerable}),{getValue:function(){return n},setValue:function(e){n=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function X(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var r=t.getValue(),n="";return e&&(n=Y(e)?e.checked?"true":"false":e.value),(e=n)!==r&&(t.setValue(e),!0)}function J(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function Z(e,t){var r=t.checked;return o({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=r?r:e._wrapperState.initialChecked})}function ee(e,t){var r=null==t.defaultValue?"":t.defaultValue,n=null!=t.checked?t.checked:t.defaultChecked;r=Q(null!=t.value?t.value:r),e._wrapperState={initialChecked:n,initialValue:r,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function te(e,t){null!=(t=t.checked)&&w(e,"checked",t,!1)}function re(e,t){te(e,t);var r=Q(t.value),n=t.type;if(null!=r)"number"===n?(0===r&&""===e.value||e.value!=r)&&(e.value=""+r):e.value!==""+r&&(e.value=""+r);else if("submit"===n||"reset"===n)return void e.removeAttribute("value");t.hasOwnProperty("value")?oe(e,t.type,r):t.hasOwnProperty("defaultValue")&&oe(e,t.type,Q(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function ne(e,t,r){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var n=t.type;if(!("submit"!==n&&"reset"!==n||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,r||t===e.value||(e.value=t),e.defaultValue=t}""!==(r=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==r&&(e.name=r)}function oe(e,t,r){"number"===t&&J(e.ownerDocument)===e||(null==r?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+r&&(e.defaultValue=""+r))}function ae(e,t){return e=o({children:void 0},t),(t=function(e){var t="";return n.Children.forEach(e,(function(e){null!=e&&(t+=e)})),t}(t.children))&&(e.children=t),e}function ie(e,t,r,n){if(e=e.options,t){t={};for(var o=0;o<r.length;o++)t["$"+r[o]]=!0;for(r=0;r<e.length;r++)o=t.hasOwnProperty("$"+e[r].value),e[r].selected!==o&&(e[r].selected=o),o&&n&&(e[r].defaultSelected=!0)}else{for(r=""+Q(r),t=null,o=0;o<e.length;o++){if(e[o].value===r)return e[o].selected=!0,void(n&&(e[o].defaultSelected=!0));null!==t||e[o].disabled||(t=e[o])}null!==t&&(t.selected=!0)}}function le(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(i(91));return o({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function ue(e,t){var r=t.value;if(null==r){if(r=t.children,t=t.defaultValue,null!=r){if(null!=t)throw Error(i(92));if(Array.isArray(r)){if(!(1>=r.length))throw Error(i(93));r=r[0]}t=r}null==t&&(t=""),r=t}e._wrapperState={initialValue:Q(r)}}function ce(e,t){var r=Q(t.value),n=Q(t.defaultValue);null!=r&&((r=""+r)!==e.value&&(e.value=r),null==t.defaultValue&&e.defaultValue!==r&&(e.defaultValue=r)),null!=n&&(e.defaultValue=""+n)}function se(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}var fe="http://www.w3.org/1999/xhtml",de="http://www.w3.org/2000/svg";function pe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function he(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?pe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var ge,ve,me=(ve=function(e,t){if(e.namespaceURI!==de||"innerHTML"in e)e.innerHTML=t;else{for((ge=ge||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ge.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,r,n){MSApp.execUnsafeLocalFunction((function(){return ve(e,t)}))}:ve);function ye(e,t){if(t){var r=e.firstChild;if(r&&r===e.lastChild&&3===r.nodeType)return void(r.nodeValue=t)}e.textContent=t}var be={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},we=["Webkit","ms","Moz","O"];function ke(e,t,r){return null==t||"boolean"===typeof t||""===t?"":r||"number"!==typeof t||0===t||be.hasOwnProperty(e)&&be[e]?(""+t).trim():t+"px"}function Ee(e,t){for(var r in e=e.style,t)if(t.hasOwnProperty(r)){var n=0===r.indexOf("--"),o=ke(r,t[r],n);"float"===r&&(r="cssFloat"),n?e.setProperty(r,o):e[r]=o}}Object.keys(be).forEach((function(e){we.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),be[t]=be[e]}))}));var xe=o({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Se(e,t){if(t){if(xe[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(i(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(i(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(i(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(i(62))}}function _e(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}function Te(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var Ce=null,Oe=null,Pe=null;function Re(e){if(e=eo(e)){if("function"!==typeof Ce)throw Error(i(280));var t=e.stateNode;t&&(t=ro(t),Ce(e.stateNode,e.type,t))}}function Ne(e){Oe?Pe?Pe.push(e):Pe=[e]:Oe=e}function Le(){if(Oe){var e=Oe,t=Pe;if(Pe=Oe=null,Re(e),t)for(e=0;e<t.length;e++)Re(t[e])}}function Ae(e,t){return e(t)}function Ie(e,t,r,n,o){return e(t,r,n,o)}function je(){}var Me=Ae,De=!1,qe=!1;function ze(){null===Oe&&null===Pe||(je(),Le())}function Ue(e,t){var r=e.stateNode;if(null===r)return null;var n=ro(r);if(null===n)return null;r=n[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(n=!n.disabled)||(n=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!n;break e;default:e=!1}if(e)return null;if(r&&"function"!==typeof r)throw Error(i(231,t,typeof r));return r}var Fe=!1;if(f)try{var Be={};Object.defineProperty(Be,"passive",{get:function(){Fe=!0}}),window.addEventListener("test",Be,Be),window.removeEventListener("test",Be,Be)}catch(ve){Fe=!1}function Ve(e,t,r,n,o,a,i,l,u){var c=Array.prototype.slice.call(arguments,3);try{t.apply(r,c)}catch(e){this.onError(e)}}var He=!1,We=null,$e=!1,Ge=null,Qe={onError:function(e){He=!0,We=e}};function Ye(e,t,r,n,o,a,i,l,u){He=!1,We=null,Ve.apply(Qe,arguments)}function Ke(e){var t=e,r=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(1026&(t=e).flags)&&(r=t.return),e=t.return}while(e)}return 3===t.tag?r:null}function Xe(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function Je(e){if(Ke(e)!==e)throw Error(i(188))}function Ze(e){if(!(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ke(e)))throw Error(i(188));return t!==e?null:e}for(var r=e,n=t;;){var o=r.return;if(null===o)break;var a=o.alternate;if(null===a){if(null!==(n=o.return)){r=n;continue}break}if(o.child===a.child){for(a=o.child;a;){if(a===r)return Je(o),e;if(a===n)return Je(o),t;a=a.sibling}throw Error(i(188))}if(r.return!==n.return)r=o,n=a;else{for(var l=!1,u=o.child;u;){if(u===r){l=!0,r=o,n=a;break}if(u===n){l=!0,n=o,r=a;break}u=u.sibling}if(!l){for(u=a.child;u;){if(u===r){l=!0,r=a,n=o;break}if(u===n){l=!0,n=a,r=o;break}u=u.sibling}if(!l)throw Error(i(189))}}if(r.alternate!==n)throw Error(i(190))}if(3!==r.tag)throw Error(i(188));return r.stateNode.current===r?e:t}(e)))return null;for(var t=e;;){if(5===t.tag||6===t.tag)return t;if(t.child)t.child.return=t,t=t.child;else{if(t===e)break;for(;!t.sibling;){if(!t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}}return null}function et(e,t){for(var r=e.alternate;null!==t;){if(t===e||t===r)return!0;t=t.return}return!1}var tt,rt,nt,ot,at=!1,it=[],lt=null,ut=null,ct=null,st=new Map,ft=new Map,dt=[],pt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function ht(e,t,r,n,o){return{blockedOn:e,domEventName:t,eventSystemFlags:16|r,nativeEvent:o,targetContainers:[n]}}function gt(e,t){switch(e){case"focusin":case"focusout":lt=null;break;case"dragenter":case"dragleave":ut=null;break;case"mouseover":case"mouseout":ct=null;break;case"pointerover":case"pointerout":st.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":ft.delete(t.pointerId)}}function vt(e,t,r,n,o,a){return null===e||e.nativeEvent!==a?(e=ht(t,r,n,o,a),null!==t&&(null!==(t=eo(t))&&rt(t)),e):(e.eventSystemFlags|=n,t=e.targetContainers,null!==o&&-1===t.indexOf(o)&&t.push(o),e)}function mt(e){var t=Zn(e.target);if(null!==t){var r=Ke(t);if(null!==r)if(13===(t=r.tag)){if(null!==(t=Xe(r)))return e.blockedOn=t,void ot(e.lanePriority,(function(){a.unstable_runWithPriority(e.priority,(function(){nt(r)}))}))}else if(3===t&&r.stateNode.hydrate)return void(e.blockedOn=3===r.tag?r.stateNode.containerInfo:null)}e.blockedOn=null}function yt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var r=Zt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==r)return null!==(t=eo(r))&&rt(t),e.blockedOn=r,!1;t.shift()}return!0}function bt(e,t,r){yt(e)&&r.delete(t)}function wt(){for(at=!1;0<it.length;){var e=it[0];if(null!==e.blockedOn){null!==(e=eo(e.blockedOn))&&tt(e);break}for(var t=e.targetContainers;0<t.length;){var r=Zt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==r){e.blockedOn=r;break}t.shift()}null===e.blockedOn&&it.shift()}null!==lt&&yt(lt)&&(lt=null),null!==ut&&yt(ut)&&(ut=null),null!==ct&&yt(ct)&&(ct=null),st.forEach(bt),ft.forEach(bt)}function kt(e,t){e.blockedOn===t&&(e.blockedOn=null,at||(at=!0,a.unstable_scheduleCallback(a.unstable_NormalPriority,wt)))}function Et(e){function t(t){return kt(t,e)}if(0<it.length){kt(it[0],e);for(var r=1;r<it.length;r++){var n=it[r];n.blockedOn===e&&(n.blockedOn=null)}}for(null!==lt&&kt(lt,e),null!==ut&&kt(ut,e),null!==ct&&kt(ct,e),st.forEach(t),ft.forEach(t),r=0;r<dt.length;r++)(n=dt[r]).blockedOn===e&&(n.blockedOn=null);for(;0<dt.length&&null===(r=dt[0]).blockedOn;)mt(r),null===r.blockedOn&&dt.shift()}function xt(e,t){var r={};return r[e.toLowerCase()]=t.toLowerCase(),r["Webkit"+e]="webkit"+t,r["Moz"+e]="moz"+t,r}var St={animationend:xt("Animation","AnimationEnd"),animationiteration:xt("Animation","AnimationIteration"),animationstart:xt("Animation","AnimationStart"),transitionend:xt("Transition","TransitionEnd")},_t={},Tt={};function Ct(e){if(_t[e])return _t[e];if(!St[e])return e;var t,r=St[e];for(t in r)if(r.hasOwnProperty(t)&&t in Tt)return _t[e]=r[t];return e}f&&(Tt=document.createElement("div").style,"AnimationEvent"in window||(delete St.animationend.animation,delete St.animationiteration.animation,delete St.animationstart.animation),"TransitionEvent"in window||delete St.transitionend.transition);var Ot=Ct("animationend"),Pt=Ct("animationiteration"),Rt=Ct("animationstart"),Nt=Ct("transitionend"),Lt=new Map,At=new Map,It=["abort","abort",Ot,"animationEnd",Pt,"animationIteration",Rt,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",Nt,"transitionEnd","waiting","waiting"];function jt(e,t){for(var r=0;r<e.length;r+=2){var n=e[r],o=e[r+1];o="on"+(o[0].toUpperCase()+o.slice(1)),At.set(n,t),Lt.set(n,o),c(o,[n])}}(0,a.unstable_now)();var Mt=8;function Dt(e){if(0!==(1&e))return Mt=15,1;if(0!==(2&e))return Mt=14,2;if(0!==(4&e))return Mt=13,4;var t=24&e;return 0!==t?(Mt=12,t):0!==(32&e)?(Mt=11,32):0!==(t=192&e)?(Mt=10,t):0!==(256&e)?(Mt=9,256):0!==(t=3584&e)?(Mt=8,t):0!==(4096&e)?(Mt=7,4096):0!==(t=4186112&e)?(Mt=6,t):0!==(t=62914560&e)?(Mt=5,t):67108864&e?(Mt=4,67108864):0!==(134217728&e)?(Mt=3,134217728):0!==(t=805306368&e)?(Mt=2,t):0!==(1073741824&e)?(Mt=1,1073741824):(Mt=8,e)}function qt(e,t){var r=e.pendingLanes;if(0===r)return Mt=0;var n=0,o=0,a=e.expiredLanes,i=e.suspendedLanes,l=e.pingedLanes;if(0!==a)n=a,o=Mt=15;else if(0!==(a=134217727&r)){var u=a&~i;0!==u?(n=Dt(u),o=Mt):0!==(l&=a)&&(n=Dt(l),o=Mt)}else 0!==(a=r&~i)?(n=Dt(a),o=Mt):0!==l&&(n=Dt(l),o=Mt);if(0===n)return 0;if(n=r&((0>(n=31-Ht(n))?0:1<<n)<<1)-1,0!==t&&t!==n&&0===(t&i)){if(Dt(t),o<=Mt)return t;Mt=o}if(0!==(t=e.entangledLanes))for(e=e.entanglements,t&=n;0<t;)o=1<<(r=31-Ht(t)),n|=e[r],t&=~o;return n}function zt(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function Ut(e,t){switch(e){case 15:return 1;case 14:return 2;case 12:return 0===(e=Ft(24&~t))?Ut(10,t):e;case 10:return 0===(e=Ft(192&~t))?Ut(8,t):e;case 8:return 0===(e=Ft(3584&~t))&&(0===(e=Ft(4186112&~t))&&(e=512)),e;case 2:return 0===(t=Ft(805306368&~t))&&(t=268435456),t}throw Error(i(358,e))}function Ft(e){return e&-e}function Bt(e){for(var t=[],r=0;31>r;r++)t.push(e);return t}function Vt(e,t,r){e.pendingLanes|=t;var n=t-1;e.suspendedLanes&=n,e.pingedLanes&=n,(e=e.eventTimes)[t=31-Ht(t)]=r}var Ht=Math.clz32?Math.clz32:function(e){return 0===e?32:31-(Wt(e)/$t|0)|0},Wt=Math.log,$t=Math.LN2;var Gt=a.unstable_UserBlockingPriority,Qt=a.unstable_runWithPriority,Yt=!0;function Kt(e,t,r,n){De||je();var o=Jt,a=De;De=!0;try{Ie(o,e,t,r,n)}finally{(De=a)||ze()}}function Xt(e,t,r,n){Qt(Gt,Jt.bind(null,e,t,r,n))}function Jt(e,t,r,n){var o;if(Yt)if((o=0===(4&t))&&0<it.length&&-1<pt.indexOf(e))e=ht(null,e,t,r,n),it.push(e);else{var a=Zt(e,t,r,n);if(null===a)o&&gt(e,n);else{if(o){if(-1<pt.indexOf(e))return e=ht(a,e,t,r,n),void it.push(e);if(function(e,t,r,n,o){switch(t){case"focusin":return lt=vt(lt,e,t,r,n,o),!0;case"dragenter":return ut=vt(ut,e,t,r,n,o),!0;case"mouseover":return ct=vt(ct,e,t,r,n,o),!0;case"pointerover":var a=o.pointerId;return st.set(a,vt(st.get(a)||null,e,t,r,n,o)),!0;case"gotpointercapture":return a=o.pointerId,ft.set(a,vt(ft.get(a)||null,e,t,r,n,o)),!0}return!1}(a,e,t,r,n))return;gt(e,n)}Ln(e,t,n,null,r)}}}function Zt(e,t,r,n){var o=Te(n);if(null!==(o=Zn(o))){var a=Ke(o);if(null===a)o=null;else{var i=a.tag;if(13===i){if(null!==(o=Xe(a)))return o;o=null}else if(3===i){if(a.stateNode.hydrate)return 3===a.tag?a.stateNode.containerInfo:null;o=null}else a!==o&&(o=null)}}return Ln(e,t,n,o,r),null}var er=null,tr=null,rr=null;function nr(){if(rr)return rr;var e,t,r=tr,n=r.length,o="value"in er?er.value:er.textContent,a=o.length;for(e=0;e<n&&r[e]===o[e];e++);var i=n-e;for(t=1;t<=i&&r[n-t]===o[a-t];t++);return rr=o.slice(e,1<t?1-t:void 0)}function or(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function ar(){return!0}function ir(){return!1}function lr(e){function t(t,r,n,o,a){for(var i in this._reactName=t,this._targetInst=n,this.type=r,this.nativeEvent=o,this.target=a,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(o):o[i]);return this.isDefaultPrevented=(null!=o.defaultPrevented?o.defaultPrevented:!1===o.returnValue)?ar:ir,this.isPropagationStopped=ir,this}return o(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=ar)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=ar)},persist:function(){},isPersistent:ar}),t}var ur,cr,sr,fr={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},dr=lr(fr),pr=o({},fr,{view:0,detail:0}),hr=lr(pr),gr=o({},pr,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Tr,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==sr&&(sr&&"mousemove"===e.type?(ur=e.screenX-sr.screenX,cr=e.screenY-sr.screenY):cr=ur=0,sr=e),ur)},movementY:function(e){return"movementY"in e?e.movementY:cr}}),vr=lr(gr),mr=lr(o({},gr,{dataTransfer:0})),yr=lr(o({},pr,{relatedTarget:0})),br=lr(o({},fr,{animationName:0,elapsedTime:0,pseudoElement:0})),wr=lr(o({},fr,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}})),kr=lr(o({},fr,{data:0})),Er={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},xr={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sr={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function _r(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sr[e])&&!!t[e]}function Tr(){return _r}var Cr=lr(o({},pr,{key:function(e){if(e.key){var t=Er[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=or(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?xr[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Tr,charCode:function(e){return"keypress"===e.type?or(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?or(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}})),Or=lr(o({},gr,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Pr=lr(o({},pr,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Tr})),Rr=lr(o({},fr,{propertyName:0,elapsedTime:0,pseudoElement:0})),Nr=lr(o({},gr,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0})),Lr=[9,13,27,32],Ar=f&&"CompositionEvent"in window,Ir=null;f&&"documentMode"in document&&(Ir=document.documentMode);var jr=f&&"TextEvent"in window&&!Ir,Mr=f&&(!Ar||Ir&&8<Ir&&11>=Ir),Dr=String.fromCharCode(32),qr=!1;function zr(e,t){switch(e){case"keyup":return-1!==Lr.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Ur(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Fr=!1;var Br={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Vr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Br[e.type]:"textarea"===t}function Hr(e,t,r,n){Ne(n),0<(t=In(t,"onChange")).length&&(r=new dr("onChange","change",null,r,n),e.push({event:r,listeners:t}))}var Wr=null,$r=null;function Gr(e){Tn(e,0)}function Qr(e){if(X(to(e)))return e}function Yr(e,t){if("change"===e)return t}var Kr=!1;if(f){var Xr;if(f){var Jr="oninput"in document;if(!Jr){var Zr=document.createElement("div");Zr.setAttribute("oninput","return;"),Jr="function"===typeof Zr.oninput}Xr=Jr}else Xr=!1;Kr=Xr&&(!document.documentMode||9<document.documentMode)}function en(){Wr&&(Wr.detachEvent("onpropertychange",tn),$r=Wr=null)}function tn(e){if("value"===e.propertyName&&Qr($r)){var t=[];if(Hr(t,$r,e,Te(e)),e=Gr,De)e(t);else{De=!0;try{Ae(e,t)}finally{De=!1,ze()}}}}function rn(e,t,r){"focusin"===e?(en(),$r=r,(Wr=t).attachEvent("onpropertychange",tn)):"focusout"===e&&en()}function nn(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Qr($r)}function on(e,t){if("click"===e)return Qr(t)}function an(e,t){if("input"===e||"change"===e)return Qr(t)}var ln="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t},un=Object.prototype.hasOwnProperty;function cn(e,t){if(ln(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(n=0;n<r.length;n++)if(!un.call(t,r[n])||!ln(e[r[n]],t[r[n]]))return!1;return!0}function sn(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function fn(e,t){var r,n=sn(e);for(e=0;n;){if(3===n.nodeType){if(r=e+n.textContent.length,e<=t&&r>=t)return{node:n,offset:t-e};e=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=sn(n)}}function dn(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?dn(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function pn(){for(var e=window,t=J();t instanceof e.HTMLIFrameElement;){try{var r="string"===typeof t.contentWindow.location.href}catch(e){r=!1}if(!r)break;t=J((e=t.contentWindow).document)}return t}function hn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}var gn=f&&"documentMode"in document&&11>=document.documentMode,vn=null,mn=null,yn=null,bn=!1;function wn(e,t,r){var n=r.window===r?r.document:9===r.nodeType?r:r.ownerDocument;bn||null==vn||vn!==J(n)||("selectionStart"in(n=vn)&&hn(n)?n={start:n.selectionStart,end:n.selectionEnd}:n={anchorNode:(n=(n.ownerDocument&&n.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:n.anchorOffset,focusNode:n.focusNode,focusOffset:n.focusOffset},yn&&cn(yn,n)||(yn=n,0<(n=In(mn,"onSelect")).length&&(t=new dr("onSelect","select",null,t,r),e.push({event:t,listeners:n}),t.target=vn)))}jt("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0),jt("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1),jt(It,2);for(var kn="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),En=0;En<kn.length;En++)At.set(kn[En],0);s("onMouseEnter",["mouseout","mouseover"]),s("onMouseLeave",["mouseout","mouseover"]),s("onPointerEnter",["pointerout","pointerover"]),s("onPointerLeave",["pointerout","pointerover"]),c("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),c("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),c("onBeforeInput",["compositionend","keypress","textInput","paste"]),c("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var xn="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Sn=new Set("cancel close invalid load scroll toggle".split(" ").concat(xn));function _n(e,t,r){var n=e.type||"unknown-event";e.currentTarget=r,function(e,t,r,n,o,a,l,u,c){if(Ye.apply(this,arguments),He){if(!He)throw Error(i(198));var s=We;He=!1,We=null,$e||($e=!0,Ge=s)}}(n,t,void 0,e),e.currentTarget=null}function Tn(e,t){t=0!==(4&t);for(var r=0;r<e.length;r++){var n=e[r],o=n.event;n=n.listeners;e:{var a=void 0;if(t)for(var i=n.length-1;0<=i;i--){var l=n[i],u=l.instance,c=l.currentTarget;if(l=l.listener,u!==a&&o.isPropagationStopped())break e;_n(o,l,c),a=u}else for(i=0;i<n.length;i++){if(u=(l=n[i]).instance,c=l.currentTarget,l=l.listener,u!==a&&o.isPropagationStopped())break e;_n(o,l,c),a=u}}}if($e)throw e=Ge,$e=!1,Ge=null,e}function Cn(e,t){var r=no(t),n=e+"__bubble";r.has(n)||(Nn(t,e,2,!1),r.add(n))}var On="_reactListening"+Math.random().toString(36).slice(2);function Pn(e){e[On]||(e[On]=!0,l.forEach((function(t){Sn.has(t)||Rn(t,!1,e,null),Rn(t,!0,e,null)})))}function Rn(e,t,r,n){var o=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,a=r;if("selectionchange"===e&&9!==r.nodeType&&(a=r.ownerDocument),null!==n&&!t&&Sn.has(e)){if("scroll"!==e)return;o|=2,a=n}var i=no(a),l=e+"__"+(t?"capture":"bubble");i.has(l)||(t&&(o|=4),Nn(a,e,o,t),i.add(l))}function Nn(e,t,r,n){var o=At.get(t);switch(void 0===o?2:o){case 0:o=Kt;break;case 1:o=Xt;break;default:o=Jt}r=o.bind(null,t,r,e),o=void 0,!Fe||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(o=!0),n?void 0!==o?e.addEventListener(t,r,{capture:!0,passive:o}):e.addEventListener(t,r,!0):void 0!==o?e.addEventListener(t,r,{passive:o}):e.addEventListener(t,r,!1)}function Ln(e,t,r,n,o){var a=n;if(0===(1&t)&&0===(2&t)&&null!==n)e:for(;;){if(null===n)return;var i=n.tag;if(3===i||4===i){var l=n.stateNode.containerInfo;if(l===o||8===l.nodeType&&l.parentNode===o)break;if(4===i)for(i=n.return;null!==i;){var u=i.tag;if((3===u||4===u)&&((u=i.stateNode.containerInfo)===o||8===u.nodeType&&u.parentNode===o))return;i=i.return}for(;null!==l;){if(null===(i=Zn(l)))return;if(5===(u=i.tag)||6===u){n=a=i;continue e}l=l.parentNode}}n=n.return}!function(e,t,r){if(qe)return e(t,r);qe=!0;try{Me(e,t,r)}finally{qe=!1,ze()}}((function(){var n=a,o=Te(r),i=[];e:{var l=Lt.get(e);if(void 0!==l){var u=dr,c=e;switch(e){case"keypress":if(0===or(r))break e;case"keydown":case"keyup":u=Cr;break;case"focusin":c="focus",u=yr;break;case"focusout":c="blur",u=yr;break;case"beforeblur":case"afterblur":u=yr;break;case"click":if(2===r.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":u=vr;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":u=mr;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":u=Pr;break;case Ot:case Pt:case Rt:u=br;break;case Nt:u=Rr;break;case"scroll":u=hr;break;case"wheel":u=Nr;break;case"copy":case"cut":case"paste":u=wr;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":u=Or}var s=0!==(4&t),f=!s&&"scroll"===e,d=s?null!==l?l+"Capture":null:l;s=[];for(var p,h=n;null!==h;){var g=(p=h).stateNode;if(5===p.tag&&null!==g&&(p=g,null!==d&&(null!=(g=Ue(h,d))&&s.push(An(h,g,p)))),f)break;h=h.return}0<s.length&&(l=new u(l,c,null,r,o),i.push({event:l,listeners:s}))}}if(0===(7&t)){if(u="mouseout"===e||"pointerout"===e,(!(l="mouseover"===e||"pointerover"===e)||0!==(16&t)||!(c=r.relatedTarget||r.fromElement)||!Zn(c)&&!c[Xn])&&(u||l)&&(l=o.window===o?o:(l=o.ownerDocument)?l.defaultView||l.parentWindow:window,u?(u=n,null!==(c=(c=r.relatedTarget||r.toElement)?Zn(c):null)&&(c!==(f=Ke(c))||5!==c.tag&&6!==c.tag)&&(c=null)):(u=null,c=n),u!==c)){if(s=vr,g="onMouseLeave",d="onMouseEnter",h="mouse","pointerout"!==e&&"pointerover"!==e||(s=Or,g="onPointerLeave",d="onPointerEnter",h="pointer"),f=null==u?l:to(u),p=null==c?l:to(c),(l=new s(g,h+"leave",u,r,o)).target=f,l.relatedTarget=p,g=null,Zn(o)===n&&((s=new s(d,h+"enter",c,r,o)).target=p,s.relatedTarget=f,g=s),f=g,u&&c)e:{for(d=c,h=0,p=s=u;p;p=jn(p))h++;for(p=0,g=d;g;g=jn(g))p++;for(;0<h-p;)s=jn(s),h--;for(;0<p-h;)d=jn(d),p--;for(;h--;){if(s===d||null!==d&&s===d.alternate)break e;s=jn(s),d=jn(d)}s=null}else s=null;null!==u&&Mn(i,l,u,s,!1),null!==c&&null!==f&&Mn(i,f,c,s,!0)}if("select"===(u=(l=n?to(n):window).nodeName&&l.nodeName.toLowerCase())||"input"===u&&"file"===l.type)var v=Yr;else if(Vr(l))if(Kr)v=an;else{v=nn;var m=rn}else(u=l.nodeName)&&"input"===u.toLowerCase()&&("checkbox"===l.type||"radio"===l.type)&&(v=on);switch(v&&(v=v(e,n))?Hr(i,v,r,o):(m&&m(e,l,n),"focusout"===e&&(m=l._wrapperState)&&m.controlled&&"number"===l.type&&oe(l,"number",l.value)),m=n?to(n):window,e){case"focusin":(Vr(m)||"true"===m.contentEditable)&&(vn=m,mn=n,yn=null);break;case"focusout":yn=mn=vn=null;break;case"mousedown":bn=!0;break;case"contextmenu":case"mouseup":case"dragend":bn=!1,wn(i,r,o);break;case"selectionchange":if(gn)break;case"keydown":case"keyup":wn(i,r,o)}var y;if(Ar)e:{switch(e){case"compositionstart":var b="onCompositionStart";break e;case"compositionend":b="onCompositionEnd";break e;case"compositionupdate":b="onCompositionUpdate";break e}b=void 0}else Fr?zr(e,r)&&(b="onCompositionEnd"):"keydown"===e&&229===r.keyCode&&(b="onCompositionStart");b&&(Mr&&"ko"!==r.locale&&(Fr||"onCompositionStart"!==b?"onCompositionEnd"===b&&Fr&&(y=nr()):(tr="value"in(er=o)?er.value:er.textContent,Fr=!0)),0<(m=In(n,b)).length&&(b=new kr(b,e,null,r,o),i.push({event:b,listeners:m}),y?b.data=y:null!==(y=Ur(r))&&(b.data=y))),(y=jr?function(e,t){switch(e){case"compositionend":return Ur(t);case"keypress":return 32!==t.which?null:(qr=!0,Dr);case"textInput":return(e=t.data)===Dr&&qr?null:e;default:return null}}(e,r):function(e,t){if(Fr)return"compositionend"===e||!Ar&&zr(e,t)?(e=nr(),rr=tr=er=null,Fr=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Mr&&"ko"!==t.locale?null:t.data;default:return null}}(e,r))&&(0<(n=In(n,"onBeforeInput")).length&&(o=new kr("onBeforeInput","beforeinput",null,r,o),i.push({event:o,listeners:n}),o.data=y))}Tn(i,t)}))}function An(e,t,r){return{instance:e,listener:t,currentTarget:r}}function In(e,t){for(var r=t+"Capture",n=[];null!==e;){var o=e,a=o.stateNode;5===o.tag&&null!==a&&(o=a,null!=(a=Ue(e,r))&&n.unshift(An(e,a,o)),null!=(a=Ue(e,t))&&n.push(An(e,a,o))),e=e.return}return n}function jn(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Mn(e,t,r,n,o){for(var a=t._reactName,i=[];null!==r&&r!==n;){var l=r,u=l.alternate,c=l.stateNode;if(null!==u&&u===n)break;5===l.tag&&null!==c&&(l=c,o?null!=(u=Ue(r,a))&&i.unshift(An(r,u,l)):o||null!=(u=Ue(r,a))&&i.push(An(r,u,l))),r=r.return}0!==i.length&&e.push({event:t,listeners:i})}function Dn(){}var qn=null,zn=null;function Un(e,t){switch(e){case"button":case"input":case"select":case"textarea":return!!t.autoFocus}return!1}function Fn(e,t){return"textarea"===e||"option"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var Bn="function"===typeof setTimeout?setTimeout:void 0,Vn="function"===typeof clearTimeout?clearTimeout:void 0;function Hn(e){1===e.nodeType?e.textContent="":9===e.nodeType&&(null!=(e=e.body)&&(e.textContent=""))}function Wn(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break}return e}function $n(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var r=e.data;if("$"===r||"$!"===r||"$?"===r){if(0===t)return e;t--}else"/$"===r&&t++}e=e.previousSibling}return null}var Gn=0;var Qn=Math.random().toString(36).slice(2),Yn="__reactFiber$"+Qn,Kn="__reactProps$"+Qn,Xn="__reactContainer$"+Qn,Jn="__reactEvents$"+Qn;function Zn(e){var t=e[Yn];if(t)return t;for(var r=e.parentNode;r;){if(t=r[Xn]||r[Yn]){if(r=t.alternate,null!==t.child||null!==r&&null!==r.child)for(e=$n(e);null!==e;){if(r=e[Yn])return r;e=$n(e)}return t}r=(e=r).parentNode}return null}function eo(e){return!(e=e[Yn]||e[Xn])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function to(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(i(33))}function ro(e){return e[Kn]||null}function no(e){var t=e[Jn];return void 0===t&&(t=e[Jn]=new Set),t}var oo=[],ao=-1;function io(e){return{current:e}}function lo(e){0>ao||(e.current=oo[ao],oo[ao]=null,ao--)}function uo(e,t){ao++,oo[ao]=e.current,e.current=t}var co={},so=io(co),fo=io(!1),po=co;function ho(e,t){var r=e.type.contextTypes;if(!r)return co;var n=e.stateNode;if(n&&n.__reactInternalMemoizedUnmaskedChildContext===t)return n.__reactInternalMemoizedMaskedChildContext;var o,a={};for(o in r)a[o]=t[o];return n&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=a),a}function go(e){return null!==(e=e.childContextTypes)&&void 0!==e}function vo(){lo(fo),lo(so)}function mo(e,t,r){if(so.current!==co)throw Error(i(168));uo(so,t),uo(fo,r)}function yo(e,t,r){var n=e.stateNode;if(e=t.childContextTypes,"function"!==typeof n.getChildContext)return r;for(var a in n=n.getChildContext())if(!(a in e))throw Error(i(108,G(t)||"Unknown",a));return o({},r,n)}function bo(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||co,po=so.current,uo(so,e),uo(fo,fo.current),!0}function wo(e,t,r){var n=e.stateNode;if(!n)throw Error(i(169));r?(e=yo(e,t,po),n.__reactInternalMemoizedMergedChildContext=e,lo(fo),lo(so),uo(so,e)):lo(fo),uo(fo,r)}var ko=null,Eo=null,xo=a.unstable_runWithPriority,So=a.unstable_scheduleCallback,_o=a.unstable_cancelCallback,To=a.unstable_shouldYield,Co=a.unstable_requestPaint,Oo=a.unstable_now,Po=a.unstable_getCurrentPriorityLevel,Ro=a.unstable_ImmediatePriority,No=a.unstable_UserBlockingPriority,Lo=a.unstable_NormalPriority,Ao=a.unstable_LowPriority,Io=a.unstable_IdlePriority,jo={},Mo=void 0!==Co?Co:function(){},Do=null,qo=null,zo=!1,Uo=Oo(),Fo=1e4>Uo?Oo:function(){return Oo()-Uo};function Bo(){switch(Po()){case Ro:return 99;case No:return 98;case Lo:return 97;case Ao:return 96;case Io:return 95;default:throw Error(i(332))}}function Vo(e){switch(e){case 99:return Ro;case 98:return No;case 97:return Lo;case 96:return Ao;case 95:return Io;default:throw Error(i(332))}}function Ho(e,t){return e=Vo(e),xo(e,t)}function Wo(e,t,r){return e=Vo(e),So(e,t,r)}function $o(){if(null!==qo){var e=qo;qo=null,_o(e)}Go()}function Go(){if(!zo&&null!==Do){zo=!0;var e=0;try{var t=Do;Ho(99,(function(){for(;e<t.length;e++){var r=t[e];do{r=r(!0)}while(null!==r)}})),Do=null}catch(t){throw null!==Do&&(Do=Do.slice(e+1)),So(Ro,$o),t}finally{zo=!1}}}var Qo=k.ReactCurrentBatchConfig;function Yo(e,t){if(e&&e.defaultProps){for(var r in t=o({},t),e=e.defaultProps)void 0===t[r]&&(t[r]=e[r]);return t}return t}var Ko=io(null),Xo=null,Jo=null,Zo=null;function ea(){Zo=Jo=Xo=null}function ta(e){var t=Ko.current;lo(Ko),e.type._context._currentValue=t}function ra(e,t){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)===t){if(null===r||(r.childLanes&t)===t)break;r.childLanes|=t}else e.childLanes|=t,null!==r&&(r.childLanes|=t);e=e.return}}function na(e,t){Xo=e,Zo=Jo=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(Ii=!0),e.firstContext=null)}function oa(e,t){if(Zo!==e&&!1!==t&&0!==t)if("number"===typeof t&&1073741823!==t||(Zo=e,t=1073741823),t={context:e,observedBits:t,next:null},null===Jo){if(null===Xo)throw Error(i(308));Jo=t,Xo.dependencies={lanes:0,firstContext:t,responders:null}}else Jo=Jo.next=t;return e._currentValue}var aa=!1;function ia(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}function la(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function ua(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function ca(e,t){if(null!==(e=e.updateQueue)){var r=(e=e.shared).pending;null===r?t.next=t:(t.next=r.next,r.next=t),e.pending=t}}function sa(e,t){var r=e.updateQueue,n=e.alternate;if(null!==n&&r===(n=n.updateQueue)){var o=null,a=null;if(null!==(r=r.firstBaseUpdate)){do{var i={eventTime:r.eventTime,lane:r.lane,tag:r.tag,payload:r.payload,callback:r.callback,next:null};null===a?o=a=i:a=a.next=i,r=r.next}while(null!==r);null===a?o=a=t:a=a.next=t}else o=a=t;return r={baseState:n.baseState,firstBaseUpdate:o,lastBaseUpdate:a,shared:n.shared,effects:n.effects},void(e.updateQueue=r)}null===(e=r.lastBaseUpdate)?r.firstBaseUpdate=t:e.next=t,r.lastBaseUpdate=t}function fa(e,t,r,n){var a=e.updateQueue;aa=!1;var i=a.firstBaseUpdate,l=a.lastBaseUpdate,u=a.shared.pending;if(null!==u){a.shared.pending=null;var c=u,s=c.next;c.next=null,null===l?i=s:l.next=s,l=c;var f=e.alternate;if(null!==f){var d=(f=f.updateQueue).lastBaseUpdate;d!==l&&(null===d?f.firstBaseUpdate=s:d.next=s,f.lastBaseUpdate=c)}}if(null!==i){for(d=a.baseState,l=0,f=s=c=null;;){u=i.lane;var p=i.eventTime;if((n&u)===u){null!==f&&(f=f.next={eventTime:p,lane:0,tag:i.tag,payload:i.payload,callback:i.callback,next:null});e:{var h=e,g=i;switch(u=t,p=r,g.tag){case 1:if("function"===typeof(h=g.payload)){d=h.call(p,d,u);break e}d=h;break e;case 3:h.flags=-4097&h.flags|64;case 0:if(null===(u="function"===typeof(h=g.payload)?h.call(p,d,u):h)||void 0===u)break e;d=o({},d,u);break e;case 2:aa=!0}}null!==i.callback&&(e.flags|=32,null===(u=a.effects)?a.effects=[i]:u.push(i))}else p={eventTime:p,lane:u,tag:i.tag,payload:i.payload,callback:i.callback,next:null},null===f?(s=f=p,c=d):f=f.next=p,l|=u;if(null===(i=i.next)){if(null===(u=a.shared.pending))break;i=u.next,u.next=null,a.lastBaseUpdate=u,a.shared.pending=null}}null===f&&(c=d),a.baseState=c,a.firstBaseUpdate=s,a.lastBaseUpdate=f,ql|=l,e.lanes=l,e.memoizedState=d}}function da(e,t,r){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var n=e[t],o=n.callback;if(null!==o){if(n.callback=null,n=r,"function"!==typeof o)throw Error(i(191,o));o.call(n)}}}var pa=(new n.Component).refs;function ha(e,t,r,n){r=null===(r=r(n,t=e.memoizedState))||void 0===r?t:o({},t,r),e.memoizedState=r,0===e.lanes&&(e.updateQueue.baseState=r)}var ga={isMounted:function(e){return!!(e=e._reactInternals)&&Ke(e)===e},enqueueSetState:function(e,t,r){e=e._reactInternals;var n=cu(),o=su(e),a=ua(n,o);a.payload=t,void 0!==r&&null!==r&&(a.callback=r),ca(e,a),fu(e,o,n)},enqueueReplaceState:function(e,t,r){e=e._reactInternals;var n=cu(),o=su(e),a=ua(n,o);a.tag=1,a.payload=t,void 0!==r&&null!==r&&(a.callback=r),ca(e,a),fu(e,o,n)},enqueueForceUpdate:function(e,t){e=e._reactInternals;var r=cu(),n=su(e),o=ua(r,n);o.tag=2,void 0!==t&&null!==t&&(o.callback=t),ca(e,o),fu(e,n,r)}};function va(e,t,r,n,o,a,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(n,a,i):!t.prototype||!t.prototype.isPureReactComponent||(!cn(r,n)||!cn(o,a))}function ma(e,t,r){var n=!1,o=co,a=t.contextType;return"object"===typeof a&&null!==a?a=oa(a):(o=go(t)?po:so.current,a=(n=null!==(n=t.contextTypes)&&void 0!==n)?ho(e,o):co),t=new t(r,a),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ga,e.stateNode=t,t._reactInternals=e,n&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=o,e.__reactInternalMemoizedMaskedChildContext=a),t}function ya(e,t,r,n){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(r,n),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(r,n),t.state!==e&&ga.enqueueReplaceState(t,t.state,null)}function ba(e,t,r,n){var o=e.stateNode;o.props=r,o.state=e.memoizedState,o.refs=pa,ia(e);var a=t.contextType;"object"===typeof a&&null!==a?o.context=oa(a):(a=go(t)?po:so.current,o.context=ho(e,a)),fa(e,r,o,n),o.state=e.memoizedState,"function"===typeof(a=t.getDerivedStateFromProps)&&(ha(e,t,a,r),o.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof o.getSnapshotBeforeUpdate||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||(t=o.state,"function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount(),t!==o.state&&ga.enqueueReplaceState(o,o.state,null),fa(e,r,o,n),o.state=e.memoizedState),"function"===typeof o.componentDidMount&&(e.flags|=4)}var wa=Array.isArray;function ka(e,t,r){if(null!==(e=r.ref)&&"function"!==typeof e&&"object"!==typeof e){if(r._owner){if(r=r._owner){if(1!==r.tag)throw Error(i(309));var n=r.stateNode}if(!n)throw Error(i(147,e));var o=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===o?t.ref:((t=function(e){var t=n.refs;t===pa&&(t=n.refs={}),null===e?delete t[o]:t[o]=e})._stringRef=o,t)}if("string"!==typeof e)throw Error(i(284));if(!r._owner)throw Error(i(290,e))}return e}function Ea(e,t){if("textarea"!==e.type)throw Error(i(31,"[object Object]"===Object.prototype.toString.call(t)?"object with keys {"+Object.keys(t).join(", ")+"}":t))}function xa(e){function t(t,r){if(e){var n=t.lastEffect;null!==n?(n.nextEffect=r,t.lastEffect=r):t.firstEffect=t.lastEffect=r,r.nextEffect=null,r.flags=8}}function r(r,n){if(!e)return null;for(;null!==n;)t(r,n),n=n.sibling;return null}function n(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function o(e,t){return(e=Vu(e,t)).index=0,e.sibling=null,e}function a(t,r,n){return t.index=n,e?null!==(n=t.alternate)?(n=n.index)<r?(t.flags=2,r):n:(t.flags=2,r):r}function l(t){return e&&null===t.alternate&&(t.flags=2),t}function u(e,t,r,n){return null===t||6!==t.tag?((t=Gu(r,e.mode,n)).return=e,t):((t=o(t,r)).return=e,t)}function c(e,t,r,n){return null!==t&&t.elementType===r.type?((n=o(t,r.props)).ref=ka(e,t,r),n.return=e,n):((n=Hu(r.type,r.key,r.props,null,e.mode,n)).ref=ka(e,t,r),n.return=e,n)}function s(e,t,r,n){return null===t||4!==t.tag||t.stateNode.containerInfo!==r.containerInfo||t.stateNode.implementation!==r.implementation?((t=Qu(r,e.mode,n)).return=e,t):((t=o(t,r.children||[])).return=e,t)}function f(e,t,r,n,a){return null===t||7!==t.tag?((t=Wu(r,e.mode,n,a)).return=e,t):((t=o(t,r)).return=e,t)}function d(e,t,r){if("string"===typeof t||"number"===typeof t)return(t=Gu(""+t,e.mode,r)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case E:return(r=Hu(t.type,t.key,t.props,null,e.mode,r)).ref=ka(e,null,t),r.return=e,r;case x:return(t=Qu(t,e.mode,r)).return=e,t}if(wa(t)||B(t))return(t=Wu(t,e.mode,r,null)).return=e,t;Ea(e,t)}return null}function p(e,t,r,n){var o=null!==t?t.key:null;if("string"===typeof r||"number"===typeof r)return null!==o?null:u(e,t,""+r,n);if("object"===typeof r&&null!==r){switch(r.$$typeof){case E:return r.key===o?r.type===S?f(e,t,r.props.children,n,o):c(e,t,r,n):null;case x:return r.key===o?s(e,t,r,n):null}if(wa(r)||B(r))return null!==o?null:f(e,t,r,n,null);Ea(e,r)}return null}function h(e,t,r,n,o){if("string"===typeof n||"number"===typeof n)return u(t,e=e.get(r)||null,""+n,o);if("object"===typeof n&&null!==n){switch(n.$$typeof){case E:return e=e.get(null===n.key?r:n.key)||null,n.type===S?f(t,e,n.props.children,o,n.key):c(t,e,n,o);case x:return s(t,e=e.get(null===n.key?r:n.key)||null,n,o)}if(wa(n)||B(n))return f(t,e=e.get(r)||null,n,o,null);Ea(t,n)}return null}function g(o,i,l,u){for(var c=null,s=null,f=i,g=i=0,v=null;null!==f&&g<l.length;g++){f.index>g?(v=f,f=null):v=f.sibling;var m=p(o,f,l[g],u);if(null===m){null===f&&(f=v);break}e&&f&&null===m.alternate&&t(o,f),i=a(m,i,g),null===s?c=m:s.sibling=m,s=m,f=v}if(g===l.length)return r(o,f),c;if(null===f){for(;g<l.length;g++)null!==(f=d(o,l[g],u))&&(i=a(f,i,g),null===s?c=f:s.sibling=f,s=f);return c}for(f=n(o,f);g<l.length;g++)null!==(v=h(f,o,g,l[g],u))&&(e&&null!==v.alternate&&f.delete(null===v.key?g:v.key),i=a(v,i,g),null===s?c=v:s.sibling=v,s=v);return e&&f.forEach((function(e){return t(o,e)})),c}function v(o,l,u,c){var s=B(u);if("function"!==typeof s)throw Error(i(150));if(null==(u=s.call(u)))throw Error(i(151));for(var f=s=null,g=l,v=l=0,m=null,y=u.next();null!==g&&!y.done;v++,y=u.next()){g.index>v?(m=g,g=null):m=g.sibling;var b=p(o,g,y.value,c);if(null===b){null===g&&(g=m);break}e&&g&&null===b.alternate&&t(o,g),l=a(b,l,v),null===f?s=b:f.sibling=b,f=b,g=m}if(y.done)return r(o,g),s;if(null===g){for(;!y.done;v++,y=u.next())null!==(y=d(o,y.value,c))&&(l=a(y,l,v),null===f?s=y:f.sibling=y,f=y);return s}for(g=n(o,g);!y.done;v++,y=u.next())null!==(y=h(g,o,v,y.value,c))&&(e&&null!==y.alternate&&g.delete(null===y.key?v:y.key),l=a(y,l,v),null===f?s=y:f.sibling=y,f=y);return e&&g.forEach((function(e){return t(o,e)})),s}return function(e,n,a,u){var c="object"===typeof a&&null!==a&&a.type===S&&null===a.key;c&&(a=a.props.children);var s="object"===typeof a&&null!==a;if(s)switch(a.$$typeof){case E:e:{for(s=a.key,c=n;null!==c;){if(c.key===s){switch(c.tag){case 7:if(a.type===S){r(e,c.sibling),(n=o(c,a.props.children)).return=e,e=n;break e}break;default:if(c.elementType===a.type){r(e,c.sibling),(n=o(c,a.props)).ref=ka(e,c,a),n.return=e,e=n;break e}}r(e,c);break}t(e,c),c=c.sibling}a.type===S?((n=Wu(a.props.children,e.mode,u,a.key)).return=e,e=n):((u=Hu(a.type,a.key,a.props,null,e.mode,u)).ref=ka(e,n,a),u.return=e,e=u)}return l(e);case x:e:{for(c=a.key;null!==n;){if(n.key===c){if(4===n.tag&&n.stateNode.containerInfo===a.containerInfo&&n.stateNode.implementation===a.implementation){r(e,n.sibling),(n=o(n,a.children||[])).return=e,e=n;break e}r(e,n);break}t(e,n),n=n.sibling}(n=Qu(a,e.mode,u)).return=e,e=n}return l(e)}if("string"===typeof a||"number"===typeof a)return a=""+a,null!==n&&6===n.tag?(r(e,n.sibling),(n=o(n,a)).return=e,e=n):(r(e,n),(n=Gu(a,e.mode,u)).return=e,e=n),l(e);if(wa(a))return g(e,n,a,u);if(B(a))return v(e,n,a,u);if(s&&Ea(e,a),"undefined"===typeof a&&!c)switch(e.tag){case 1:case 22:case 0:case 11:case 15:throw Error(i(152,G(e.type)||"Component"))}return r(e,n)}}var Sa=xa(!0),_a=xa(!1),Ta={},Ca=io(Ta),Oa=io(Ta),Pa=io(Ta);function Ra(e){if(e===Ta)throw Error(i(174));return e}function Na(e,t){switch(uo(Pa,t),uo(Oa,e),uo(Ca,Ta),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:he(null,"");break;default:t=he(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}lo(Ca),uo(Ca,t)}function La(){lo(Ca),lo(Oa),lo(Pa)}function Aa(e){Ra(Pa.current);var t=Ra(Ca.current),r=he(t,e.type);t!==r&&(uo(Oa,e),uo(Ca,r))}function Ia(e){Oa.current===e&&(lo(Ca),lo(Oa))}var ja=io(0);function Ma(e){for(var t=e;null!==t;){if(13===t.tag){var r=t.memoizedState;if(null!==r&&(null===(r=r.dehydrated)||"$?"===r.data||"$!"===r.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(64&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var Da=null,qa=null,za=!1;function Ua(e,t){var r=Fu(5,null,null,0);r.elementType="DELETED",r.type="DELETED",r.stateNode=t,r.return=e,r.flags=8,null!==e.lastEffect?(e.lastEffect.nextEffect=r,e.lastEffect=r):e.firstEffect=e.lastEffect=r}function Fa(e,t){switch(e.tag){case 5:var r=e.type;return null!==(t=1!==t.nodeType||r.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,!0);case 13:default:return!1}}function Ba(e){if(za){var t=qa;if(t){var r=t;if(!Fa(e,t)){if(!(t=Wn(r.nextSibling))||!Fa(e,t))return e.flags=-1025&e.flags|2,za=!1,void(Da=e);Ua(Da,r)}Da=e,qa=Wn(t.firstChild)}else e.flags=-1025&e.flags|2,za=!1,Da=e}}function Va(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;Da=e}function Ha(e){if(e!==Da)return!1;if(!za)return Va(e),za=!0,!1;var t=e.type;if(5!==e.tag||"head"!==t&&"body"!==t&&!Fn(t,e.memoizedProps))for(t=qa;t;)Ua(e,t),t=Wn(t.nextSibling);if(Va(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(i(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var r=e.data;if("/$"===r){if(0===t){qa=Wn(e.nextSibling);break e}t--}else"$"!==r&&"$!"!==r&&"$?"!==r||t++}e=e.nextSibling}qa=null}}else qa=Da?Wn(e.stateNode.nextSibling):null;return!0}function Wa(){qa=Da=null,za=!1}var $a=[];function Ga(){for(var e=0;e<$a.length;e++)$a[e]._workInProgressVersionPrimary=null;$a.length=0}var Qa=k.ReactCurrentDispatcher,Ya=k.ReactCurrentBatchConfig,Ka=0,Xa=null,Ja=null,Za=null,ei=!1,ti=!1;function ri(){throw Error(i(321))}function ni(e,t){if(null===t)return!1;for(var r=0;r<t.length&&r<e.length;r++)if(!ln(e[r],t[r]))return!1;return!0}function oi(e,t,r,n,o,a){if(Ka=a,Xa=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,Qa.current=null===e||null===e.memoizedState?Ri:Ni,e=r(n,o),ti){a=0;do{if(ti=!1,!(25>a))throw Error(i(301));a+=1,Za=Ja=null,t.updateQueue=null,Qa.current=Li,e=r(n,o)}while(ti)}if(Qa.current=Pi,t=null!==Ja&&null!==Ja.next,Ka=0,Za=Ja=Xa=null,ei=!1,t)throw Error(i(300));return e}function ai(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===Za?Xa.memoizedState=Za=e:Za=Za.next=e,Za}function ii(){if(null===Ja){var e=Xa.alternate;e=null!==e?e.memoizedState:null}else e=Ja.next;var t=null===Za?Xa.memoizedState:Za.next;if(null!==t)Za=t,Ja=e;else{if(null===e)throw Error(i(310));e={memoizedState:(Ja=e).memoizedState,baseState:Ja.baseState,baseQueue:Ja.baseQueue,queue:Ja.queue,next:null},null===Za?Xa.memoizedState=Za=e:Za=Za.next=e}return Za}function li(e,t){return"function"===typeof t?t(e):t}function ui(e){var t=ii(),r=t.queue;if(null===r)throw Error(i(311));r.lastRenderedReducer=e;var n=Ja,o=n.baseQueue,a=r.pending;if(null!==a){if(null!==o){var l=o.next;o.next=a.next,a.next=l}n.baseQueue=o=a,r.pending=null}if(null!==o){o=o.next,n=n.baseState;var u=l=a=null,c=o;do{var s=c.lane;if((Ka&s)===s)null!==u&&(u=u.next={lane:0,action:c.action,eagerReducer:c.eagerReducer,eagerState:c.eagerState,next:null}),n=c.eagerReducer===e?c.eagerState:e(n,c.action);else{var f={lane:s,action:c.action,eagerReducer:c.eagerReducer,eagerState:c.eagerState,next:null};null===u?(l=u=f,a=n):u=u.next=f,Xa.lanes|=s,ql|=s}c=c.next}while(null!==c&&c!==o);null===u?a=n:u.next=l,ln(n,t.memoizedState)||(Ii=!0),t.memoizedState=n,t.baseState=a,t.baseQueue=u,r.lastRenderedState=n}return[t.memoizedState,r.dispatch]}function ci(e){var t=ii(),r=t.queue;if(null===r)throw Error(i(311));r.lastRenderedReducer=e;var n=r.dispatch,o=r.pending,a=t.memoizedState;if(null!==o){r.pending=null;var l=o=o.next;do{a=e(a,l.action),l=l.next}while(l!==o);ln(a,t.memoizedState)||(Ii=!0),t.memoizedState=a,null===t.baseQueue&&(t.baseState=a),r.lastRenderedState=a}return[a,n]}function si(e,t,r){var n=t._getVersion;n=n(t._source);var o=t._workInProgressVersionPrimary;if(null!==o?e=o===n:(e=e.mutableReadLanes,(e=(Ka&e)===e)&&(t._workInProgressVersionPrimary=n,$a.push(t))),e)return r(t._source);throw $a.push(t),Error(i(350))}function fi(e,t,r,n){var o=Rl;if(null===o)throw Error(i(349));var a=t._getVersion,l=a(t._source),u=Qa.current,c=u.useState((function(){return si(o,t,r)})),s=c[1],f=c[0];c=Za;var d=e.memoizedState,p=d.refs,h=p.getSnapshot,g=d.source;d=d.subscribe;var v=Xa;return e.memoizedState={refs:p,source:t,subscribe:n},u.useEffect((function(){p.getSnapshot=r,p.setSnapshot=s;var e=a(t._source);if(!ln(l,e)){e=r(t._source),ln(f,e)||(s(e),e=su(v),o.mutableReadLanes|=e&o.pendingLanes),e=o.mutableReadLanes,o.entangledLanes|=e;for(var n=o.entanglements,i=e;0<i;){var u=31-Ht(i),c=1<<u;n[u]|=e,i&=~c}}}),[r,t,n]),u.useEffect((function(){return n(t._source,(function(){var e=p.getSnapshot,r=p.setSnapshot;try{r(e(t._source));var n=su(v);o.mutableReadLanes|=n&o.pendingLanes}catch(e){r((function(){throw e}))}}))}),[t,n]),ln(h,r)&&ln(g,t)&&ln(d,n)||((e={pending:null,dispatch:null,lastRenderedReducer:li,lastRenderedState:f}).dispatch=s=Oi.bind(null,Xa,e),c.queue=e,c.baseQueue=null,f=si(o,t,r),c.memoizedState=c.baseState=f),f}function di(e,t,r){return fi(ii(),e,t,r)}function pi(e){var t=ai();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e=(e=t.queue={pending:null,dispatch:null,lastRenderedReducer:li,lastRenderedState:e}).dispatch=Oi.bind(null,Xa,e),[t.memoizedState,e]}function hi(e,t,r,n){return e={tag:e,create:t,destroy:r,deps:n,next:null},null===(t=Xa.updateQueue)?(t={lastEffect:null},Xa.updateQueue=t,t.lastEffect=e.next=e):null===(r=t.lastEffect)?t.lastEffect=e.next=e:(n=r.next,r.next=e,e.next=n,t.lastEffect=e),e}function gi(e){return e={current:e},ai().memoizedState=e}function vi(){return ii().memoizedState}function mi(e,t,r,n){var o=ai();Xa.flags|=e,o.memoizedState=hi(1|t,r,void 0,void 0===n?null:n)}function yi(e,t,r,n){var o=ii();n=void 0===n?null:n;var a=void 0;if(null!==Ja){var i=Ja.memoizedState;if(a=i.destroy,null!==n&&ni(n,i.deps))return void hi(t,r,a,n)}Xa.flags|=e,o.memoizedState=hi(1|t,r,a,n)}function bi(e,t){return mi(516,4,e,t)}function wi(e,t){return yi(516,4,e,t)}function ki(e,t){return yi(4,2,e,t)}function Ei(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function xi(e,t,r){return r=null!==r&&void 0!==r?r.concat([e]):null,yi(4,2,Ei.bind(null,t,e),r)}function Si(){}function _i(e,t){var r=ii();t=void 0===t?null:t;var n=r.memoizedState;return null!==n&&null!==t&&ni(t,n[1])?n[0]:(r.memoizedState=[e,t],e)}function Ti(e,t){var r=ii();t=void 0===t?null:t;var n=r.memoizedState;return null!==n&&null!==t&&ni(t,n[1])?n[0]:(e=e(),r.memoizedState=[e,t],e)}function Ci(e,t){var r=Bo();Ho(98>r?98:r,(function(){e(!0)})),Ho(97<r?97:r,(function(){var r=Ya.transition;Ya.transition=1;try{e(!1),t()}finally{Ya.transition=r}}))}function Oi(e,t,r){var n=cu(),o=su(e),a={lane:o,action:r,eagerReducer:null,eagerState:null,next:null},i=t.pending;if(null===i?a.next=a:(a.next=i.next,i.next=a),t.pending=a,i=e.alternate,e===Xa||null!==i&&i===Xa)ti=ei=!0;else{if(0===e.lanes&&(null===i||0===i.lanes)&&null!==(i=t.lastRenderedReducer))try{var l=t.lastRenderedState,u=i(l,r);if(a.eagerReducer=i,a.eagerState=u,ln(u,l))return}catch(e){}fu(e,o,n)}}var Pi={readContext:oa,useCallback:ri,useContext:ri,useEffect:ri,useImperativeHandle:ri,useLayoutEffect:ri,useMemo:ri,useReducer:ri,useRef:ri,useState:ri,useDebugValue:ri,useDeferredValue:ri,useTransition:ri,useMutableSource:ri,useOpaqueIdentifier:ri,unstable_isNewReconciler:!1},Ri={readContext:oa,useCallback:function(e,t){return ai().memoizedState=[e,void 0===t?null:t],e},useContext:oa,useEffect:bi,useImperativeHandle:function(e,t,r){return r=null!==r&&void 0!==r?r.concat([e]):null,mi(4,2,Ei.bind(null,t,e),r)},useLayoutEffect:function(e,t){return mi(4,2,e,t)},useMemo:function(e,t){var r=ai();return t=void 0===t?null:t,e=e(),r.memoizedState=[e,t],e},useReducer:function(e,t,r){var n=ai();return t=void 0!==r?r(t):t,n.memoizedState=n.baseState=t,e=(e=n.queue={pending:null,dispatch:null,lastRenderedReducer:e,lastRenderedState:t}).dispatch=Oi.bind(null,Xa,e),[n.memoizedState,e]},useRef:gi,useState:pi,useDebugValue:Si,useDeferredValue:function(e){var t=pi(e),r=t[0],n=t[1];return bi((function(){var t=Ya.transition;Ya.transition=1;try{n(e)}finally{Ya.transition=t}}),[e]),r},useTransition:function(){var e=pi(!1),t=e[0];return gi(e=Ci.bind(null,e[1])),[e,t]},useMutableSource:function(e,t,r){var n=ai();return n.memoizedState={refs:{getSnapshot:t,setSnapshot:null},source:e,subscribe:r},fi(n,e,t,r)},useOpaqueIdentifier:function(){if(za){var e=!1,t=function(e){return{$$typeof:j,toString:e,valueOf:e}}((function(){throw e||(e=!0,r("r:"+(Gn++).toString(36))),Error(i(355))})),r=pi(t)[1];return 0===(2&Xa.mode)&&(Xa.flags|=516,hi(5,(function(){r("r:"+(Gn++).toString(36))}),void 0,null)),t}return pi(t="r:"+(Gn++).toString(36)),t},unstable_isNewReconciler:!1},Ni={readContext:oa,useCallback:_i,useContext:oa,useEffect:wi,useImperativeHandle:xi,useLayoutEffect:ki,useMemo:Ti,useReducer:ui,useRef:vi,useState:function(){return ui(li)},useDebugValue:Si,useDeferredValue:function(e){var t=ui(li),r=t[0],n=t[1];return wi((function(){var t=Ya.transition;Ya.transition=1;try{n(e)}finally{Ya.transition=t}}),[e]),r},useTransition:function(){var e=ui(li)[0];return[vi().current,e]},useMutableSource:di,useOpaqueIdentifier:function(){return ui(li)[0]},unstable_isNewReconciler:!1},Li={readContext:oa,useCallback:_i,useContext:oa,useEffect:wi,useImperativeHandle:xi,useLayoutEffect:ki,useMemo:Ti,useReducer:ci,useRef:vi,useState:function(){return ci(li)},useDebugValue:Si,useDeferredValue:function(e){var t=ci(li),r=t[0],n=t[1];return wi((function(){var t=Ya.transition;Ya.transition=1;try{n(e)}finally{Ya.transition=t}}),[e]),r},useTransition:function(){var e=ci(li)[0];return[vi().current,e]},useMutableSource:di,useOpaqueIdentifier:function(){return ci(li)[0]},unstable_isNewReconciler:!1},Ai=k.ReactCurrentOwner,Ii=!1;function ji(e,t,r,n){t.child=null===e?_a(t,null,r,n):Sa(t,e.child,r,n)}function Mi(e,t,r,n,o){r=r.render;var a=t.ref;return na(t,o),n=oi(e,t,r,n,a,o),null===e||Ii?(t.flags|=1,ji(e,t,n,o),t.child):(t.updateQueue=e.updateQueue,t.flags&=-517,e.lanes&=~o,rl(e,t,o))}function Di(e,t,r,n,o,a){if(null===e){var i=r.type;return"function"!==typeof i||Bu(i)||void 0!==i.defaultProps||null!==r.compare||void 0!==r.defaultProps?((e=Hu(r.type,null,n,t,t.mode,a)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=i,qi(e,t,i,n,o,a))}return i=e.child,0===(o&a)&&(o=i.memoizedProps,(r=null!==(r=r.compare)?r:cn)(o,n)&&e.ref===t.ref)?rl(e,t,a):(t.flags|=1,(e=Vu(i,n)).ref=t.ref,e.return=t,t.child=e)}function qi(e,t,r,n,o,a){if(null!==e&&cn(e.memoizedProps,n)&&e.ref===t.ref){if(Ii=!1,0===(a&o))return t.lanes=e.lanes,rl(e,t,a);0!==(16384&e.flags)&&(Ii=!0)}return Fi(e,t,r,n,a)}function zi(e,t,r){var n=t.pendingProps,o=n.children,a=null!==e?e.memoizedState:null;if("hidden"===n.mode||"unstable-defer-without-hiding"===n.mode)if(0===(4&t.mode))t.memoizedState={baseLanes:0},bu(t,r);else{if(0===(1073741824&r))return e=null!==a?a.baseLanes|r:r,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e},bu(t,e),null;t.memoizedState={baseLanes:0},bu(t,null!==a?a.baseLanes:r)}else null!==a?(n=a.baseLanes|r,t.memoizedState=null):n=r,bu(t,n);return ji(e,t,o,r),t.child}function Ui(e,t){var r=t.ref;(null===e&&null!==r||null!==e&&e.ref!==r)&&(t.flags|=128)}function Fi(e,t,r,n,o){var a=go(r)?po:so.current;return a=ho(t,a),na(t,o),r=oi(e,t,r,n,a,o),null===e||Ii?(t.flags|=1,ji(e,t,r,o),t.child):(t.updateQueue=e.updateQueue,t.flags&=-517,e.lanes&=~o,rl(e,t,o))}function Bi(e,t,r,n,o){if(go(r)){var a=!0;bo(t)}else a=!1;if(na(t,o),null===t.stateNode)null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),ma(t,r,n),ba(t,r,n,o),n=!0;else if(null===e){var i=t.stateNode,l=t.memoizedProps;i.props=l;var u=i.context,c=r.contextType;"object"===typeof c&&null!==c?c=oa(c):c=ho(t,c=go(r)?po:so.current);var s=r.getDerivedStateFromProps,f="function"===typeof s||"function"===typeof i.getSnapshotBeforeUpdate;f||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(l!==n||u!==c)&&ya(t,i,n,c),aa=!1;var d=t.memoizedState;i.state=d,fa(t,n,i,o),u=t.memoizedState,l!==n||d!==u||fo.current||aa?("function"===typeof s&&(ha(t,r,s,n),u=t.memoizedState),(l=aa||va(t,r,l,n,d,u,c))?(f||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(t.flags|=4)):("function"===typeof i.componentDidMount&&(t.flags|=4),t.memoizedProps=n,t.memoizedState=u),i.props=n,i.state=u,i.context=c,n=l):("function"===typeof i.componentDidMount&&(t.flags|=4),n=!1)}else{i=t.stateNode,la(e,t),l=t.memoizedProps,c=t.type===t.elementType?l:Yo(t.type,l),i.props=c,f=t.pendingProps,d=i.context,"object"===typeof(u=r.contextType)&&null!==u?u=oa(u):u=ho(t,u=go(r)?po:so.current);var p=r.getDerivedStateFromProps;(s="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(l!==f||d!==u)&&ya(t,i,n,u),aa=!1,d=t.memoizedState,i.state=d,fa(t,n,i,o);var h=t.memoizedState;l!==f||d!==h||fo.current||aa?("function"===typeof p&&(ha(t,r,p,n),h=t.memoizedState),(c=aa||va(t,r,c,n,d,h,u))?(s||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(n,h,u),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(n,h,u)),"function"===typeof i.componentDidUpdate&&(t.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(t.flags|=256)):("function"!==typeof i.componentDidUpdate||l===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||l===e.memoizedProps&&d===e.memoizedState||(t.flags|=256),t.memoizedProps=n,t.memoizedState=h),i.props=n,i.state=h,i.context=u,n=c):("function"!==typeof i.componentDidUpdate||l===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||l===e.memoizedProps&&d===e.memoizedState||(t.flags|=256),n=!1)}return Vi(e,t,r,n,a,o)}function Vi(e,t,r,n,o,a){Ui(e,t);var i=0!==(64&t.flags);if(!n&&!i)return o&&wo(t,r,!1),rl(e,t,a);n=t.stateNode,Ai.current=t;var l=i&&"function"!==typeof r.getDerivedStateFromError?null:n.render();return t.flags|=1,null!==e&&i?(t.child=Sa(t,e.child,null,a),t.child=Sa(t,null,l,a)):ji(e,t,l,a),t.memoizedState=n.state,o&&wo(t,r,!0),t.child}function Hi(e){var t=e.stateNode;t.pendingContext?mo(0,t.pendingContext,t.pendingContext!==t.context):t.context&&mo(0,t.context,!1),Na(e,t.containerInfo)}var Wi,$i,Gi,Qi={dehydrated:null,retryLane:0};function Yi(e,t,r){var n,o=t.pendingProps,a=ja.current,i=!1;return(n=0!==(64&t.flags))||(n=(null===e||null!==e.memoizedState)&&0!==(2&a)),n?(i=!0,t.flags&=-65):null!==e&&null===e.memoizedState||void 0===o.fallback||!0===o.unstable_avoidThisFallback||(a|=1),uo(ja,1&a),null===e?(void 0!==o.fallback&&Ba(t),e=o.children,a=o.fallback,i?(e=Ki(t,e,a,r),t.child.memoizedState={baseLanes:r},t.memoizedState=Qi,e):"number"===typeof o.unstable_expectedLoadTime?(e=Ki(t,e,a,r),t.child.memoizedState={baseLanes:r},t.memoizedState=Qi,t.lanes=33554432,e):((r=$u({mode:"visible",children:e},t.mode,r,null)).return=t,t.child=r)):(e.memoizedState,i?(o=Ji(e,t,o.children,o.fallback,r),i=t.child,a=e.child.memoizedState,i.memoizedState=null===a?{baseLanes:r}:{baseLanes:a.baseLanes|r},i.childLanes=e.childLanes&~r,t.memoizedState=Qi,o):(r=Xi(e,t,o.children,r),t.memoizedState=null,r))}function Ki(e,t,r,n){var o=e.mode,a=e.child;return t={mode:"hidden",children:t},0===(2&o)&&null!==a?(a.childLanes=0,a.pendingProps=t):a=$u(t,o,0,null),r=Wu(r,o,n,null),a.return=e,r.return=e,a.sibling=r,e.child=a,r}function Xi(e,t,r,n){var o=e.child;return e=o.sibling,r=Vu(o,{mode:"visible",children:r}),0===(2&t.mode)&&(r.lanes=n),r.return=t,r.sibling=null,null!==e&&(e.nextEffect=null,e.flags=8,t.firstEffect=t.lastEffect=e),t.child=r}function Ji(e,t,r,n,o){var a=t.mode,i=e.child;e=i.sibling;var l={mode:"hidden",children:r};return 0===(2&a)&&t.child!==i?((r=t.child).childLanes=0,r.pendingProps=l,null!==(i=r.lastEffect)?(t.firstEffect=r.firstEffect,t.lastEffect=i,i.nextEffect=null):t.firstEffect=t.lastEffect=null):r=Vu(i,l),null!==e?n=Vu(e,n):(n=Wu(n,a,o,null)).flags|=2,n.return=t,r.return=t,r.sibling=n,t.child=r,n}function Zi(e,t){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),ra(e.return,t)}function el(e,t,r,n,o,a){var i=e.memoizedState;null===i?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:n,tail:r,tailMode:o,lastEffect:a}:(i.isBackwards=t,i.rendering=null,i.renderingStartTime=0,i.last=n,i.tail=r,i.tailMode=o,i.lastEffect=a)}function tl(e,t,r){var n=t.pendingProps,o=n.revealOrder,a=n.tail;if(ji(e,t,n.children,r),0!==(2&(n=ja.current)))n=1&n|2,t.flags|=64;else{if(null!==e&&0!==(64&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Zi(e,r);else if(19===e.tag)Zi(e,r);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}n&=1}if(uo(ja,n),0===(2&t.mode))t.memoizedState=null;else switch(o){case"forwards":for(r=t.child,o=null;null!==r;)null!==(e=r.alternate)&&null===Ma(e)&&(o=r),r=r.sibling;null===(r=o)?(o=t.child,t.child=null):(o=r.sibling,r.sibling=null),el(t,!1,o,r,a,t.lastEffect);break;case"backwards":for(r=null,o=t.child,t.child=null;null!==o;){if(null!==(e=o.alternate)&&null===Ma(e)){t.child=o;break}e=o.sibling,o.sibling=r,r=o,o=e}el(t,!0,r,null,a,t.lastEffect);break;case"together":el(t,!1,null,null,void 0,t.lastEffect);break;default:t.memoizedState=null}return t.child}function rl(e,t,r){if(null!==e&&(t.dependencies=e.dependencies),ql|=t.lanes,0!==(r&t.childLanes)){if(null!==e&&t.child!==e.child)throw Error(i(153));if(null!==t.child){for(r=Vu(e=t.child,e.pendingProps),t.child=r,r.return=t;null!==e.sibling;)e=e.sibling,(r=r.sibling=Vu(e,e.pendingProps)).return=t;r.sibling=null}return t.child}return null}function nl(e,t){if(!za)switch(e.tailMode){case"hidden":t=e.tail;for(var r=null;null!==t;)null!==t.alternate&&(r=t),t=t.sibling;null===r?e.tail=null:r.sibling=null;break;case"collapsed":r=e.tail;for(var n=null;null!==r;)null!==r.alternate&&(n=r),r=r.sibling;null===n?t||null===e.tail?e.tail=null:e.tail.sibling=null:n.sibling=null}}function ol(e,t,r){var n=t.pendingProps;switch(t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return go(t.type)&&vo(),null;case 3:return La(),lo(fo),lo(so),Ga(),(n=t.stateNode).pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),null!==e&&null!==e.child||(Ha(t)?t.flags|=4:n.hydrate||(t.flags|=256)),null;case 5:Ia(t);var a=Ra(Pa.current);if(r=t.type,null!==e&&null!=t.stateNode)$i(e,t,r,n),e.ref!==t.ref&&(t.flags|=128);else{if(!n){if(null===t.stateNode)throw Error(i(166));return null}if(e=Ra(Ca.current),Ha(t)){n=t.stateNode,r=t.type;var l=t.memoizedProps;switch(n[Yn]=t,n[Kn]=l,r){case"dialog":Cn("cancel",n),Cn("close",n);break;case"iframe":case"object":case"embed":Cn("load",n);break;case"video":case"audio":for(e=0;e<xn.length;e++)Cn(xn[e],n);break;case"source":Cn("error",n);break;case"img":case"image":case"link":Cn("error",n),Cn("load",n);break;case"details":Cn("toggle",n);break;case"input":ee(n,l),Cn("invalid",n);break;case"select":n._wrapperState={wasMultiple:!!l.multiple},Cn("invalid",n);break;case"textarea":ue(n,l),Cn("invalid",n)}for(var c in Se(r,l),e=null,l)l.hasOwnProperty(c)&&(a=l[c],"children"===c?"string"===typeof a?n.textContent!==a&&(e=["children",a]):"number"===typeof a&&n.textContent!==""+a&&(e=["children",""+a]):u.hasOwnProperty(c)&&null!=a&&"onScroll"===c&&Cn("scroll",n));switch(r){case"input":K(n),ne(n,l,!0);break;case"textarea":K(n),se(n);break;case"select":case"option":break;default:"function"===typeof l.onClick&&(n.onclick=Dn)}n=e,t.updateQueue=n,null!==n&&(t.flags|=4)}else{switch(c=9===a.nodeType?a:a.ownerDocument,e===fe&&(e=pe(r)),e===fe?"script"===r?((e=c.createElement("div")).innerHTML="<script><\\/script>",e=e.removeChild(e.firstChild)):"string"===typeof n.is?e=c.createElement(r,{is:n.is}):(e=c.createElement(r),"select"===r&&(c=e,n.multiple?c.multiple=!0:n.size&&(c.size=n.size))):e=c.createElementNS(e,r),e[Yn]=t,e[Kn]=n,Wi(e,t),t.stateNode=e,c=_e(r,n),r){case"dialog":Cn("cancel",e),Cn("close",e),a=n;break;case"iframe":case"object":case"embed":Cn("load",e),a=n;break;case"video":case"audio":for(a=0;a<xn.length;a++)Cn(xn[a],e);a=n;break;case"source":Cn("error",e),a=n;break;case"img":case"image":case"link":Cn("error",e),Cn("load",e),a=n;break;case"details":Cn("toggle",e),a=n;break;case"input":ee(e,n),a=Z(e,n),Cn("invalid",e);break;case"option":a=ae(e,n);break;case"select":e._wrapperState={wasMultiple:!!n.multiple},a=o({},n,{value:void 0}),Cn("invalid",e);break;case"textarea":ue(e,n),a=le(e,n),Cn("invalid",e);break;default:a=n}Se(r,a);var s=a;for(l in s)if(s.hasOwnProperty(l)){var f=s[l];"style"===l?Ee(e,f):"dangerouslySetInnerHTML"===l?null!=(f=f?f.__html:void 0)&&me(e,f):"children"===l?"string"===typeof f?("textarea"!==r||""!==f)&&ye(e,f):"number"===typeof f&&ye(e,""+f):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(u.hasOwnProperty(l)?null!=f&&"onScroll"===l&&Cn("scroll",e):null!=f&&w(e,l,f,c))}switch(r){case"input":K(e),ne(e,n,!1);break;case"textarea":K(e),se(e);break;case"option":null!=n.value&&e.setAttribute("value",""+Q(n.value));break;case"select":e.multiple=!!n.multiple,null!=(l=n.value)?ie(e,!!n.multiple,l,!1):null!=n.defaultValue&&ie(e,!!n.multiple,n.defaultValue,!0);break;default:"function"===typeof a.onClick&&(e.onclick=Dn)}Un(r,n)&&(t.flags|=4)}null!==t.ref&&(t.flags|=128)}return null;case 6:if(e&&null!=t.stateNode)Gi(0,t,e.memoizedProps,n);else{if("string"!==typeof n&&null===t.stateNode)throw Error(i(166));r=Ra(Pa.current),Ra(Ca.current),Ha(t)?(n=t.stateNode,r=t.memoizedProps,n[Yn]=t,n.nodeValue!==r&&(t.flags|=4)):((n=(9===r.nodeType?r:r.ownerDocument).createTextNode(n))[Yn]=t,t.stateNode=n)}return null;case 13:return lo(ja),n=t.memoizedState,0!==(64&t.flags)?(t.lanes=r,t):(n=null!==n,r=!1,null===e?void 0!==t.memoizedProps.fallback&&Ha(t):r=null!==e.memoizedState,n&&!r&&0!==(2&t.mode)&&(null===e&&!0!==t.memoizedProps.unstable_avoidThisFallback||0!==(1&ja.current)?0===jl&&(jl=3):(0!==jl&&3!==jl||(jl=4),null===Rl||0===(134217727&ql)&&0===(134217727&zl)||gu(Rl,Ll))),(n||r)&&(t.flags|=4),null);case 4:return La(),null===e&&Pn(t.stateNode.containerInfo),null;case 10:return ta(t),null;case 17:return go(t.type)&&vo(),null;case 19:if(lo(ja),null===(n=t.memoizedState))return null;if(l=0!==(64&t.flags),null===(c=n.rendering))if(l)nl(n,!1);else{if(0!==jl||null!==e&&0!==(64&e.flags))for(e=t.child;null!==e;){if(null!==(c=Ma(e))){for(t.flags|=64,nl(n,!1),null!==(l=c.updateQueue)&&(t.updateQueue=l,t.flags|=4),null===n.lastEffect&&(t.firstEffect=null),t.lastEffect=n.lastEffect,n=r,r=t.child;null!==r;)e=n,(l=r).flags&=2,l.nextEffect=null,l.firstEffect=null,l.lastEffect=null,null===(c=l.alternate)?(l.childLanes=0,l.lanes=e,l.child=null,l.memoizedProps=null,l.memoizedState=null,l.updateQueue=null,l.dependencies=null,l.stateNode=null):(l.childLanes=c.childLanes,l.lanes=c.lanes,l.child=c.child,l.memoizedProps=c.memoizedProps,l.memoizedState=c.memoizedState,l.updateQueue=c.updateQueue,l.type=c.type,e=c.dependencies,l.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),r=r.sibling;return uo(ja,1&ja.current|2),t.child}e=e.sibling}null!==n.tail&&Fo()>Vl&&(t.flags|=64,l=!0,nl(n,!1),t.lanes=33554432)}else{if(!l)if(null!==(e=Ma(c))){if(t.flags|=64,l=!0,null!==(r=e.updateQueue)&&(t.updateQueue=r,t.flags|=4),nl(n,!0),null===n.tail&&"hidden"===n.tailMode&&!c.alternate&&!za)return null!==(t=t.lastEffect=n.lastEffect)&&(t.nextEffect=null),null}else 2*Fo()-n.renderingStartTime>Vl&&1073741824!==r&&(t.flags|=64,l=!0,nl(n,!1),t.lanes=33554432);n.isBackwards?(c.sibling=t.child,t.child=c):(null!==(r=n.last)?r.sibling=c:t.child=c,n.last=c)}return null!==n.tail?(r=n.tail,n.rendering=r,n.tail=r.sibling,n.lastEffect=t.lastEffect,n.renderingStartTime=Fo(),r.sibling=null,t=ja.current,uo(ja,l?1&t|2:1&t),r):null;case 23:case 24:return wu(),null!==e&&null!==e.memoizedState!==(null!==t.memoizedState)&&"unstable-defer-without-hiding"!==n.mode&&(t.flags|=4),null}throw Error(i(156,t.tag))}function al(e){switch(e.tag){case 1:go(e.type)&&vo();var t=e.flags;return 4096&t?(e.flags=-4097&t|64,e):null;case 3:if(La(),lo(fo),lo(so),Ga(),0!==(64&(t=e.flags)))throw Error(i(285));return e.flags=-4097&t|64,e;case 5:return Ia(e),null;case 13:return lo(ja),4096&(t=e.flags)?(e.flags=-4097&t|64,e):null;case 19:return lo(ja),null;case 4:return La(),null;case 10:return ta(e),null;case 23:case 24:return wu(),null;default:return null}}function il(e,t){try{var r="",n=t;do{r+=$(n),n=n.return}while(n);var o=r}catch(e){o="\\nError generating stack: "+e.message+"\\n"+e.stack}return{value:e,source:t,stack:o}}function ll(e,t){try{console.error(t.value)}catch(e){setTimeout((function(){throw e}))}}Wi=function(e,t){for(var r=t.child;null!==r;){if(5===r.tag||6===r.tag)e.appendChild(r.stateNode);else if(4!==r.tag&&null!==r.child){r.child.return=r,r=r.child;continue}if(r===t)break;for(;null===r.sibling;){if(null===r.return||r.return===t)return;r=r.return}r.sibling.return=r.return,r=r.sibling}},$i=function(e,t,r,n){var a=e.memoizedProps;if(a!==n){e=t.stateNode,Ra(Ca.current);var i,l=null;switch(r){case"input":a=Z(e,a),n=Z(e,n),l=[];break;case"option":a=ae(e,a),n=ae(e,n),l=[];break;case"select":a=o({},a,{value:void 0}),n=o({},n,{value:void 0}),l=[];break;case"textarea":a=le(e,a),n=le(e,n),l=[];break;default:"function"!==typeof a.onClick&&"function"===typeof n.onClick&&(e.onclick=Dn)}for(f in Se(r,n),r=null,a)if(!n.hasOwnProperty(f)&&a.hasOwnProperty(f)&&null!=a[f])if("style"===f){var c=a[f];for(i in c)c.hasOwnProperty(i)&&(r||(r={}),r[i]="")}else"dangerouslySetInnerHTML"!==f&&"children"!==f&&"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(u.hasOwnProperty(f)?l||(l=[]):(l=l||[]).push(f,null));for(f in n){var s=n[f];if(c=null!=a?a[f]:void 0,n.hasOwnProperty(f)&&s!==c&&(null!=s||null!=c))if("style"===f)if(c){for(i in c)!c.hasOwnProperty(i)||s&&s.hasOwnProperty(i)||(r||(r={}),r[i]="");for(i in s)s.hasOwnProperty(i)&&c[i]!==s[i]&&(r||(r={}),r[i]=s[i])}else r||(l||(l=[]),l.push(f,r)),r=s;else"dangerouslySetInnerHTML"===f?(s=s?s.__html:void 0,c=c?c.__html:void 0,null!=s&&c!==s&&(l=l||[]).push(f,s)):"children"===f?"string"!==typeof s&&"number"!==typeof s||(l=l||[]).push(f,""+s):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&(u.hasOwnProperty(f)?(null!=s&&"onScroll"===f&&Cn("scroll",e),l||c===s||(l=[])):"object"===typeof s&&null!==s&&s.$$typeof===j?s.toString():(l=l||[]).push(f,s))}r&&(l=l||[]).push("style",r);var f=l;(t.updateQueue=f)&&(t.flags|=4)}},Gi=function(e,t,r,n){r!==n&&(t.flags|=4)};var ul="function"===typeof WeakMap?WeakMap:Map;function cl(e,t,r){(r=ua(-1,r)).tag=3,r.payload={element:null};var n=t.value;return r.callback=function(){Gl||(Gl=!0,Ql=n),ll(0,t)},r}function sl(e,t,r){(r=ua(-1,r)).tag=3;var n=e.type.getDerivedStateFromError;if("function"===typeof n){var o=t.value;r.payload=function(){return ll(0,t),n(o)}}var a=e.stateNode;return null!==a&&"function"===typeof a.componentDidCatch&&(r.callback=function(){"function"!==typeof n&&(null===Yl?Yl=new Set([this]):Yl.add(this),ll(0,t));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),r}var fl="function"===typeof WeakSet?WeakSet:Set;function dl(e){var t=e.ref;if(null!==t)if("function"===typeof t)try{t(null)}catch(t){Du(e,t)}else t.current=null}function pl(e,t){switch(t.tag){case 0:case 11:case 15:case 22:return;case 1:if(256&t.flags&&null!==e){var r=e.memoizedProps,n=e.memoizedState;t=(e=t.stateNode).getSnapshotBeforeUpdate(t.elementType===t.type?r:Yo(t.type,r),n),e.__reactInternalSnapshotBeforeUpdate=t}return;case 3:return void(256&t.flags&&Hn(t.stateNode.containerInfo));case 5:case 6:case 4:case 17:return}throw Error(i(163))}function hl(e,t,r){switch(r.tag){case 0:case 11:case 15:case 22:if(null!==(t=null!==(t=r.updateQueue)?t.lastEffect:null)){e=t=t.next;do{if(3===(3&e.tag)){var n=e.create;e.destroy=n()}e=e.next}while(e!==t)}if(null!==(t=null!==(t=r.updateQueue)?t.lastEffect:null)){e=t=t.next;do{var o=e;n=o.next,0!==(4&(o=o.tag))&&0!==(1&o)&&(Iu(r,e),Au(r,e)),e=n}while(e!==t)}return;case 1:return e=r.stateNode,4&r.flags&&(null===t?e.componentDidMount():(n=r.elementType===r.type?t.memoizedProps:Yo(r.type,t.memoizedProps),e.componentDidUpdate(n,t.memoizedState,e.__reactInternalSnapshotBeforeUpdate))),void(null!==(t=r.updateQueue)&&da(r,t,e));case 3:if(null!==(t=r.updateQueue)){if(e=null,null!==r.child)switch(r.child.tag){case 5:e=r.child.stateNode;break;case 1:e=r.child.stateNode}da(r,t,e)}return;case 5:return e=r.stateNode,void(null===t&&4&r.flags&&Un(r.type,r.memoizedProps)&&e.focus());case 6:case 4:case 12:return;case 13:return void(null===r.memoizedState&&(r=r.alternate,null!==r&&(r=r.memoizedState,null!==r&&(r=r.dehydrated,null!==r&&Et(r)))));case 19:case 17:case 20:case 21:case 23:case 24:return}throw Error(i(163))}function gl(e,t){for(var r=e;;){if(5===r.tag){var n=r.stateNode;if(t)"function"===typeof(n=n.style).setProperty?n.setProperty("display","none","important"):n.display="none";else{n=r.stateNode;var o=r.memoizedProps.style;o=void 0!==o&&null!==o&&o.hasOwnProperty("display")?o.display:null,n.style.display=ke("display",o)}}else if(6===r.tag)r.stateNode.nodeValue=t?"":r.memoizedProps;else if((23!==r.tag&&24!==r.tag||null===r.memoizedState||r===e)&&null!==r.child){r.child.return=r,r=r.child;continue}if(r===e)break;for(;null===r.sibling;){if(null===r.return||r.return===e)return;r=r.return}r.sibling.return=r.return,r=r.sibling}}function vl(e,t){if(Eo&&"function"===typeof Eo.onCommitFiberUnmount)try{Eo.onCommitFiberUnmount(ko,t)}catch(e){}switch(t.tag){case 0:case 11:case 14:case 15:case 22:if(null!==(e=t.updateQueue)&&null!==(e=e.lastEffect)){var r=e=e.next;do{var n=r,o=n.destroy;if(n=n.tag,void 0!==o)if(0!==(4&n))Iu(t,r);else{n=t;try{o()}catch(e){Du(n,e)}}r=r.next}while(r!==e)}break;case 1:if(dl(t),"function"===typeof(e=t.stateNode).componentWillUnmount)try{e.props=t.memoizedProps,e.state=t.memoizedState,e.componentWillUnmount()}catch(e){Du(t,e)}break;case 5:dl(t);break;case 4:El(e,t)}}function ml(e){e.alternate=null,e.child=null,e.dependencies=null,e.firstEffect=null,e.lastEffect=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.return=null,e.updateQueue=null}function yl(e){return 5===e.tag||3===e.tag||4===e.tag}function bl(e){e:{for(var t=e.return;null!==t;){if(yl(t))break e;t=t.return}throw Error(i(160))}var r=t;switch(t=r.stateNode,r.tag){case 5:var n=!1;break;case 3:case 4:t=t.containerInfo,n=!0;break;default:throw Error(i(161))}16&r.flags&&(ye(t,""),r.flags&=-17);e:t:for(r=e;;){for(;null===r.sibling;){if(null===r.return||yl(r.return)){r=null;break e}r=r.return}for(r.sibling.return=r.return,r=r.sibling;5!==r.tag&&6!==r.tag&&18!==r.tag;){if(2&r.flags)continue t;if(null===r.child||4===r.tag)continue t;r.child.return=r,r=r.child}if(!(2&r.flags)){r=r.stateNode;break e}}n?wl(e,r,t):kl(e,r,t)}function wl(e,t,r){var n=e.tag,o=5===n||6===n;if(o)e=o?e.stateNode:e.stateNode.instance,t?8===r.nodeType?r.parentNode.insertBefore(e,t):r.insertBefore(e,t):(8===r.nodeType?(t=r.parentNode).insertBefore(e,r):(t=r).appendChild(e),null!==(r=r._reactRootContainer)&&void 0!==r||null!==t.onclick||(t.onclick=Dn));else if(4!==n&&null!==(e=e.child))for(wl(e,t,r),e=e.sibling;null!==e;)wl(e,t,r),e=e.sibling}function kl(e,t,r){var n=e.tag,o=5===n||6===n;if(o)e=o?e.stateNode:e.stateNode.instance,t?r.insertBefore(e,t):r.appendChild(e);else if(4!==n&&null!==(e=e.child))for(kl(e,t,r),e=e.sibling;null!==e;)kl(e,t,r),e=e.sibling}function El(e,t){for(var r,n,o=t,a=!1;;){if(!a){a=o.return;e:for(;;){if(null===a)throw Error(i(160));switch(r=a.stateNode,a.tag){case 5:n=!1;break e;case 3:case 4:r=r.containerInfo,n=!0;break e}a=a.return}a=!0}if(5===o.tag||6===o.tag){e:for(var l=e,u=o,c=u;;)if(vl(l,c),null!==c.child&&4!==c.tag)c.child.return=c,c=c.child;else{if(c===u)break e;for(;null===c.sibling;){if(null===c.return||c.return===u)break e;c=c.return}c.sibling.return=c.return,c=c.sibling}n?(l=r,u=o.stateNode,8===l.nodeType?l.parentNode.removeChild(u):l.removeChild(u)):r.removeChild(o.stateNode)}else if(4===o.tag){if(null!==o.child){r=o.stateNode.containerInfo,n=!0,o.child.return=o,o=o.child;continue}}else if(vl(e,o),null!==o.child){o.child.return=o,o=o.child;continue}if(o===t)break;for(;null===o.sibling;){if(null===o.return||o.return===t)return;4===(o=o.return).tag&&(a=!1)}o.sibling.return=o.return,o=o.sibling}}function xl(e,t){switch(t.tag){case 0:case 11:case 14:case 15:case 22:var r=t.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var n=r=r.next;do{3===(3&n.tag)&&(e=n.destroy,n.destroy=void 0,void 0!==e&&e()),n=n.next}while(n!==r)}return;case 1:return;case 5:if(null!=(r=t.stateNode)){n=t.memoizedProps;var o=null!==e?e.memoizedProps:n;e=t.type;var a=t.updateQueue;if(t.updateQueue=null,null!==a){for(r[Kn]=n,"input"===e&&"radio"===n.type&&null!=n.name&&te(r,n),_e(e,o),t=_e(e,n),o=0;o<a.length;o+=2){var l=a[o],u=a[o+1];"style"===l?Ee(r,u):"dangerouslySetInnerHTML"===l?me(r,u):"children"===l?ye(r,u):w(r,l,u,t)}switch(e){case"input":re(r,n);break;case"textarea":ce(r,n);break;case"select":e=r._wrapperState.wasMultiple,r._wrapperState.wasMultiple=!!n.multiple,null!=(a=n.value)?ie(r,!!n.multiple,a,!1):e!==!!n.multiple&&(null!=n.defaultValue?ie(r,!!n.multiple,n.defaultValue,!0):ie(r,!!n.multiple,n.multiple?[]:"",!1))}}}return;case 6:if(null===t.stateNode)throw Error(i(162));return void(t.stateNode.nodeValue=t.memoizedProps);case 3:return void((r=t.stateNode).hydrate&&(r.hydrate=!1,Et(r.containerInfo)));case 12:return;case 13:return null!==t.memoizedState&&(Bl=Fo(),gl(t.child,!0)),void Sl(t);case 19:return void Sl(t);case 17:return;case 23:case 24:return void gl(t,null!==t.memoizedState)}throw Error(i(163))}function Sl(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var r=e.stateNode;null===r&&(r=e.stateNode=new fl),t.forEach((function(t){var n=zu.bind(null,e,t);r.has(t)||(r.add(t),t.then(n,n))}))}}function _l(e,t){return null!==e&&(null===(e=e.memoizedState)||null!==e.dehydrated)&&(null!==(t=t.memoizedState)&&null===t.dehydrated)}var Tl=Math.ceil,Cl=k.ReactCurrentDispatcher,Ol=k.ReactCurrentOwner,Pl=0,Rl=null,Nl=null,Ll=0,Al=0,Il=io(0),jl=0,Ml=null,Dl=0,ql=0,zl=0,Ul=0,Fl=null,Bl=0,Vl=1/0;function Hl(){Vl=Fo()+500}var Wl,$l=null,Gl=!1,Ql=null,Yl=null,Kl=!1,Xl=null,Jl=90,Zl=[],eu=[],tu=null,ru=0,nu=null,ou=-1,au=0,iu=0,lu=null,uu=!1;function cu(){return 0!==(48&Pl)?Fo():-1!==ou?ou:ou=Fo()}function su(e){if(0===(2&(e=e.mode)))return 1;if(0===(4&e))return 99===Bo()?1:2;if(0===au&&(au=Dl),0!==Qo.transition){0!==iu&&(iu=null!==Fl?Fl.pendingLanes:0),e=au;var t=4186112&~iu;return 0===(t&=-t)&&(0===(t=(e=4186112&~e)&-e)&&(t=8192)),t}return e=Bo(),0!==(4&Pl)&&98===e?e=Ut(12,au):e=Ut(e=function(e){switch(e){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}(e),au),e}function fu(e,t,r){if(50<ru)throw ru=0,nu=null,Error(i(185));if(null===(e=du(e,t)))return null;Vt(e,t,r),e===Rl&&(zl|=t,4===jl&&gu(e,Ll));var n=Bo();1===t?0!==(8&Pl)&&0===(48&Pl)?vu(e):(pu(e,r),0===Pl&&(Hl(),$o())):(0===(4&Pl)||98!==n&&99!==n||(null===tu?tu=new Set([e]):tu.add(e)),pu(e,r)),Fl=e}function du(e,t){e.lanes|=t;var r=e.alternate;for(null!==r&&(r.lanes|=t),r=e,e=e.return;null!==e;)e.childLanes|=t,null!==(r=e.alternate)&&(r.childLanes|=t),r=e,e=e.return;return 3===r.tag?r.stateNode:null}function pu(e,t){for(var r=e.callbackNode,n=e.suspendedLanes,o=e.pingedLanes,a=e.expirationTimes,l=e.pendingLanes;0<l;){var u=31-Ht(l),c=1<<u,s=a[u];if(-1===s){if(0===(c&n)||0!==(c&o)){s=t,Dt(c);var f=Mt;a[u]=10<=f?s+250:6<=f?s+5e3:-1}}else s<=t&&(e.expiredLanes|=c);l&=~c}if(n=qt(e,e===Rl?Ll:0),t=Mt,0===n)null!==r&&(r!==jo&&_o(r),e.callbackNode=null,e.callbackPriority=0);else{if(null!==r){if(e.callbackPriority===t)return;r!==jo&&_o(r)}15===t?(r=vu.bind(null,e),null===Do?(Do=[r],qo=So(Ro,Go)):Do.push(r),r=jo):14===t?r=Wo(99,vu.bind(null,e)):r=Wo(r=function(e){switch(e){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(i(358,e))}}(t),hu.bind(null,e)),e.callbackPriority=t,e.callbackNode=r}}function hu(e){if(ou=-1,iu=au=0,0!==(48&Pl))throw Error(i(327));var t=e.callbackNode;if(Lu()&&e.callbackNode!==t)return null;var r=qt(e,e===Rl?Ll:0);if(0===r)return null;var n=r,o=Pl;Pl|=16;var a=xu();for(Rl===e&&Ll===n||(Hl(),ku(e,n));;)try{Tu();break}catch(t){Eu(e,t)}if(ea(),Cl.current=a,Pl=o,null!==Nl?n=0:(Rl=null,Ll=0,n=jl),0!==(Dl&zl))ku(e,0);else if(0!==n){if(2===n&&(Pl|=64,e.hydrate&&(e.hydrate=!1,Hn(e.containerInfo)),0!==(r=zt(e))&&(n=Su(e,r))),1===n)throw t=Ml,ku(e,0),gu(e,r),pu(e,Fo()),t;switch(e.finishedWork=e.current.alternate,e.finishedLanes=r,n){case 0:case 1:throw Error(i(345));case 2:Pu(e);break;case 3:if(gu(e,r),(62914560&r)===r&&10<(n=Bl+500-Fo())){if(0!==qt(e,0))break;if(((o=e.suspendedLanes)&r)!==r){cu(),e.pingedLanes|=e.suspendedLanes&o;break}e.timeoutHandle=Bn(Pu.bind(null,e),n);break}Pu(e);break;case 4:if(gu(e,r),(4186112&r)===r)break;for(n=e.eventTimes,o=-1;0<r;){var l=31-Ht(r);a=1<<l,(l=n[l])>o&&(o=l),r&=~a}if(r=o,10<(r=(120>(r=Fo()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Tl(r/1960))-r)){e.timeoutHandle=Bn(Pu.bind(null,e),r);break}Pu(e);break;case 5:Pu(e);break;default:throw Error(i(329))}}return pu(e,Fo()),e.callbackNode===t?hu.bind(null,e):null}function gu(e,t){for(t&=~Ul,t&=~zl,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var r=31-Ht(t),n=1<<r;e[r]=-1,t&=~n}}function vu(e){if(0!==(48&Pl))throw Error(i(327));if(Lu(),e===Rl&&0!==(e.expiredLanes&Ll)){var t=Ll,r=Su(e,t);0!==(Dl&zl)&&(r=Su(e,t=qt(e,t)))}else r=Su(e,t=qt(e,0));if(0!==e.tag&&2===r&&(Pl|=64,e.hydrate&&(e.hydrate=!1,Hn(e.containerInfo)),0!==(t=zt(e))&&(r=Su(e,t))),1===r)throw r=Ml,ku(e,0),gu(e,t),pu(e,Fo()),r;return e.finishedWork=e.current.alternate,e.finishedLanes=t,Pu(e),pu(e,Fo()),null}function mu(e,t){var r=Pl;Pl|=1;try{return e(t)}finally{0===(Pl=r)&&(Hl(),$o())}}function yu(e,t){var r=Pl;Pl&=-2,Pl|=8;try{return e(t)}finally{0===(Pl=r)&&(Hl(),$o())}}function bu(e,t){uo(Il,Al),Al|=t,Dl|=t}function wu(){Al=Il.current,lo(Il)}function ku(e,t){e.finishedWork=null,e.finishedLanes=0;var r=e.timeoutHandle;if(-1!==r&&(e.timeoutHandle=-1,Vn(r)),null!==Nl)for(r=Nl.return;null!==r;){var n=r;switch(n.tag){case 1:null!==(n=n.type.childContextTypes)&&void 0!==n&&vo();break;case 3:La(),lo(fo),lo(so),Ga();break;case 5:Ia(n);break;case 4:La();break;case 13:case 19:lo(ja);break;case 10:ta(n);break;case 23:case 24:wu()}r=r.return}Rl=e,Nl=Vu(e.current,null),Ll=Al=Dl=t,jl=0,Ml=null,Ul=zl=ql=0}function Eu(e,t){for(;;){var r=Nl;try{if(ea(),Qa.current=Pi,ei){for(var n=Xa.memoizedState;null!==n;){var o=n.queue;null!==o&&(o.pending=null),n=n.next}ei=!1}if(Ka=0,Za=Ja=Xa=null,ti=!1,Ol.current=null,null===r||null===r.return){jl=1,Ml=t,Nl=null;break}e:{var a=e,i=r.return,l=r,u=t;if(t=Ll,l.flags|=2048,l.firstEffect=l.lastEffect=null,null!==u&&"object"===typeof u&&"function"===typeof u.then){var c=u;if(0===(2&l.mode)){var s=l.alternate;s?(l.updateQueue=s.updateQueue,l.memoizedState=s.memoizedState,l.lanes=s.lanes):(l.updateQueue=null,l.memoizedState=null)}var f=0!==(1&ja.current),d=i;do{var p;if(p=13===d.tag){var h=d.memoizedState;if(null!==h)p=null!==h.dehydrated;else{var g=d.memoizedProps;p=void 0!==g.fallback&&(!0!==g.unstable_avoidThisFallback||!f)}}if(p){var v=d.updateQueue;if(null===v){var m=new Set;m.add(c),d.updateQueue=m}else v.add(c);if(0===(2&d.mode)){if(d.flags|=64,l.flags|=16384,l.flags&=-2981,1===l.tag)if(null===l.alternate)l.tag=17;else{var y=ua(-1,1);y.tag=2,ca(l,y)}l.lanes|=1;break e}u=void 0,l=t;var b=a.pingCache;if(null===b?(b=a.pingCache=new ul,u=new Set,b.set(c,u)):void 0===(u=b.get(c))&&(u=new Set,b.set(c,u)),!u.has(l)){u.add(l);var w=qu.bind(null,a,c,l);c.then(w,w)}d.flags|=4096,d.lanes=t;break e}d=d.return}while(null!==d);u=Error((G(l.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\\n\\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")}5!==jl&&(jl=2),u=il(u,l),d=i;do{switch(d.tag){case 3:a=u,d.flags|=4096,t&=-t,d.lanes|=t,sa(d,cl(0,a,t));break e;case 1:a=u;var k=d.type,E=d.stateNode;if(0===(64&d.flags)&&("function"===typeof k.getDerivedStateFromError||null!==E&&"function"===typeof E.componentDidCatch&&(null===Yl||!Yl.has(E)))){d.flags|=4096,t&=-t,d.lanes|=t,sa(d,sl(d,a,t));break e}}d=d.return}while(null!==d)}Ou(r)}catch(e){t=e,Nl===r&&null!==r&&(Nl=r=r.return);continue}break}}function xu(){var e=Cl.current;return Cl.current=Pi,null===e?Pi:e}function Su(e,t){var r=Pl;Pl|=16;var n=xu();for(Rl===e&&Ll===t||ku(e,t);;)try{_u();break}catch(t){Eu(e,t)}if(ea(),Pl=r,Cl.current=n,null!==Nl)throw Error(i(261));return Rl=null,Ll=0,jl}function _u(){for(;null!==Nl;)Cu(Nl)}function Tu(){for(;null!==Nl&&!To();)Cu(Nl)}function Cu(e){var t=Wl(e.alternate,e,Al);e.memoizedProps=e.pendingProps,null===t?Ou(e):Nl=t,Ol.current=null}function Ou(e){var t=e;do{var r=t.alternate;if(e=t.return,0===(2048&t.flags)){if(null!==(r=ol(r,t,Al)))return void(Nl=r);if(24!==(r=t).tag&&23!==r.tag||null===r.memoizedState||0!==(1073741824&Al)||0===(4&r.mode)){for(var n=0,o=r.child;null!==o;)n|=o.lanes|o.childLanes,o=o.sibling;r.childLanes=n}null!==e&&0===(2048&e.flags)&&(null===e.firstEffect&&(e.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==e.lastEffect&&(e.lastEffect.nextEffect=t.firstEffect),e.lastEffect=t.lastEffect),1<t.flags&&(null!==e.lastEffect?e.lastEffect.nextEffect=t:e.firstEffect=t,e.lastEffect=t))}else{if(null!==(r=al(t)))return r.flags&=2047,void(Nl=r);null!==e&&(e.firstEffect=e.lastEffect=null,e.flags|=2048)}if(null!==(t=t.sibling))return void(Nl=t);Nl=t=e}while(null!==t);0===jl&&(jl=5)}function Pu(e){var t=Bo();return Ho(99,Ru.bind(null,e,t)),null}function Ru(e,t){do{Lu()}while(null!==Xl);if(0!==(48&Pl))throw Error(i(327));var r=e.finishedWork;if(null===r)return null;if(e.finishedWork=null,e.finishedLanes=0,r===e.current)throw Error(i(177));e.callbackNode=null;var n=r.lanes|r.childLanes,o=n,a=e.pendingLanes&~o;e.pendingLanes=o,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=o,e.mutableReadLanes&=o,e.entangledLanes&=o,o=e.entanglements;for(var l=e.eventTimes,u=e.expirationTimes;0<a;){var c=31-Ht(a),s=1<<c;o[c]=0,l[c]=-1,u[c]=-1,a&=~s}if(null!==tu&&0===(24&n)&&tu.has(e)&&tu.delete(e),e===Rl&&(Nl=Rl=null,Ll=0),1<r.flags?null!==r.lastEffect?(r.lastEffect.nextEffect=r,n=r.firstEffect):n=r:n=r.firstEffect,null!==n){if(o=Pl,Pl|=32,Ol.current=null,qn=Yt,hn(l=pn())){if("selectionStart"in l)u={start:l.selectionStart,end:l.selectionEnd};else e:if(u=(u=l.ownerDocument)&&u.defaultView||window,(s=u.getSelection&&u.getSelection())&&0!==s.rangeCount){u=s.anchorNode,a=s.anchorOffset,c=s.focusNode,s=s.focusOffset;try{u.nodeType,c.nodeType}catch(e){u=null;break e}var f=0,d=-1,p=-1,h=0,g=0,v=l,m=null;t:for(;;){for(var y;v!==u||0!==a&&3!==v.nodeType||(d=f+a),v!==c||0!==s&&3!==v.nodeType||(p=f+s),3===v.nodeType&&(f+=v.nodeValue.length),null!==(y=v.firstChild);)m=v,v=y;for(;;){if(v===l)break t;if(m===u&&++h===a&&(d=f),m===c&&++g===s&&(p=f),null!==(y=v.nextSibling))break;m=(v=m).parentNode}v=y}u=-1===d||-1===p?null:{start:d,end:p}}else u=null;u=u||{start:0,end:0}}else u=null;zn={focusedElem:l,selectionRange:u},Yt=!1,lu=null,uu=!1,$l=n;do{try{Nu()}catch(e){if(null===$l)throw Error(i(330));Du($l,e),$l=$l.nextEffect}}while(null!==$l);lu=null,$l=n;do{try{for(l=e;null!==$l;){var b=$l.flags;if(16&b&&ye($l.stateNode,""),128&b){var w=$l.alternate;if(null!==w){var k=w.ref;null!==k&&("function"===typeof k?k(null):k.current=null)}}switch(1038&b){case 2:bl($l),$l.flags&=-3;break;case 6:bl($l),$l.flags&=-3,xl($l.alternate,$l);break;case 1024:$l.flags&=-1025;break;case 1028:$l.flags&=-1025,xl($l.alternate,$l);break;case 4:xl($l.alternate,$l);break;case 8:El(l,u=$l);var E=u.alternate;ml(u),null!==E&&ml(E)}$l=$l.nextEffect}}catch(e){if(null===$l)throw Error(i(330));Du($l,e),$l=$l.nextEffect}}while(null!==$l);if(k=zn,w=pn(),b=k.focusedElem,l=k.selectionRange,w!==b&&b&&b.ownerDocument&&dn(b.ownerDocument.documentElement,b)){null!==l&&hn(b)&&(w=l.start,void 0===(k=l.end)&&(k=w),"selectionStart"in b?(b.selectionStart=w,b.selectionEnd=Math.min(k,b.value.length)):(k=(w=b.ownerDocument||document)&&w.defaultView||window).getSelection&&(k=k.getSelection(),u=b.textContent.length,E=Math.min(l.start,u),l=void 0===l.end?E:Math.min(l.end,u),!k.extend&&E>l&&(u=l,l=E,E=u),u=fn(b,E),a=fn(b,l),u&&a&&(1!==k.rangeCount||k.anchorNode!==u.node||k.anchorOffset!==u.offset||k.focusNode!==a.node||k.focusOffset!==a.offset)&&((w=w.createRange()).setStart(u.node,u.offset),k.removeAllRanges(),E>l?(k.addRange(w),k.extend(a.node,a.offset)):(w.setEnd(a.node,a.offset),k.addRange(w))))),w=[];for(k=b;k=k.parentNode;)1===k.nodeType&&w.push({element:k,left:k.scrollLeft,top:k.scrollTop});for("function"===typeof b.focus&&b.focus(),b=0;b<w.length;b++)(k=w[b]).element.scrollLeft=k.left,k.element.scrollTop=k.top}Yt=!!qn,zn=qn=null,e.current=r,$l=n;do{try{for(b=e;null!==$l;){var x=$l.flags;if(36&x&&hl(b,$l.alternate,$l),128&x){w=void 0;var S=$l.ref;if(null!==S){var _=$l.stateNode;switch($l.tag){case 5:w=_;break;default:w=_}"function"===typeof S?S(w):S.current=w}}$l=$l.nextEffect}}catch(e){if(null===$l)throw Error(i(330));Du($l,e),$l=$l.nextEffect}}while(null!==$l);$l=null,Mo(),Pl=o}else e.current=r;if(Kl)Kl=!1,Xl=e,Jl=t;else for($l=n;null!==$l;)t=$l.nextEffect,$l.nextEffect=null,8&$l.flags&&((x=$l).sibling=null,x.stateNode=null),$l=t;if(0===(n=e.pendingLanes)&&(Yl=null),1===n?e===nu?ru++:(ru=0,nu=e):ru=0,r=r.stateNode,Eo&&"function"===typeof Eo.onCommitFiberRoot)try{Eo.onCommitFiberRoot(ko,r,void 0,64===(64&r.current.flags))}catch(e){}if(pu(e,Fo()),Gl)throw Gl=!1,e=Ql,Ql=null,e;return 0!==(8&Pl)||$o(),null}function Nu(){for(;null!==$l;){var e=$l.alternate;uu||null===lu||(0!==(8&$l.flags)?et($l,lu)&&(uu=!0):13===$l.tag&&_l(e,$l)&&et($l,lu)&&(uu=!0));var t=$l.flags;0!==(256&t)&&pl(e,$l),0===(512&t)||Kl||(Kl=!0,Wo(97,(function(){return Lu(),null}))),$l=$l.nextEffect}}function Lu(){if(90!==Jl){var e=97<Jl?97:Jl;return Jl=90,Ho(e,ju)}return!1}function Au(e,t){Zl.push(t,e),Kl||(Kl=!0,Wo(97,(function(){return Lu(),null})))}function Iu(e,t){eu.push(t,e),Kl||(Kl=!0,Wo(97,(function(){return Lu(),null})))}function ju(){if(null===Xl)return!1;var e=Xl;if(Xl=null,0!==(48&Pl))throw Error(i(331));var t=Pl;Pl|=32;var r=eu;eu=[];for(var n=0;n<r.length;n+=2){var o=r[n],a=r[n+1],l=o.destroy;if(o.destroy=void 0,"function"===typeof l)try{l()}catch(e){if(null===a)throw Error(i(330));Du(a,e)}}for(r=Zl,Zl=[],n=0;n<r.length;n+=2){o=r[n],a=r[n+1];try{var u=o.create;o.destroy=u()}catch(e){if(null===a)throw Error(i(330));Du(a,e)}}for(u=e.current.firstEffect;null!==u;)e=u.nextEffect,u.nextEffect=null,8&u.flags&&(u.sibling=null,u.stateNode=null),u=e;return Pl=t,$o(),!0}function Mu(e,t,r){ca(e,t=cl(0,t=il(r,t),1)),t=cu(),null!==(e=du(e,1))&&(Vt(e,1,t),pu(e,t))}function Du(e,t){if(3===e.tag)Mu(e,e,t);else for(var r=e.return;null!==r;){if(3===r.tag){Mu(r,e,t);break}if(1===r.tag){var n=r.stateNode;if("function"===typeof r.type.getDerivedStateFromError||"function"===typeof n.componentDidCatch&&(null===Yl||!Yl.has(n))){var o=sl(r,e=il(t,e),1);if(ca(r,o),o=cu(),null!==(r=du(r,1)))Vt(r,1,o),pu(r,o);else if("function"===typeof n.componentDidCatch&&(null===Yl||!Yl.has(n)))try{n.componentDidCatch(t,e)}catch(e){}break}}r=r.return}}function qu(e,t,r){var n=e.pingCache;null!==n&&n.delete(t),t=cu(),e.pingedLanes|=e.suspendedLanes&r,Rl===e&&(Ll&r)===r&&(4===jl||3===jl&&(62914560&Ll)===Ll&&500>Fo()-Bl?ku(e,0):Ul|=r),pu(e,t)}function zu(e,t){var r=e.stateNode;null!==r&&r.delete(t),0===(t=0)&&(0===(2&(t=e.mode))?t=1:0===(4&t)?t=99===Bo()?1:2:(0===au&&(au=Dl),0===(t=Ft(62914560&~au))&&(t=4194304))),r=cu(),null!==(e=du(e,t))&&(Vt(e,t,r),pu(e,r))}function Uu(e,t,r,n){this.tag=e,this.key=r,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=n,this.flags=0,this.lastEffect=this.firstEffect=this.nextEffect=null,this.childLanes=this.lanes=0,this.alternate=null}function Fu(e,t,r,n){return new Uu(e,t,r,n)}function Bu(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Vu(e,t){var r=e.alternate;return null===r?((r=Fu(e.tag,t,e.key,e.mode)).elementType=e.elementType,r.type=e.type,r.stateNode=e.stateNode,r.alternate=e,e.alternate=r):(r.pendingProps=t,r.type=e.type,r.flags=0,r.nextEffect=null,r.firstEffect=null,r.lastEffect=null),r.childLanes=e.childLanes,r.lanes=e.lanes,r.child=e.child,r.memoizedProps=e.memoizedProps,r.memoizedState=e.memoizedState,r.updateQueue=e.updateQueue,t=e.dependencies,r.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},r.sibling=e.sibling,r.index=e.index,r.ref=e.ref,r}function Hu(e,t,r,n,o,a){var l=2;if(n=e,"function"===typeof e)Bu(e)&&(l=1);else if("string"===typeof e)l=5;else e:switch(e){case S:return Wu(r.children,o,a,t);case M:l=8,o|=16;break;case _:l=8,o|=1;break;case T:return(e=Fu(12,r,t,8|o)).elementType=T,e.type=T,e.lanes=a,e;case R:return(e=Fu(13,r,t,o)).type=R,e.elementType=R,e.lanes=a,e;case N:return(e=Fu(19,r,t,o)).elementType=N,e.lanes=a,e;case D:return $u(r,o,a,t);case q:return(e=Fu(24,r,t,o)).elementType=q,e.lanes=a,e;default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case C:l=10;break e;case O:l=9;break e;case P:l=11;break e;case L:l=14;break e;case A:l=16,n=null;break e;case I:l=22;break e}throw Error(i(130,null==e?e:typeof e,""))}return(t=Fu(l,r,t,o)).elementType=e,t.type=n,t.lanes=a,t}function Wu(e,t,r,n){return(e=Fu(7,e,n,t)).lanes=r,e}function $u(e,t,r,n){return(e=Fu(23,e,n,t)).elementType=D,e.lanes=r,e}function Gu(e,t,r){return(e=Fu(6,e,null,t)).lanes=r,e}function Qu(e,t,r){return(t=Fu(4,null!==e.children?e.children:[],e.key,t)).lanes=r,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Yu(e,t,r){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.pendingContext=this.context=null,this.hydrate=r,this.callbackNode=null,this.callbackPriority=0,this.eventTimes=Bt(0),this.expirationTimes=Bt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Bt(0),this.mutableSourceEagerHydrationData=null}function Ku(e,t,r){var n=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:x,key:null==n?null:""+n,children:e,containerInfo:t,implementation:r}}function Xu(e,t,r,n){var o=t.current,a=cu(),l=su(o);e:if(r){t:{if(Ke(r=r._reactInternals)!==r||1!==r.tag)throw Error(i(170));var u=r;do{switch(u.tag){case 3:u=u.stateNode.context;break t;case 1:if(go(u.type)){u=u.stateNode.__reactInternalMemoizedMergedChildContext;break t}}u=u.return}while(null!==u);throw Error(i(171))}if(1===r.tag){var c=r.type;if(go(c)){r=yo(r,c,u);break e}}r=u}else r=co;return null===t.context?t.context=r:t.pendingContext=r,(t=ua(a,l)).payload={element:e},null!==(n=void 0===n?null:n)&&(t.callback=n),ca(o,t),fu(o,l,a),l}function Ju(e){if(!(e=e.current).child)return null;switch(e.child.tag){case 5:default:return e.child.stateNode}}function Zu(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var r=e.retryLane;e.retryLane=0!==r&&r<t?r:t}}function ec(e,t){Zu(e,t),(e=e.alternate)&&Zu(e,t)}function tc(e,t,r){var n=null!=r&&null!=r.hydrationOptions&&r.hydrationOptions.mutableSources||null;if(r=new Yu(e,t,null!=r&&!0===r.hydrate),t=Fu(3,null,null,2===t?7:1===t?3:0),r.current=t,t.stateNode=r,ia(t),e[Xn]=r.current,Pn(8===e.nodeType?e.parentNode:e),n)for(e=0;e<n.length;e++){var o=(t=n[e])._getVersion;o=o(t._source),null==r.mutableSourceEagerHydrationData?r.mutableSourceEagerHydrationData=[t,o]:r.mutableSourceEagerHydrationData.push(t,o)}this._internalRoot=r}function rc(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function nc(e,t,r,n,o){var a=r._reactRootContainer;if(a){var i=a._internalRoot;if("function"===typeof o){var l=o;o=function(){var e=Ju(i);l.call(e)}}Xu(t,i,e,o)}else{if(a=r._reactRootContainer=function(e,t){if(t||(t=!(!(t=e?9===e.nodeType?e.documentElement:e.firstChild:null)||1!==t.nodeType||!t.hasAttribute("data-reactroot"))),!t)for(var r;r=e.lastChild;)e.removeChild(r);return new tc(e,0,t?{hydrate:!0}:void 0)}(r,n),i=a._internalRoot,"function"===typeof o){var u=o;o=function(){var e=Ju(i);u.call(e)}}yu((function(){Xu(t,i,e,o)}))}return Ju(i)}function oc(e,t){var r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!rc(t))throw Error(i(200));return Ku(e,t,null,r)}Wl=function(e,t,r){var n=t.lanes;if(null!==e)if(e.memoizedProps!==t.pendingProps||fo.current)Ii=!0;else{if(0===(r&n)){switch(Ii=!1,t.tag){case 3:Hi(t),Wa();break;case 5:Aa(t);break;case 1:go(t.type)&&bo(t);break;case 4:Na(t,t.stateNode.containerInfo);break;case 10:n=t.memoizedProps.value;var o=t.type._context;uo(Ko,o._currentValue),o._currentValue=n;break;case 13:if(null!==t.memoizedState)return 0!==(r&t.child.childLanes)?Yi(e,t,r):(uo(ja,1&ja.current),null!==(t=rl(e,t,r))?t.sibling:null);uo(ja,1&ja.current);break;case 19:if(n=0!==(r&t.childLanes),0!==(64&e.flags)){if(n)return tl(e,t,r);t.flags|=64}if(null!==(o=t.memoizedState)&&(o.rendering=null,o.tail=null,o.lastEffect=null),uo(ja,ja.current),n)break;return null;case 23:case 24:return t.lanes=0,zi(e,t,r)}return rl(e,t,r)}Ii=0!==(16384&e.flags)}else Ii=!1;switch(t.lanes=0,t.tag){case 2:if(n=t.type,null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),e=t.pendingProps,o=ho(t,so.current),na(t,r),o=oi(null,t,n,e,o,r),t.flags|=1,"object"===typeof o&&null!==o&&"function"===typeof o.render&&void 0===o.$$typeof){if(t.tag=1,t.memoizedState=null,t.updateQueue=null,go(n)){var a=!0;bo(t)}else a=!1;t.memoizedState=null!==o.state&&void 0!==o.state?o.state:null,ia(t);var l=n.getDerivedStateFromProps;"function"===typeof l&&ha(t,n,l,e),o.updater=ga,t.stateNode=o,o._reactInternals=t,ba(t,n,e,r),t=Vi(null,t,n,!0,a,r)}else t.tag=0,ji(null,t,o,r),t=t.child;return t;case 16:o=t.elementType;e:{switch(null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),e=t.pendingProps,o=(a=o._init)(o._payload),t.type=o,a=t.tag=function(e){if("function"===typeof e)return Bu(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===P)return 11;if(e===L)return 14}return 2}(o),e=Yo(o,e),a){case 0:t=Fi(null,t,o,e,r);break e;case 1:t=Bi(null,t,o,e,r);break e;case 11:t=Mi(null,t,o,e,r);break e;case 14:t=Di(null,t,o,Yo(o.type,e),n,r);break e}throw Error(i(306,o,""))}return t;case 0:return n=t.type,o=t.pendingProps,Fi(e,t,n,o=t.elementType===n?o:Yo(n,o),r);case 1:return n=t.type,o=t.pendingProps,Bi(e,t,n,o=t.elementType===n?o:Yo(n,o),r);case 3:if(Hi(t),n=t.updateQueue,null===e||null===n)throw Error(i(282));if(n=t.pendingProps,o=null!==(o=t.memoizedState)?o.element:null,la(e,t),fa(t,n,null,r),(n=t.memoizedState.element)===o)Wa(),t=rl(e,t,r);else{if((a=(o=t.stateNode).hydrate)&&(qa=Wn(t.stateNode.containerInfo.firstChild),Da=t,a=za=!0),a){if(null!=(e=o.mutableSourceEagerHydrationData))for(o=0;o<e.length;o+=2)(a=e[o])._workInProgressVersionPrimary=e[o+1],$a.push(a);for(r=_a(t,null,n,r),t.child=r;r;)r.flags=-3&r.flags|1024,r=r.sibling}else ji(e,t,n,r),Wa();t=t.child}return t;case 5:return Aa(t),null===e&&Ba(t),n=t.type,o=t.pendingProps,a=null!==e?e.memoizedProps:null,l=o.children,Fn(n,o)?l=null:null!==a&&Fn(n,a)&&(t.flags|=16),Ui(e,t),ji(e,t,l,r),t.child;case 6:return null===e&&Ba(t),null;case 13:return Yi(e,t,r);case 4:return Na(t,t.stateNode.containerInfo),n=t.pendingProps,null===e?t.child=Sa(t,null,n,r):ji(e,t,n,r),t.child;case 11:return n=t.type,o=t.pendingProps,Mi(e,t,n,o=t.elementType===n?o:Yo(n,o),r);case 7:return ji(e,t,t.pendingProps,r),t.child;case 8:case 12:return ji(e,t,t.pendingProps.children,r),t.child;case 10:e:{n=t.type._context,o=t.pendingProps,l=t.memoizedProps,a=o.value;var u=t.type._context;if(uo(Ko,u._currentValue),u._currentValue=a,null!==l)if(u=l.value,0===(a=ln(u,a)?0:0|("function"===typeof n._calculateChangedBits?n._calculateChangedBits(u,a):1073741823))){if(l.children===o.children&&!fo.current){t=rl(e,t,r);break e}}else for(null!==(u=t.child)&&(u.return=t);null!==u;){var c=u.dependencies;if(null!==c){l=u.child;for(var s=c.firstContext;null!==s;){if(s.context===n&&0!==(s.observedBits&a)){1===u.tag&&((s=ua(-1,r&-r)).tag=2,ca(u,s)),u.lanes|=r,null!==(s=u.alternate)&&(s.lanes|=r),ra(u.return,r),c.lanes|=r;break}s=s.next}}else l=10===u.tag&&u.type===t.type?null:u.child;if(null!==l)l.return=u;else for(l=u;null!==l;){if(l===t){l=null;break}if(null!==(u=l.sibling)){u.return=l.return,l=u;break}l=l.return}u=l}ji(e,t,o.children,r),t=t.child}return t;case 9:return o=t.type,n=(a=t.pendingProps).children,na(t,r),n=n(o=oa(o,a.unstable_observedBits)),t.flags|=1,ji(e,t,n,r),t.child;case 14:return a=Yo(o=t.type,t.pendingProps),Di(e,t,o,a=Yo(o.type,a),n,r);case 15:return qi(e,t,t.type,t.pendingProps,n,r);case 17:return n=t.type,o=t.pendingProps,o=t.elementType===n?o:Yo(n,o),null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),t.tag=1,go(n)?(e=!0,bo(t)):e=!1,na(t,r),ma(t,n,o),ba(t,n,o,r),Vi(null,t,n,!0,e,r);case 19:return tl(e,t,r);case 23:case 24:return zi(e,t,r)}throw Error(i(156,t.tag))},tc.prototype.render=function(e){Xu(e,this._internalRoot,null,null)},tc.prototype.unmount=function(){var e=this._internalRoot,t=e.containerInfo;Xu(null,e,null,(function(){t[Xn]=null}))},tt=function(e){13===e.tag&&(fu(e,4,cu()),ec(e,4))},rt=function(e){13===e.tag&&(fu(e,67108864,cu()),ec(e,67108864))},nt=function(e){if(13===e.tag){var t=cu(),r=su(e);fu(e,r,t),ec(e,r)}},ot=function(e,t){return t()},Ce=function(e,t,r){switch(t){case"input":if(re(e,r),t=r.name,"radio"===r.type&&null!=t){for(r=e;r.parentNode;)r=r.parentNode;for(r=r.querySelectorAll("input[name="+JSON.stringify(""+t)+\'][type="radio"]\'),t=0;t<r.length;t++){var n=r[t];if(n!==e&&n.form===e.form){var o=ro(n);if(!o)throw Error(i(90));X(n),re(n,o)}}}break;case"textarea":ce(e,r);break;case"select":null!=(t=r.value)&&ie(e,!!r.multiple,t,!1)}},Ae=mu,Ie=function(e,t,r,n,o){var a=Pl;Pl|=4;try{return Ho(98,e.bind(null,t,r,n,o))}finally{0===(Pl=a)&&(Hl(),$o())}},je=function(){0===(49&Pl)&&(function(){if(null!==tu){var e=tu;tu=null,e.forEach((function(e){e.expiredLanes|=24&e.pendingLanes,pu(e,Fo())}))}$o()}(),Lu())},Me=function(e,t){var r=Pl;Pl|=2;try{return e(t)}finally{0===(Pl=r)&&(Hl(),$o())}};var ac={Events:[eo,to,ro,Ne,Le,Lu,{current:!1}]},ic={findFiberByHostInstance:Zn,bundleType:0,version:"17.0.1",rendererPackageName:"react-dom"},lc={bundleType:ic.bundleType,version:ic.version,rendererPackageName:ic.rendererPackageName,rendererConfig:ic.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:k.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Ze(e))?null:e.stateNode},findFiberByHostInstance:ic.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if("undefined"!==typeof{}){var uc={};if(!uc.isDisabled&&uc.supportsFiber)try{ko=uc.inject(lc),Eo=uc}catch(ve){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ac,t.createPortal=oc,t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(i(188));throw Error(i(268,Object.keys(e)))}return e=null===(e=Ze(t))?null:e.stateNode},t.flushSync=function(e,t){var r=Pl;if(0!==(48&r))return e(t);Pl|=1;try{if(e)return Ho(99,e.bind(null,t))}finally{Pl=r,$o()}},t.hydrate=function(e,t,r){if(!rc(t))throw Error(i(200));return nc(null,e,t,!0,r)},t.render=function(e,t,r){if(!rc(t))throw Error(i(200));return nc(null,e,t,!1,r)},t.unmountComponentAtNode=function(e){if(!rc(e))throw Error(i(40));return!!e._reactRootContainer&&(yu((function(){nc(null,null,e,!1,(function(){e._reactRootContainer=null,e[Xn]=null}))})),!0)},t.unstable_batchedUpdates=mu,t.unstable_createPortal=function(e,t){return oc(e,t,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)},t.unstable_renderSubtreeIntoContainer=function(e,t,r,n){if(!rc(r))throw Error(i(200));if(null==e||void 0===e._reactInternals)throw Error(i(38));return nc(e,t,r,!1,n)},t.version="17.0.1"},function(e,t,r){"use strict";e.exports=r(186)},function(e,t,r){"use strict";var n,o,a,i;if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;t.unstable_now=function(){return l.now()}}else{var u=Date,c=u.now();t.unstable_now=function(){return u.now()-c}}if("undefined"===typeof window||"function"!==typeof MessageChannel){var s=null,f=null,d=function e(){if(null!==s)try{var r=t.unstable_now();s(!0,r),s=null}catch(t){throw setTimeout(e,0),t}};n=function(e){null!==s?setTimeout(n,0,e):(s=e,setTimeout(d,0))},o=function(e,t){f=setTimeout(e,t)},a=function(){clearTimeout(f)},t.unstable_shouldYield=function(){return!1},i=t.unstable_forceFrameRate=function(){}}else{var p=window.setTimeout,h=window.clearTimeout;if("undefined"!==typeof console){var g=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn\'t support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),"function"!==typeof g&&console.error("This browser doesn\'t support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var v=!1,m=null,y=-1,b=5,w=0;t.unstable_shouldYield=function(){return t.unstable_now()>=w},i=function(){},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):b=0<e?Math.floor(1e3/e):5};var k=new MessageChannel,E=k.port2;k.port1.onmessage=function(){if(null!==m){var e=t.unstable_now();w=e+b;try{m(!0,e)?E.postMessage(null):(v=!1,m=null)}catch(e){throw E.postMessage(null),e}}else v=!1},n=function(e){m=e,v||(v=!0,E.postMessage(null))},o=function(e,r){y=p((function(){e(t.unstable_now())}),r)},a=function(){h(y),y=-1}}function x(e,t){var r=e.length;e.push(t);e:for(;;){var n=r-1>>>1,o=e[n];if(!(void 0!==o&&0<T(o,t)))break e;e[n]=t,e[r]=o,r=n}}function S(e){return void 0===(e=e[0])?null:e}function _(e){var t=e[0];if(void 0!==t){var r=e.pop();if(r!==t){e[0]=r;e:for(var n=0,o=e.length;n<o;){var a=2*(n+1)-1,i=e[a],l=a+1,u=e[l];if(void 0!==i&&0>T(i,r))void 0!==u&&0>T(u,i)?(e[n]=u,e[l]=r,n=l):(e[n]=i,e[a]=r,n=a);else{if(!(void 0!==u&&0>T(u,r)))break e;e[n]=u,e[l]=r,n=l}}}return t}return null}function T(e,t){var r=e.sortIndex-t.sortIndex;return 0!==r?r:e.id-t.id}var C=[],O=[],P=1,R=null,N=3,L=!1,A=!1,I=!1;function j(e){for(var t=S(O);null!==t;){if(null===t.callback)_(O);else{if(!(t.startTime<=e))break;_(O),t.sortIndex=t.expirationTime,x(C,t)}t=S(O)}}function M(e){if(I=!1,j(e),!A)if(null!==S(C))A=!0,n(D);else{var t=S(O);null!==t&&o(M,t.startTime-e)}}function D(e,r){A=!1,I&&(I=!1,a()),L=!0;var n=N;try{for(j(r),R=S(C);null!==R&&(!(R.expirationTime>r)||e&&!t.unstable_shouldYield());){var i=R.callback;if("function"===typeof i){R.callback=null,N=R.priorityLevel;var l=i(R.expirationTime<=r);r=t.unstable_now(),"function"===typeof l?R.callback=l:R===S(C)&&_(C),j(r)}else _(C);R=S(C)}if(null!==R)var u=!0;else{var c=S(O);null!==c&&o(M,c.startTime-r),u=!1}return u}finally{R=null,N=n,L=!1}}var q=i;t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){A||L||(A=!0,n(D))},t.unstable_getCurrentPriorityLevel=function(){return N},t.unstable_getFirstCallbackNode=function(){return S(C)},t.unstable_next=function(e){switch(N){case 1:case 2:case 3:var t=3;break;default:t=N}var r=N;N=t;try{return e()}finally{N=r}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=q,t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var r=N;N=e;try{return t()}finally{N=r}},t.unstable_scheduleCallback=function(e,r,i){var l=t.unstable_now();switch("object"===typeof i&&null!==i?i="number"===typeof(i=i.delay)&&0<i?l+i:l:i=l,e){case 1:var u=-1;break;case 2:u=250;break;case 5:u=1073741823;break;case 4:u=1e4;break;default:u=5e3}return e={id:P++,callback:r,priorityLevel:e,startTime:i,expirationTime:u=i+u,sortIndex:-1},i>l?(e.sortIndex=i,x(O,e),null===S(C)&&e===S(O)&&(I?a():I=!0,o(M,i-l))):(e.sortIndex=u,x(C,e),A||L||(A=!0,n(D))),e},t.unstable_wrapCallback=function(e){var t=N;return function(){var r=N;N=t;try{return e.apply(this,arguments)}finally{N=r}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n={"&lt":"<","&gt":">","&quot":\'"\',"&apos":"\'","&amp":"&","&lt;":"<","&gt;":">","&quot;":\'"\',"&apos;":"\'","&amp;":"&"},o={60:"lt",62:"gt",34:"quot",39:"apos",38:"amp"},a={"<":"&lt;",">":"&gt;",\'"\':"&quot;","\'":"&apos;","&":"&amp;"},i=function(){function e(){}return e.prototype.encode=function(e){return e&&e.length?e.replace(/[<>"\'&]/g,(function(e){return a[e]})):""},e.encode=function(t){return(new e).encode(t)},e.prototype.decode=function(e){return e&&e.length?e.replace(/&#?[0-9a-zA-Z]+;?/g,(function(e){if("#"===e.charAt(1)){var t="x"===e.charAt(2).toLowerCase()?parseInt(e.substr(3),16):parseInt(e.substr(2));return isNaN(t)||t<-32768||t>65535?"":String.fromCharCode(t)}return n[e]||e})):""},e.decode=function(t){return(new e).decode(t)},e.prototype.encodeNonUTF=function(e){if(!e||!e.length)return"";for(var t=e.length,r="",n=0;n<t;){var a=e.charCodeAt(n),i=o[a];i?(r+="&"+i+";",n++):(r+=a<32||a>126?"&#"+a+";":e.charAt(n),n++)}return r},e.encodeNonUTF=function(t){return(new e).encodeNonUTF(t)},e.prototype.encodeNonASCII=function(e){if(!e||!e.length)return"";for(var t=e.length,r="",n=0;n<t;){var o=e.charCodeAt(n);o<=255?r+=e[n++]:(r+="&#"+o+";",n++)}return r},e.encodeNonASCII=function(t){return(new e).encodeNonASCII(t)},e}();t.XmlEntities=i},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=["apos","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","Aelig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","quot","amp","lt","gt","OElig","oelig","Scaron","scaron","Yuml","circ","tilde","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","permil","lsaquo","rsaquo","euro","fnof","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","bull","hellip","prime","Prime","oline","frasl","weierp","image","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","prop","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams"],o=[39,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,34,38,60,62,338,339,352,353,376,710,732,8194,8195,8201,8204,8205,8206,8207,8211,8212,8216,8217,8218,8220,8221,8222,8224,8225,8240,8249,8250,8364,402,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,931,932,933,934,935,936,937,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,977,978,982,8226,8230,8242,8243,8254,8260,8472,8465,8476,8482,8501,8592,8593,8594,8595,8596,8629,8656,8657,8658,8659,8660,8704,8706,8707,8709,8711,8712,8713,8715,8719,8721,8722,8727,8730,8733,8734,8736,8743,8744,8745,8746,8747,8756,8764,8773,8776,8800,8801,8804,8805,8834,8835,8836,8838,8839,8853,8855,8869,8901,8968,8969,8970,8971,9001,9002,9674,9824,9827,9829,9830],a={},i={};!function(){for(var e=0,t=n.length;e<t;){var r=n[e],l=o[e];a[r]=String.fromCharCode(l),i[l]=r,e++}}();var l=function(){function e(){}return e.prototype.decode=function(e){return e&&e.length?e.replace(/&(#?[\\w\\d]+);?/g,(function(e,t){var r;if("#"===t.charAt(0)){var n="x"===t.charAt(1).toLowerCase()?parseInt(t.substr(2),16):parseInt(t.substr(1));isNaN(n)||n<-32768||n>65535||(r=String.fromCharCode(n))}else r=a[t];return r||e})):""},e.decode=function(t){return(new e).decode(t)},e.prototype.encode=function(e){if(!e||!e.length)return"";for(var t=e.length,r="",n=0;n<t;){var o=i[e.charCodeAt(n)];r+=o?"&"+o+";":e.charAt(n),n++}return r},e.encode=function(t){return(new e).encode(t)},e.prototype.encodeNonUTF=function(e){if(!e||!e.length)return"";for(var t=e.length,r="",n=0;n<t;){var o=e.charCodeAt(n),a=i[o];r+=a?"&"+a+";":o<32||o>126?"&#"+o+";":e.charAt(n),n++}return r},e.encodeNonUTF=function(t){return(new e).encodeNonUTF(t)},e.prototype.encodeNonASCII=function(e){if(!e||!e.length)return"";for(var t=e.length,r="",n=0;n<t;){var o=e.charCodeAt(n);o<=255?r+=e[n++]:(r+="&#"+o+";",n++)}return r},e.encodeNonASCII=function(t){return(new e).encodeNonASCII(t)},e}();t.Html4Entities=l},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=[["Aacute",[193]],["aacute",[225]],["Abreve",[258]],["abreve",[259]],["ac",[8766]],["acd",[8767]],["acE",[8766,819]],["Acirc",[194]],["acirc",[226]],["acute",[180]],["Acy",[1040]],["acy",[1072]],["AElig",[198]],["aelig",[230]],["af",[8289]],["Afr",[120068]],["afr",[120094]],["Agrave",[192]],["agrave",[224]],["alefsym",[8501]],["aleph",[8501]],["Alpha",[913]],["alpha",[945]],["Amacr",[256]],["amacr",[257]],["amalg",[10815]],["amp",[38]],["AMP",[38]],["andand",[10837]],["And",[10835]],["and",[8743]],["andd",[10844]],["andslope",[10840]],["andv",[10842]],["ang",[8736]],["ange",[10660]],["angle",[8736]],["angmsdaa",[10664]],["angmsdab",[10665]],["angmsdac",[10666]],["angmsdad",[10667]],["angmsdae",[10668]],["angmsdaf",[10669]],["angmsdag",[10670]],["angmsdah",[10671]],["angmsd",[8737]],["angrt",[8735]],["angrtvb",[8894]],["angrtvbd",[10653]],["angsph",[8738]],["angst",[197]],["angzarr",[9084]],["Aogon",[260]],["aogon",[261]],["Aopf",[120120]],["aopf",[120146]],["apacir",[10863]],["ap",[8776]],["apE",[10864]],["ape",[8778]],["apid",[8779]],["apos",[39]],["ApplyFunction",[8289]],["approx",[8776]],["approxeq",[8778]],["Aring",[197]],["aring",[229]],["Ascr",[119964]],["ascr",[119990]],["Assign",[8788]],["ast",[42]],["asymp",[8776]],["asympeq",[8781]],["Atilde",[195]],["atilde",[227]],["Auml",[196]],["auml",[228]],["awconint",[8755]],["awint",[10769]],["backcong",[8780]],["backepsilon",[1014]],["backprime",[8245]],["backsim",[8765]],["backsimeq",[8909]],["Backslash",[8726]],["Barv",[10983]],["barvee",[8893]],["barwed",[8965]],["Barwed",[8966]],["barwedge",[8965]],["bbrk",[9141]],["bbrktbrk",[9142]],["bcong",[8780]],["Bcy",[1041]],["bcy",[1073]],["bdquo",[8222]],["becaus",[8757]],["because",[8757]],["Because",[8757]],["bemptyv",[10672]],["bepsi",[1014]],["bernou",[8492]],["Bernoullis",[8492]],["Beta",[914]],["beta",[946]],["beth",[8502]],["between",[8812]],["Bfr",[120069]],["bfr",[120095]],["bigcap",[8898]],["bigcirc",[9711]],["bigcup",[8899]],["bigodot",[10752]],["bigoplus",[10753]],["bigotimes",[10754]],["bigsqcup",[10758]],["bigstar",[9733]],["bigtriangledown",[9661]],["bigtriangleup",[9651]],["biguplus",[10756]],["bigvee",[8897]],["bigwedge",[8896]],["bkarow",[10509]],["blacklozenge",[10731]],["blacksquare",[9642]],["blacktriangle",[9652]],["blacktriangledown",[9662]],["blacktriangleleft",[9666]],["blacktriangleright",[9656]],["blank",[9251]],["blk12",[9618]],["blk14",[9617]],["blk34",[9619]],["block",[9608]],["bne",[61,8421]],["bnequiv",[8801,8421]],["bNot",[10989]],["bnot",[8976]],["Bopf",[120121]],["bopf",[120147]],["bot",[8869]],["bottom",[8869]],["bowtie",[8904]],["boxbox",[10697]],["boxdl",[9488]],["boxdL",[9557]],["boxDl",[9558]],["boxDL",[9559]],["boxdr",[9484]],["boxdR",[9554]],["boxDr",[9555]],["boxDR",[9556]],["boxh",[9472]],["boxH",[9552]],["boxhd",[9516]],["boxHd",[9572]],["boxhD",[9573]],["boxHD",[9574]],["boxhu",[9524]],["boxHu",[9575]],["boxhU",[9576]],["boxHU",[9577]],["boxminus",[8863]],["boxplus",[8862]],["boxtimes",[8864]],["boxul",[9496]],["boxuL",[9563]],["boxUl",[9564]],["boxUL",[9565]],["boxur",[9492]],["boxuR",[9560]],["boxUr",[9561]],["boxUR",[9562]],["boxv",[9474]],["boxV",[9553]],["boxvh",[9532]],["boxvH",[9578]],["boxVh",[9579]],["boxVH",[9580]],["boxvl",[9508]],["boxvL",[9569]],["boxVl",[9570]],["boxVL",[9571]],["boxvr",[9500]],["boxvR",[9566]],["boxVr",[9567]],["boxVR",[9568]],["bprime",[8245]],["breve",[728]],["Breve",[728]],["brvbar",[166]],["bscr",[119991]],["Bscr",[8492]],["bsemi",[8271]],["bsim",[8765]],["bsime",[8909]],["bsolb",[10693]],["bsol",[92]],["bsolhsub",[10184]],["bull",[8226]],["bullet",[8226]],["bump",[8782]],["bumpE",[10926]],["bumpe",[8783]],["Bumpeq",[8782]],["bumpeq",[8783]],["Cacute",[262]],["cacute",[263]],["capand",[10820]],["capbrcup",[10825]],["capcap",[10827]],["cap",[8745]],["Cap",[8914]],["capcup",[10823]],["capdot",[10816]],["CapitalDifferentialD",[8517]],["caps",[8745,65024]],["caret",[8257]],["caron",[711]],["Cayleys",[8493]],["ccaps",[10829]],["Ccaron",[268]],["ccaron",[269]],["Ccedil",[199]],["ccedil",[231]],["Ccirc",[264]],["ccirc",[265]],["Cconint",[8752]],["ccups",[10828]],["ccupssm",[10832]],["Cdot",[266]],["cdot",[267]],["cedil",[184]],["Cedilla",[184]],["cemptyv",[10674]],["cent",[162]],["centerdot",[183]],["CenterDot",[183]],["cfr",[120096]],["Cfr",[8493]],["CHcy",[1063]],["chcy",[1095]],["check",[10003]],["checkmark",[10003]],["Chi",[935]],["chi",[967]],["circ",[710]],["circeq",[8791]],["circlearrowleft",[8634]],["circlearrowright",[8635]],["circledast",[8859]],["circledcirc",[8858]],["circleddash",[8861]],["CircleDot",[8857]],["circledR",[174]],["circledS",[9416]],["CircleMinus",[8854]],["CirclePlus",[8853]],["CircleTimes",[8855]],["cir",[9675]],["cirE",[10691]],["cire",[8791]],["cirfnint",[10768]],["cirmid",[10991]],["cirscir",[10690]],["ClockwiseContourIntegral",[8754]],["clubs",[9827]],["clubsuit",[9827]],["colon",[58]],["Colon",[8759]],["Colone",[10868]],["colone",[8788]],["coloneq",[8788]],["comma",[44]],["commat",[64]],["comp",[8705]],["compfn",[8728]],["complement",[8705]],["complexes",[8450]],["cong",[8773]],["congdot",[10861]],["Congruent",[8801]],["conint",[8750]],["Conint",[8751]],["ContourIntegral",[8750]],["copf",[120148]],["Copf",[8450]],["coprod",[8720]],["Coproduct",[8720]],["copy",[169]],["COPY",[169]],["copysr",[8471]],["CounterClockwiseContourIntegral",[8755]],["crarr",[8629]],["cross",[10007]],["Cross",[10799]],["Cscr",[119966]],["cscr",[119992]],["csub",[10959]],["csube",[10961]],["csup",[10960]],["csupe",[10962]],["ctdot",[8943]],["cudarrl",[10552]],["cudarrr",[10549]],["cuepr",[8926]],["cuesc",[8927]],["cularr",[8630]],["cularrp",[10557]],["cupbrcap",[10824]],["cupcap",[10822]],["CupCap",[8781]],["cup",[8746]],["Cup",[8915]],["cupcup",[10826]],["cupdot",[8845]],["cupor",[10821]],["cups",[8746,65024]],["curarr",[8631]],["curarrm",[10556]],["curlyeqprec",[8926]],["curlyeqsucc",[8927]],["curlyvee",[8910]],["curlywedge",[8911]],["curren",[164]],["curvearrowleft",[8630]],["curvearrowright",[8631]],["cuvee",[8910]],["cuwed",[8911]],["cwconint",[8754]],["cwint",[8753]],["cylcty",[9005]],["dagger",[8224]],["Dagger",[8225]],["daleth",[8504]],["darr",[8595]],["Darr",[8609]],["dArr",[8659]],["dash",[8208]],["Dashv",[10980]],["dashv",[8867]],["dbkarow",[10511]],["dblac",[733]],["Dcaron",[270]],["dcaron",[271]],["Dcy",[1044]],["dcy",[1076]],["ddagger",[8225]],["ddarr",[8650]],["DD",[8517]],["dd",[8518]],["DDotrahd",[10513]],["ddotseq",[10871]],["deg",[176]],["Del",[8711]],["Delta",[916]],["delta",[948]],["demptyv",[10673]],["dfisht",[10623]],["Dfr",[120071]],["dfr",[120097]],["dHar",[10597]],["dharl",[8643]],["dharr",[8642]],["DiacriticalAcute",[180]],["DiacriticalDot",[729]],["DiacriticalDoubleAcute",[733]],["DiacriticalGrave",[96]],["DiacriticalTilde",[732]],["diam",[8900]],["diamond",[8900]],["Diamond",[8900]],["diamondsuit",[9830]],["diams",[9830]],["die",[168]],["DifferentialD",[8518]],["digamma",[989]],["disin",[8946]],["div",[247]],["divide",[247]],["divideontimes",[8903]],["divonx",[8903]],["DJcy",[1026]],["djcy",[1106]],["dlcorn",[8990]],["dlcrop",[8973]],["dollar",[36]],["Dopf",[120123]],["dopf",[120149]],["Dot",[168]],["dot",[729]],["DotDot",[8412]],["doteq",[8784]],["doteqdot",[8785]],["DotEqual",[8784]],["dotminus",[8760]],["dotplus",[8724]],["dotsquare",[8865]],["doublebarwedge",[8966]],["DoubleContourIntegral",[8751]],["DoubleDot",[168]],["DoubleDownArrow",[8659]],["DoubleLeftArrow",[8656]],["DoubleLeftRightArrow",[8660]],["DoubleLeftTee",[10980]],["DoubleLongLeftArrow",[10232]],["DoubleLongLeftRightArrow",[10234]],["DoubleLongRightArrow",[10233]],["DoubleRightArrow",[8658]],["DoubleRightTee",[8872]],["DoubleUpArrow",[8657]],["DoubleUpDownArrow",[8661]],["DoubleVerticalBar",[8741]],["DownArrowBar",[10515]],["downarrow",[8595]],["DownArrow",[8595]],["Downarrow",[8659]],["DownArrowUpArrow",[8693]],["DownBreve",[785]],["downdownarrows",[8650]],["downharpoonleft",[8643]],["downharpoonright",[8642]],["DownLeftRightVector",[10576]],["DownLeftTeeVector",[10590]],["DownLeftVectorBar",[10582]],["DownLeftVector",[8637]],["DownRightTeeVector",[10591]],["DownRightVectorBar",[10583]],["DownRightVector",[8641]],["DownTeeArrow",[8615]],["DownTee",[8868]],["drbkarow",[10512]],["drcorn",[8991]],["drcrop",[8972]],["Dscr",[119967]],["dscr",[119993]],["DScy",[1029]],["dscy",[1109]],["dsol",[10742]],["Dstrok",[272]],["dstrok",[273]],["dtdot",[8945]],["dtri",[9663]],["dtrif",[9662]],["duarr",[8693]],["duhar",[10607]],["dwangle",[10662]],["DZcy",[1039]],["dzcy",[1119]],["dzigrarr",[10239]],["Eacute",[201]],["eacute",[233]],["easter",[10862]],["Ecaron",[282]],["ecaron",[283]],["Ecirc",[202]],["ecirc",[234]],["ecir",[8790]],["ecolon",[8789]],["Ecy",[1069]],["ecy",[1101]],["eDDot",[10871]],["Edot",[278]],["edot",[279]],["eDot",[8785]],["ee",[8519]],["efDot",[8786]],["Efr",[120072]],["efr",[120098]],["eg",[10906]],["Egrave",[200]],["egrave",[232]],["egs",[10902]],["egsdot",[10904]],["el",[10905]],["Element",[8712]],["elinters",[9191]],["ell",[8467]],["els",[10901]],["elsdot",[10903]],["Emacr",[274]],["emacr",[275]],["empty",[8709]],["emptyset",[8709]],["EmptySmallSquare",[9723]],["emptyv",[8709]],["EmptyVerySmallSquare",[9643]],["emsp13",[8196]],["emsp14",[8197]],["emsp",[8195]],["ENG",[330]],["eng",[331]],["ensp",[8194]],["Eogon",[280]],["eogon",[281]],["Eopf",[120124]],["eopf",[120150]],["epar",[8917]],["eparsl",[10723]],["eplus",[10865]],["epsi",[949]],["Epsilon",[917]],["epsilon",[949]],["epsiv",[1013]],["eqcirc",[8790]],["eqcolon",[8789]],["eqsim",[8770]],["eqslantgtr",[10902]],["eqslantless",[10901]],["Equal",[10869]],["equals",[61]],["EqualTilde",[8770]],["equest",[8799]],["Equilibrium",[8652]],["equiv",[8801]],["equivDD",[10872]],["eqvparsl",[10725]],["erarr",[10609]],["erDot",[8787]],["escr",[8495]],["Escr",[8496]],["esdot",[8784]],["Esim",[10867]],["esim",[8770]],["Eta",[919]],["eta",[951]],["ETH",[208]],["eth",[240]],["Euml",[203]],["euml",[235]],["euro",[8364]],["excl",[33]],["exist",[8707]],["Exists",[8707]],["expectation",[8496]],["exponentiale",[8519]],["ExponentialE",[8519]],["fallingdotseq",[8786]],["Fcy",[1060]],["fcy",[1092]],["female",[9792]],["ffilig",[64259]],["fflig",[64256]],["ffllig",[64260]],["Ffr",[120073]],["ffr",[120099]],["filig",[64257]],["FilledSmallSquare",[9724]],["FilledVerySmallSquare",[9642]],["fjlig",[102,106]],["flat",[9837]],["fllig",[64258]],["fltns",[9649]],["fnof",[402]],["Fopf",[120125]],["fopf",[120151]],["forall",[8704]],["ForAll",[8704]],["fork",[8916]],["forkv",[10969]],["Fouriertrf",[8497]],["fpartint",[10765]],["frac12",[189]],["frac13",[8531]],["frac14",[188]],["frac15",[8533]],["frac16",[8537]],["frac18",[8539]],["frac23",[8532]],["frac25",[8534]],["frac34",[190]],["frac35",[8535]],["frac38",[8540]],["frac45",[8536]],["frac56",[8538]],["frac58",[8541]],["frac78",[8542]],["frasl",[8260]],["frown",[8994]],["fscr",[119995]],["Fscr",[8497]],["gacute",[501]],["Gamma",[915]],["gamma",[947]],["Gammad",[988]],["gammad",[989]],["gap",[10886]],["Gbreve",[286]],["gbreve",[287]],["Gcedil",[290]],["Gcirc",[284]],["gcirc",[285]],["Gcy",[1043]],["gcy",[1075]],["Gdot",[288]],["gdot",[289]],["ge",[8805]],["gE",[8807]],["gEl",[10892]],["gel",[8923]],["geq",[8805]],["geqq",[8807]],["geqslant",[10878]],["gescc",[10921]],["ges",[10878]],["gesdot",[10880]],["gesdoto",[10882]],["gesdotol",[10884]],["gesl",[8923,65024]],["gesles",[10900]],["Gfr",[120074]],["gfr",[120100]],["gg",[8811]],["Gg",[8921]],["ggg",[8921]],["gimel",[8503]],["GJcy",[1027]],["gjcy",[1107]],["gla",[10917]],["gl",[8823]],["glE",[10898]],["glj",[10916]],["gnap",[10890]],["gnapprox",[10890]],["gne",[10888]],["gnE",[8809]],["gneq",[10888]],["gneqq",[8809]],["gnsim",[8935]],["Gopf",[120126]],["gopf",[120152]],["grave",[96]],["GreaterEqual",[8805]],["GreaterEqualLess",[8923]],["GreaterFullEqual",[8807]],["GreaterGreater",[10914]],["GreaterLess",[8823]],["GreaterSlantEqual",[10878]],["GreaterTilde",[8819]],["Gscr",[119970]],["gscr",[8458]],["gsim",[8819]],["gsime",[10894]],["gsiml",[10896]],["gtcc",[10919]],["gtcir",[10874]],["gt",[62]],["GT",[62]],["Gt",[8811]],["gtdot",[8919]],["gtlPar",[10645]],["gtquest",[10876]],["gtrapprox",[10886]],["gtrarr",[10616]],["gtrdot",[8919]],["gtreqless",[8923]],["gtreqqless",[10892]],["gtrless",[8823]],["gtrsim",[8819]],["gvertneqq",[8809,65024]],["gvnE",[8809,65024]],["Hacek",[711]],["hairsp",[8202]],["half",[189]],["hamilt",[8459]],["HARDcy",[1066]],["hardcy",[1098]],["harrcir",[10568]],["harr",[8596]],["hArr",[8660]],["harrw",[8621]],["Hat",[94]],["hbar",[8463]],["Hcirc",[292]],["hcirc",[293]],["hearts",[9829]],["heartsuit",[9829]],["hellip",[8230]],["hercon",[8889]],["hfr",[120101]],["Hfr",[8460]],["HilbertSpace",[8459]],["hksearow",[10533]],["hkswarow",[10534]],["hoarr",[8703]],["homtht",[8763]],["hookleftarrow",[8617]],["hookrightarrow",[8618]],["hopf",[120153]],["Hopf",[8461]],["horbar",[8213]],["HorizontalLine",[9472]],["hscr",[119997]],["Hscr",[8459]],["hslash",[8463]],["Hstrok",[294]],["hstrok",[295]],["HumpDownHump",[8782]],["HumpEqual",[8783]],["hybull",[8259]],["hyphen",[8208]],["Iacute",[205]],["iacute",[237]],["ic",[8291]],["Icirc",[206]],["icirc",[238]],["Icy",[1048]],["icy",[1080]],["Idot",[304]],["IEcy",[1045]],["iecy",[1077]],["iexcl",[161]],["iff",[8660]],["ifr",[120102]],["Ifr",[8465]],["Igrave",[204]],["igrave",[236]],["ii",[8520]],["iiiint",[10764]],["iiint",[8749]],["iinfin",[10716]],["iiota",[8489]],["IJlig",[306]],["ijlig",[307]],["Imacr",[298]],["imacr",[299]],["image",[8465]],["ImaginaryI",[8520]],["imagline",[8464]],["imagpart",[8465]],["imath",[305]],["Im",[8465]],["imof",[8887]],["imped",[437]],["Implies",[8658]],["incare",[8453]],["in",[8712]],["infin",[8734]],["infintie",[10717]],["inodot",[305]],["intcal",[8890]],["int",[8747]],["Int",[8748]],["integers",[8484]],["Integral",[8747]],["intercal",[8890]],["Intersection",[8898]],["intlarhk",[10775]],["intprod",[10812]],["InvisibleComma",[8291]],["InvisibleTimes",[8290]],["IOcy",[1025]],["iocy",[1105]],["Iogon",[302]],["iogon",[303]],["Iopf",[120128]],["iopf",[120154]],["Iota",[921]],["iota",[953]],["iprod",[10812]],["iquest",[191]],["iscr",[119998]],["Iscr",[8464]],["isin",[8712]],["isindot",[8949]],["isinE",[8953]],["isins",[8948]],["isinsv",[8947]],["isinv",[8712]],["it",[8290]],["Itilde",[296]],["itilde",[297]],["Iukcy",[1030]],["iukcy",[1110]],["Iuml",[207]],["iuml",[239]],["Jcirc",[308]],["jcirc",[309]],["Jcy",[1049]],["jcy",[1081]],["Jfr",[120077]],["jfr",[120103]],["jmath",[567]],["Jopf",[120129]],["jopf",[120155]],["Jscr",[119973]],["jscr",[119999]],["Jsercy",[1032]],["jsercy",[1112]],["Jukcy",[1028]],["jukcy",[1108]],["Kappa",[922]],["kappa",[954]],["kappav",[1008]],["Kcedil",[310]],["kcedil",[311]],["Kcy",[1050]],["kcy",[1082]],["Kfr",[120078]],["kfr",[120104]],["kgreen",[312]],["KHcy",[1061]],["khcy",[1093]],["KJcy",[1036]],["kjcy",[1116]],["Kopf",[120130]],["kopf",[120156]],["Kscr",[119974]],["kscr",[12e4]],["lAarr",[8666]],["Lacute",[313]],["lacute",[314]],["laemptyv",[10676]],["lagran",[8466]],["Lambda",[923]],["lambda",[955]],["lang",[10216]],["Lang",[10218]],["langd",[10641]],["langle",[10216]],["lap",[10885]],["Laplacetrf",[8466]],["laquo",[171]],["larrb",[8676]],["larrbfs",[10527]],["larr",[8592]],["Larr",[8606]],["lArr",[8656]],["larrfs",[10525]],["larrhk",[8617]],["larrlp",[8619]],["larrpl",[10553]],["larrsim",[10611]],["larrtl",[8610]],["latail",[10521]],["lAtail",[10523]],["lat",[10923]],["late",[10925]],["lates",[10925,65024]],["lbarr",[10508]],["lBarr",[10510]],["lbbrk",[10098]],["lbrace",[123]],["lbrack",[91]],["lbrke",[10635]],["lbrksld",[10639]],["lbrkslu",[10637]],["Lcaron",[317]],["lcaron",[318]],["Lcedil",[315]],["lcedil",[316]],["lceil",[8968]],["lcub",[123]],["Lcy",[1051]],["lcy",[1083]],["ldca",[10550]],["ldquo",[8220]],["ldquor",[8222]],["ldrdhar",[10599]],["ldrushar",[10571]],["ldsh",[8626]],["le",[8804]],["lE",[8806]],["LeftAngleBracket",[10216]],["LeftArrowBar",[8676]],["leftarrow",[8592]],["LeftArrow",[8592]],["Leftarrow",[8656]],["LeftArrowRightArrow",[8646]],["leftarrowtail",[8610]],["LeftCeiling",[8968]],["LeftDoubleBracket",[10214]],["LeftDownTeeVector",[10593]],["LeftDownVectorBar",[10585]],["LeftDownVector",[8643]],["LeftFloor",[8970]],["leftharpoondown",[8637]],["leftharpoonup",[8636]],["leftleftarrows",[8647]],["leftrightarrow",[8596]],["LeftRightArrow",[8596]],["Leftrightarrow",[8660]],["leftrightarrows",[8646]],["leftrightharpoons",[8651]],["leftrightsquigarrow",[8621]],["LeftRightVector",[10574]],["LeftTeeArrow",[8612]],["LeftTee",[8867]],["LeftTeeVector",[10586]],["leftthreetimes",[8907]],["LeftTriangleBar",[10703]],["LeftTriangle",[8882]],["LeftTriangleEqual",[8884]],["LeftUpDownVector",[10577]],["LeftUpTeeVector",[10592]],["LeftUpVectorBar",[10584]],["LeftUpVector",[8639]],["LeftVectorBar",[10578]],["LeftVector",[8636]],["lEg",[10891]],["leg",[8922]],["leq",[8804]],["leqq",[8806]],["leqslant",[10877]],["lescc",[10920]],["les",[10877]],["lesdot",[10879]],["lesdoto",[10881]],["lesdotor",[10883]],["lesg",[8922,65024]],["lesges",[10899]],["lessapprox",[10885]],["lessdot",[8918]],["lesseqgtr",[8922]],["lesseqqgtr",[10891]],["LessEqualGreater",[8922]],["LessFullEqual",[8806]],["LessGreater",[8822]],["lessgtr",[8822]],["LessLess",[10913]],["lesssim",[8818]],["LessSlantEqual",[10877]],["LessTilde",[8818]],["lfisht",[10620]],["lfloor",[8970]],["Lfr",[120079]],["lfr",[120105]],["lg",[8822]],["lgE",[10897]],["lHar",[10594]],["lhard",[8637]],["lharu",[8636]],["lharul",[10602]],["lhblk",[9604]],["LJcy",[1033]],["ljcy",[1113]],["llarr",[8647]],["ll",[8810]],["Ll",[8920]],["llcorner",[8990]],["Lleftarrow",[8666]],["llhard",[10603]],["lltri",[9722]],["Lmidot",[319]],["lmidot",[320]],["lmoustache",[9136]],["lmoust",[9136]],["lnap",[10889]],["lnapprox",[10889]],["lne",[10887]],["lnE",[8808]],["lneq",[10887]],["lneqq",[8808]],["lnsim",[8934]],["loang",[10220]],["loarr",[8701]],["lobrk",[10214]],["longleftarrow",[10229]],["LongLeftArrow",[10229]],["Longleftarrow",[10232]],["longleftrightarrow",[10231]],["LongLeftRightArrow",[10231]],["Longleftrightarrow",[10234]],["longmapsto",[10236]],["longrightarrow",[10230]],["LongRightArrow",[10230]],["Longrightarrow",[10233]],["looparrowleft",[8619]],["looparrowright",[8620]],["lopar",[10629]],["Lopf",[120131]],["lopf",[120157]],["loplus",[10797]],["lotimes",[10804]],["lowast",[8727]],["lowbar",[95]],["LowerLeftArrow",[8601]],["LowerRightArrow",[8600]],["loz",[9674]],["lozenge",[9674]],["lozf",[10731]],["lpar",[40]],["lparlt",[10643]],["lrarr",[8646]],["lrcorner",[8991]],["lrhar",[8651]],["lrhard",[10605]],["lrm",[8206]],["lrtri",[8895]],["lsaquo",[8249]],["lscr",[120001]],["Lscr",[8466]],["lsh",[8624]],["Lsh",[8624]],["lsim",[8818]],["lsime",[10893]],["lsimg",[10895]],["lsqb",[91]],["lsquo",[8216]],["lsquor",[8218]],["Lstrok",[321]],["lstrok",[322]],["ltcc",[10918]],["ltcir",[10873]],["lt",[60]],["LT",[60]],["Lt",[8810]],["ltdot",[8918]],["lthree",[8907]],["ltimes",[8905]],["ltlarr",[10614]],["ltquest",[10875]],["ltri",[9667]],["ltrie",[8884]],["ltrif",[9666]],["ltrPar",[10646]],["lurdshar",[10570]],["luruhar",[10598]],["lvertneqq",[8808,65024]],["lvnE",[8808,65024]],["macr",[175]],["male",[9794]],["malt",[10016]],["maltese",[10016]],["Map",[10501]],["map",[8614]],["mapsto",[8614]],["mapstodown",[8615]],["mapstoleft",[8612]],["mapstoup",[8613]],["marker",[9646]],["mcomma",[10793]],["Mcy",[1052]],["mcy",[1084]],["mdash",[8212]],["mDDot",[8762]],["measuredangle",[8737]],["MediumSpace",[8287]],["Mellintrf",[8499]],["Mfr",[120080]],["mfr",[120106]],["mho",[8487]],["micro",[181]],["midast",[42]],["midcir",[10992]],["mid",[8739]],["middot",[183]],["minusb",[8863]],["minus",[8722]],["minusd",[8760]],["minusdu",[10794]],["MinusPlus",[8723]],["mlcp",[10971]],["mldr",[8230]],["mnplus",[8723]],["models",[8871]],["Mopf",[120132]],["mopf",[120158]],["mp",[8723]],["mscr",[120002]],["Mscr",[8499]],["mstpos",[8766]],["Mu",[924]],["mu",[956]],["multimap",[8888]],["mumap",[8888]],["nabla",[8711]],["Nacute",[323]],["nacute",[324]],["nang",[8736,8402]],["nap",[8777]],["napE",[10864,824]],["napid",[8779,824]],["napos",[329]],["napprox",[8777]],["natural",[9838]],["naturals",[8469]],["natur",[9838]],["nbsp",[160]],["nbump",[8782,824]],["nbumpe",[8783,824]],["ncap",[10819]],["Ncaron",[327]],["ncaron",[328]],["Ncedil",[325]],["ncedil",[326]],["ncong",[8775]],["ncongdot",[10861,824]],["ncup",[10818]],["Ncy",[1053]],["ncy",[1085]],["ndash",[8211]],["nearhk",[10532]],["nearr",[8599]],["neArr",[8663]],["nearrow",[8599]],["ne",[8800]],["nedot",[8784,824]],["NegativeMediumSpace",[8203]],["NegativeThickSpace",[8203]],["NegativeThinSpace",[8203]],["NegativeVeryThinSpace",[8203]],["nequiv",[8802]],["nesear",[10536]],["nesim",[8770,824]],["NestedGreaterGreater",[8811]],["NestedLessLess",[8810]],["nexist",[8708]],["nexists",[8708]],["Nfr",[120081]],["nfr",[120107]],["ngE",[8807,824]],["nge",[8817]],["ngeq",[8817]],["ngeqq",[8807,824]],["ngeqslant",[10878,824]],["nges",[10878,824]],["nGg",[8921,824]],["ngsim",[8821]],["nGt",[8811,8402]],["ngt",[8815]],["ngtr",[8815]],["nGtv",[8811,824]],["nharr",[8622]],["nhArr",[8654]],["nhpar",[10994]],["ni",[8715]],["nis",[8956]],["nisd",[8954]],["niv",[8715]],["NJcy",[1034]],["njcy",[1114]],["nlarr",[8602]],["nlArr",[8653]],["nldr",[8229]],["nlE",[8806,824]],["nle",[8816]],["nleftarrow",[8602]],["nLeftarrow",[8653]],["nleftrightarrow",[8622]],["nLeftrightarrow",[8654]],["nleq",[8816]],["nleqq",[8806,824]],["nleqslant",[10877,824]],["nles",[10877,824]],["nless",[8814]],["nLl",[8920,824]],["nlsim",[8820]],["nLt",[8810,8402]],["nlt",[8814]],["nltri",[8938]],["nltrie",[8940]],["nLtv",[8810,824]],["nmid",[8740]],["NoBreak",[8288]],["NonBreakingSpace",[160]],["nopf",[120159]],["Nopf",[8469]],["Not",[10988]],["not",[172]],["NotCongruent",[8802]],["NotCupCap",[8813]],["NotDoubleVerticalBar",[8742]],["NotElement",[8713]],["NotEqual",[8800]],["NotEqualTilde",[8770,824]],["NotExists",[8708]],["NotGreater",[8815]],["NotGreaterEqual",[8817]],["NotGreaterFullEqual",[8807,824]],["NotGreaterGreater",[8811,824]],["NotGreaterLess",[8825]],["NotGreaterSlantEqual",[10878,824]],["NotGreaterTilde",[8821]],["NotHumpDownHump",[8782,824]],["NotHumpEqual",[8783,824]],["notin",[8713]],["notindot",[8949,824]],["notinE",[8953,824]],["notinva",[8713]],["notinvb",[8951]],["notinvc",[8950]],["NotLeftTriangleBar",[10703,824]],["NotLeftTriangle",[8938]],["NotLeftTriangleEqual",[8940]],["NotLess",[8814]],["NotLessEqual",[8816]],["NotLessGreater",[8824]],["NotLessLess",[8810,824]],["NotLessSlantEqual",[10877,824]],["NotLessTilde",[8820]],["NotNestedGreaterGreater",[10914,824]],["NotNestedLessLess",[10913,824]],["notni",[8716]],["notniva",[8716]],["notnivb",[8958]],["notnivc",[8957]],["NotPrecedes",[8832]],["NotPrecedesEqual",[10927,824]],["NotPrecedesSlantEqual",[8928]],["NotReverseElement",[8716]],["NotRightTriangleBar",[10704,824]],["NotRightTriangle",[8939]],["NotRightTriangleEqual",[8941]],["NotSquareSubset",[8847,824]],["NotSquareSubsetEqual",[8930]],["NotSquareSuperset",[8848,824]],["NotSquareSupersetEqual",[8931]],["NotSubset",[8834,8402]],["NotSubsetEqual",[8840]],["NotSucceeds",[8833]],["NotSucceedsEqual",[10928,824]],["NotSucceedsSlantEqual",[8929]],["NotSucceedsTilde",[8831,824]],["NotSuperset",[8835,8402]],["NotSupersetEqual",[8841]],["NotTilde",[8769]],["NotTildeEqual",[8772]],["NotTildeFullEqual",[8775]],["NotTildeTilde",[8777]],["NotVerticalBar",[8740]],["nparallel",[8742]],["npar",[8742]],["nparsl",[11005,8421]],["npart",[8706,824]],["npolint",[10772]],["npr",[8832]],["nprcue",[8928]],["nprec",[8832]],["npreceq",[10927,824]],["npre",[10927,824]],["nrarrc",[10547,824]],["nrarr",[8603]],["nrArr",[8655]],["nrarrw",[8605,824]],["nrightarrow",[8603]],["nRightarrow",[8655]],["nrtri",[8939]],["nrtrie",[8941]],["nsc",[8833]],["nsccue",[8929]],["nsce",[10928,824]],["Nscr",[119977]],["nscr",[120003]],["nshortmid",[8740]],["nshortparallel",[8742]],["nsim",[8769]],["nsime",[8772]],["nsimeq",[8772]],["nsmid",[8740]],["nspar",[8742]],["nsqsube",[8930]],["nsqsupe",[8931]],["nsub",[8836]],["nsubE",[10949,824]],["nsube",[8840]],["nsubset",[8834,8402]],["nsubseteq",[8840]],["nsubseteqq",[10949,824]],["nsucc",[8833]],["nsucceq",[10928,824]],["nsup",[8837]],["nsupE",[10950,824]],["nsupe",[8841]],["nsupset",[8835,8402]],["nsupseteq",[8841]],["nsupseteqq",[10950,824]],["ntgl",[8825]],["Ntilde",[209]],["ntilde",[241]],["ntlg",[8824]],["ntriangleleft",[8938]],["ntrianglelefteq",[8940]],["ntriangleright",[8939]],["ntrianglerighteq",[8941]],["Nu",[925]],["nu",[957]],["num",[35]],["numero",[8470]],["numsp",[8199]],["nvap",[8781,8402]],["nvdash",[8876]],["nvDash",[8877]],["nVdash",[8878]],["nVDash",[8879]],["nvge",[8805,8402]],["nvgt",[62,8402]],["nvHarr",[10500]],["nvinfin",[10718]],["nvlArr",[10498]],["nvle",[8804,8402]],["nvlt",[60,8402]],["nvltrie",[8884,8402]],["nvrArr",[10499]],["nvrtrie",[8885,8402]],["nvsim",[8764,8402]],["nwarhk",[10531]],["nwarr",[8598]],["nwArr",[8662]],["nwarrow",[8598]],["nwnear",[10535]],["Oacute",[211]],["oacute",[243]],["oast",[8859]],["Ocirc",[212]],["ocirc",[244]],["ocir",[8858]],["Ocy",[1054]],["ocy",[1086]],["odash",[8861]],["Odblac",[336]],["odblac",[337]],["odiv",[10808]],["odot",[8857]],["odsold",[10684]],["OElig",[338]],["oelig",[339]],["ofcir",[10687]],["Ofr",[120082]],["ofr",[120108]],["ogon",[731]],["Ograve",[210]],["ograve",[242]],["ogt",[10689]],["ohbar",[10677]],["ohm",[937]],["oint",[8750]],["olarr",[8634]],["olcir",[10686]],["olcross",[10683]],["oline",[8254]],["olt",[10688]],["Omacr",[332]],["omacr",[333]],["Omega",[937]],["omega",[969]],["Omicron",[927]],["omicron",[959]],["omid",[10678]],["ominus",[8854]],["Oopf",[120134]],["oopf",[120160]],["opar",[10679]],["OpenCurlyDoubleQuote",[8220]],["OpenCurlyQuote",[8216]],["operp",[10681]],["oplus",[8853]],["orarr",[8635]],["Or",[10836]],["or",[8744]],["ord",[10845]],["order",[8500]],["orderof",[8500]],["ordf",[170]],["ordm",[186]],["origof",[8886]],["oror",[10838]],["orslope",[10839]],["orv",[10843]],["oS",[9416]],["Oscr",[119978]],["oscr",[8500]],["Oslash",[216]],["oslash",[248]],["osol",[8856]],["Otilde",[213]],["otilde",[245]],["otimesas",[10806]],["Otimes",[10807]],["otimes",[8855]],["Ouml",[214]],["ouml",[246]],["ovbar",[9021]],["OverBar",[8254]],["OverBrace",[9182]],["OverBracket",[9140]],["OverParenthesis",[9180]],["para",[182]],["parallel",[8741]],["par",[8741]],["parsim",[10995]],["parsl",[11005]],["part",[8706]],["PartialD",[8706]],["Pcy",[1055]],["pcy",[1087]],["percnt",[37]],["period",[46]],["permil",[8240]],["perp",[8869]],["pertenk",[8241]],["Pfr",[120083]],["pfr",[120109]],["Phi",[934]],["phi",[966]],["phiv",[981]],["phmmat",[8499]],["phone",[9742]],["Pi",[928]],["pi",[960]],["pitchfork",[8916]],["piv",[982]],["planck",[8463]],["planckh",[8462]],["plankv",[8463]],["plusacir",[10787]],["plusb",[8862]],["pluscir",[10786]],["plus",[43]],["plusdo",[8724]],["plusdu",[10789]],["pluse",[10866]],["PlusMinus",[177]],["plusmn",[177]],["plussim",[10790]],["plustwo",[10791]],["pm",[177]],["Poincareplane",[8460]],["pointint",[10773]],["popf",[120161]],["Popf",[8473]],["pound",[163]],["prap",[10935]],["Pr",[10939]],["pr",[8826]],["prcue",[8828]],["precapprox",[10935]],["prec",[8826]],["preccurlyeq",[8828]],["Precedes",[8826]],["PrecedesEqual",[10927]],["PrecedesSlantEqual",[8828]],["PrecedesTilde",[8830]],["preceq",[10927]],["precnapprox",[10937]],["precneqq",[10933]],["precnsim",[8936]],["pre",[10927]],["prE",[10931]],["precsim",[8830]],["prime",[8242]],["Prime",[8243]],["primes",[8473]],["prnap",[10937]],["prnE",[10933]],["prnsim",[8936]],["prod",[8719]],["Product",[8719]],["profalar",[9006]],["profline",[8978]],["profsurf",[8979]],["prop",[8733]],["Proportional",[8733]],["Proportion",[8759]],["propto",[8733]],["prsim",[8830]],["prurel",[8880]],["Pscr",[119979]],["pscr",[120005]],["Psi",[936]],["psi",[968]],["puncsp",[8200]],["Qfr",[120084]],["qfr",[120110]],["qint",[10764]],["qopf",[120162]],["Qopf",[8474]],["qprime",[8279]],["Qscr",[119980]],["qscr",[120006]],["quaternions",[8461]],["quatint",[10774]],["quest",[63]],["questeq",[8799]],["quot",[34]],["QUOT",[34]],["rAarr",[8667]],["race",[8765,817]],["Racute",[340]],["racute",[341]],["radic",[8730]],["raemptyv",[10675]],["rang",[10217]],["Rang",[10219]],["rangd",[10642]],["range",[10661]],["rangle",[10217]],["raquo",[187]],["rarrap",[10613]],["rarrb",[8677]],["rarrbfs",[10528]],["rarrc",[10547]],["rarr",[8594]],["Rarr",[8608]],["rArr",[8658]],["rarrfs",[10526]],["rarrhk",[8618]],["rarrlp",[8620]],["rarrpl",[10565]],["rarrsim",[10612]],["Rarrtl",[10518]],["rarrtl",[8611]],["rarrw",[8605]],["ratail",[10522]],["rAtail",[10524]],["ratio",[8758]],["rationals",[8474]],["rbarr",[10509]],["rBarr",[10511]],["RBarr",[10512]],["rbbrk",[10099]],["rbrace",[125]],["rbrack",[93]],["rbrke",[10636]],["rbrksld",[10638]],["rbrkslu",[10640]],["Rcaron",[344]],["rcaron",[345]],["Rcedil",[342]],["rcedil",[343]],["rceil",[8969]],["rcub",[125]],["Rcy",[1056]],["rcy",[1088]],["rdca",[10551]],["rdldhar",[10601]],["rdquo",[8221]],["rdquor",[8221]],["CloseCurlyDoubleQuote",[8221]],["rdsh",[8627]],["real",[8476]],["realine",[8475]],["realpart",[8476]],["reals",[8477]],["Re",[8476]],["rect",[9645]],["reg",[174]],["REG",[174]],["ReverseElement",[8715]],["ReverseEquilibrium",[8651]],["ReverseUpEquilibrium",[10607]],["rfisht",[10621]],["rfloor",[8971]],["rfr",[120111]],["Rfr",[8476]],["rHar",[10596]],["rhard",[8641]],["rharu",[8640]],["rharul",[10604]],["Rho",[929]],["rho",[961]],["rhov",[1009]],["RightAngleBracket",[10217]],["RightArrowBar",[8677]],["rightarrow",[8594]],["RightArrow",[8594]],["Rightarrow",[8658]],["RightArrowLeftArrow",[8644]],["rightarrowtail",[8611]],["RightCeiling",[8969]],["RightDoubleBracket",[10215]],["RightDownTeeVector",[10589]],["RightDownVectorBar",[10581]],["RightDownVector",[8642]],["RightFloor",[8971]],["rightharpoondown",[8641]],["rightharpoonup",[8640]],["rightleftarrows",[8644]],["rightleftharpoons",[8652]],["rightrightarrows",[8649]],["rightsquigarrow",[8605]],["RightTeeArrow",[8614]],["RightTee",[8866]],["RightTeeVector",[10587]],["rightthreetimes",[8908]],["RightTriangleBar",[10704]],["RightTriangle",[8883]],["RightTriangleEqual",[8885]],["RightUpDownVector",[10575]],["RightUpTeeVector",[10588]],["RightUpVectorBar",[10580]],["RightUpVector",[8638]],["RightVectorBar",[10579]],["RightVector",[8640]],["ring",[730]],["risingdotseq",[8787]],["rlarr",[8644]],["rlhar",[8652]],["rlm",[8207]],["rmoustache",[9137]],["rmoust",[9137]],["rnmid",[10990]],["roang",[10221]],["roarr",[8702]],["robrk",[10215]],["ropar",[10630]],["ropf",[120163]],["Ropf",[8477]],["roplus",[10798]],["rotimes",[10805]],["RoundImplies",[10608]],["rpar",[41]],["rpargt",[10644]],["rppolint",[10770]],["rrarr",[8649]],["Rrightarrow",[8667]],["rsaquo",[8250]],["rscr",[120007]],["Rscr",[8475]],["rsh",[8625]],["Rsh",[8625]],["rsqb",[93]],["rsquo",[8217]],["rsquor",[8217]],["CloseCurlyQuote",[8217]],["rthree",[8908]],["rtimes",[8906]],["rtri",[9657]],["rtrie",[8885]],["rtrif",[9656]],["rtriltri",[10702]],["RuleDelayed",[10740]],["ruluhar",[10600]],["rx",[8478]],["Sacute",[346]],["sacute",[347]],["sbquo",[8218]],["scap",[10936]],["Scaron",[352]],["scaron",[353]],["Sc",[10940]],["sc",[8827]],["sccue",[8829]],["sce",[10928]],["scE",[10932]],["Scedil",[350]],["scedil",[351]],["Scirc",[348]],["scirc",[349]],["scnap",[10938]],["scnE",[10934]],["scnsim",[8937]],["scpolint",[10771]],["scsim",[8831]],["Scy",[1057]],["scy",[1089]],["sdotb",[8865]],["sdot",[8901]],["sdote",[10854]],["searhk",[10533]],["searr",[8600]],["seArr",[8664]],["searrow",[8600]],["sect",[167]],["semi",[59]],["seswar",[10537]],["setminus",[8726]],["setmn",[8726]],["sext",[10038]],["Sfr",[120086]],["sfr",[120112]],["sfrown",[8994]],["sharp",[9839]],["SHCHcy",[1065]],["shchcy",[1097]],["SHcy",[1064]],["shcy",[1096]],["ShortDownArrow",[8595]],["ShortLeftArrow",[8592]],["shortmid",[8739]],["shortparallel",[8741]],["ShortRightArrow",[8594]],["ShortUpArrow",[8593]],["shy",[173]],["Sigma",[931]],["sigma",[963]],["sigmaf",[962]],["sigmav",[962]],["sim",[8764]],["simdot",[10858]],["sime",[8771]],["simeq",[8771]],["simg",[10910]],["simgE",[10912]],["siml",[10909]],["simlE",[10911]],["simne",[8774]],["simplus",[10788]],["simrarr",[10610]],["slarr",[8592]],["SmallCircle",[8728]],["smallsetminus",[8726]],["smashp",[10803]],["smeparsl",[10724]],["smid",[8739]],["smile",[8995]],["smt",[10922]],["smte",[10924]],["smtes",[10924,65024]],["SOFTcy",[1068]],["softcy",[1100]],["solbar",[9023]],["solb",[10692]],["sol",[47]],["Sopf",[120138]],["sopf",[120164]],["spades",[9824]],["spadesuit",[9824]],["spar",[8741]],["sqcap",[8851]],["sqcaps",[8851,65024]],["sqcup",[8852]],["sqcups",[8852,65024]],["Sqrt",[8730]],["sqsub",[8847]],["sqsube",[8849]],["sqsubset",[8847]],["sqsubseteq",[8849]],["sqsup",[8848]],["sqsupe",[8850]],["sqsupset",[8848]],["sqsupseteq",[8850]],["square",[9633]],["Square",[9633]],["SquareIntersection",[8851]],["SquareSubset",[8847]],["SquareSubsetEqual",[8849]],["SquareSuperset",[8848]],["SquareSupersetEqual",[8850]],["SquareUnion",[8852]],["squarf",[9642]],["squ",[9633]],["squf",[9642]],["srarr",[8594]],["Sscr",[119982]],["sscr",[120008]],["ssetmn",[8726]],["ssmile",[8995]],["sstarf",[8902]],["Star",[8902]],["star",[9734]],["starf",[9733]],["straightepsilon",[1013]],["straightphi",[981]],["strns",[175]],["sub",[8834]],["Sub",[8912]],["subdot",[10941]],["subE",[10949]],["sube",[8838]],["subedot",[10947]],["submult",[10945]],["subnE",[10955]],["subne",[8842]],["subplus",[10943]],["subrarr",[10617]],["subset",[8834]],["Subset",[8912]],["subseteq",[8838]],["subseteqq",[10949]],["SubsetEqual",[8838]],["subsetneq",[8842]],["subsetneqq",[10955]],["subsim",[10951]],["subsub",[10965]],["subsup",[10963]],["succapprox",[10936]],["succ",[8827]],["succcurlyeq",[8829]],["Succeeds",[8827]],["SucceedsEqual",[10928]],["SucceedsSlantEqual",[8829]],["SucceedsTilde",[8831]],["succeq",[10928]],["succnapprox",[10938]],["succneqq",[10934]],["succnsim",[8937]],["succsim",[8831]],["SuchThat",[8715]],["sum",[8721]],["Sum",[8721]],["sung",[9834]],["sup1",[185]],["sup2",[178]],["sup3",[179]],["sup",[8835]],["Sup",[8913]],["supdot",[10942]],["supdsub",[10968]],["supE",[10950]],["supe",[8839]],["supedot",[10948]],["Superset",[8835]],["SupersetEqual",[8839]],["suphsol",[10185]],["suphsub",[10967]],["suplarr",[10619]],["supmult",[10946]],["supnE",[10956]],["supne",[8843]],["supplus",[10944]],["supset",[8835]],["Supset",[8913]],["supseteq",[8839]],["supseteqq",[10950]],["supsetneq",[8843]],["supsetneqq",[10956]],["supsim",[10952]],["supsub",[10964]],["supsup",[10966]],["swarhk",[10534]],["swarr",[8601]],["swArr",[8665]],["swarrow",[8601]],["swnwar",[10538]],["szlig",[223]],["Tab",[9]],["target",[8982]],["Tau",[932]],["tau",[964]],["tbrk",[9140]],["Tcaron",[356]],["tcaron",[357]],["Tcedil",[354]],["tcedil",[355]],["Tcy",[1058]],["tcy",[1090]],["tdot",[8411]],["telrec",[8981]],["Tfr",[120087]],["tfr",[120113]],["there4",[8756]],["therefore",[8756]],["Therefore",[8756]],["Theta",[920]],["theta",[952]],["thetasym",[977]],["thetav",[977]],["thickapprox",[8776]],["thicksim",[8764]],["ThickSpace",[8287,8202]],["ThinSpace",[8201]],["thinsp",[8201]],["thkap",[8776]],["thksim",[8764]],["THORN",[222]],["thorn",[254]],["tilde",[732]],["Tilde",[8764]],["TildeEqual",[8771]],["TildeFullEqual",[8773]],["TildeTilde",[8776]],["timesbar",[10801]],["timesb",[8864]],["times",[215]],["timesd",[10800]],["tint",[8749]],["toea",[10536]],["topbot",[9014]],["topcir",[10993]],["top",[8868]],["Topf",[120139]],["topf",[120165]],["topfork",[10970]],["tosa",[10537]],["tprime",[8244]],["trade",[8482]],["TRADE",[8482]],["triangle",[9653]],["triangledown",[9663]],["triangleleft",[9667]],["trianglelefteq",[8884]],["triangleq",[8796]],["triangleright",[9657]],["trianglerighteq",[8885]],["tridot",[9708]],["trie",[8796]],["triminus",[10810]],["TripleDot",[8411]],["triplus",[10809]],["trisb",[10701]],["tritime",[10811]],["trpezium",[9186]],["Tscr",[119983]],["tscr",[120009]],["TScy",[1062]],["tscy",[1094]],["TSHcy",[1035]],["tshcy",[1115]],["Tstrok",[358]],["tstrok",[359]],["twixt",[8812]],["twoheadleftarrow",[8606]],["twoheadrightarrow",[8608]],["Uacute",[218]],["uacute",[250]],["uarr",[8593]],["Uarr",[8607]],["uArr",[8657]],["Uarrocir",[10569]],["Ubrcy",[1038]],["ubrcy",[1118]],["Ubreve",[364]],["ubreve",[365]],["Ucirc",[219]],["ucirc",[251]],["Ucy",[1059]],["ucy",[1091]],["udarr",[8645]],["Udblac",[368]],["udblac",[369]],["udhar",[10606]],["ufisht",[10622]],["Ufr",[120088]],["ufr",[120114]],["Ugrave",[217]],["ugrave",[249]],["uHar",[10595]],["uharl",[8639]],["uharr",[8638]],["uhblk",[9600]],["ulcorn",[8988]],["ulcorner",[8988]],["ulcrop",[8975]],["ultri",[9720]],["Umacr",[362]],["umacr",[363]],["uml",[168]],["UnderBar",[95]],["UnderBrace",[9183]],["UnderBracket",[9141]],["UnderParenthesis",[9181]],["Union",[8899]],["UnionPlus",[8846]],["Uogon",[370]],["uogon",[371]],["Uopf",[120140]],["uopf",[120166]],["UpArrowBar",[10514]],["uparrow",[8593]],["UpArrow",[8593]],["Uparrow",[8657]],["UpArrowDownArrow",[8645]],["updownarrow",[8597]],["UpDownArrow",[8597]],["Updownarrow",[8661]],["UpEquilibrium",[10606]],["upharpoonleft",[8639]],["upharpoonright",[8638]],["uplus",[8846]],["UpperLeftArrow",[8598]],["UpperRightArrow",[8599]],["upsi",[965]],["Upsi",[978]],["upsih",[978]],["Upsilon",[933]],["upsilon",[965]],["UpTeeArrow",[8613]],["UpTee",[8869]],["upuparrows",[8648]],["urcorn",[8989]],["urcorner",[8989]],["urcrop",[8974]],["Uring",[366]],["uring",[367]],["urtri",[9721]],["Uscr",[119984]],["uscr",[120010]],["utdot",[8944]],["Utilde",[360]],["utilde",[361]],["utri",[9653]],["utrif",[9652]],["uuarr",[8648]],["Uuml",[220]],["uuml",[252]],["uwangle",[10663]],["vangrt",[10652]],["varepsilon",[1013]],["varkappa",[1008]],["varnothing",[8709]],["varphi",[981]],["varpi",[982]],["varpropto",[8733]],["varr",[8597]],["vArr",[8661]],["varrho",[1009]],["varsigma",[962]],["varsubsetneq",[8842,65024]],["varsubsetneqq",[10955,65024]],["varsupsetneq",[8843,65024]],["varsupsetneqq",[10956,65024]],["vartheta",[977]],["vartriangleleft",[8882]],["vartriangleright",[8883]],["vBar",[10984]],["Vbar",[10987]],["vBarv",[10985]],["Vcy",[1042]],["vcy",[1074]],["vdash",[8866]],["vDash",[8872]],["Vdash",[8873]],["VDash",[8875]],["Vdashl",[10982]],["veebar",[8891]],["vee",[8744]],["Vee",[8897]],["veeeq",[8794]],["vellip",[8942]],["verbar",[124]],["Verbar",[8214]],["vert",[124]],["Vert",[8214]],["VerticalBar",[8739]],["VerticalLine",[124]],["VerticalSeparator",[10072]],["VerticalTilde",[8768]],["VeryThinSpace",[8202]],["Vfr",[120089]],["vfr",[120115]],["vltri",[8882]],["vnsub",[8834,8402]],["vnsup",[8835,8402]],["Vopf",[120141]],["vopf",[120167]],["vprop",[8733]],["vrtri",[8883]],["Vscr",[119985]],["vscr",[120011]],["vsubnE",[10955,65024]],["vsubne",[8842,65024]],["vsupnE",[10956,65024]],["vsupne",[8843,65024]],["Vvdash",[8874]],["vzigzag",[10650]],["Wcirc",[372]],["wcirc",[373]],["wedbar",[10847]],["wedge",[8743]],["Wedge",[8896]],["wedgeq",[8793]],["weierp",[8472]],["Wfr",[120090]],["wfr",[120116]],["Wopf",[120142]],["wopf",[120168]],["wp",[8472]],["wr",[8768]],["wreath",[8768]],["Wscr",[119986]],["wscr",[120012]],["xcap",[8898]],["xcirc",[9711]],["xcup",[8899]],["xdtri",[9661]],["Xfr",[120091]],["xfr",[120117]],["xharr",[10231]],["xhArr",[10234]],["Xi",[926]],["xi",[958]],["xlarr",[10229]],["xlArr",[10232]],["xmap",[10236]],["xnis",[8955]],["xodot",[10752]],["Xopf",[120143]],["xopf",[120169]],["xoplus",[10753]],["xotime",[10754]],["xrarr",[10230]],["xrArr",[10233]],["Xscr",[119987]],["xscr",[120013]],["xsqcup",[10758]],["xuplus",[10756]],["xutri",[9651]],["xvee",[8897]],["xwedge",[8896]],["Yacute",[221]],["yacute",[253]],["YAcy",[1071]],["yacy",[1103]],["Ycirc",[374]],["ycirc",[375]],["Ycy",[1067]],["ycy",[1099]],["yen",[165]],["Yfr",[120092]],["yfr",[120118]],["YIcy",[1031]],["yicy",[1111]],["Yopf",[120144]],["yopf",[120170]],["Yscr",[119988]],["yscr",[120014]],["YUcy",[1070]],["yucy",[1102]],["yuml",[255]],["Yuml",[376]],["Zacute",[377]],["zacute",[378]],["Zcaron",[381]],["zcaron",[382]],["Zcy",[1047]],["zcy",[1079]],["Zdot",[379]],["zdot",[380]],["zeetrf",[8488]],["ZeroWidthSpace",[8203]],["Zeta",[918]],["zeta",[950]],["zfr",[120119]],["Zfr",[8488]],["ZHcy",[1046]],["zhcy",[1078]],["zigrarr",[8669]],["zopf",[120171]],["Zopf",[8484]],["Zscr",[119989]],["zscr",[120015]],["zwj",[8205]],["zwnj",[8204]]],o={},a={};!function(e,t){var r=n.length;for(;r--;){var o=n[r],a=o[0],i=o[1],l=i[0],u=l<32||l>126||62===l||60===l||38===l||34===l||39===l,c=void 0;if(u&&(c=t[l]=t[l]||{}),i[1]){var s=i[1];e[a]=String.fromCharCode(l)+String.fromCharCode(s),u&&(c[s]=a)}else e[a]=String.fromCharCode(l),u&&(c[""]=a)}}(o,a);var i=function(){function e(){}return e.prototype.decode=function(e){return e&&e.length?e.replace(/&(#?[\\w\\d]+);?/g,(function(e,t){var r;if("#"===t.charAt(0)){var n="x"===t.charAt(1)?parseInt(t.substr(2).toLowerCase(),16):parseInt(t.substr(1));isNaN(n)||n<-32768||n>65535||(r=String.fromCharCode(n))}else r=o[t];return r||e})):""},e.decode=function(t){return(new e).decode(t)},e.prototype.encode=function(e){if(!e||!e.length)return"";for(var t=e.length,r="",n=0;n<t;){var o=a[e.charCodeAt(n)];if(o){var i=o[e.charCodeAt(n+1)];if(i?n++:i=o[""],i){r+="&"+i+";",n++;continue}}r+=e.charAt(n),n++}return r},e.encode=function(t){return(new e).encode(t)},e.prototype.encodeNonUTF=function(e){if(!e||!e.length)return"";for(var t=e.length,r="",n=0;n<t;){var o=e.charCodeAt(n),i=a[o];if(i){var l=i[e.charCodeAt(n+1)];if(l?n++:l=i[""],l){r+="&"+l+";",n++;continue}}r+=o<32||o>126?"&#"+o+";":e.charAt(n),n++}return r},e.encodeNonUTF=function(t){return(new e).encodeNonUTF(t)},e.prototype.encodeNonASCII=function(e){if(!e||!e.length)return"";for(var t=e.length,r="",n=0;n<t;){var o=e.charCodeAt(n);o<=255?r+=e[n++]:(r+="&#"+o+";",n++)}return r},e.encodeNonASCII=function(t){return(new e).encodeNonASCII(t)},e}();t.Html5Entities=i},function(e,t,r){"use strict";var n=r(52),o=r(193);Object.defineProperty(t,"__esModule",{value:!0}),t.shouldHighlight=b,t.getChalk=w,t.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(b(t)){var r=w(t),n=f(r);return y(n,e)}return e};var a,i=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==typeof e&&"function"!==typeof e)return{default:e};var t=c();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if(Object.prototype.hasOwnProperty.call(e,o)){var a=n?Object.getOwnPropertyDescriptor(e,o):null;a&&(a.get||a.set)?Object.defineProperty(r,o,a):r[o]=e[o]}r.default=e,t&&t.set(e,r);return r}(r(195)),l=r(196),u=(a=r(199))&&a.__esModule?a:{default:a};function c(){if("function"!==typeof WeakMap)return null;var e=new WeakMap;return c=function(){return e},e}var s=new Set(["as","async","from","get","of","set"]);function f(e){return{keyword:e.cyan,capitalized:e.yellow,jsxIdentifier:e.yellow,punctuator:e.yellow,number:e.magenta,string:e.green,regex:e.magenta,comment:e.grey,invalid:e.white.bgRed.bold}}var d,p=/\\r\\n|[\\n\\r\\u2028\\u2029]/,h=/^[()[\\]{}]$/,g=i.matchToToken,v=/^[a-z][\\w-]*$/i,m=function(e,t,r){if("name"===e.type){if((0,l.isKeyword)(e.value)||(0,l.isStrictReservedWord)(e.value,!0)||s.has(e.value))return"keyword";if(v.test(e.value)&&("<"===r[t-1]||"</"==r.substr(t-2,2)))return"jsxIdentifier";if(e.value[0]!==e.value[0].toLowerCase())return"capitalized"}return"punctuator"===e.type&&h.test(e.value)?"bracket":"invalid"!==e.type||"@"!==e.value&&"#"!==e.value?e.type:"punctuator"};function y(e,t){var r,o="",a=n(d(t));try{var i=function(){var t=r.value,n=t.type,a=t.value,i=e[n];o+=i?a.split(p).map((function(e){return i(e)})).join("\\n"):a};for(a.s();!(r=a.n()).done;)i()}catch(e){a.e(e)}finally{a.f()}return o}function b(e){return u.default.supportsColor||e.forceColor}function w(e){var t=u.default;return e.forceColor&&(t=new u.default.constructor({enabled:!0,level:1})),t}d=o.mark((function e(t){var r,n;return o.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(!(r=i.default.exec(t))){e.next=6;break}return n=g(r),e.next=4,{type:m(n,r.index,t),value:n.value};case 4:e.next=0;break;case 6:case"end":return e.stop()}}),e)}))},function(e,t,r){var n=r(192);e.exports=function(e,t){if(e){if("string"===typeof e)return n(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?n(e,t):void 0}}},function(e,t){e.exports=function(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}},function(e,t,r){e.exports=r(194)},function(e,t,r){var n=function(e){"use strict";var t,r=Object.prototype,n=r.hasOwnProperty,o="function"===typeof Symbol?Symbol:{},a=o.iterator||"@@iterator",i=o.asyncIterator||"@@asyncIterator",l=o.toStringTag||"@@toStringTag";function u(e,t,r){return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{u({},"")}catch(e){u=function(e,t,r){return e[t]=r}}function c(e,t,r,n){var o=t&&t.prototype instanceof v?t:v,a=Object.create(o.prototype),i=new O(n||[]);return a._invoke=function(e,t,r){var n=f;return function(o,a){if(n===p)throw new Error("Generator is already running");if(n===h){if("throw"===o)throw a;return R()}for(r.method=o,r.arg=a;;){var i=r.delegate;if(i){var l=_(i,r);if(l){if(l===g)continue;return l}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===f)throw n=h,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=p;var u=s(e,t,r);if("normal"===u.type){if(n=r.done?h:d,u.arg===g)continue;return{value:u.arg,done:r.done}}"throw"===u.type&&(n=h,r.method="throw",r.arg=u.arg)}}}(e,r,i),a}function s(e,t,r){try{return{type:"normal",arg:e.call(t,r)}}catch(e){return{type:"throw",arg:e}}}e.wrap=c;var f="suspendedStart",d="suspendedYield",p="executing",h="completed",g={};function v(){}function m(){}function y(){}var b={};b[a]=function(){return this};var w=Object.getPrototypeOf,k=w&&w(w(P([])));k&&k!==r&&n.call(k,a)&&(b=k);var E=y.prototype=v.prototype=Object.create(b);function x(e){["next","throw","return"].forEach((function(t){u(e,t,(function(e){return this._invoke(t,e)}))}))}function S(e,t){function r(o,a,i,l){var u=s(e[o],e,a);if("throw"!==u.type){var c=u.arg,f=c.value;return f&&"object"===typeof f&&n.call(f,"__await")?t.resolve(f.__await).then((function(e){r("next",e,i,l)}),(function(e){r("throw",e,i,l)})):t.resolve(f).then((function(e){c.value=e,i(c)}),(function(e){return r("throw",e,i,l)}))}l(u.arg)}var o;this._invoke=function(e,n){function a(){return new t((function(t,o){r(e,n,t,o)}))}return o=o?o.then(a,a):a()}}function _(e,r){var n=e.iterator[r.method];if(n===t){if(r.delegate=null,"throw"===r.method){if(e.iterator.return&&(r.method="return",r.arg=t,_(e,r),"throw"===r.method))return g;r.method="throw",r.arg=new TypeError("The iterator does not provide a \'throw\' method")}return g}var o=s(n,e.iterator,r.arg);if("throw"===o.type)return r.method="throw",r.arg=o.arg,r.delegate=null,g;var a=o.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,g):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,g)}function T(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function C(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function O(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(T,this),this.reset(!0)}function P(e){if(e){var r=e[a];if(r)return r.call(e);if("function"===typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function r(){for(;++o<e.length;)if(n.call(e,o))return r.value=e[o],r.done=!1,r;return r.value=t,r.done=!0,r};return i.next=i}}return{next:R}}function R(){return{value:t,done:!0}}return m.prototype=E.constructor=y,y.constructor=m,m.displayName=u(y,l,"GeneratorFunction"),e.isGeneratorFunction=function(e){var t="function"===typeof e&&e.constructor;return!!t&&(t===m||"GeneratorFunction"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,y):(e.__proto__=y,u(e,l,"GeneratorFunction")),e.prototype=Object.create(E),e},e.awrap=function(e){return{__await:e}},x(S.prototype),S.prototype[i]=function(){return this},e.AsyncIterator=S,e.async=function(t,r,n,o,a){void 0===a&&(a=Promise);var i=new S(c(t,r,n,o),a);return e.isGeneratorFunction(r)?i:i.next().then((function(e){return e.done?e.value:i.next()}))},x(E),u(E,l,"Generator"),E[a]=function(){return this},E.toString=function(){return"[object Generator]"},e.keys=function(e){var t=[];for(var r in e)t.push(r);return t.reverse(),function r(){for(;t.length;){var n=t.pop();if(n in e)return r.value=n,r.done=!1,r}return r.done=!0,r}},e.values=P,O.prototype={constructor:O,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(C),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function o(n,o){return l.type="throw",l.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var a=this.tryEntries.length-1;a>=0;--a){var i=this.tryEntries[a],l=i.completion;if("root"===i.tryLoc)return o("end");if(i.tryLoc<=this.prev){var u=n.call(i,"catchLoc"),c=n.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return o(i.catchLoc,!0);if(this.prev<i.finallyLoc)return o(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return o(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return o(i.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var a=o;break}}a&&("break"===e||"continue"===e)&&a.tryLoc<=t&&t<=a.finallyLoc&&(a=null);var i=a?a.completion:{};return i.type=e,i.arg=t,a?(this.method="next",this.next=a.finallyLoc,g):this.complete(i)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),g},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),C(r),g}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if("throw"===n.type){var o=n.arg;C(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:P(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),g}},e}(e.exports);try{regeneratorRuntime=n}catch(e){Function("r","regeneratorRuntime = r")(n)}},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=/(([\'"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\\'"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyus]{1,6}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|(0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?)|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-\\/%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\\](){}])|(\\s+)|(^$|[\\s\\S])/g,t.matchToToken=function(e){var t={type:"invalid",value:e[0],closed:void 0};return e[1]?(t.type="string",t.closed=!(!e[3]&&!e[4])):e[5]?t.type="comment":e[6]?(t.type="comment",t.closed=!!e[7]):e[8]?t.type="regex":e[9]?t.type="number":e[10]?t.type="name":e[11]?t.type="punctuator":e[12]&&(t.type="whitespace"),t}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"isIdentifierName",{enumerable:!0,get:function(){return n.isIdentifierName}}),Object.defineProperty(t,"isIdentifierChar",{enumerable:!0,get:function(){return n.isIdentifierChar}}),Object.defineProperty(t,"isIdentifierStart",{enumerable:!0,get:function(){return n.isIdentifierStart}}),Object.defineProperty(t,"isReservedWord",{enumerable:!0,get:function(){return o.isReservedWord}}),Object.defineProperty(t,"isStrictBindOnlyReservedWord",{enumerable:!0,get:function(){return o.isStrictBindOnlyReservedWord}}),Object.defineProperty(t,"isStrictBindReservedWord",{enumerable:!0,get:function(){return o.isStrictBindReservedWord}}),Object.defineProperty(t,"isStrictReservedWord",{enumerable:!0,get:function(){return o.isStrictReservedWord}}),Object.defineProperty(t,"isKeyword",{enumerable:!0,get:function(){return o.isKeyword}});var n=r(197),o=r(198)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isIdentifierStart=s,t.isIdentifierChar=f,t.isIdentifierName=function(e){for(var t=!0,r=0,n=Array.from(e);r<n.length;r++){var o=n[r].codePointAt(0);if(t){if(!s(o))return!1;t=!1}else if(!f(o))return!1}return!t};var n="\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",o="\u200C\u200D\xb7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F",a=new RegExp("["+n+"]"),i=new RegExp("["+n+o+"]");n=o=null;var l=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938],u=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];function c(e,t){for(var r=65536,n=0,o=t.length;n<o;n+=2){if((r+=t[n])>e)return!1;if((r+=t[n+1])>=e)return!0}return!1}function s(e){return e<65?36===e:e<=90||(e<97?95===e:e<=122||(e<=65535?e>=170&&a.test(String.fromCharCode(e)):c(e,l)))}function f(e){return e<48?36===e:e<58||!(e<65)&&(e<=90||(e<97?95===e:e<=122||(e<=65535?e>=170&&i.test(String.fromCharCode(e)):c(e,l)||c(e,u))))}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isReservedWord=u,t.isStrictReservedWord=c,t.isStrictBindOnlyReservedWord=s,t.isStrictBindReservedWord=function(e,t){return c(e,t)||s(e)},t.isKeyword=function(e){return a.has(e)};var n=["implements","interface","let","package","private","protected","public","static","yield"],o=["eval","arguments"],a=new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"]),i=new Set(n),l=new Set(o);function u(e,t){return t&&"await"===e||"enum"===e}function c(e,t){return u(e,t)||i.has(e)}function s(e){return l.has(e)}},function(e,t,r){"use strict";(function(t){var n=r(52),o=r(200),a=r(201),i=r(206).stdout,l=r(207),u="win32"===t.platform&&!(Object({NODE_ENV:"production"}).TERM||"").toLowerCase().startsWith("xterm"),c=["ansi","ansi","ansi256","ansi16m"],s=new Set(["gray"]),f=Object.create(null);function d(e,t){t=t||{};var r=i?i.level:0;e.level=void 0===t.level?r:t.level,e.enabled="enabled"in t?t.enabled:e.level>0}function p(e){if(!this||!(this instanceof p)||this.template){var t={};return d(t,e),t.template=function(){var e=[].slice.call(arguments);return T.apply(null,[t.template].concat(e))},Object.setPrototypeOf(t,p.prototype),Object.setPrototypeOf(t.template,t),t.template.constructor=p,t.template}d(this,e)}u&&(a.blue.open="\x1b[94m");for(var h=function(){var e=v[g];a[e].closeRe=new RegExp(o(a[e].close),"g"),f[e]={get:function(){var t=a[e];return S.call(this,this._styles?this._styles.concat(t):[t],this._empty,e)}}},g=0,v=Object.keys(a);g<v.length;g++)h();f.visible={get:function(){return S.call(this,this._styles||[],!0,"visible")}},a.color.closeRe=new RegExp(o(a.color.close),"g");for(var m=function(){var e=b[y];if(s.has(e))return"continue";f[e]={get:function(){var t=this.level;return function(){var r=a.color[c[t]][e].apply(null,arguments),n={open:r,close:a.color.close,closeRe:a.color.closeRe};return S.call(this,this._styles?this._styles.concat(n):[n],this._empty,e)}}}},y=0,b=Object.keys(a.color.ansi);y<b.length;y++)m();a.bgColor.closeRe=new RegExp(o(a.bgColor.close),"g");for(var w=function(){var e=E[k];if(s.has(e))return"continue";var t="bg"+e[0].toUpperCase()+e.slice(1);f[t]={get:function(){var t=this.level;return function(){var r=a.bgColor[c[t]][e].apply(null,arguments),n={open:r,close:a.bgColor.close,closeRe:a.bgColor.closeRe};return S.call(this,this._styles?this._styles.concat(n):[n],this._empty,e)}}}},k=0,E=Object.keys(a.bgColor.ansi);k<E.length;k++)w();var x=Object.defineProperties((function(){}),f);function S(e,t,r){var n=function e(){return _.apply(e,arguments)};n._styles=e,n._empty=t;var o=this;return Object.defineProperty(n,"level",{enumerable:!0,get:function(){return o.level},set:function(e){o.level=e}}),Object.defineProperty(n,"enabled",{enumerable:!0,get:function(){return o.enabled},set:function(e){o.enabled=e}}),n.hasGrey=this.hasGrey||"gray"===r||"grey"===r,n.__proto__=x,n}function _(){var e=arguments,t=e.length,r=String(arguments[0]);if(0===t)return"";if(t>1)for(var o=1;o<t;o++)r+=" "+e[o];if(!this.enabled||this.level<=0||!r)return this._empty?"":r;var i=a.dim.open;u&&this.hasGrey&&(a.dim.open="");var l,c=n(this._styles.slice().reverse());try{for(c.s();!(l=c.n()).done;){var s=l.value;r=(r=s.open+r.replace(s.closeRe,s.open)+s.close).replace(/\\r?\\n/g,"".concat(s.close,"$&").concat(s.open))}}catch(e){c.e(e)}finally{c.f()}return a.dim.open=i,r}function T(e,t){if(!Array.isArray(t))return[].slice.call(arguments,1).join(" ");for(var r=[].slice.call(arguments,2),n=[t.raw[0]],o=1;o<t.length;o++)n.push(String(r[o-1]).replace(/[{}\\\\]/g,"\\\\$&")),n.push(String(t.raw[o]));return l(e,n.join(""))}Object.defineProperties(p.prototype,f),e.exports=p(),e.exports.supportsColor=i,e.exports.default=e.exports}).call(this,r(51))},function(e,t,r){"use strict";var n=/[|\\\\{}()[\\]^$+*?.]/g;e.exports=function(e){if("string"!==typeof e)throw new TypeError("Expected a string");return e.replace(n,"\\\\$&")}},function(e,t,r){"use strict";(function(e){var t=r(203),n=function(e,r){return function(){var n=e.apply(t,arguments);return"\x1b[".concat(n+r,"m")}},o=function(e,r){return function(){var n=e.apply(t,arguments);return"\x1b[".concat(38+r,";5;").concat(n,"m")}},a=function(e,r){return function(){var n=e.apply(t,arguments);return"\x1b[".concat(38+r,";2;").concat(n[0],";").concat(n[1],";").concat(n[2],"m")}};Object.defineProperty(e,"exports",{enumerable:!0,get:function(){var e=new Map,r={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};r.color.grey=r.color.gray;for(var i=0,l=Object.keys(r);i<l.length;i++){for(var u=l[i],c=r[u],s=0,f=Object.keys(c);s<f.length;s++){var d=f[s],p=c[d];r[d]={open:"\x1b[".concat(p[0],"m"),close:"\x1b[".concat(p[1],"m")},c[d]=r[d],e.set(p[0],p[1])}Object.defineProperty(r,u,{value:c,enumerable:!1}),Object.defineProperty(r,"codes",{value:e,enumerable:!1})}var h=function(e){return e},g=function(e,t,r){return[e,t,r]};r.color.close="\x1b[39m",r.bgColor.close="\x1b[49m",r.color.ansi={ansi:n(h,0)},r.color.ansi256={ansi256:o(h,0)},r.color.ansi16m={rgb:a(g,0)},r.bgColor.ansi={ansi:n(h,10)},r.bgColor.ansi256={ansi256:o(h,10)},r.bgColor.ansi16m={rgb:a(g,10)};for(var v=0,m=Object.keys(t);v<m.length;v++){var y=m[v];if("object"===typeof t[y]){var b=t[y];"ansi16"===y&&(y="ansi"),"ansi16"in b&&(r.color.ansi[y]=n(b.ansi16,0),r.bgColor.ansi[y]=n(b.ansi16,10)),"ansi256"in b&&(r.color.ansi256[y]=o(b.ansi256,0),r.bgColor.ansi256[y]=o(b.ansi256,10)),"rgb"in b&&(r.color.ansi16m[y]=a(b.rgb,0),r.bgColor.ansi16m[y]=a(b.rgb,10))}}return r}})}).call(this,r(202)(e))},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t,r){var n=r(87),o=r(205),a={};Object.keys(n).forEach((function(e){a[e]={},Object.defineProperty(a[e],"channels",{value:n[e].channels}),Object.defineProperty(a[e],"labels",{value:n[e].labels});var t=o(e);Object.keys(t).forEach((function(r){var n=t[r];a[e][r]=function(e){var t=function(t){if(void 0===t||null===t)return t;arguments.length>1&&(t=Array.prototype.slice.call(arguments));var r=e(t);if("object"===typeof r)for(var n=r.length,o=0;o<n;o++)r[o]=Math.round(r[o]);return r};return"conversion"in e&&(t.conversion=e.conversion),t}(n),a[e][r].raw=function(e){var t=function(t){return void 0===t||null===t?t:(arguments.length>1&&(t=Array.prototype.slice.call(arguments)),e(t))};return"conversion"in e&&(t.conversion=e.conversion),t}(n)}))})),e.exports=a},function(e,t,r){"use strict";e.exports={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}},function(e,t,r){var n=r(87);function o(e){var t=function(){for(var e={},t=Object.keys(n),r=t.length,o=0;o<r;o++)e[t[o]]={distance:-1,parent:null};return e}(),r=[e];for(t[e].distance=0;r.length;)for(var o=r.pop(),a=Object.keys(n[o]),i=a.length,l=0;l<i;l++){var u=a[l],c=t[u];-1===c.distance&&(c.distance=t[o].distance+1,c.parent=o,r.unshift(u))}return t}function a(e,t){return function(r){return t(e(r))}}function i(e,t){for(var r=[t[e].parent,e],o=n[t[e].parent][e],i=t[e].parent;t[i].parent;)r.unshift(t[i].parent),o=a(n[t[i].parent][i],o),i=t[i].parent;return o.conversion=r,o}e.exports=function(e){for(var t=o(e),r={},n=Object.keys(t),a=n.length,l=0;l<a;l++){var u=n[l];null!==t[u].parent&&(r[u]=i(u,t))}return r}},function(e,t,r){"use strict";e.exports={stdout:!1,stderr:!1}},function(e,t,r){"use strict";var n=r(52),o=/(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi,a=/(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g,i=/^([\'"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/,l=/\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi,u=new Map([["n","\\n"],["r","\\r"],["t","\\t"],["b","\\b"],["f","\\f"],["v","\\v"],["0","\\0"],["\\\\","\\\\"],["e","\x1b"],["a","\x07"]]);function c(e){return"u"===e[0]&&5===e.length||"x"===e[0]&&3===e.length?String.fromCharCode(parseInt(e.slice(1),16)):u.get(e)||e}function s(e,t){var r,o,a=[],u=t.trim().split(/\\s*,\\s*/g),s=n(u);try{for(s.s();!(o=s.n()).done;){var f=o.value;if(isNaN(f)){if(!(r=f.match(i)))throw new Error("Invalid Chalk template style argument: ".concat(f," (in style \'").concat(e,"\')"));a.push(r[2].replace(l,(function(e,t,r){return t?c(t):r})))}else a.push(Number(f))}}catch(e){s.e(e)}finally{s.f()}return a}function f(e){a.lastIndex=0;for(var t,r=[];null!==(t=a.exec(e));){var n=t[1];if(t[2]){var o=s(n,t[2]);r.push([n].concat(o))}else r.push([n])}return r}function d(e,t){var r,o={},a=n(t);try{for(a.s();!(r=a.n()).done;){var i,l=r.value,u=n(l.styles);try{for(u.s();!(i=u.n()).done;){var c=i.value;o[c[0]]=l.inverse?null:c.slice(1)}}catch(e){u.e(e)}finally{u.f()}}}catch(e){a.e(e)}finally{a.f()}for(var s=e,f=0,d=Object.keys(o);f<d.length;f++){var p=d[f];if(Array.isArray(o[p])){if(!(p in s))throw new Error("Unknown Chalk style: ".concat(p));s=o[p].length>0?s[p].apply(s,o[p]):s[p]}}return s}e.exports=function(e,t){var r=[],n=[],a=[];if(t.replace(o,(function(t,o,i,l,u,s){if(o)a.push(c(o));else if(l){var p=a.join("");a=[],n.push(0===r.length?p:d(e,r)(p)),r.push({inverse:i,styles:f(l)})}else if(u){if(0===r.length)throw new Error("Found extraneous } in Chalk template literal");n.push(d(e,r)(a.join(""))),a=[],r.pop()}else a.push(s)})),n.push(a.join("")),r.length>0){var i="Chalk template literal is missing ".concat(r.length," closing bracket").concat(1===r.length?"":"s"," (`}`)");throw new Error(i)}return n.join("")}},function(e,t,r){"use strict";r.r(t),r.d(t,"ThemeContext",(function(){return me}));r(90);var n=r(0),o=r.n(n),a=r(53),i=r.n(a),l=function(e){return{position:"relative",display:"inline-flex",flexDirection:"column",height:"100%",width:"1024px",maxWidth:"100%",overflowX:"hidden",overflowY:"auto",padding:"0.5rem",boxSizing:"border-box",textAlign:"left",fontFamily:"Consolas, Menlo, monospace",fontSize:"11px",whiteSpace:"pre-wrap",wordBreak:"break-word",lineHeight:1.5,color:e.color}},u=null;var c=function(e){var t=Object(n.useContext)(me),r=e.shortcutHandler;return Object(n.useEffect)((function(){var e=function(e){r&&r(e.key)};return window.addEventListener("keydown",e),u&&u.addEventListener("keydown",e),function(){window.removeEventListener("keydown",e),u&&u.removeEventListener("keydown",e)}}),[r]),o.a.createElement("div",{style:l(t),ref:function(e){if(e){var t=e.ownerDocument;u=t.defaultView}}},e.children)},s=function(e){return{fontFamily:"sans-serif",color:e.footer,marginTop:"0.5rem",flex:"0 0 auto"}};var f=function(e){var t=Object(n.useContext)(me);return o.a.createElement("div",{style:s(t)},e.line1,o.a.createElement("br",null),e.line2)},d=function(e){return{fontSize:"2em",fontFamily:"sans-serif",color:e.headerColor,whiteSpace:"pre-wrap",margin:"0 2rem 0.75rem 0",flex:"0 0 auto",maxHeight:"50%",overflow:"auto"}};var p=function(e){var t=Object(n.useContext)(me);return o.a.createElement("div",{style:d(t)},e.headerText)};function h(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function g(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function v(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?g(Object(r),!0).forEach((function(t){h(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):g(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}var m={position:"relative",display:"block",padding:"0.5em",marginTop:"0.5em",marginBottom:"0.5em",overflowX:"auto",whiteSpace:"pre-wrap",borderRadius:"0.25rem"},y={fontFamily:"Consolas, Menlo, monospace"};var b=function(e){var t=e.main,r=e.codeHTML,a=Object(n.useContext)(me),i=v(v({},m),{},{backgroundColor:a.primaryPreBackground,color:a.primaryPreColor}),l=v(v({},m),{},{backgroundColor:a.secondaryPreBackground,color:a.secondaryPreColor}),u=t?i:l,c={__html:r};return o.a.createElement("pre",{style:u},o.a.createElement("code",{style:y,dangerouslySetInnerHTML:c}))},w=r(33),k=r.n(w),E=new(r(88).AllHtmlEntities),x=function(e){return{reset:[e.base05,"transparent"],black:e.base05,red:e.base08,green:e.base0B,yellow:e.base08,blue:e.base0C,magenta:e.base0C,cyan:e.base0E,gray:e.base03,lightgrey:e.base01,darkgrey:e.base03}},S={"ansi-bright-black":"black","ansi-bright-yellow":"yellow","ansi-yellow":"yellow","ansi-bright-green":"green","ansi-green":"green","ansi-bright-cyan":"cyan","ansi-cyan":"cyan","ansi-bright-red":"red","ansi-red":"red","ansi-bright-magenta":"magenta","ansi-magenta":"magenta","ansi-white":"darkgrey"};var _=function(e,t){for(var r=(new k.a).ansiToJson(E.encode(e),{use_classes:!0}),n="",o=!1,a=0;a<r.length;++a)for(var i=r[a],l=i.content,u=i.fg,c=l.split("\\n"),s=0;s<c.length;++s){o||(n+=\'<span data-ansi-line="true">\',o=!0);var f=c[s].replace("\\r",""),d=x(t)[S[u]];null!=d?n+=\'<span style="color: \'+d+\';">\'+f+"</span>":(null!=u&&console.log("Missing color mapping: ",u),n+="<span>"+f+"</span>"),s<c.length-1&&(n+="</span>",o=!1,n+="<br/>")}return o&&(n+="</span>",o=!1),n},T=/^\\.(\\/[^/\\n ]+)+\\.[^/\\n ]+$/,C=[/^.*\\((\\d+):(\\d+)\\)$/,/^Line (\\d+):.+$/];var O=function(e){for(var t=e.split("\\n"),r="",n=0,o=0,a=0;a<t.length;a++){var i=k.a.ansiToText(t[a]).trim();if(i){!r&&i.match(T)&&(r=i);for(var l=0;l<C.length;){var u=i.match(C[l]);if(u){n=parseInt(u[1],10),o=parseInt(u[2],10)+1||1;break}l++}if(r&&n)break}}return r&&n?{fileName:r,lineNumber:n,colNumber:o}:null},P={cursor:"pointer"};var R=function(e){var t=Object(n.useContext)(me),r=e.error,a=e.editorHandler,i=O(r),l=null!==i&&null!==a;return o.a.createElement(c,null,o.a.createElement(p,{headerText:"Failed to compile"}),o.a.createElement("div",{onClick:l&&i?function(){return a(i)}:null,style:l?P:null},o.a.createElement(b,{main:!0,codeHTML:_(r,t)})),o.a.createElement(f,{line1:"This error occurred during the build time and cannot be dismissed."}))};function N(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function L(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function A(e,t,r){return t&&L(e.prototype,t),r&&L(e,r),e}function I(e,t){return(I=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function j(e,t){if("function"!==typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&I(e,t)}function M(e){return(M=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function D(e){return(D="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function q(e,t){return!t||"object"!==D(t)&&"function"!==typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return e}(e):t}function z(e){var t=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=M(e);if(t){var o=M(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return q(this,r)}}var U=function(e){return{color:e.closeColor,lineHeight:"1rem",fontSize:"1.5rem",padding:"1rem",cursor:"pointer",position:"absolute",right:0,top:0}};var F=function(e){var t=e.close,r=Object(n.useContext)(me);return o.a.createElement("span",{title:"Click or press Escape to dismiss.",onClick:t,style:U(r)},"\xd7")},B={marginBottom:"0.5rem"},V={marginRight:"1em"},H={border:"none",borderRadius:"4px",padding:"3px 6px",cursor:"pointer"},W=function(e){return v(v({},H),{},{backgroundColor:e.navBackground,color:e.navArrow,borderTopRightRadius:"0px",borderBottomRightRadius:"0px",marginRight:"1px"})},$=function(e){return v(v({},H),{},{backgroundColor:e.navBackground,color:e.navArrow,borderTopLeftRadius:"0px",borderBottomLeftRadius:"0px"})};var G=function(e){var t=Object(n.useContext)(me),r=e.currentError,a=e.totalErrors,i=e.previous,l=e.next;return o.a.createElement("div",{style:B},o.a.createElement("span",{style:V},o.a.createElement("button",{onClick:i,style:W(t)},"\u2190"),o.a.createElement("button",{onClick:l,style:$(t)},"\u2192")),"".concat(r," of ").concat(a," errors on the page"))};function Q(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function Y(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if("undefined"!==typeof Symbol&&Symbol.iterator in Object(e)){var r=[],n=!0,o=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(n=(i=l.next()).done)&&(r.push(i.value),!t||r.length!==t);n=!0);}catch(e){o=!0,a=e}finally{try{n||null==l.return||l.return()}finally{if(o)throw a}}return r}}(e,t)||function(e,t){if(e){if("string"===typeof e)return Q(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Q(e,t):void 0}}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function K(e,t){for(;null!=t&&"br"!==t.tagName.toLowerCase();)t=t.nextElementSibling;null!=t&&e.removeChild(t)}var X=r(89);var J=function(e){var t=Object(n.useContext)(me),r=e.lines,a=e.lineNum,i=e.columnNum,l=e.contextSize,u=e.main,c=[],s=1/0;r.forEach((function(e){var t=e.content,r=t.match(/^\\s*/);""!==t&&(s=r&&r[0]?Math.min(s,r[0].length):0)})),r.forEach((function(e){var t=e.content,r=e.lineNumber;isFinite(s)&&(t=t.substring(s)),c[r-1]=t}));var f=Object(X.codeFrameColumns)(c.join("\\n"),{start:{line:a,column:null==i?0:i-(isFinite(s)?s:0)}},{forceColor:!0,linesAbove:l,linesBelow:l}),d=_(f,t),p=document.createElement("code");p.innerHTML=d,function(e){for(var t=e.childNodes,r=0;r<t.length;++r){var n=t[r];if("span"===n.tagName.toLowerCase()){var o=n.innerText;null!=o&&"|^"===o.replace(/\\s/g,"")&&(n.style.position="absolute",K(e,n))}}}(p);var h=p.childNodes;e:for(var g=0;g<h.length;++g)for(var v=h[g].childNodes,m=0;m<v.length;++m){var y=v[m].innerText;if(null!=y&&-1!==y.indexOf(" "+a+" |"))break e}return o.a.createElement(b,{main:u,codeHTML:p.innerHTML})};function Z(e,t,r,n,o,a,i){var l;if(!i&&e&&"number"===typeof t){var u=/^[/|\\\\].*?[/|\\\\]((src|node_modules)[/|\\\\].*)/.exec(e);l=u&&u[1]?u[1]:e,l+=":"+t,r&&(l+=":"+r)}else n&&"number"===typeof o?(l=n+":"+o,a&&(l+=":"+a)):l="unknown";return l.replace("webpack://",".")}var ee=function(e){return{textDecoration:"none",color:e.anchorColor,cursor:"pointer"}},te=function(e){return{marginBottom:"1.5em",color:e.toggleColor,cursor:"pointer",border:"none",display:"block",width:"100%",textAlign:"left",background:e.toggleBackground,fontFamily:"Consolas, Menlo, monospace",fontSize:"1em",padding:"0px",lineHeight:"1.5"}};var re=function(e){var t=Object(n.useContext)(me),r=Y(Object(n.useState)(!1),2),a=r[0],i=r[1],l=function(){var t=e.frame,r=t._originalFileName,n=t._originalLineNumber;return r?-1!==r.trim().indexOf(" ")?null:{fileName:r,lineNumber:n||1}:null},u=function(){var t=l();t&&e.editorHandler(t)},c=e.frame,s=e.contextSize,f=e.critical,d=e.showCode,p=c.fileName,h=c.lineNumber,g=c.columnNumber,v=c._scriptCode,m=c._originalFileName,y=c._originalLineNumber,b=c._originalColumnNumber,w=c._originalScriptCode,k=c.getFunctionName(),E=Z(m,y,b,p,h,g,a),x=null;d&&(a&&v&&0!==v.length&&null!=h?x={lines:v,lineNum:h,columnNum:g,contextSize:s,main:f}:!a&&w&&0!==w.length&&null!=y&&(x={lines:w,lineNum:y,columnNum:b,contextSize:s,main:f}));var S=null!==l()&&null!==e.editorHandler;return o.a.createElement("div",null,o.a.createElement("div",null,k),o.a.createElement("div",{style:{fontSize:"0.9em",marginBottom:"0.9em"}},o.a.createElement("span",{style:S?ee(t):null,onClick:S?u:null,onKeyDown:S?function(e){"Enter"===e.key&&u()}:null,tabIndex:S?"0":null},E)),x&&o.a.createElement("span",null,o.a.createElement("span",{onClick:S?u:null,style:S?{cursor:"pointer"}:null},o.a.createElement(J,x)),o.a.createElement("button",{style:te(t),onClick:function(){i(!a)}},"View "+(a?"source":"compiled"))))},ne={cursor:"pointer",border:"none",display:"block",width:"100%",textAlign:"left",fontFamily:"Consolas, Menlo, monospace",fontSize:"1em",padding:"0px",lineHeight:"1.5"},oe=function(e){return v(v({},ne),{},{color:e.color,background:e.background,marginBottom:"1.5em"})},ae=function(e){return v(v({},ne),{},{color:e.color,background:e.background,marginBottom:"0.6em"})};var ie=function(e){var t=Object(n.useContext)(me),r=Y(Object(n.useState)(!0),2),a=r[0],i=r[1],l=function(){i(!a)},u=e.children.length;return o.a.createElement("div",null,o.a.createElement("button",{onClick:l,style:a?oe(t):ae(t)},(a?"\u25B6":"\u25BC")+" ".concat(u," stack frames were ")+(a?"collapsed.":"expanded.")),o.a.createElement("div",{style:{display:a?"none":"block"}},e.children,o.a.createElement("button",{onClick:l,style:ae(t)},"\u25B2 ".concat(u," stack frames were expanded."))))};function le(e){switch(e){case"EvalError":case"InternalError":case"RangeError":case"ReferenceError":case"SyntaxError":case"TypeError":case"URIError":return!0;default:return!1}}var ue={fontSize:"1em",flex:"0 1 auto",minHeight:"0px",overflow:"auto"},ce=function(e){j(r,e);var t=z(r);function r(){return N(this,r),t.apply(this,arguments)}return A(r,[{key:"renderFrames",value:function(){var e=this.props,t=e.stackFrames,r=e.errorName,n=e.contextSize,a=e.editorHandler,i=[],l=!1,u=[],c=0;return t.forEach((function(e,s){var f=e.fileName,d=function(e,t){return null==e||""===e||-1!==e.indexOf("/~/")||-1!==e.indexOf("/node_modules/")||-1!==e.trim().indexOf(" ")||null==t||""===t}(e._originalFileName,f),p=!le(r),h=d&&(p||l);d||(l=!0);var g=o.a.createElement(re,{key:"frame-"+s,frame:e,contextSize:n,critical:0===s,showCode:!h,editorHandler:a}),v=s===t.length-1;h&&u.push(g),h&&!v||(1===u.length?i.push(u[0]):u.length>1&&(c++,i.push(o.a.createElement(ie,{key:"bundle-"+c},u))),u=[]),h||i.push(g)})),i}},{key:"render",value:function(){return o.a.createElement("div",{style:ue},this.renderFrames())}}]),r}(n.Component),se={display:"flex",flexDirection:"column"};var fe=function(e){var t=e.errorRecord,r=e.editorHandler,n=t.error,a=t.unhandledRejection,i=t.contextSize,l=t.stackFrames,u=a?"Unhandled Rejection ("+n.name+")":n.name,c=n.message,s=c.match(/^\\w*:/)||!u?c:u+": "+c;return s=s.replace(/^Invariant Violation:\\s*/,"").replace(/^Warning:\\s*/,"").replace(" Check the render method","\\n\\nCheck the render method").replace(" Check your code at","\\n\\nCheck your code at"),o.a.createElement("div",{style:se},o.a.createElement(p,{headerText:s}),o.a.createElement(ce,{stackFrames:l,errorName:u,contextSize:i,editorHandler:r}))},de=function(e){j(r,e);var t=z(r);function r(){var e;N(this,r);for(var n=arguments.length,o=new Array(n),a=0;a<n;a++)o[a]=arguments[a];return(e=t.call.apply(t,[this].concat(o))).state={currentIndex:0},e.previous=function(){e.setState((function(e,t){return{currentIndex:e.currentIndex>0?e.currentIndex-1:t.errorRecords.length-1}}))},e.next=function(){e.setState((function(e,t){return{currentIndex:e.currentIndex<t.errorRecords.length-1?e.currentIndex+1:0}}))},e.shortcutHandler=function(t){"Escape"===t?e.props.close():"ArrowLeft"===t?e.previous():"ArrowRight"===t&&e.next()},e}return A(r,[{key:"render",value:function(){var e=this.props,t=e.errorRecords,r=e.close,n=t.length;return o.a.createElement(c,{shortcutHandler:this.shortcutHandler},o.a.createElement(F,{close:r}),n>1&&o.a.createElement(G,{currentError:this.state.currentIndex+1,totalErrors:n,previous:this.previous,next:this.next}),o.a.createElement(fe,{errorRecord:t[this.state.currentIndex],editorHandler:this.props.editorHandler}),o.a.createElement(f,{line1:"This screen is visible only in development. It will not appear if the app crashes in production.",line2:"Open your browser\u2019s developer console to further inspect this error.  Click the \'X\' or hit ESC to dismiss this message."}))}}]),r}(n.PureComponent),pe={background:"white",color:"black",headerColor:"#ce1126",primaryPreBackground:"rgba(206, 17, 38, 0.05)",primaryPreColor:"inherit",secondaryPreBackground:"rgba(251, 245, 180, 0.3)",secondaryPreColor:"inherit",footer:"#878e91",anchorColor:"#878e91",toggleBackground:"transparent",toggleColor:"#878e91",closeColor:"#293238",navBackground:"rgba(206, 17, 38, 0.05)",navArrow:"#ce1126",base01:"#f5f5f5",base03:"#6e6e6e",base05:"#333333",base08:"#881280",base0B:"#1155cc",base0C:"#994500",base0E:"#c80000"},he={background:"#353535",color:"white",headerColor:"#e83b46",primaryPreBackground:"rgba(206, 17, 38, 0.1)",primaryPreColor:"#fccfcf",secondaryPreBackground:"rgba(251, 245, 180, 0.1)",secondaryPreColor:"#fbf5b4",footer:"#878e91",anchorColor:"#878e91",toggleBackground:"transparent",toggleColor:"#878e91",closeColor:"#ffffff",navBackground:"rgba(206, 17, 38, 0.2)",navArrow:"#ce1126",base01:"#282a2e",base03:"#969896",base05:"#c5c8c6",base08:"#cc6666",base0B:"#b5bd68",base0C:"#8abeb7",base0E:"#b294bb"};var ge=null,ve=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?he:pe,me=Object(n.createContext)();window.updateContent=function(e){var t,r,n,a,l,u=(r=(t=e).currentBuildError,n=t.currentRuntimeErrorRecords,a=t.dismissRuntimeErrors,l=t.editorHandler,r?o.a.createElement(me.Provider,{value:ve},o.a.createElement(R,{error:r,editorHandler:l})):n.length>0?o.a.createElement(me.Provider,{value:ve},o.a.createElement(de,{errorRecords:n,close:a,editorHandler:l})):null);return null===u?(i.a.unmountComponentAtNode(ge),!1):(i.a.render(u,ge),!0)},document.body.style.margin="0",document.body.style["max-width"]="100vw",function(e,t){for(var r in e.setAttribute("style",""),t)t.hasOwnProperty(r)&&(e.style[r]=t[r])}(ge=document.createElement("div"),{width:"100%",height:"100%","box-sizing":"border-box","text-align":"center","background-color":ve.background}),document.body.appendChild(ge),window.parent.__REACT_ERROR_OVERLAY_GLOBAL_HOOK__.iframeReady()}]);', ee = null, te = !1, re = !1, ne = null, oe = null, ae = [], ie = null, le = null;
            function ue(e) {
                ne = e, ee && me();
            }
            function ce(e) {
                oe = e, me();
            }
            function se(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                ie = t, X(pe(t))(e);
            }
            function fe() {
                oe = null, me();
            }
            function de(e) {
                if (null !== le) throw new Error("Already listening");
                e.launchEditorEndpoint && console.warn("Warning: `startReportingRuntimeErrors` doesn\u2019t accept `launchEditorEndpoint` argument anymore. Use `listenToOpenInEditor` instead with your own implementation to open errors in editor "), ie = e, le = K(pe(e), e.filename);
            }
            var pe = function(e) {
                return function(t) {
                    try {
                        "function" == typeof e.onError && e.onError.call(null);
                    } finally{
                        if (ae.some(function(e) {
                            return e.error === t.error;
                        })) return;
                        ae = ae.concat([
                            t
                        ]), me();
                    }
                };
            };
            function he() {
                ae = [], me();
            }
            function ge() {
                if (null === le) throw new Error("Not currently listening");
                ie = null;
                try {
                    le();
                } finally{
                    le = null;
                }
            }
            function me() {
                if (!te) {
                    if (re) ve();
                    else {
                        te = !0;
                        var e = window.document.createElement("iframe");
                        !function(e, t) {
                            for(var r in e.setAttribute("style", ""), t)t.hasOwnProperty(r) && (e.style[r] = t[r]);
                        }(e, J), e.onload = function() {
                            var t = e.contentDocument;
                            if (null != t && null != t.body) {
                                ee = e;
                                var r = e.contentWindow.document.createElement("script");
                                r.type = "text/javascript", r.innerHTML = Z, t.body.appendChild(r);
                            }
                        }, window.document.body.appendChild(e);
                    }
                }
            }
            function ve() {
                if (!ie) throw new Error("Expected options to be injected.");
                if (!ee) throw new Error("Iframe has not been created yet.");
                ee.contentWindow.updateContent({
                    currentBuildError: oe,
                    currentRuntimeErrorRecords: ae,
                    dismissRuntimeErrors: he,
                    editorHandler: ne
                }) || (window.document.body.removeChild(ee), ee = null, re = !1);
            }
            window.__REACT_ERROR_OVERLAY_GLOBAL_HOOK__ = window.__REACT_ERROR_OVERLAY_GLOBAL_HOOK__ || {}, window.__REACT_ERROR_OVERLAY_GLOBAL_HOOK__.iframeReady = function() {
                re = !0, te = !1, ve();
            };
        }
    ]);
});

},{"d1546958eb39fdcf":"d5jf4"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"8lqZg":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$20e5 = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$20e5.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _client = require("react-dom/client");
var _app = require("./components/App");
var _appDefault = parcelHelpers.interopDefault(_app);
var _resetCss = require("./reset.css");
var _stylesCss = require("./styles.css");
const root = (0, _client.createRoot)(document.querySelector("#root"));
root.render(/*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _appDefault.default), {}, void 0, false, {
    fileName: "src/index.js",
    lineNumber: 10,
    columnNumber: 13
}, undefined));

  $parcel$ReactRefreshHelpers$20e5.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","react-dom/client":"lOjBx","./components/App":"2Pgyy","./reset.css":"8XPx9","./styles.css":"lW6qc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru"}],"iTorj":[function(require,module,exports) {
"use strict";
module.exports = require("ee51401569654d91");

},{"ee51401569654d91":"48uCM"}],"48uCM":[function(require,module,exports) {
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
(function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function disabledLog() {}
    function disableLogs() {
        if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
                configurable: !0,
                enumerable: !0,
                value: disabledLog,
                writable: !0
            };
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
            var props = {
                configurable: !0,
                enumerable: !0,
                writable: !0
            };
            Object.defineProperties(console, {
                log: assign({}, props, {
                    value: prevLog
                }),
                info: assign({}, props, {
                    value: prevInfo
                }),
                warn: assign({}, props, {
                    value: prevWarn
                }),
                error: assign({}, props, {
                    value: prevError
                }),
                group: assign({}, props, {
                    value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                    value: prevGroupEnd
                })
            });
        }
        0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix) try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
        return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = !0;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher = null;
        previousDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
            var RunInRootFrame = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (construct) {
                            var Fake = function() {
                                throw Error();
                            };
                            Object.defineProperty(Fake.prototype, "props", {
                                set: function() {
                                    throw Error();
                                }
                            });
                            if ("object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(Fake, []);
                                } catch (x) {
                                    var control = x;
                                }
                                Reflect.construct(fn, [], Fake);
                            } else {
                                try {
                                    Fake.call();
                                } catch (x$0) {
                                    control = x$0;
                                }
                                fn.call(Fake.prototype);
                            }
                        } else {
                            try {
                                throw Error();
                            } catch (x$1) {
                                control = x$1;
                            }
                            (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
                        }
                    } catch (sample) {
                        if (sample && control && "string" === typeof sample.stack) return [
                            sample.stack,
                            control.stack
                        ];
                    }
                    return [
                        null,
                        null
                    ];
                }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
                var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");)namePropDescriptor++;
                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");)_RunInRootFrame$Deter++;
                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;
                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                            var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                            fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                            "function" === typeof fn && componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                    }
                    break;
                }
            }
        } finally{
            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
        if (null == type) return "";
        if ("function" === typeof type) {
            var prototype = type.prototype;
            return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
        }
        if ("string" === typeof type) return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
        }
        if ("object" === typeof type) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return type = describeNativeComponentFrame(type.render, !1), type;
            case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type);
            case REACT_LAZY_TYPE:
                prototype = type._payload;
                type = type._init;
                try {
                    return describeUnknownElementTypeFrameInDEV(type(prototype));
                } catch (x) {}
        }
        return "";
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self) {
        if ("string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId)) {
            var children = config.children;
            if (void 0 !== children) {
                if (isStaticChildren) {
                    if (isArrayImpl(children)) {
                        for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren], type);
                        Object.freeze && Object.freeze(children);
                    } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                } else validateChildKeys(children, type);
            }
        } else {
            children = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) children += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            null === type ? isStaticChildren = "null" : isArrayImpl(type) ? isStaticChildren = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (isStaticChildren = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", children = " Did you accidentally export a JSX literal instead of a component?") : isStaticChildren = typeof type;
            console.error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", isStaticChildren, children);
        }
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey);
    }
    function validateChildKeys(node, parentType) {
        if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) {
            if (isArrayImpl(node)) for(var i = 0; i < node.length; i++){
                var child = node[i];
                isValidElement(child) && validateExplicitKey(child, parentType);
            }
            else if (isValidElement(node)) node._store && (node._store.validated = 1);
            else if (null === node || "object" !== typeof node ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for(; !(node = i.next()).done;)isValidElement(node.value) && validateExplicitKey(node.value, parentType);
        }
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function validateExplicitKey(element, parentType) {
        if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
            ownerHasKeyUseWarning[parentType] = !0;
            var childOwner = "";
            element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
            var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = function() {
                var stack = describeUnknownElementTypeFrameInDEV(element.type);
                prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
                return stack;
            };
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
        }
    }
    function getCurrentComponentErrorInfo(parentType) {
        var info = "", owner = getOwner();
        owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
        info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
        return info;
    }
    var React = require("58362d9d82be395f"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, assign = Object.assign, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix, suffix, reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {}, ownerHasKeyUseWarning = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);
    };
})();

},{"58362d9d82be395f":"21dqq"}],"21dqq":[function(require,module,exports) {
"use strict";
module.exports = require("a569817e6ea559f6");

},{"a569817e6ea559f6":"6YvXz"}],"6YvXz":[function(require,module,exports) {
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var process = require("9ffea7b9cafb49c3");
"use strict";
(function() {
    function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
            get: function() {
                console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
            }
        });
    }
    function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = !0);
    }
    function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function isValidElementType(type) {
        return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId) ? !0 : !1;
    }
    function disabledLog() {}
    function disableLogs() {
        if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
                configurable: !0,
                enumerable: !0,
                value: disabledLog,
                writable: !0
            };
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
            var props = {
                configurable: !0,
                enumerable: !0,
                writable: !0
            };
            Object.defineProperties(console, {
                log: assign({}, props, {
                    value: prevLog
                }),
                info: assign({}, props, {
                    value: prevInfo
                }),
                warn: assign({}, props, {
                    value: prevWarn
                }),
                error: assign({}, props, {
                    value: prevError
                }),
                group: assign({}, props, {
                    value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                    value: prevGroupEnd
                })
            });
        }
        0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix) try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
        return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = !0;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher = null;
        previousDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
            var RunInRootFrame = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (construct) {
                            var Fake = function() {
                                throw Error();
                            };
                            Object.defineProperty(Fake.prototype, "props", {
                                set: function() {
                                    throw Error();
                                }
                            });
                            if ("object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(Fake, []);
                                } catch (x) {
                                    var control = x;
                                }
                                Reflect.construct(fn, [], Fake);
                            } else {
                                try {
                                    Fake.call();
                                } catch (x$0) {
                                    control = x$0;
                                }
                                fn.call(Fake.prototype);
                            }
                        } else {
                            try {
                                throw Error();
                            } catch (x$1) {
                                control = x$1;
                            }
                            (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
                        }
                    } catch (sample) {
                        if (sample && control && "string" === typeof sample.stack) return [
                            sample.stack,
                            control.stack
                        ];
                    }
                    return [
                        null,
                        null
                    ];
                }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
                var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");)namePropDescriptor++;
                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");)_RunInRootFrame$Deter++;
                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;
                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                            var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                            fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                            "function" === typeof fn && componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                    }
                    break;
                }
            }
        } finally{
            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
        if (null == type) return "";
        if ("function" === typeof type) {
            var prototype = type.prototype;
            return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
        }
        if ("string" === typeof type) return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
        }
        if ("object" === typeof type) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return type = describeNativeComponentFrame(type.render, !1), type;
            case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type);
            case REACT_LAZY_TYPE:
                prototype = type._payload;
                type = type._init;
                try {
                    return describeUnknownElementTypeFrameInDEV(type(prototype));
                } catch (x) {}
        }
        return "";
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement(oldElement.type, newKey, void 0, void 0, oldElement._owner, oldElement.props);
        newKey._store.validated = oldElement._store.validated;
        return newKey;
    }
    function validateChildKeys(node, parentType) {
        if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) {
            if (isArrayImpl(node)) for(var i = 0; i < node.length; i++){
                var child = node[i];
                isValidElement(child) && validateExplicitKey(child, parentType);
            }
            else if (isValidElement(node)) node._store && (node._store.validated = 1);
            else if (i = getIteratorFn(node), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for(; !(node = i.next()).done;)isValidElement(node.value) && validateExplicitKey(node.value, parentType);
        }
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function validateExplicitKey(element, parentType) {
        if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
            ownerHasKeyUseWarning[parentType] = !0;
            var childOwner = "";
            element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
            var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = function() {
                var stack = describeUnknownElementTypeFrameInDEV(element.type);
                prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
                return stack;
            };
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
        }
    }
    function getCurrentComponentErrorInfo(parentType) {
        var info = "", owner = getOwner();
        owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
        info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
        return info;
    }
    function escape(key) {
        var escaperLookup = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + key.replace(/[=:]/g, function(match) {
            return escaperLookup[match];
        });
    }
    function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
    }
    function noop$1() {}
    function resolveThenable(thenable) {
        switch(thenable.status){
            case "fulfilled":
                return thenable.value;
            case "rejected":
                throw thenable.reason;
            default:
                switch("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
                    "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                }, function(error) {
                    "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                })), thenable.status){
                    case "fulfilled":
                        return thenable.value;
                    case "rejected":
                        throw thenable.reason;
                }
        }
        throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = !1;
        if (null === children) invokeCallback = !0;
        else switch(type){
            case "bigint":
            case "string":
            case "number":
                invokeCallback = !0;
                break;
            case "object":
                switch(children.$$typeof){
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                        invokeCallback = !0;
                        break;
                    case REACT_LAZY_TYPE:
                        return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
                }
        }
        if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
                return c;
            })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children)) for(var i = 0; i < children.length; i++)nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
        else if (i = getIteratorFn(children), "function" === typeof i) for(i === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0), children = i.call(children), i = 0; !(nameSoFar = children.next()).done;)nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
        else if ("object" === type) {
            if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
            array = String(children);
            throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
        }
        return invokeCallback;
    }
    function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
        });
        return result;
    }
    function lazyInitializer(payload) {
        if (-1 === payload._status) {
            var ctor = payload._result;
            ctor = ctor();
            ctor.then(function(moduleObject) {
                if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
            }, function(error) {
                if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
            });
            -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return ctor = payload._result, void 0 === ctor && console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", ctor), "default" in ctor || console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", ctor), ctor.default;
        throw payload._result;
    }
    function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
        return dispatcher;
    }
    function noop() {}
    function enqueueTask(task) {
        if (null === enqueueTaskImpl) try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
        } catch (_err) {
            enqueueTaskImpl = function(callback) {
                !1 === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = !0, "undefined" === typeof MessageChannel && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
            };
        }
        return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
        actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue) {
            if (0 !== queue.length) try {
                flushActQueue(queue);
                enqueueTask(function() {
                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
                return;
            } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
            }
            else ReactSharedInternals.actQueue = null;
        }
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
    }
    function flushActQueue(queue) {
        if (!isFlushing) {
            isFlushing = !0;
            var i = 0;
            try {
                for(; i < queue.length; i++){
                    var callback = queue[i];
                    do {
                        ReactSharedInternals.didUsePromise = !1;
                        var continuation = callback(!1);
                        if (null !== continuation) {
                            if (ReactSharedInternals.didUsePromise) {
                                queue[i] = callback;
                                queue.splice(0, i);
                                return;
                            }
                            callback = continuation;
                        } else break;
                    }while (1);
                }
                queue.length = 0;
            } catch (error) {
                queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally{
                isFlushing = !1;
            }
        }
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: function() {
            return !1;
        },
        enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
        }
    }, assign = Object.assign, emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
        isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
    }, fnName;
    for(fnName in deprecatedAPIs)deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = !0;
    var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null
    }, hasOwnProperty = Object.prototype.hasOwnProperty, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix, suffix, reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var ownerHasKeyUseWarning = {}, didWarnAboutMaps = !1, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
                error: error
            });
            if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
        }
        console.error(error);
    }, didWarnAboutMessageChannel = !1, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = !1, isFlushing = !1, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
            return queueMicrotask(callback);
        });
    } : enqueueTask;
    exports.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
                forEachFunc.apply(this, arguments);
            }, forEachContext);
        },
        count: function(children) {
            var n = 0;
            mapChildren(children, function() {
                n++;
            });
            return n;
        },
        toArray: function(children) {
            return mapChildren(children, function(child) {
                return child;
            }) || [];
        },
        only: function(children) {
            if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
            return children;
        }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = !1;
        try {
            var result = callback();
        } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
        }
        if (0 < ReactSharedInternals.thrownErrors.length) throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
                didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            });
            return {
                then: function(resolve, reject) {
                    didAwaitActCall = !0;
                    thenable.then(function(returnValue) {
                        popActScope(prevActQueue, prevActScopeDepth);
                        if (0 === prevActScopeDepth) {
                            try {
                                flushActQueue(queue), enqueueTask(function() {
                                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                                });
                            } catch (error$2) {
                                ReactSharedInternals.thrownErrors.push(error$2);
                            }
                            if (0 < ReactSharedInternals.thrownErrors.length) {
                                var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                                ReactSharedInternals.thrownErrors.length = 0;
                                reject(_thrownError);
                            }
                        } else resolve(returnValue);
                    }, function(error) {
                        popActScope(prevActQueue, prevActScopeDepth);
                        0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                    });
                }
            };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length) throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
            then: function(resolve, reject) {
                didAwaitActCall = !0;
                0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                    return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);
                })) : resolve(returnValue$jscomp$0);
            }
        };
    };
    exports.cache = function(fn) {
        return function() {
            return fn.apply(null, arguments);
        };
    };
    exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
        var props = assign({}, element.props), key = element.key, owner = element._owner;
        if (null != config) {
            var JSCompiler_inline_result;
            a: {
                if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config, "ref").get) && JSCompiler_inline_result.isReactWarning) {
                    JSCompiler_inline_result = !1;
                    break a;
                }
                JSCompiler_inline_result = void 0 !== config.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
            for(propName in config)!hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for(var i = 0; i < propName; i++)JSCompiler_inline_result[i] = arguments[i + 2];
            props.children = JSCompiler_inline_result;
        }
        props = ReactElement(element.type, key, void 0, void 0, owner, props);
        for(key = 2; key < arguments.length; key++)validateChildKeys(arguments[key], props.type);
        return props;
    };
    exports.createContext = function(defaultValue) {
        defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
    };
    exports.createElement = function(type, config, children) {
        if (isValidElementType(type)) for(var i = 2; i < arguments.length; i++)validateChildKeys(arguments[i], type);
        else {
            i = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) i += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            if (null === type) var typeString = "null";
            else isArrayImpl(type) ? typeString = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", i = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type;
            console.error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, i);
        }
        var propName;
        i = {};
        typeString = null;
        if (null != config) for(propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = !0, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config) && (checkKeyStringCoercion(config.key), typeString = "" + config.key), config)hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) i.children = children;
        else if (1 < childrenLength) {
            for(var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i.children = childArray;
        }
        if (type && type.defaultProps) for(propName in childrenLength = type.defaultProps, childrenLength)void 0 === i[propName] && (i[propName] = childrenLength[propName]);
        typeString && defineKeyPropWarningGetter(i, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, typeString, void 0, void 0, getOwner(), i);
    };
    exports.createRef = function() {
        var refObject = {
            current: null
        };
        Object.seal(refObject);
        return refObject;
    };
    exports.forwardRef = function(render) {
        null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : "function" !== typeof render ? console.error("forwardRef requires a render function but was given %s.", null === render ? "null" : typeof render) : 0 !== render.length && 2 !== render.length && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", 1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
        null != render && null != render.defaultProps && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
        var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: render
        }, ownName;
        Object.defineProperty(elementType, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name;
                render.name || render.displayName || (Object.defineProperty(render, "name", {
                    value: name
                }), render.displayName = name);
            }
        });
        return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
        return {
            $$typeof: REACT_LAZY_TYPE,
            _payload: {
                _status: -1,
                _result: ctor
            },
            _init: lazyInitializer
        };
    };
    exports.memo = function(type, compare) {
        isValidElementType(type) || console.error("memo: The first argument must be a component. Instead received: %s", null === type ? "null" : typeof type);
        compare = {
            $$typeof: REACT_MEMO_TYPE,
            type: type,
            compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name;
                type.name || type.displayName || (Object.defineProperty(type, "name", {
                    value: name
                }), type.displayName = name);
            }
        });
        return compare;
    };
    exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        currentTransition._updatedFibers = new Set();
        try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
            reportGlobalError(error);
        } finally{
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), ReactSharedInternals.T = prevTransition;
        }
    };
    exports.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function(usable) {
        return resolveDispatcher().use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
        var dispatcher = resolveDispatcher();
        Context.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
        return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, deps) {
        return resolveDispatcher().useEffect(create, deps);
    };
    exports.useId = function() {
        return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function(ref, create, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
        return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
        return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
        return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init) {
        return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    };
    exports.useTransition = function() {
        return resolveDispatcher().useTransition();
    };
    exports.version = "19.0.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
})();

},{"9ffea7b9cafb49c3":"d5jf4"}],"lOjBx":[function(require,module,exports) {
"use strict";
function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") return;
    var err;
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error("^_^");
}
module.exports = require("2b53550ce04dc092");

},{"2b53550ce04dc092":"dztFz"}],"dztFz":[function(require,module,exports) {
/**
 * @license React
 * react-dom-client.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/ var process = require("4a48913baa1a8f0");
"use strict";
(function() {
    function findHook(fiber, id) {
        for(fiber = fiber.memoizedState; null !== fiber && 0 < id;)fiber = fiber.next, id--;
        return fiber;
    }
    function copyWithSetImpl(obj, path, index, value) {
        if (index >= path.length) return value;
        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
        updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
        return updated;
    }
    function copyWithRename(obj, oldPath, newPath) {
        if (oldPath.length !== newPath.length) console.warn("copyWithRename() expects paths of the same length");
        else {
            for(var i = 0; i < newPath.length - 1; i++)if (oldPath[i] !== newPath[i]) {
                console.warn("copyWithRename() expects paths to be the same except for the deepest key");
                return;
            }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
        }
    }
    function copyWithRenameImpl(obj, oldPath, newPath, index) {
        var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
        index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);
        return updated;
    }
    function copyWithDeleteImpl(obj, path, index) {
        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
        if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
        updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
        return updated;
    }
    function shouldSuspendImpl() {
        return !1;
    }
    function shouldErrorImpl() {
        return null;
    }
    function createFiber(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
    }
    function warnInvalidHookAccess() {
        console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
    }
    function warnInvalidContextAccess() {
        console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    }
    function noop$2() {}
    function warnForMissingKey() {}
    function setToSortedString(set) {
        var array = [];
        set.forEach(function(value) {
            array.push(value);
        });
        return array.sort().join(", ");
    }
    function scheduleRoot(root, element) {
        root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork$1());
    }
    function scheduleRefresh(root, update) {
        if (null !== resolveFamily) {
            var staleFamilies = update.staleFamilies;
            update = update.updatedFamilies;
            flushPassiveEffects();
            scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);
            flushSyncWork$1();
        }
    }
    function setRefreshHandler(handler) {
        resolveFamily = handler;
    }
    function isValidContainer(node) {
        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
    }
    function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function getComponentNameFromOwner(owner) {
        return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
    }
    function getComponentNameFromFiber(fiber) {
        var type = fiber.type;
        switch(fiber.tag){
            case 24:
                return "Cache";
            case 9:
                return (type._context.displayName || "Context") + ".Consumer";
            case 10:
                return (type.displayName || "Context") + ".Provider";
            case 18:
                return "DehydratedFragment";
            case 11:
                return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
            case 7:
                return "Fragment";
            case 26:
            case 27:
            case 5:
                return type;
            case 4:
                return "Portal";
            case 3:
                return "Root";
            case 6:
                return "Text";
            case 16:
                return getComponentNameFromType(type);
            case 8:
                return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
            case 22:
                return "Offscreen";
            case 12:
                return "Profiler";
            case 21:
                return "Scope";
            case 13:
                return "Suspense";
            case 19:
                return "SuspenseList";
            case 25:
                return "TracingMarker";
            case 1:
            case 0:
            case 14:
            case 15:
                if ("function" === typeof type) return type.displayName || type.name || null;
                if ("string" === typeof type) return type;
                break;
            case 29:
                type = fiber._debugInfo;
                if (null != type) {
                    for(var i = type.length - 1; 0 <= i; i--)if ("string" === typeof type[i].name) return type[i].name;
                }
                if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);
        }
        return null;
    }
    function disabledLog() {}
    function disableLogs() {
        if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
                configurable: !0,
                enumerable: !0,
                value: disabledLog,
                writable: !0
            };
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
            var props = {
                configurable: !0,
                enumerable: !0,
                writable: !0
            };
            Object.defineProperties(console, {
                log: assign({}, props, {
                    value: prevLog
                }),
                info: assign({}, props, {
                    value: prevInfo
                }),
                warn: assign({}, props, {
                    value: prevWarn
                }),
                error: assign({}, props, {
                    value: prevError
                }),
                group: assign({}, props, {
                    value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                    value: prevGroupEnd
                })
            });
        }
        0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix) try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
        return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = !0;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher = null;
        previousDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
            var RunInRootFrame = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (construct) {
                            var Fake = function() {
                                throw Error();
                            };
                            Object.defineProperty(Fake.prototype, "props", {
                                set: function() {
                                    throw Error();
                                }
                            });
                            if ("object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(Fake, []);
                                } catch (x) {
                                    var control = x;
                                }
                                Reflect.construct(fn, [], Fake);
                            } else {
                                try {
                                    Fake.call();
                                } catch (x$0) {
                                    control = x$0;
                                }
                                fn.call(Fake.prototype);
                            }
                        } else {
                            try {
                                throw Error();
                            } catch (x$1) {
                                control = x$1;
                            }
                            (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
                        }
                    } catch (sample) {
                        if (sample && control && "string" === typeof sample.stack) return [
                            sample.stack,
                            control.stack
                        ];
                    }
                    return [
                        null,
                        null
                    ];
                }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
                var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");)namePropDescriptor++;
                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");)_RunInRootFrame$Deter++;
                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;
                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                            var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                            fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                            "function" === typeof fn && componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                    }
                    break;
                }
            }
        } finally{
            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
    }
    function describeFiber(fiber) {
        switch(fiber.tag){
            case 26:
            case 27:
            case 5:
                return describeBuiltInComponentFrame(fiber.type);
            case 16:
                return describeBuiltInComponentFrame("Lazy");
            case 13:
                return describeBuiltInComponentFrame("Suspense");
            case 19:
                return describeBuiltInComponentFrame("SuspenseList");
            case 0:
            case 15:
                return fiber = describeNativeComponentFrame(fiber.type, !1), fiber;
            case 11:
                return fiber = describeNativeComponentFrame(fiber.type.render, !1), fiber;
            case 1:
                return fiber = describeNativeComponentFrame(fiber.type, !0), fiber;
            default:
                return "";
        }
    }
    function getStackByFiberInDevAndProd(workInProgress) {
        try {
            var info = "";
            do {
                info += describeFiber(workInProgress);
                var debugInfo = workInProgress._debugInfo;
                if (debugInfo) for(var i = debugInfo.length - 1; 0 <= i; i--){
                    var entry = debugInfo[i];
                    if ("string" === typeof entry.name) {
                        var JSCompiler_temp_const = info, env = entry.env;
                        var JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (env ? " [" + env + "]" : ""));
                        info = JSCompiler_temp_const + JSCompiler_inline_result;
                    }
                }
                workInProgress = workInProgress.return;
            }while (workInProgress);
            return info;
        } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
    }
    function getCurrentFiberOwnerNameInDevOrNull() {
        if (null === current) return null;
        var owner = current._debugOwner;
        return null != owner ? getComponentNameFromOwner(owner) : null;
    }
    function getCurrentFiberStackInDev() {
        return null === current ? "" : getStackByFiberInDevAndProd(current);
    }
    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
        var previousFiber = current;
        ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
        isRendering = !1;
        current = fiber;
        try {
            return callback(arg0, arg1, arg2, arg3, arg4);
        } finally{
            current = previousFiber;
        }
        throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
    }
    function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for(; node.return;)node = node.return;
        else {
            fiber = node;
            do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
            while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
            if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
    }
    function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber) throw Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
            alternate = getNearestMountedFiber(fiber);
            if (null === alternate) throw Error("Unable to find node on an unmounted component.");
            return alternate !== fiber ? null : fiber;
        }
        for(var a = fiber, b = alternate;;){
            var parentA = a.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
                b = parentA.return;
                if (null !== b) {
                    a = b;
                    continue;
                }
                break;
            }
            if (parentA.child === parentB.child) {
                for(parentB = parentA.child; parentB;){
                    if (parentB === a) return assertIsMounted(parentA), fiber;
                    if (parentB === b) return assertIsMounted(parentA), alternate;
                    parentB = parentB.sibling;
                }
                throw Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) a = parentA, b = parentB;
            else {
                for(var didFindChild = !1, _child = parentA.child; _child;){
                    if (_child === a) {
                        didFindChild = !0;
                        a = parentA;
                        b = parentB;
                        break;
                    }
                    if (_child === b) {
                        didFindChild = !0;
                        b = parentA;
                        a = parentB;
                        break;
                    }
                    _child = _child.sibling;
                }
                if (!didFindChild) {
                    for(_child = parentB.child; _child;){
                        if (_child === a) {
                            didFindChild = !0;
                            a = parentB;
                            b = parentA;
                            break;
                        }
                        if (_child === b) {
                            didFindChild = !0;
                            b = parentB;
                            a = parentA;
                            break;
                        }
                        _child = _child.sibling;
                    }
                    if (!didFindChild) throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                }
            }
            if (a.alternate !== b) throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
        }
        if (3 !== a.tag) throw Error("Unable to find node on an unmounted component.");
        return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for(node = node.child; null !== node;){
            tag = findCurrentHostFiberImpl(node);
            if (null !== tag) return tag;
            node = node.sibling;
        }
        return null;
    }
    function createCursor(defaultValue) {
        return {
            current: defaultValue
        };
    }
    function pop(cursor, fiber) {
        0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
    }
    function push(cursor, value, fiber) {
        index$jscomp$0++;
        valueStack[index$jscomp$0] = cursor.current;
        fiberStack[index$jscomp$0] = fiber;
        cursor.current = value;
    }
    function requiredContext(c) {
        null === c && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
        return c;
    }
    function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor, null, fiber);
        var nextRootContext = nextRootInstance.nodeType;
        switch(nextRootContext){
            case 9:
            case 11:
                nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
                nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
                break;
            default:
                if (nextRootInstance = 8 === nextRootContext ? nextRootInstance.parentNode : nextRootInstance, nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI) nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(nextRootInstance, nextRootContext);
                else switch(nextRootContext){
                    case "svg":
                        nextRootInstance = HostContextNamespaceSvg;
                        break;
                    case "math":
                        nextRootInstance = HostContextNamespaceMath;
                        break;
                    default:
                        nextRootInstance = HostContextNamespaceNone;
                }
        }
        nextRootContext = nextRootContext.toLowerCase();
        nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
        nextRootContext = {
            context: nextRootInstance,
            ancestorInfo: nextRootContext
        };
        pop(contextStackCursor, fiber);
        push(contextStackCursor, nextRootContext, fiber);
    }
    function popHostContainer(fiber) {
        pop(contextStackCursor, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
        return requiredContext(contextStackCursor.current);
    }
    function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
        var context = requiredContext(contextStackCursor.current);
        var type = fiber.type;
        var nextContext = getChildHostContextProd(context.context, type);
        type = updatedAncestorInfoDev(context.ancestorInfo, type);
        nextContext = {
            context: nextContext,
            ancestorInfo: type
        };
        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
    }
    function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
    }
    function typeName(value) {
        return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
    }
    function willCoercionThrow(value) {
        try {
            return testStringCoercion(value), !1;
        } catch (e) {
            return !0;
        }
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value)) return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName(value)), testStringCoercion(value);
    }
    function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value)) return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propName, typeName(value)), testStringCoercion(value);
    }
    function checkFormFieldValueStringCoercion(value) {
        if (willCoercionThrow(value)) return console.error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.", typeName(value)), testStringCoercion(value);
    }
    function injectInternals(internals) {
        if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled) return !0;
        if (!hook.supportsFiber) return console.error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"), !0;
        try {
            rendererID = hook.inject(internals), injectedHook = hook;
        } catch (err) {
            console.error("React instrumentation encountered an error: %s.", err);
        }
        return hook.checkDCE ? !0 : !1;
    }
    function onCommitRoot$1(root, eventPriority) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
            var didError = 128 === (root.current.flags & 128);
            switch(eventPriority){
                case DiscreteEventPriority:
                    var schedulerPriority = ImmediatePriority;
                    break;
                case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                case DefaultEventPriority:
                    schedulerPriority = NormalPriority$1;
                    break;
                case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                default:
                    schedulerPriority = NormalPriority$1;
            }
            injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);
        } catch (err) {
            hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
        }
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode) try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
            hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
        }
    }
    function injectProfilingHooks(profilingHooks) {
        injectedProfilingHooks = profilingHooks;
    }
    function markCommitStopped() {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();
    }
    function markComponentRenderStarted(fiber) {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);
    }
    function markComponentRenderStopped() {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();
    }
    function markRenderStarted(lanes) {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);
    }
    function markRenderStopped() {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();
    }
    function markStateUpdateScheduled(fiber, lane) {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
    }
    function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
    }
    function getLabelForLane(lane) {
        if (lane & 1) return "SyncHydrationLane";
        if (lane & 2) return "Sync";
        if (lane & 4) return "InputContinuousHydration";
        if (lane & 8) return "InputContinuous";
        if (lane & 16) return "DefaultHydration";
        if (lane & 32) return "Default";
        if (lane & 64) return "TransitionHydration";
        if (lane & 4194176) return "Transition";
        if (lane & 62914560) return "Retry";
        if (lane & 67108864) return "SelectiveHydration";
        if (lane & 134217728) return "IdleHydration";
        if (lane & 268435456) return "Idle";
        if (lane & 536870912) return "Offscreen";
        if (lane & 1073741824) return "Deferred";
    }
    function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch(lanes & -lanes){
            case 1:
                return 1;
            case 2:
                return 2;
            case 4:
                return 4;
            case 8:
                return 8;
            case 16:
                return 16;
            case 32:
                return 32;
            case 64:
                return 64;
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return lanes & 4194176;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
                return lanes & 62914560;
            case 67108864:
                return 67108864;
            case 134217728:
                return 134217728;
            case 268435456:
                return 268435456;
            case 536870912:
                return 536870912;
            case 1073741824:
                return 0;
            default:
                return console.error("Should have found matching lanes. This is a bug in React."), lanes;
        }
    }
    function getNextLanes(root, wipLanes) {
        var pendingLanes = root.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, warmLanes = root.warmLanes;
        root = 0 !== root.finishedLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root, renderLanes) {
        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);
    }
    function computeExpirationTime(lane, currentTime) {
        switch(lane){
            case 1:
            case 2:
            case 4:
            case 8:
                return currentTime + 250;
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return currentTime + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
                return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
                return -1;
            default:
                return console.error("Should have found matching lanes. This is a bug in React."), -1;
        }
    }
    function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
        return lane;
    }
    function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
    }
    function createLaneMap(initial) {
        for(var laneMap = [], i = 0; 31 > i; i++)laneMap.push(initial);
        return laneMap;
    }
    function markRootUpdated$1(root, updateLane) {
        root.pendingLanes |= updateLane;
        268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
    }
    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root.pendingLanes;
        root.pendingLanes = remainingLanes;
        root.suspendedLanes = 0;
        root.pingedLanes = 0;
        root.warmLanes = 0;
        root.expiredLanes &= remainingLanes;
        root.entangledLanes &= remainingLanes;
        root.errorRecoveryDisabledLanes &= remainingLanes;
        root.shellSuspendCounter = 0;
        var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;
        for(remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;){
            var index = 31 - clz32(remainingLanes), lane = 1 << index;
            entanglements[index] = 0;
            expirationTimes[index] = -1;
            var hiddenUpdatesForLane = hiddenUpdates[index];
            if (null !== hiddenUpdatesForLane) for(hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++){
                var update = hiddenUpdatesForLane[index];
                null !== update && (update.lane &= -536870913);
            }
            remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
        root.pendingLanes |= spawnedLane;
        root.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root.entangledLanes |= spawnedLane;
        root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;
    }
    function markRootEntangled(root, entangledLanes) {
        var rootEntangledLanes = root.entangledLanes |= entangledLanes;
        for(root = root.entanglements; rootEntangledLanes;){
            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
            lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);
            rootEntangledLanes &= ~lane;
        }
    }
    function addFiberToLanesMap(root, fiber, lanes) {
        if (isDevToolsPresent) for(root = root.pendingUpdatersLaneMap; 0 < lanes;){
            var index = 31 - clz32(lanes), lane = 1 << index;
            root[index].add(fiber);
            lanes &= ~lane;
        }
    }
    function movePendingFibersToMemoized(root, lanes) {
        if (isDevToolsPresent) for(var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;){
            var index = 31 - clz32(lanes);
            root = 1 << index;
            index = pendingUpdatersLaneMap[index];
            0 < index.size && (index.forEach(function(fiber) {
                var alternate = fiber.alternate;
                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
            }), index.clear());
            lanes &= ~root;
        }
    }
    function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
    }
    function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
            return ReactDOMSharedInternals.p = priority, fn();
        } finally{
            ReactDOMSharedInternals.p = previousPriority;
        }
    }
    function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for(var parentNode = targetNode.parentNode; parentNode;){
            if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
                parentNode = targetInst.alternate;
                if (null !== targetInst.child || null !== parentNode && null !== parentNode.child) for(targetNode = getParentSuspenseInstance(targetNode); null !== targetNode;){
                    if (parentNode = targetNode[internalInstanceKey]) return parentNode;
                    targetNode = getParentSuspenseInstance(targetNode);
                }
                return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
        }
        return null;
    }
    function getInstanceFromNode(node) {
        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
            var tag = node.tag;
            if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag) return node;
        }
        return null;
    }
    function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
        throw Error("getNodeFromInstance: Invalid argument.");
    }
    function getResourcesFromRoot(root) {
        var resources = root[internalRootNodeResourcesKey];
        resources || (resources = root[internalRootNodeResourcesKey] = {
            hoistableStyles: new Map(),
            hoistableScripts: new Map()
        });
        return resources;
    }
    function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = !0;
    }
    function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] && console.error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
        registrationNameDependencies[registrationName] = dependencies;
        var lowerCasedName = registrationName.toLowerCase();
        possibleRegistrationNames[lowerCasedName] = registrationName;
        "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
        for(registrationName = 0; registrationName < dependencies.length; registrationName++)allNativeEvents.add(dependencies[registrationName]);
    }
    function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
        props.onChange || props.readOnly || props.disabled || null == props.checked || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return !0;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) return validatedAttributeNameCache[attributeName] = !0;
        illegalAttributeNameCache[attributeName] = !0;
        console.error("Invalid attribute name: `%s`", attributeName);
        return !1;
    }
    function getValueForAttributeOnCustomComponent(node, name, expected) {
        if (isAttributeNameSafe(name)) {
            if (!node.hasAttribute(name)) {
                switch(typeof expected){
                    case "symbol":
                    case "object":
                        return expected;
                    case "function":
                        return expected;
                    case "boolean":
                        if (!1 === expected) return expected;
                }
                return void 0 === expected ? void 0 : null;
            }
            node = node.getAttribute(name);
            if ("" === node && !0 === expected) return !0;
            checkAttributeStringCoercion(expected, name);
            return node === "" + expected ? expected : node;
        }
    }
    function setValueForAttribute(node, name, value) {
        if (isAttributeNameSafe(name)) {
            if (null === value) node.removeAttribute(name);
            else {
                switch(typeof value){
                    case "undefined":
                    case "function":
                    case "symbol":
                        node.removeAttribute(name);
                        return;
                    case "boolean":
                        var prefix = name.toLowerCase().slice(0, 5);
                        if ("data-" !== prefix && "aria-" !== prefix) {
                            node.removeAttribute(name);
                            return;
                        }
                }
                checkAttributeStringCoercion(value, name);
                node.setAttribute(name, "" + value);
            }
        }
    }
    function setValueForKnownAttribute(node, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
            switch(typeof value){
                case "undefined":
                case "function":
                case "symbol":
                case "boolean":
                    node.removeAttribute(name);
                    return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttribute(name, "" + value);
        }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
            switch(typeof value){
                case "undefined":
                case "function":
                case "symbol":
                case "boolean":
                    node.removeAttribute(name);
                    return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttributeNS(namespace, name, "" + value);
        }
    }
    function getToStringValue(value) {
        switch(typeof value){
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
                return value;
            case "object":
                return checkFormFieldValueStringCoercion(value), value;
            default:
                return "";
        }
    }
    function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
    }
    function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
        checkFormFieldValueStringCoercion(node[valueField]);
        var currentValue = "" + node[valueField];
        if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
            var get = descriptor.get, set = descriptor.set;
            Object.defineProperty(node, valueField, {
                configurable: !0,
                get: function() {
                    return get.call(this);
                },
                set: function(value) {
                    checkFormFieldValueStringCoercion(value);
                    currentValue = "" + value;
                    set.call(this, value);
                }
            });
            Object.defineProperty(node, valueField, {
                enumerable: descriptor.enumerable
            });
            return {
                getValue: function() {
                    return currentValue;
                },
                setValue: function(value) {
                    checkFormFieldValueStringCoercion(value);
                    currentValue = "" + value;
                },
                stopTracking: function() {
                    node._valueTracker = null;
                    delete node[valueField];
                }
            };
        }
    }
    function track(node) {
        node._valueTracker || (node._valueTracker = trackValueOnNode(node));
    }
    function updateValueIfChanged(node) {
        if (!node) return !1;
        var tracker = node._valueTracker;
        if (!tracker) return !0;
        var lastValue = tracker.getValue();
        var value = "";
        node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), !0) : !1;
    }
    function getActiveElement(doc) {
        doc = doc || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc) return null;
        try {
            return doc.activeElement || doc.body;
        } catch (e) {
            return doc.body;
        }
    }
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
        });
    }
    function validateInputProps(element, props) {
        void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnCheckedDefaultChecked = !0);
        void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnValueDefaultValue$1 = !0);
    }
    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
        if (null != value) {
            if ("number" === type) {
                if (0 === value && "" === element.value || element.value != value) element.value = "" + getToStringValue(value);
            } else element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        } else "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
    }
    function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
        if (null != value || null != defaultValue) {
            if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) return;
            defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
            value = null != value ? "" + getToStringValue(value) : defaultValue;
            isHydrating || value === element.value || (element.value = value);
            element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
    }
    function setDefaultValue(node, type, value) {
        "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
    }
    function validateOptionProps(element, props) {
        null == props.value && ("object" === typeof props.children && null !== props.children ? React.Children.forEach(props.children, function(child) {
            null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = !0, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."));
        }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = !0, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")));
        null == props.selected || didWarnSelectedSetOnOption || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
    }
    function getDeclarationErrorAddendum() {
        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
        return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
            multiple = {};
            for(var i = 0; i < propValue.length; i++)multiple["$" + propValue[i]] = !0;
            for(propValue = 0; propValue < node.length; propValue++)i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = !0);
        } else {
            propValue = "" + getToStringValue(propValue);
            multiple = null;
            for(i = 0; i < node.length; i++){
                if (node[i].value === propValue) {
                    node[i].selected = !0;
                    setDefaultSelected && (node[i].defaultSelected = !0);
                    return;
                }
                null !== multiple || node[i].disabled || (multiple = node[i]);
            }
            null !== multiple && (multiple.selected = !0);
        }
    }
    function validateSelectProps(element, props) {
        for(element = 0; element < valuePropNames.length; element++){
            var propName = valuePropNames[element];
            if (null != props[propName]) {
                var propNameIsArray = isArrayImpl(props[propName]);
                props.multiple && !propNameIsArray ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum()) : !props.multiple && propNameIsArray && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
            }
        }
        void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnValueDefaultValue = !0);
    }
    function validateTextareaProps(element, props) {
        void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component"), didWarnValDefaultVal = !0);
        null != props.children && null == props.value && console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
    }
    function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
            element.defaultValue !== value && (element.defaultValue = value);
            return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
            if (null != children) {
                if (null != defaultValue) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                if (isArrayImpl(children)) {
                    if (1 < children.length) throw Error("<textarea> can only have at most one child.");
                    children = children[0];
                }
                defaultValue = children;
            }
            null == defaultValue && (defaultValue = "");
            value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue && "" !== children && null !== children && (element.value = children);
    }
    function findNotableNode(node, indent) {
        return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
    }
    function indentation(indent) {
        return "  " + "  ".repeat(indent);
    }
    function added(indent) {
        return "+ " + "  ".repeat(indent);
    }
    function removed(indent) {
        return "- " + "  ".repeat(indent);
    }
    function describeFiberType(fiber) {
        switch(fiber.tag){
            case 26:
            case 27:
            case 5:
                return fiber.type;
            case 16:
                return "Lazy";
            case 13:
                return "Suspense";
            case 19:
                return "SuspenseList";
            case 0:
            case 15:
                return fiber = fiber.type, fiber.displayName || fiber.name || null;
            case 11:
                return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
            case 1:
                return fiber = fiber.type, fiber.displayName || fiber.name || null;
            default:
                return null;
        }
    }
    function describeTextNode(content, maxLength) {
        return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
    }
    function describeTextDiff(clientText, serverProps, indent) {
        var maxLength = 120 - 2 * indent;
        if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + "\n";
        if ("string" === typeof serverProps) {
            for(var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);
            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
            return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
        }
        return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
    }
    function objectName(object) {
        return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
            return p0;
        });
    }
    function describeValue(value, maxLength) {
        switch(typeof value){
            case "string":
                return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
            case "object":
                if (null === value) return "null";
                if (isArrayImpl(value)) return "[...]";
                if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
                var name = objectName(value);
                if ("Object" === name) {
                    name = "";
                    maxLength -= 2;
                    for(var propName in value)if (value.hasOwnProperty(propName)) {
                        var jsonPropName = JSON.stringify(propName);
                        jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                        maxLength -= propName.length - 2;
                        jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);
                        maxLength -= jsonPropName.length;
                        if (0 > maxLength) {
                            name += "" === name ? "..." : ", ...";
                            break;
                        }
                        name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                    }
                    return "{" + name + "}";
                }
                return name;
            case "function":
                return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
            default:
                return String(value);
        }
    }
    function describePropValue(value, maxLength) {
        return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
    }
    function describeExpandedElement(type, props, rowPrefix) {
        var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
        for(propName in props)if (props.hasOwnProperty(propName) && "children" !== propName) {
            var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);
            remainingRowLength -= propName.length + propValue.length + 2;
            properties.push(propName + "=" + propValue);
        }
        return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
    }
    function describePropertiesDiff(clientObject, serverObject, indent) {
        var properties = "", remainingServerProperties = assign({}, serverObject), propName;
        for(propName in clientObject)if (clientObject.hasOwnProperty(propName)) {
            delete remainingServerProperties[propName];
            var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
            serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
        }
        for(var _propName in remainingServerProperties)remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + ": " + clientObject + "\n");
        return properties;
    }
    function describeElementDiff(type, clientProps, serverProps, indent) {
        var content = "", serverPropNames = new Map();
        for(propName$jscomp$0 in serverProps)serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);
        if (1 === serverPropNames.size && serverPropNames.has("children")) content += describeExpandedElement(type, clientProps, indentation(indent));
        else {
            for(var _propName2 in clientProps)if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
                if (void 0 !== serverPropName) {
                    serverPropNames.delete(_propName2.toLowerCase());
                    var propName$jscomp$0 = clientProps[_propName2];
                    serverPropName = serverProps[serverPropName];
                    var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);
                    maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);
                    "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
                } else content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
            }
            serverPropNames.forEach(function(propName) {
                if ("children" !== propName) {
                    var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
                    content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
                }
            });
            content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
        }
        type = serverProps.children;
        clientProps = clientProps.children;
        if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
            serverPropNames = "";
            if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps) serverPropNames = "" + clientProps;
            content += describeTextDiff(serverPropNames, "" + type, indent + 1);
        } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps) content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
        return content;
    }
    function describeSiblingFiber(fiber, indent) {
        var type = describeFiberType(fiber);
        if (null === type) {
            type = "";
            for(fiber = fiber.child; fiber;)type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
            return type;
        }
        return indentation(indent) + "<" + type + ">\n";
    }
    function describeNode(node, indent) {
        var skipToNode = findNotableNode(node, indent);
        if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
        skipToNode = "";
        var debugInfo = node.fiber._debugInfo;
        if (debugInfo) for(var i = 0; i < debugInfo.length; i++){
            var serverComponentName = debugInfo[i].name;
            "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
        }
        debugInfo = "";
        i = node.fiber.pendingProps;
        if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
        else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) {
            if (void 0 === node.serverProps) {
                debugInfo = indent;
                var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
                for(propName in i)if (i.hasOwnProperty(propName) && "children" !== propName) {
                    var propValue = describePropValue(i[propName], 15);
                    maxLength -= propName.length + propValue.length + 2;
                    if (0 > maxLength) {
                        content += " ...";
                        break;
                    }
                    content += " " + propName + "=" + propValue;
                }
                debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
                indent++;
            } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : "string" === typeof node.serverProps ? console.error("Should not have matched a non HostText fiber to a Text node. This is a bug in React.") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);
        }
        var propName = "";
        i = node.fiber.child;
        for(serverComponentName = 0; i && serverComponentName < node.children.length;)maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
        i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
        i = node.serverTail;
        null === node.serverProps && indent--;
        for(node = 0; node < i.length; node++)serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));
        return skipToNode + debugInfo + propName;
    }
    function describeDiff(rootNode) {
        try {
            return "\n\n" + describeNode(rootNode, 0);
        } catch (x) {
            return "";
        }
    }
    function describeAncestors(ancestor, child, props) {
        for(var fiber = child, node = null, distanceFromLeaf = 0; fiber;)fiber === ancestor && (distanceFromLeaf = 0), node = {
            fiber: fiber,
            children: null !== node ? [
                node
            ] : [],
            serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
            serverTail: [],
            distanceFromLeaf: distanceFromLeaf
        }, distanceFromLeaf++, fiber = fiber.return;
        return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
    }
    function updatedAncestorInfoDev(oldInfo, tag) {
        oldInfo = assign({}, oldInfo || emptyAncestorInfoDev);
        var info = {
            tag: tag
        };
        -1 !== inScopeTags.indexOf(tag) && (oldInfo.aTagInScope = null, oldInfo.buttonTagInScope = null, oldInfo.nobrTagInScope = null);
        -1 !== buttonScopeTags.indexOf(tag) && (oldInfo.pTagInButtonScope = null);
        -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (oldInfo.listItemTagAutoclosing = null, oldInfo.dlItemTagAutoclosing = null);
        oldInfo.current = info;
        "form" === tag && (oldInfo.formTag = info);
        "a" === tag && (oldInfo.aTagInScope = info);
        "button" === tag && (oldInfo.buttonTagInScope = info);
        "nobr" === tag && (oldInfo.nobrTagInScope = info);
        "p" === tag && (oldInfo.pTagInButtonScope = info);
        "li" === tag && (oldInfo.listItemTagAutoclosing = info);
        if ("dd" === tag || "dt" === tag) oldInfo.dlItemTagAutoclosing = info;
        "#document" === tag || "html" === tag ? oldInfo.containerTagInScope = null : oldInfo.containerTagInScope || (oldInfo.containerTagInScope = info);
        return oldInfo;
    }
    function isTagValidWithParent(tag, parentTag) {
        switch(parentTag){
            case "select":
                return "hr" === tag || "option" === tag || "optgroup" === tag || "#text" === tag;
            case "optgroup":
                return "option" === tag || "#text" === tag;
            case "option":
                return "#text" === tag;
            case "tr":
                return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "tbody":
            case "thead":
            case "tfoot":
                return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "colgroup":
                return "col" === tag || "template" === tag;
            case "table":
                return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "head":
                return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "html":
                return "head" === tag || "body" === tag || "frameset" === tag;
            case "frameset":
                return "frame" === tag;
            case "#document":
                return "html" === tag;
        }
        switch(tag){
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
                return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
            case "rp":
            case "rt":
                return -1 === impliedEndTags.indexOf(parentTag);
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "head":
            case "html":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
                return null == parentTag;
        }
        return !0;
    }
    function findInvalidAncestorForTag(tag, ancestorInfo) {
        switch(tag){
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
                return ancestorInfo.pTagInButtonScope;
            case "form":
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
                return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
                return ancestorInfo.dlItemTagAutoclosing;
            case "button":
                return ancestorInfo.buttonTagInScope;
            case "a":
                return ancestorInfo.aTagInScope;
            case "nobr":
                return ancestorInfo.nobrTagInScope;
        }
        return null;
    }
    function findAncestor(parent, tagName) {
        for(; parent;){
            switch(parent.tag){
                case 5:
                case 26:
                case 27:
                    if (parent.type === tagName) return parent;
            }
            parent = parent.return;
        }
        return null;
    }
    function validateDOMNesting(childTag, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
        var parentInfo = ancestorInfo.current;
        ancestorInfo = (parentInfo = isTagValidWithParent(childTag, parentInfo && parentInfo.tag) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
        ancestorInfo = parentInfo || ancestorInfo;
        if (!ancestorInfo) return !0;
        ancestorInfo = ancestorInfo.tag;
        var warnKey = String(!!parentInfo) + "|" + childTag + "|" + ancestorInfo;
        if (didWarn[warnKey]) return !1;
        didWarn[warnKey] = !0;
        var ancestor = (warnKey = current) ? findAncestor(warnKey.return, ancestorInfo) : null;
        warnKey = null !== warnKey && null !== ancestor ? describeAncestors(ancestor, warnKey, null) : "";
        ancestor = "<" + childTag + ">";
        parentInfo ? (parentInfo = "", "table" === ancestorInfo && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error("In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s", ancestor, ancestorInfo, parentInfo, warnKey)) : console.error("In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s", ancestor, ancestorInfo, warnKey);
        return !1;
    }
    function validateTextNesting(childText, parentTag) {
        if (isTagValidWithParent("#text", parentTag)) return !0;
        var warnKey = "#text|" + parentTag;
        if (didWarn[warnKey]) return !1;
        didWarn[warnKey] = !0;
        var ancestor = (warnKey = current) ? findAncestor(warnKey, parentTag) : null;
        warnKey = null !== warnKey && null !== ancestor ? describeAncestors(ancestor, warnKey, 6 !== warnKey.tag ? {
            children: null
        } : null) : "";
        /\S/.test(childText) ? console.error("In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s", parentTag, warnKey) : console.error("In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s", parentTag, warnKey);
        return !1;
    }
    function setTextContent(node, text) {
        if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
                firstChild.nodeValue = text;
                return;
            }
        }
        node.textContent = text;
    }
    function camelize(string) {
        return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
        });
    }
    function setValueForStyle(style, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = !0, console.error("Unsupported style property %s. Did you mean %s?", styleName, camelize(styleName.replace(msPattern, "ms-")))) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = !0, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", styleName, styleName.charAt(0).toUpperCase() + styleName.slice(1))) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = !0, console.error('Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.', styleName, value.replace(badStyleValueWithSemicolonPattern, ""))), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = !0, console.error("`NaN` is an invalid value for the `%s` css style property.", styleName)) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = !0, console.error("`Infinity` is an invalid value for the `%s` css style property.", styleName))));
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style.setProperty(styleName, "") : "float" === styleName ? style.cssFloat = "" : style[styleName] = "" : isCustomProperty ? style.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style[styleName] = ("" + value).trim()) : style[styleName] = value + "px";
    }
    function setValueForStyles(node, styles, prevStyles) {
        if (null != styles && "object" !== typeof styles) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        styles && Object.freeze(styles);
        node = node.style;
        if (null != prevStyles) {
            if (styles) {
                var expandedUpdates = {};
                if (prevStyles) {
                    for(var key in prevStyles)if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key)) for(var longhands = shorthandToLonghand[key] || [
                        key
                    ], i = 0; i < longhands.length; i++)expandedUpdates[longhands[i]] = key;
                }
                for(var _key in styles)if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key])) for(key = shorthandToLonghand[_key] || [
                    _key
                ], longhands = 0; longhands < key.length; longhands++)expandedUpdates[key[longhands]] = _key;
                _key = {};
                for(var key$jscomp$0 in styles)for(key = shorthandToLonghand[key$jscomp$0] || [
                    key$jscomp$0
                ], longhands = 0; longhands < key.length; longhands++)_key[key[longhands]] = key$jscomp$0;
                key$jscomp$0 = {};
                for(var _key2 in expandedUpdates)if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
                    key$jscomp$0[i] = !0;
                    i = console;
                    var value = styles[key];
                    i.error.call(i, "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating", key, longhands);
                }
            }
            for(var styleName in prevStyles)!prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
            for(var _styleName in styles)_key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
        } else for(expandedUpdates in styles)styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
    }
    function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-")) return !1;
        switch(tagName){
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
                return !1;
            default:
                return !0;
        }
    }
    function getAttributeAlias(name) {
        return aliases.get(name) || name;
    }
    function validateProperty$1(tagName, name) {
        if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) return !0;
        if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties$1[name] = !0;
            if (name !== tagName) return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0;
        }
        if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = !0, !1;
            name !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0);
        }
        return !0;
    }
    function validateProperties$2(type, props) {
        var invalidProps = [], key;
        for(key in props)validateProperty$1(type, key) || invalidProps.push(key);
        props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
        }).join(", ");
        1 === invalidProps.length ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type);
    }
    function validateProperty(tagName, name, value, eventRegistry) {
        if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) return !0;
        var lowerCasedName = name.toLowerCase();
        if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName) return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties[name] = !0;
        if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name)) return !0;
        if (null != eventRegistry) {
            tagName = eventRegistry.possibleRegistrationNames;
            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name)) return !0;
            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry) return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name, eventRegistry), warnedProperties[name] = !0;
            if (EVENT_NAME_REGEX.test(name)) return console.error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties[name] = !0;
        } else if (EVENT_NAME_REGEX.test(name)) return INVALID_EVENT_NAME_REGEX.test(name) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties[name] = !0;
        if (rARIA.test(name) || rARIACamel.test(name)) return !0;
        if ("innerhtml" === lowerCasedName) return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties[name] = !0;
        if ("aria" === lowerCasedName) return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties[name] = !0;
        if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value) return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties[name] = !0;
        if ("number" === typeof value && isNaN(value)) return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties[name] = !0;
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name) return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name, lowerCasedName), warnedProperties[name] = !0;
        } else if (name !== lowerCasedName) return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties[name] = !0;
        switch(name){
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
                return !0;
            case "innerText":
            case "textContent":
                return !0;
        }
        switch(typeof value){
            case "boolean":
                switch(name){
                    case "autoFocus":
                    case "checked":
                    case "multiple":
                    case "muted":
                    case "selected":
                    case "contentEditable":
                    case "spellCheck":
                    case "draggable":
                    case "value":
                    case "autoReverse":
                    case "externalResourcesRequired":
                    case "focusable":
                    case "preserveAlpha":
                    case "allowFullScreen":
                    case "async":
                    case "autoPlay":
                    case "controls":
                    case "default":
                    case "defer":
                    case "disabled":
                    case "disablePictureInPicture":
                    case "disableRemotePlayback":
                    case "formNoValidate":
                    case "hidden":
                    case "loop":
                    case "noModule":
                    case "noValidate":
                    case "open":
                    case "playsInline":
                    case "readOnly":
                    case "required":
                    case "reversed":
                    case "scoped":
                    case "seamless":
                    case "itemScope":
                    case "capture":
                    case "download":
                    case "inert":
                        return !0;
                    default:
                        lowerCasedName = name.toLowerCase().slice(0, 5);
                        if ("data-" === lowerCasedName || "aria-" === lowerCasedName) return !0;
                        value ? console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                        return warnedProperties[name] = !0;
                }
            case "function":
            case "symbol":
                return warnedProperties[name] = !0, !1;
            case "string":
                if ("false" === value || "true" === value) {
                    switch(name){
                        case "checked":
                        case "selected":
                        case "multiple":
                        case "muted":
                        case "allowFullScreen":
                        case "async":
                        case "autoPlay":
                        case "controls":
                        case "default":
                        case "defer":
                        case "disabled":
                        case "disablePictureInPicture":
                        case "disableRemotePlayback":
                        case "formNoValidate":
                        case "hidden":
                        case "loop":
                        case "noModule":
                        case "noValidate":
                        case "open":
                        case "playsInline":
                        case "readOnly":
                        case "required":
                        case "reversed":
                        case "scoped":
                        case "seamless":
                        case "itemScope":
                        case "inert":
                            break;
                        default:
                            return !0;
                    }
                    console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                    warnedProperties[name] = !0;
                }
        }
        return !0;
    }
    function warnUnknownProperties(type, props, eventRegistry) {
        var unknownProps = [], key;
        for(key in props)validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
        props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
        }).join(", ");
        1 === unknownProps.length ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type);
    }
    function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
            var props = target[internalPropsKey] || null;
            a: switch(target = internalInstance.stateNode, internalInstance.type){
                case "input":
                    updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
                    internalInstance = props.name;
                    if ("radio" === props.type && null != internalInstance) {
                        for(props = target; props.parentNode;)props = props.parentNode;
                        checkAttributeStringCoercion(internalInstance, "name");
                        props = props.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + '"][type="radio"]');
                        for(internalInstance = 0; internalInstance < props.length; internalInstance++){
                            var otherNode = props[internalInstance];
                            if (otherNode !== target && otherNode.form === target.form) {
                                var otherProps = otherNode[internalPropsKey] || null;
                                if (!otherProps) throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                                updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
                            }
                        }
                        for(internalInstance = 0; internalInstance < props.length; internalInstance++)otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                    }
                    break a;
                case "textarea":
                    updateTextarea(target, props.value, props.defaultValue);
                    break a;
                case "select":
                    internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, !1);
            }
        }
    }
    function batchedUpdates$1(fn, a, b) {
        if (isInsideEventHandler) return fn(a, b);
        isInsideEventHandler = !0;
        try {
            var JSCompiler_inline_result = fn(a);
            return JSCompiler_inline_result;
        } finally{
            if (isInsideEventHandler = !1, null !== restoreTarget || null !== restoreQueue) {
                if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn)) for(a = 0; a < fn.length; a++)restoreStateOfTarget(fn[a]);
            }
        }
    }
    function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch(registrationName){
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
                (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
                inst = !props;
                break a;
            default:
                inst = !1;
        }
        if (inst) return null;
        if (stateNode && "function" !== typeof stateNode) throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type.");
        return stateNode;
    }
    function getData() {
        if (fallbackText) return fallbackText;
        var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
        for(start = 0; start < startLength && startValue[start] === endValue[start]; start++);
        var minEnd = startLength - start;
        for(end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);
        return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
    }
    function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
        return !0;
    }
    function functionThatReturnsFalse() {
        return !1;
    }
    function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for(var propName in Interface)Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
            this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : !1 === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
        }
        assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var event = this.nativeEvent;
                event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue);
            },
            stopPropagation: function() {
                var event = this.nativeEvent;
                event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue);
            },
            persist: function() {},
            isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
    }
    function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : !1;
    }
    function getEventModifierState() {
        return modifierStateGetter;
    }
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch(domEventName){
            case "keyup":
                return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
                return !0;
            default:
                return !1;
        }
    }
    function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
    }
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch(domEventName){
            case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
            case "keypress":
                if (nativeEvent.which !== SPACEBAR_CODE) return null;
                hasSpaceKeypress = !0;
                return SPACEBAR_CHAR;
            case "textInput":
                return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
            default:
                return null;
        }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing) return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = !1, domEventName) : null;
        switch(domEventName){
            case "paste":
                return null;
            case "keypress":
                if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                    if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char;
                    if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
                }
                return null;
            case "compositionend":
                return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
            default:
                return null;
        }
    }
    function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? !0 : !1;
    }
    function isEventSupported(eventNameSuffix) {
        if (!canUseDOM) return !1;
        eventNameSuffix = "on" + eventNameSuffix;
        var isSupported = eventNameSuffix in document;
        isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
        return isSupported;
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [
            target
        ] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target), dispatchQueue.push({
            event: nativeEvent,
            listeners: inst
        }));
    }
    function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName) return targetInst;
    }
    function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
            batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName) return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return !0;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return !1;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return !1;
        for(keysB = 0; keysB < keysA.length; keysB++){
            var currentKey = keysA[keysB];
            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;
        }
        return !0;
    }
    function getLeafNode(node) {
        for(; node && node.firstChild;)node = node.firstChild;
        return node;
    }
    function getNodeForCharacterOffset(root, offset) {
        var node = getLeafNode(root);
        root = 0;
        for(var nodeEnd; node;){
            if (3 === node.nodeType) {
                nodeEnd = root + node.textContent.length;
                if (root <= offset && nodeEnd >= offset) return {
                    node: node,
                    offset: offset - root
                };
                root = nodeEnd;
            }
            a: {
                for(; node;){
                    if (node.nextSibling) {
                        node = node.nextSibling;
                        break a;
                    }
                    node = node.parentNode;
                }
                node = void 0;
            }
            node = getLeafNode(node);
        }
    }
    function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? !0 : outerNode && 3 === outerNode.nodeType ? !1 : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : !1 : !1;
    }
    function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for(var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement;){
            try {
                var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
            } catch (err) {
                JSCompiler_inline_result = !1;
            }
            if (JSCompiler_inline_result) containerInfo = element.contentWindow;
            else break;
            element = getActiveElement(containerInfo.document);
        }
        return element;
    }
    function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
    }
    function restoreSelection(priorSelectionInformation, containerInfo) {
        var curFocusedElem = getActiveElementDeep(containerInfo);
        containerInfo = priorSelectionInformation.focusedElem;
        var priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== containerInfo && containerInfo && containerInfo.ownerDocument && containsNode(containerInfo.ownerDocument.documentElement, containerInfo)) {
            if (null !== priorSelectionRange && hasSelectionCapabilities(containerInfo)) {
                if (priorSelectionInformation = priorSelectionRange.start, curFocusedElem = priorSelectionRange.end, void 0 === curFocusedElem && (curFocusedElem = priorSelectionInformation), "selectionStart" in containerInfo) containerInfo.selectionStart = priorSelectionInformation, containerInfo.selectionEnd = Math.min(curFocusedElem, containerInfo.value.length);
                else if (curFocusedElem = (priorSelectionInformation = containerInfo.ownerDocument || document) && priorSelectionInformation.defaultView || window, curFocusedElem.getSelection) {
                    curFocusedElem = curFocusedElem.getSelection();
                    var length = containerInfo.textContent.length, start = Math.min(priorSelectionRange.start, length);
                    priorSelectionRange = void 0 === priorSelectionRange.end ? start : Math.min(priorSelectionRange.end, length);
                    !curFocusedElem.extend && start > priorSelectionRange && (length = priorSelectionRange, priorSelectionRange = start, start = length);
                    length = getNodeForCharacterOffset(containerInfo, start);
                    var endMarker = getNodeForCharacterOffset(containerInfo, priorSelectionRange);
                    length && endMarker && (1 !== curFocusedElem.rangeCount || curFocusedElem.anchorNode !== length.node || curFocusedElem.anchorOffset !== length.offset || curFocusedElem.focusNode !== endMarker.node || curFocusedElem.focusOffset !== endMarker.offset) && (priorSelectionInformation = priorSelectionInformation.createRange(), priorSelectionInformation.setStart(length.node, length.offset), curFocusedElem.removeAllRanges(), start > priorSelectionRange ? (curFocusedElem.addRange(priorSelectionInformation), curFocusedElem.extend(endMarker.node, endMarker.offset)) : (priorSelectionInformation.setEnd(endMarker.node, endMarker.offset), curFocusedElem.addRange(priorSelectionInformation)));
                }
            }
            priorSelectionInformation = [];
            for(curFocusedElem = containerInfo; curFocusedElem = curFocusedElem.parentNode;)1 === curFocusedElem.nodeType && priorSelectionInformation.push({
                element: curFocusedElem,
                left: curFocusedElem.scrollLeft,
                top: curFocusedElem.scrollTop
            });
            "function" === typeof containerInfo.focus && containerInfo.focus();
            for(containerInfo = 0; containerInfo < priorSelectionInformation.length; containerInfo++)curFocusedElem = priorSelectionInformation[containerInfo], curFocusedElem.element.scrollLeft = curFocusedElem.left, curFocusedElem.element.scrollTop = curFocusedElem.top;
        }
    }
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = {
            start: doc.selectionStart,
            end: doc.selectionEnd
        } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
            anchorNode: doc.anchorNode,
            anchorOffset: doc.anchorOffset,
            focusNode: doc.focusNode,
            focusOffset: doc.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
            event: nativeEvent,
            listeners: doc
        }), nativeEvent.target = activeElement)));
    }
    function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit" + styleProp] = "webkit" + eventName;
        prefixes["Moz" + styleProp] = "moz" + eventName;
        return prefixes;
    }
    function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for(styleProp in prefixMap)if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
    }
    function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [
            domEventName
        ]);
    }
    function finishQueueingConcurrentUpdates() {
        for(var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;){
            var fiber = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var queue = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var update = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var lane = concurrentQueues[i];
            concurrentQueues[i++] = null;
            if (null !== queue && null !== update) {
                var pending = queue.pending;
                null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
                queue.pending = update;
            }
            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for(var isHidden = !1, parent = sourceFiber.return; null !== parent;)parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = !0)), sourceFiber = parent, parent = parent.return;
        isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [
            update
        ] : sourceFiber.push(update), update.lane = lane | 536870912);
    }
    function getRootForUpdatedFiber(sourceFiber) {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
        null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        for(var node = sourceFiber, parent = node.return; null !== parent;)null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
        return 3 === node.tag ? node.stateNode : null;
    }
    function resolveFunctionForHotReloading(type) {
        if (null === resolveFamily) return type;
        var family = resolveFamily(type);
        return void 0 === family ? type : family.current;
    }
    function resolveForwardRefForHotReloading(type) {
        if (null === resolveFamily) return type;
        var family = resolveFamily(type);
        return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: family
        }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
        if (null === resolveFamily) return !1;
        var prevType = fiber.elementType;
        element = element.type;
        var needsCompareFamilies = !1, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
        switch(fiber.tag){
            case 1:
                "function" === typeof element && (needsCompareFamilies = !0);
                break;
            case 0:
                "function" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
                break;
            case 11:
                $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
                break;
            case 14:
            case 15:
                $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
                break;
            default:
                return !1;
        }
        return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
        null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));
    }
    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
        switch(tag){
            case 0:
            case 15:
            case 1:
                candidateType = type;
                break;
            case 11:
                candidateType = type.render;
        }
        if (null === resolveFamily) throw Error("Expected resolveFamily to be set during hot reload.");
        var needsRender = !1;
        type = !1;
        null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = !0 : updatedFamilies.has(candidateType) && (1 === tag ? type = !0 : needsRender = !0)));
        null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = !0);
        type && (fiber._debugNeedsRemount = !0);
        if (type || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
        null === child || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
        null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
    }
    function pushNestedEffectDurations() {
        var prevEffectDuration = profilerEffectDuration;
        profilerEffectDuration = 0;
        return prevEffectDuration;
    }
    function popNestedEffectDurations(prevEffectDuration) {
        var elapsedTime = profilerEffectDuration;
        profilerEffectDuration = prevEffectDuration;
        return elapsedTime;
    }
    function bubbleNestedEffectDurations(prevEffectDuration) {
        var elapsedTime = profilerEffectDuration;
        profilerEffectDuration += prevEffectDuration;
        return elapsedTime;
    }
    function startProfilerTimer(fiber) {
        profilerStartTime = now();
        0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
    }
    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
        if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
        }
    }
    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
        if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            profilerStartTime = -1;
        }
    }
    function recordEffectDuration() {
        if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            profilerStartTime = -1;
            profilerEffectDuration += elapsedTime;
        }
    }
    function startEffectTimer() {
        profilerStartTime = now();
    }
    function transferActualDuration(fiber) {
        for(var child = fiber.child; child;)fiber.actualDuration += child.actualDuration, child = child.sibling;
    }
    function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
            var existing = CapturedStacks.get(value);
            if (void 0 !== existing) return existing;
            source = {
                value: value,
                source: source,
                stack: getStackByFiberInDevAndProd(source)
            };
            CapturedStacks.set(value, source);
            return source;
        }
        return {
            value: value,
            source: source,
            stack: getStackByFiberInDevAndProd(source)
        };
    }
    function pushTreeFork(workInProgress, totalChildren) {
        warnIfNotHydrating();
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress;
        treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress, totalChildren, index) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
            treeContextOverflow = length + workInProgress;
        } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;
    }
    function pushMaterializedTreeId(workInProgress) {
        warnIfNotHydrating();
        null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
    }
    function popTreeContext(workInProgress) {
        for(; workInProgress === treeForkProvider;)treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for(; workInProgress === treeContextProvider;)treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function warnIfNotHydrating() {
        isHydrating || console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
        if (null === fiber.return) {
            if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {
                fiber: fiber,
                children: [],
                serverProps: void 0,
                serverTail: [],
                distanceFromLeaf: distanceFromLeaf
            };
            else {
                if (hydrationDiffRootDEV.fiber !== fiber) throw Error("Saw multiple hydration diff roots in a pass. This is a bug in React.");
                hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
            }
            return hydrationDiffRootDEV;
        }
        var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;
        if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
        distanceFromLeaf = {
            fiber: fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf: distanceFromLeaf
        };
        siblings.push(distanceFromLeaf);
        return distanceFromLeaf;
    }
    function warnNonHydratedInstance(fiber, rejectedCandidate) {
        didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
    }
    function throwOnHydrationMismatch(fiber) {
        var diff = "", diffRoot = hydrationDiffRootDEV;
        null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
        queueHydrationError(createCapturedValueAtFiber(Error("Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff), fiber));
        throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
        var didHydrate = fiber.stateNode;
        var type = fiber.type, props = fiber.memoizedProps;
        didHydrate[internalInstanceKey] = fiber;
        didHydrate[internalPropsKey] = props;
        validatePropertiesInDevelopment(type, props);
        switch(type){
            case "dialog":
                listenToNonDelegatedEvent("cancel", didHydrate);
                listenToNonDelegatedEvent("close", didHydrate);
                break;
            case "iframe":
            case "object":
            case "embed":
                listenToNonDelegatedEvent("load", didHydrate);
                break;
            case "video":
            case "audio":
                for(type = 0; type < mediaEventTypes.length; type++)listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
                break;
            case "source":
                listenToNonDelegatedEvent("error", didHydrate);
                break;
            case "img":
            case "image":
            case "link":
                listenToNonDelegatedEvent("error", didHydrate);
                listenToNonDelegatedEvent("load", didHydrate);
                break;
            case "details":
                listenToNonDelegatedEvent("toggle", didHydrate);
                break;
            case "input":
                checkControlledValueProps("input", props);
                listenToNonDelegatedEvent("invalid", didHydrate);
                validateInputProps(didHydrate, props);
                initInput(didHydrate, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, !0);
                track(didHydrate);
                break;
            case "option":
                validateOptionProps(didHydrate, props);
                break;
            case "select":
                checkControlledValueProps("select", props);
                listenToNonDelegatedEvent("invalid", didHydrate);
                validateSelectProps(didHydrate, props);
                break;
            case "textarea":
                checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(didHydrate, props.value, props.defaultValue, props.children), track(didHydrate);
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || !0 === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = !0) : didHydrate = !1;
        didHydrate || throwOnHydrationMismatch(fiber);
    }
    function popToNextHostParent(fiber) {
        for(hydrationParentFiber = fiber.return; hydrationParentFiber;)switch(hydrationParentFiber.tag){
            case 3:
            case 27:
                rootOrSingletonContext = !0;
                return;
            case 5:
            case 13:
                rootOrSingletonContext = !1;
                return;
            default:
                hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return !1;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;
        var shouldClear = !1, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag) {
            if (JSCompiler_temp = 5 === fiber.tag) JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
            JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && (shouldClear = !0);
        if (shouldClear && nextHydratableInstance) {
            for(shouldClear = nextHydratableInstance; shouldClear;){
                JSCompiler_temp = buildHydrationDiffNode(fiber, 0);
                var description = describeHydratableInstanceForDevWarnings(shouldClear);
                JSCompiler_temp.serverTail.push(description);
                shouldClear = "Suspense" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear) : getNextHydratable(shouldClear.nextSibling);
            }
            throwOnHydrationMismatch(fiber);
        }
        popToNextHostParent(fiber);
        if (13 === fiber.tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
        } else nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return !0;
    }
    function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        didSuspendOrErrorDEV = isHydrating = !1;
    }
    function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [
            error
        ] : hydrationErrors.push(error);
    }
    function emitPendingHydrationWarnings() {
        var diffRoot = hydrationDiffRootDEV;
        null !== diffRoot && (hydrationDiffRootDEV = null, diffRoot = describeDiff(diffRoot), console.error("A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s", "https://react.dev/link/hydration-mismatch", diffRoot));
    }
    function createThenableState() {
        return {
            didWarnAboutUncachedPromise: !1,
            thenables: []
        };
    }
    function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
    }
    function noop$3() {}
    function trackUsedThenable(thenableState, thenable, index) {
        null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);
        var trackedThenables = thenableState.thenables;
        index = trackedThenables[index];
        void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), thenable.then(noop$3, noop$3), thenable = index);
        switch(thenable.status){
            case "fulfilled":
                return thenable.value;
            case "rejected":
                throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
            default:
                if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
                else {
                    thenableState = workInProgressRoot;
                    if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error("async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
                    thenableState = thenable;
                    thenableState.status = "pending";
                    thenableState.then(function(fulfilledValue) {
                        if ("pending" === thenable.status) {
                            var fulfilledThenable = thenable;
                            fulfilledThenable.status = "fulfilled";
                            fulfilledThenable.value = fulfilledValue;
                        }
                    }, function(error) {
                        if ("pending" === thenable.status) {
                            var rejectedThenable = thenable;
                            rejectedThenable.status = "rejected";
                            rejectedThenable.reason = error;
                        }
                    });
                }
                switch(thenable.status){
                    case "fulfilled":
                        return thenable.value;
                    case "rejected":
                        throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
                }
                suspendedThenable = thenable;
                needsToResetSuspendedThenableDEV = !0;
                throw SuspenseException;
        }
    }
    function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
        var thenable = suspendedThenable;
        suspendedThenable = null;
        needsToResetSuspendedThenableDEV = !1;
        return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException) throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
    }
    function pushDebugInfo(debugInfo) {
        var previousDebugInfo = currentDebugInfo;
        null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
        return previousDebugInfo;
    }
    function validateFragmentProps(element, fiber, returnFiber) {
        for(var keys = Object.keys(element.props), i = 0; i < keys.length; i++){
            var key = keys[i];
            if ("children" !== key && "key" !== key) {
                null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
                runWithFiberInDEV(fiber, function(erroredKey) {
                    console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", erroredKey);
                }, key);
                break;
            }
        }
    }
    function unwrapThenable(thenable) {
        var index = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = createThenableState());
        return trackUsedThenable(thenableState$1, thenable, index);
    }
    function coerceRef(workInProgress, element) {
        element = element.props.ref;
        workInProgress.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.');
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead.");
    }
    function warnOnFunctionType(returnFiber, invalidChild) {
        var parentName = getComponentNameFromFiber(returnFiber) || "Component";
        ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)", invalidChild, invalidChild, invalidChild) : console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>", invalidChild, invalidChild, parentName, invalidChild, parentName));
    }
    function warnOnSymbolType(returnFiber, invalidChild) {
        var parentName = getComponentNameFromFiber(returnFiber) || "Component";
        ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error("Symbols are not valid as a React child.\n  root.render(%s)", invalidChild) : console.error("Symbols are not valid as a React child.\n  <%s>%s</%s>", parentName, invalidChild, parentName));
    }
    function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
                var deletions = returnFiber.deletions;
                null === deletions ? (returnFiber.deletions = [
                    childToDelete
                ], returnFiber.flags |= 16) : deletions.push(childToDelete);
            }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for(; null !== currentFirstChild;)deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return null;
        }
        function mapRemainingChildren(currentFirstChild) {
            for(var existingChildren = new Map(); null !== currentFirstChild;)null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
            fiber = createWorkInProgress(fiber, pendingProps);
            fiber.index = 0;
            fiber.sibling = null;
            return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;
            newIndex = newFiber.alternate;
            if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;
            newFiber.flags |= 33554434;
            return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);
            return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
            if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;
            current = useFiber(current, textContent);
            current.return = returnFiber;
            current._debugInfo = currentDebugInfo;
            return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;
            if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;
            current = createFiberFromElement(element, returnFiber.mode, lanes);
            coerceRef(current, element);
            current.return = returnFiber;
            current._debugInfo = currentDebugInfo;
            return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
            if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;
            current = useFiber(current, portal.children || []);
            current.return = returnFiber;
            current._debugInfo = currentDebugInfo;
            return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
            if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;
            current = useFiber(current, fragment);
            current.return = returnFiber;
            current._debugInfo = currentDebugInfo;
            return current;
        }
        function createChild(returnFiber, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
            if ("object" === typeof newChild && null !== newChild) {
                switch(newChild.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                    case REACT_PORTAL_TYPE:
                        return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
                    case REACT_LAZY_TYPE:
                        var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                        newChild = callLazyInitInDEV(newChild);
                        returnFiber = createChild(returnFiber, newChild, lanes);
                        currentDebugInfo = _prevDebugInfo;
                        return returnFiber;
                }
                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                if ("function" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;
                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
                throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
                switch(newChild.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;
                    case REACT_PORTAL_TYPE:
                        return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                    case REACT_LAZY_TYPE:
                        return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;
                }
                if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
                    if (null !== key) return null;
                    key = pushDebugInfo(newChild._debugInfo);
                    returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);
                    currentDebugInfo = key;
                    return returnFiber;
                }
                if ("function" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;
                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
                throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
                switch(newChild.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;
                    case REACT_PORTAL_TYPE:
                        return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                    case REACT_LAZY_TYPE:
                        var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                        newChild = callLazyInitInDEV(newChild);
                        returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
                        currentDebugInfo = _prevDebugInfo7;
                        return returnFiber;
                }
                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;
                if ("function" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;
                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
                throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
        }
        function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {
            if ("object" !== typeof child || null === child) return knownKeys;
            switch(child.$$typeof){
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                    warnForMissingKey(returnFiber, workInProgress, child);
                    var key = child.key;
                    if ("string" !== typeof key) break;
                    if (null === knownKeys) {
                        knownKeys = new Set();
                        knownKeys.add(key);
                        break;
                    }
                    if (!knownKeys.has(key)) {
                        knownKeys.add(key);
                        break;
                    }
                    runWithFiberInDEV(workInProgress, function() {
                        console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    });
                    break;
                case REACT_LAZY_TYPE:
                    child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);
            }
            return knownKeys;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            for(var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++){
                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (null === newFiber) {
                    null === oldFiber && (oldFiber = nextOldFiber);
                    break;
                }
                knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);
                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
                for(; newIdx < newChildren.length; newIdx++)oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
                isHydrating && pushTreeFork(returnFiber, newIdx);
                return resultingFirstChild;
            }
            for(oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
                return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
            if (null == newChildren) throw Error("An iterable object provided no iterator.");
            for(var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()){
                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (null === newFiber) {
                    null === oldFiber && (oldFiber = nextOldFiber);
                    break;
                }
                knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);
                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
            }
            if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
                for(; !step.done; newIdx++, step = newChildren.next())oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
                isHydrating && pushTreeFork(returnFiber, newIdx);
                return resultingFirstChild;
            }
            for(oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
                return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
            "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
            if ("object" === typeof newChild && null !== newChild) {
                switch(newChild.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                        a: {
                            for(var key = newChild.key; null !== currentFirstChild;){
                                if (currentFirstChild.key === key) {
                                    key = newChild.type;
                                    if (key === REACT_FRAGMENT_TYPE) {
                                        if (7 === currentFirstChild.tag) {
                                            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                                            lanes = useFiber(currentFirstChild, newChild.props.children);
                                            lanes.return = returnFiber;
                                            lanes._debugOwner = newChild._owner;
                                            lanes._debugInfo = currentDebugInfo;
                                            validateFragmentProps(newChild, lanes, returnFiber);
                                            returnFiber = lanes;
                                            break a;
                                        }
                                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
                                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                                        lanes = useFiber(currentFirstChild, newChild.props);
                                        coerceRef(lanes, newChild);
                                        lanes.return = returnFiber;
                                        lanes._debugOwner = newChild._owner;
                                        lanes._debugInfo = currentDebugInfo;
                                        returnFiber = lanes;
                                        break a;
                                    }
                                    deleteRemainingChildren(returnFiber, currentFirstChild);
                                    break;
                                } else deleteChild(returnFiber, currentFirstChild);
                                currentFirstChild = currentFirstChild.sibling;
                            }
                            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                        }
                        returnFiber = placeSingleChild(returnFiber);
                        currentDebugInfo = prevDebugInfo;
                        return returnFiber;
                    case REACT_PORTAL_TYPE:
                        a: {
                            prevDebugInfo = newChild;
                            for(newChild = prevDebugInfo.key; null !== currentFirstChild;){
                                if (currentFirstChild.key === newChild) {
                                    if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                                        lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);
                                        lanes.return = returnFiber;
                                        returnFiber = lanes;
                                        break a;
                                    } else {
                                        deleteRemainingChildren(returnFiber, currentFirstChild);
                                        break;
                                    }
                                } else deleteChild(returnFiber, currentFirstChild);
                                currentFirstChild = currentFirstChild.sibling;
                            }
                            lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);
                            lanes.return = returnFiber;
                            returnFiber = lanes;
                        }
                        return placeSingleChild(returnFiber);
                    case REACT_LAZY_TYPE:
                        return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
                }
                if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
                if (getIteratorFn(newChild)) {
                    prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                    key = getIteratorFn(newChild);
                    if ("function" !== typeof key) throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
                    var newChildren = key.call(newChild);
                    if (newChildren === newChild) {
                        if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = !0;
                    } else newChild.entries !== key || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
                    returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);
                    currentDebugInfo = prevDebugInfo;
                    return returnFiber;
                }
                if ("function" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;
                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
                throwOnInvalidObjectType(returnFiber, newChild);
            }
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
            var prevDebugInfo = currentDebugInfo;
            currentDebugInfo = null;
            try {
                thenableIndexCounter$1 = 0;
                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
                thenableState$1 = null;
                return firstChildFiber;
            } catch (x) {
                if (x === SuspenseException) throw x;
                var fiber = createFiber(29, x, null, returnFiber.mode);
                fiber.lanes = lanes;
                fiber.return = returnFiber;
                var debugInfo = fiber._debugInfo = currentDebugInfo;
                fiber._debugOwner = returnFiber._debugOwner;
                if (null != debugInfo) {
                    for(var i = debugInfo.length - 1; 0 <= i; i--)if ("string" === typeof debugInfo[i].stack) {
                        fiber._debugOwner = debugInfo[i];
                        break;
                    }
                }
                return fiber;
            } finally{
                currentDebugInfo = prevDebugInfo;
            }
        };
    }
    function pushHiddenContext(fiber, context) {
        var prevEntangledRenderLanes = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
        push(currentTreeHiddenStackCursor, context, fiber);
        entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
    }
    function reuseHiddenContextOnStack(fiber) {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);
    }
    function popHiddenContext(fiber) {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor, fiber);
        pop(prevEntangledRenderLanesCursor, fiber);
    }
    function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);
        push(suspenseHandlerStackCursor, handler, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushOffscreenSuspenseHandler(fiber) {
        if (22 === fiber.tag) {
            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {
                var current = fiber.alternate;
                null !== current && null !== current.memoizedState && (shellBoundary = fiber);
            }
        } else reuseSuspenseHandlerOnStack(fiber);
    }
    function reuseSuspenseHandlerOnStack(fiber) {
        push(suspenseStackCursor, suspenseStackCursor.current, fiber);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);
    }
    function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor, fiber);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor, fiber);
    }
    function findFirstSuspended(row) {
        for(var node = row; null !== node;){
            if (13 === node.tag) {
                var state = node.memoizedState;
                if (null !== state && (state = state.dehydrated, null === state || state.data === SUSPENSE_PENDING_START_DATA || state.data === SUSPENSE_FALLBACK_START_DATA)) return node;
            } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
                if (0 !== (node.flags & 128)) return node;
            } else if (null !== node.child) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === row) break;
            for(; null === node.sibling;){
                if (null === node.return || node.return === row) return null;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
        return null;
    }
    function createCache() {
        return {
            controller: new AbortControllerLocal(),
            data: new Map(),
            refCount: 0
        };
    }
    function retainCache(cache) {
        cache.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React.");
        cache.refCount++;
    }
    function releaseCache(cache) {
        cache.refCount--;
        0 > cache.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React.");
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
            cache.controller.abort();
        });
    }
    function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
            var entangledListeners = currentEntangledListeners = [];
            currentEntangledPendingCount = 0;
            currentEntangledLane = requestTransitionLane();
            currentEntangledActionThenable = {
                status: "pending",
                value: void 0,
                then: function(resolve) {
                    entangledListeners.push(resolve);
                }
            };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
    }
    function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
            var listeners = currentEntangledListeners;
            currentEntangledListeners = null;
            currentEntangledLane = 0;
            currentEntangledActionThenable = null;
            for(var i = 0; i < listeners.length; i++)(0, listeners[i])();
        }
    }
    function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
            status: "pending",
            value: null,
            reason: null,
            then: function(resolve) {
                listeners.push(resolve);
            }
        };
        thenable.then(function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for(var i = 0; i < listeners.length; i++)(0, listeners[i])(result);
        }, function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for(error = 0; error < listeners.length; error++)(0, listeners[error])(void 0);
        });
        return thenableWithOverride;
    }
    function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
    }
    function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : {
            parent: CacheContext._currentValue,
            pool: cacheFromPool
        };
    }
    function mountHookTypesDev() {
        var hookName = currentHookNameInDev;
        null === hookTypesDev ? hookTypesDev = [
            hookName
        ] : hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
        var hookName = currentHookNameInDev;
        if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {
                for(var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++){
                    var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
                    for(oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length;)oldHookName += " ";
                    oldHookName += newHookName + "\n";
                    table += oldHookName;
                }
                console.error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
            }
        }
    }
    function checkDepsAreArrayDev(deps) {
        void 0 === deps || null === deps || isArrayImpl(deps) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
    }
    function warnOnUseFormStateInDev() {
        var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
        didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", componentName));
    }
    function throwInvalidHookError() {
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
        if (ignorePreviousDependencies) return !1;
        if (null === prevDeps) return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
        nextDeps.length !== prevDeps.length && console.error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++)if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
        return !0;
    }
    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber$1 = workInProgress;
        hookTypesDev = null !== current ? current._debugHookTypes : null;
        hookTypesUpdateIndexDev = -1;
        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;
        if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber$1), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error("async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."));
        workInProgress.memoizedState = null;
        workInProgress.updateQueue = null;
        workInProgress.lanes = 0;
        ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
        shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & StrictLegacyMode) !== NoMode;
        var children = callComponentInDEV(Component, props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = !1;
        didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));
        if (nextRenderLanes) {
            setIsStrictModeForDevtools(!0);
            try {
                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);
            } finally{
                setIsStrictModeForDevtools(!1);
            }
        }
        finishRenderingHooks(current, workInProgress);
        return children;
    }
    function finishRenderingHooks(current, workInProgress) {
        workInProgress._debugHookTypes = hookTypesDev;
        null === workInProgress.dependencies ? null !== thenableState && (workInProgress.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState
        }) : workInProgress.dependencies._debugThenableState = thenableState;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
        hookTypesUpdateIndexDev = -1;
        null !== current && (current.flags & 31457280) !== (workInProgress.flags & 31457280) && console.error("Internal React error: Expected static flag was missing. Please notify the React team.");
        didScheduleRenderPhaseUpdate = !1;
        thenableIndexCounter = 0;
        thenableState = null;
        if (didRenderTooFewHooks) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));
        needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;
        current && (workInProgress = getComponentNameFromFiber(workInProgress) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
    }
    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
        currentlyRenderingFiber$1 = workInProgress;
        var numberOfReRenders = 0;
        do {
            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
            thenableIndexCounter = 0;
            didScheduleRenderPhaseUpdateDuringThisPass = !1;
            if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            numberOfReRenders += 1;
            ignorePreviousDependencies = !1;
            workInProgressHook = currentHook = null;
            if (null != workInProgress.updateQueue) {
                var children = workInProgress.updateQueue;
                children.lastEffect = null;
                children.events = null;
                children.stores = null;
                null != children.memoCache && (children.memoCache.index = 0);
            }
            hookTypesUpdateIndexDev = -1;
            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
            children = callComponentInDEV(Component, props, secondArg);
        }while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
    }
    function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);
        return maybeThenable;
    }
    function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress, lanes) {
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.flags = (workInProgress.mode & StrictEffectsMode) !== NoMode ? workInProgress.flags & -201328645 : workInProgress.flags & -2053;
        current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress) {
        if (didScheduleRenderPhaseUpdate) {
            for(workInProgress = workInProgress.memoizedState; null !== workInProgress;){
                var queue = workInProgress.queue;
                null !== queue && (queue.pending = null);
                workInProgress = workInProgress.next;
            }
            didScheduleRenderPhaseUpdate = !1;
        }
        renderLanes = 0;
        hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
        hookTypesUpdateIndexDev = -1;
        currentHookNameInDev = null;
        didScheduleRenderPhaseUpdateDuringThisPass = !1;
        thenableIndexCounter = localIdCounter = 0;
        thenableState = null;
    }
    function mountWorkInProgressHook() {
        var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
    }
    function updateWorkInProgressHook() {
        if (null === currentHook) {
            var nextCurrentHook = currentlyRenderingFiber$1.alternate;
            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
            if (null === nextCurrentHook) {
                if (null === currentlyRenderingFiber$1.alternate) throw Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");
                throw Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            nextCurrentHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
            };
            null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
    }
    function useThenable(thenable) {
        var index = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = createThenableState());
        thenable = trackUsedThenable(thenableState, thenable, index);
        index = currentlyRenderingFiber$1;
        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
        return thenable;
    }
    function use(usable) {
        if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then) return useThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error("An unsupported type was passed to use(): " + String(usable));
    }
    function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber$1.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
            var current = currentlyRenderingFiber$1.alternate;
            null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
                data: current.data.map(function(array) {
                    return array.slice();
                }),
                index: 0
            })));
        }
        null == memoCache && (memoCache = {
            data: [],
            index: 0
        });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue || ignorePreviousDependencies) for(updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        else updateQueue.length !== size && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", updateQueue.length, size);
        memoCache.index++;
        return updateQueue;
    }
    function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
                setIsStrictModeForDevtools(!0);
                try {
                    init(initialArg);
                } finally{
                    setIsStrictModeForDevtools(!1);
                }
            }
        } else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
        };
        hook.queue = reducer;
        reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, reducer);
        return [
            hook.memoizedState,
            reducer
        ];
    }
    function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
            if (null !== baseQueue) {
                var baseFirst = baseQueue.next;
                baseQueue.next = pendingQueue.next;
                pendingQueue.next = baseFirst;
            }
            current.baseQueue !== baseQueue && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
            current.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
            current = baseQueue.next;
            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction = !1;
            do {
                var updateLane = update.lane & -536870913;
                if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                    var revertLane = update.revertLane;
                    if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                        lane: 0,
                        revertLane: 0,
                        action: update.action,
                        hasEagerState: update.hasEagerState,
                        eagerState: update.eagerState,
                        next: null
                    }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
                    else if ((renderLanes & revertLane) === revertLane) {
                        update = update.next;
                        revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
                        continue;
                    } else updateLane = {
                        lane: 0,
                        revertLane: update.revertLane,
                        action: update.action,
                        hasEagerState: update.hasEagerState,
                        eagerState: update.eagerState,
                        next: null
                    }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                    updateLane = update.action;
                    shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                    pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
                } else revertLane = {
                    lane: updateLane,
                    revertLane: update.revertLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
                update = update.next;
            }while (null !== update && update !== current);
            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;
            hook.memoizedState = pendingQueue;
            hook.baseState = baseFirst;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [
            hook.memoizedState,
            queue.dispatch
        ];
    }
    function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            do newState = reducer(newState, update.action), update = update.next;
            while (update !== lastRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
            hook.memoizedState = newState;
            null === hook.baseQueue && (hook.baseState = newState);
            queue.lastRenderedState = newState;
        }
        return [
            newState,
            dispatch
        ];
    }
    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook();
        if (isHydrating) {
            if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            var nextSnapshot = getServerSnapshot();
            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error("The result of getServerSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
        } else {
            nextSnapshot = getSnapshot();
            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0));
            if (null === workInProgressRoot) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
        }
        hook.memoizedState = nextSnapshot;
        getServerSnapshot = {
            value: nextSnapshot,
            getSnapshot: getSnapshot
        };
        hook.queue = getServerSnapshot;
        mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [
            subscribe
        ]);
        fiber.flags |= 2048;
        pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), {
            destroy: void 0
        }, null);
        return nextSnapshot;
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
            if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            getServerSnapshot = getServerSnapshot();
        } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            objectIs(getServerSnapshot, cachedSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
        }
        if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;
        hook = hook.queue;
        var create = subscribeToStore.bind(null, fiber, hook, subscribe);
        updateEffectImpl(2048, Passive, create, [
            subscribe
        ]);
        if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= 2048;
            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), {
                destroy: void 0
            }, null);
            if (null === workInProgressRoot) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = {
            getSnapshot: getSnapshot,
            value: renderedSnapshot
        };
        getSnapshot = currentlyRenderingFiber$1.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [
            fiber
        ]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [
            fiber
        ] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
    }
    function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
        } catch (error) {
            return !0;
        }
    }
    function forceStoreRerender(fiber) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    }
    function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
            var initialStateInitializer = initialState;
            initialState = initialStateInitializer();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
                setIsStrictModeForDevtools(!0);
                try {
                    initialStateInitializer();
                } finally{
                    setIsStrictModeForDevtools(!1);
                }
            }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
        };
        return hook;
    }
    function mountState(initialState) {
        initialState = mountStateImpl(initialState);
        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
        queue.dispatch = dispatch;
        return [
            initialState.memoizedState,
            dispatch
        ];
    }
    function mountOptimistic(passthrough) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = hook.baseState = passthrough;
        var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
        };
        hook.queue = queue;
        hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !0, queue);
        queue.dispatch = hook;
        return [
            passthrough,
            hook
        ];
    }
    function updateOptimistic(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(hook, currentHook, "function" === typeof reducer ? reducer : basicStateReducer);
    }
    function rerenderOptimistic(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        hook.baseState = passthrough;
        return [
            passthrough,
            hook.queue.dispatch
        ];
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error("Cannot update form state while rendering.");
        fiber = actionQueue.action;
        if (null !== fiber) {
            var actionNode = {
                payload: payload,
                action: fiber,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function(listener) {
                    actionNode.listeners.push(listener);
                }
            };
            null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;
            setState(actionNode);
            setPendingState = actionQueue.pending;
            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
    }
    function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            ReactSharedInternals.T = currentTransition;
            ReactSharedInternals.T._updatedFibers = new Set();
            try {
                var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
                handleActionReturnValue(actionQueue, node, returnValue);
            } catch (error) {
                onActionError(actionQueue, node, error);
            } finally{
                ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
            }
        } else try {
            currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
        } catch (error$3) {
            onActionError(actionQueue, node, error$3);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (returnValue.then(function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
        }, function(error) {
            return onActionError(actionQueue, node, error);
        }), node.isTransition || console.error("An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`")) : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
            last = last.next;
            do actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
            while (actionNode !== last);
        }
        actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for(var i = 0; i < actionNode.length; i++)(0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
        return newState;
    }
    function mountActionState(action, initialStateProp) {
        if (isHydrating) {
            var ssrFormState = workInProgressRoot.formState;
            if (null !== ssrFormState) {
                a: {
                    var isMatching = currentlyRenderingFiber$1;
                    if (isHydrating) {
                        if (nextHydratableInstance) {
                            b: {
                                var markerInstance = nextHydratableInstance;
                                for(var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType;){
                                    if (!inRootOrSingleton) {
                                        markerInstance = null;
                                        break b;
                                    }
                                    markerInstance = getNextHydratable(markerInstance.nextSibling);
                                    if (null === markerInstance) {
                                        markerInstance = null;
                                        break b;
                                    }
                                }
                                inRootOrSingleton = markerInstance.data;
                                markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                            }
                            if (markerInstance) {
                                nextHydratableInstance = getNextHydratable(markerInstance.nextSibling);
                                isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                                break a;
                            }
                        }
                        throwOnHydrationMismatch(isMatching);
                    }
                    isMatching = !1;
                }
                isMatching && (initialStateProp = ssrFormState[0]);
            }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        isMatching = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: actionStateReducer,
            lastRenderedState: initialStateProp
        };
        ssrFormState.queue = isMatching;
        ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber$1, isMatching);
        isMatching.dispatch = ssrFormState;
        isMatching = mountStateImpl(!1);
        inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !1, isMatching.queue);
        isMatching = mountWorkInProgressHook();
        markerInstance = {
            state: initialStateProp,
            dispatch: null,
            action: action,
            pending: null
        };
        isMatching.queue = markerInstance;
        ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber$1, markerInstance, inRootOrSingleton, ssrFormState);
        markerInstance.dispatch = ssrFormState;
        isMatching.memoizedState = action;
        return [
            initialStateProp,
            ssrFormState,
            !1
        ];
    }
    function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
        stateHook = updateReducer(basicStateReducer)[0];
        currentStateHook = "object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;
        var actionQueueHook = updateWorkInProgressHook(), actionQueue = actionQueueHook.queue, dispatch = actionQueue.dispatch;
        action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), {
            destroy: void 0
        }, null));
        return [
            currentStateHook,
            dispatch,
            stateHook
        ];
    }
    function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
    }
    function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [
            stateHook,
            dispatch,
            !1
        ];
    }
    function pushEffect(tag, create, inst, deps) {
        tag = {
            tag: tag,
            create: create,
            inst: inst,
            deps: deps,
            next: null
        };
        create = currentlyRenderingFiber$1.updateQueue;
        null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);
        inst = create.lastEffect;
        null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);
        return tag;
    }
    function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        initialValue = {
            current: initialValue
        };
        return hook.memoizedState = initialValue;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = mountWorkInProgressHook();
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, {
            destroy: void 0
        }, void 0 === deps ? null : deps);
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, deps));
    }
    function mountEffect(create, deps) {
        (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber$1.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(142608384, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);
    }
    function mountLayoutEffect(create, deps) {
        var fiberFlags = 4194308;
        (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 67108864);
        return mountEffectImpl(fiberFlags, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
        if ("function" === typeof ref) {
            create = create();
            var refCleanup = ref(create);
            return function() {
                "function" === typeof refCleanup ? refCleanup() : ref(null);
            };
        }
        if (null !== ref && void 0 !== ref) return ref.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(ref).join(", ") + "}"), create = create(), ref.current = create, function() {
            ref.current = null;
        };
    }
    function mountImperativeHandle(ref, create, deps) {
        "function" !== typeof create && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== create ? typeof create : "null");
        deps = null !== deps && void 0 !== deps ? deps.concat([
            ref
        ]) : null;
        var fiberFlags = 4194308;
        (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 67108864);
        mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function updateImperativeHandle(ref, create, deps) {
        "function" !== typeof create && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== create ? typeof create : "null");
        deps = null !== deps && void 0 !== deps ? deps.concat([
            ref
        ]) : null;
        updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function mountCallback(callback, deps) {
        mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
        ];
        return callback;
    }
    function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
        hook.memoizedState = [
            callback,
            deps
        ];
        return callback;
    }
    function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var nextValue = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(!0);
            try {
                nextCreate();
            } finally{
                setIsStrictModeForDevtools(!1);
            }
        }
        hook.memoizedState = [
            nextValue,
            deps
        ];
        return nextValue;
    }
    function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(!0);
            try {
                nextCreate();
            } finally{
                setIsStrictModeForDevtools(!1);
            }
        }
        hook.memoizedState = [
            prevState,
            deps
        ];
        return prevState;
    }
    function mountDeferredValue(value, initialValue) {
        var hook = mountWorkInProgressHook();
        return mountDeferredValueImpl(hook, value, initialValue);
    }
    function updateDeferredValue(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function rerenderDeferredValue(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber$1.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;
        if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber$1.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, !1, queue, pendingState);
        currentTransition._updatedFibers = new Set();
        try {
            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
                var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
                dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
            } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
        } catch (error) {
            dispatchSetStateInternal(fiber, queue, {
                then: function() {},
                status: "rejected",
                reason: error
            }, requestUpdateLane(fiber));
        } finally{
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
        }
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error("Expected the form instance to be a HostComponent. This is a bug in React.");
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop$2 : function() {
            requestFormReset$1(formFiber);
            return action(formData);
        });
    }
    function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
            memoizedState: NotPendingTransition,
            baseState: NotPendingTransition,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: NotPendingTransition
            },
            next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
            memoizedState: initialResetState,
            baseState: initialResetState,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: initialResetState
            },
            next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
        null === ReactSharedInternals.T && console.error("requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.");
        var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
        dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));
    }
    function mountTransition() {
        var stateHook = mountStateImpl(!1);
        stateHook = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, !0, !1);
        mountWorkInProgressHook().memoizedState = stateHook;
        return [
            !1,
            stateHook
        ];
    }
    function updateTransition() {
        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
        ];
    }
    function rerenderTransition() {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
        ];
    }
    function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
    }
    function mountId() {
        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
            var treeId = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
            identifierPrefix = ":" + identifierPrefix + "R" + treeId;
            treeId = localIdCounter++;
            0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
            identifierPrefix += ":";
        } else treeId = globalClientIdCounter++, identifierPrefix = ":" + identifierPrefix + "r" + treeId.toString(32) + ":";
        return hook.memoizedState = identifierPrefix;
    }
    function mountRefresh() {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);
    }
    function refreshCache(fiber, seedKey) {
        for(var provider = fiber.return; null !== provider;){
            switch(provider.tag){
                case 24:
                case 3:
                    var lane = requestUpdateLane(provider);
                    fiber = createUpdate(lane);
                    var root = enqueueUpdate(provider, fiber, lane);
                    null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));
                    provider = createCache();
                    null !== seedKey && void 0 !== seedKey && null !== root && console.error("The seed argument is not enabled outside experimental channels.");
                    fiber.payload = {
                        cache: provider
                    };
                    return;
            }
            provider = provider.return;
        }
    }
    function dispatchReducerAction(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0) {
        "function" === typeof JSCompiler_OptimizeArgumentsArray_p0 && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
        JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);
        action = {
            lane: JSCompiler_OptimizeArgumentsArray_p0,
            revertLane: 0,
            action: action,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0), null !== action && (scheduleUpdateOnFiber(action, fiber, JSCompiler_OptimizeArgumentsArray_p0), entangleTransitionUpdate(action, queue, JSCompiler_OptimizeArgumentsArray_p0)));
        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);
    }
    function dispatchSetState(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1) {
        "function" === typeof JSCompiler_OptimizeArgumentsArray_p1 && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
        JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);
        dispatchSetStateInternal(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1);
        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
            lane: lane,
            revertLane: 0,
            action: action,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
            var alternate = fiber.alternate;
            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
                var prevDispatcher = ReactSharedInternals.H;
                ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                    var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                    update.hasEagerState = !0;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;
                } catch (error) {} finally{
                    ReactSharedInternals.H = prevDispatcher;
                }
            }
            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;
        }
        return !1;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.");
        action = {
            lane: 2,
            revertLane: requestTransitionLane(),
            action: action,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
            if (throwIfDuringRender) throw Error("Cannot update optimistic state while rendering.");
            console.error("Cannot call startTransition while rendering.");
        } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
        markStateUpdateScheduled(fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
    }
    function entangleTransitionUpdate(root, queue, lane) {
        if (0 !== (lane & 4194176)) {
            var queueLanes = queue.lanes;
            queueLanes &= root.pendingLanes;
            lane |= queueLanes;
            queue.lanes = lane;
            markRootEntangled(root, lane);
        }
    }
    function warnOnInvalidCallback(callback) {
        if (null !== callback && "function" !== typeof callback) {
            var key = String(callback);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
        }
    }
    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
        if (workInProgress.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(!0);
            try {
                partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally{
                setIsStrictModeForDevtools(!1);
            }
        }
        void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", ctor)));
        prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
        workInProgress.memoizedState = prevState;
        0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);
    }
    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress.stateNode;
        if ("function" === typeof instance.shouldComponentUpdate) {
            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
            if (workInProgress.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(!0);
                try {
                    oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
                } finally{
                    setIsStrictModeForDevtools(!1);
                }
            }
            void 0 === oldProps && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
            return oldProps;
        }
        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
    }
    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
        var oldState = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
    }
    function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
            newProps = {};
            for(var propName in baseProps)"ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
            newProps === baseProps && (newProps = assign({}, newProps));
            for(var _propName in Component)void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
        }
        return newProps;
    }
    function defaultOnUncaughtError(error, errorInfo) {
        reportGlobalError(error);
        error = componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.";
        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : "";
        ReactSharedInternals.getCurrentStack = function() {
            return componentStack;
        };
        try {
            console.warn("%s\n\n%s\n", error, "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.");
        } finally{
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
        }
    }
    function defaultOnCaughtError(error, errorInfo) {
        var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + "."), prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : "";
        ReactSharedInternals.getCurrentStack = function() {
            return componentStack;
        };
        try {
            "object" === typeof error && null !== error && "string" === typeof error.environmentName ? bindToConsole("error", [
                "%o\n\n%s\n\n%s\n",
                error,
                componentNameMessage,
                recreateMessage
            ], error.environmentName)() : console.error("%o\n\n%s\n\n%s\n", error, componentNameMessage, recreateMessage);
        } finally{
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
        }
    }
    function defaultOnRecoverableError(error) {
        reportGlobalError(error);
    }
    function logUncaughtError(root, errorInfo) {
        try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = null;
            var error = errorInfo.value;
            if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);
            else {
                var onUncaughtError = root.onUncaughtError;
                onUncaughtError(error, {
                    componentStack: errorInfo.stack
                });
            }
        } catch (e$4) {
            setTimeout(function() {
                throw e$4;
            });
        }
    }
    function logCaughtError(root, boundary, errorInfo) {
        try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = getComponentNameFromFiber(boundary);
            var onCaughtError = root.onCaughtError;
            onCaughtError(errorInfo.value, {
                componentStack: errorInfo.stack,
                errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
            });
        } catch (e$5) {
            setTimeout(function() {
                throw e$5;
            });
        }
    }
    function createRootErrorUpdate(root, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = CaptureUpdate;
        lane.payload = {
            element: null
        };
        lane.callback = function() {
            runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
        };
        return lane;
    }
    function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = CaptureUpdate;
        return lane;
    }
    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
            var error = errorInfo.value;
            update.payload = function() {
                return getDerivedStateFromError(error);
            };
            update.callback = function() {
                markFailedErrorBoundaryForHotReloading(fiber);
                runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
            };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
            "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([
                this
            ]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
            callComponentDidCatchInDEV(this, errorInfo);
            "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
        });
    }
    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            returnFiber = sourceFiber.alternate;
            null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);
            isHydrating && (didSuspendOrErrorDEV = !0);
            sourceFiber = suspenseHandlerStackCursor.current;
            if (null !== sourceFiber) {
                switch(sourceFiber.tag){
                    case 13:
                        return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([
                            value
                        ]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;
                    case 22:
                        return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                            transitions: null,
                            markerInstances: null,
                            retryQueue: new Set([
                                value
                            ])
                        }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([
                            value
                        ]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;
                }
                throw Error("Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React.");
            }
            attachPingListener(root, value, rootRenderLanes);
            renderDidSuspendDelayIfPossible();
            return !1;
        }
        if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.", {
            cause: value
        }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering the entire root.", {
            cause: value
        }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;
        var error = createCapturedValueAtFiber(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", {
            cause: value
        }), sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [
            error
        ] : workInProgressRootConcurrentErrors.push(error);
        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
        if (null === returnFiber) return !0;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
            switch(sourceFiber.tag){
                case 3:
                    return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;
                case 1:
                    if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;
            }
            sourceFiber = sourceFiber.return;
        }while (null !== sourceFiber);
        return !1;
    }
    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
        workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
    }
    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
        Component = Component.render;
        var ref = workInProgress.ref;
        if ("ref" in nextProps) {
            var propsWithoutRef = {};
            for(var key in nextProps)"ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress);
        markComponentRenderStarted(workInProgress);
        nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);
        key = checkDidRenderIdHook();
        markComponentRenderStopped();
        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        isHydrating && key && pushMaterializedTreeId(workInProgress);
        workInProgress.flags |= 1;
        reconcileChildren(current, workInProgress, nextProps, renderLanes);
        return workInProgress.child;
    }
    function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
        if (null === current) {
            var type = Component.type;
            if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);
            current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
            current.ref = workInProgress.ref;
            current.return = workInProgress;
            return workInProgress.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes)) {
            var prevProps = type.memoizedProps;
            Component = Component.compare;
            Component = null !== Component ? Component : shallowEqual;
            if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        }
        workInProgress.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress.ref;
        current.return = workInProgress;
        return workInProgress.child = current;
    }
    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
        if (null !== current) {
            var prevProps = current.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) {
                if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
                else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
            }
        }
        return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
    }
    function updateOffscreenComponent(current, workInProgress, renderLanes) {
        var nextProps = workInProgress.pendingProps, nextChildren = nextProps.children, nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & OffscreenDetached), prevState = null !== current ? current.memoizedState : null;
        markRef(current, workInProgress);
        if ("hidden" === nextProps.mode || nextIsDetached) {
            if (0 !== (workInProgress.flags & 128)) {
                nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
                if (null !== current) {
                    nextChildren = workInProgress.child = current.child;
                    for(nextIsDetached = 0; null !== nextChildren;)nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
                    workInProgress.childLanes = nextIsDetached & ~nextProps;
                } else workInProgress.childLanes = 0, workInProgress.child = null;
                return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);
            }
            if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {
                baseLanes: 0,
                cachePool: null
            }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);
            else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);
        } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));
        reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
    }
    function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
            parent: CacheContext._currentValue,
            pool: JSCompiler_inline_result
        };
        workInProgress.memoizedState = {
            baseLanes: nextBaseLanes,
            cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress, null);
        reuseHiddenContextOnStack(workInProgress);
        pushOffscreenSuspenseHandler(workInProgress);
        null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);
        return null;
    }
    function markRef(current, workInProgress) {
        var ref = workInProgress.ref;
        if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 2097664);
        else {
            if ("function" !== typeof ref && "object" !== typeof ref) throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
            if (null === current || current.ref !== ref) workInProgress.flags |= 2097664;
        }
    }
    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
        if (Component.prototype && "function" === typeof Component.prototype.render) {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutBadClass[componentName] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName), didWarnAboutBadClass[componentName] = !0);
        }
        workInProgress.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
        null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", componentName))));
        prepareToReadContext(workInProgress);
        markComponentRenderStarted(workInProgress);
        Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);
        nextProps = checkDidRenderIdHook();
        markComponentRenderStopped();
        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
        workInProgress.flags |= 1;
        reconcileChildren(current, workInProgress, Component, renderLanes);
        return workInProgress.child;
    }
    function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {
        prepareToReadContext(workInProgress);
        markComponentRenderStarted(workInProgress);
        hookTypesUpdateIndexDev = -1;
        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;
        workInProgress.updateQueue = null;
        nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);
        finishRenderingHooks(current, workInProgress);
        Component = checkDidRenderIdHook();
        markComponentRenderStopped();
        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        isHydrating && Component && pushMaterializedTreeId(workInProgress);
        workInProgress.flags |= 1;
        reconcileChildren(current, workInProgress, nextProps, renderLanes);
        return workInProgress.child;
    }
    function updateClassComponent(current$jscomp$0, workInProgress, Component, nextProps, renderLanes) {
        switch(shouldErrorImpl(workInProgress)){
            case !1:
                var _instance = workInProgress.stateNode, state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;
                _instance.updater.enqueueSetState(_instance, state, null);
                break;
            case !0:
                workInProgress.flags |= 128;
                workInProgress.flags |= 65536;
                _instance = Error("Simulated error coming from DevTools");
                var lane = renderLanes & -renderLanes;
                workInProgress.lanes |= lane;
                state = workInProgressRoot;
                if (null === state) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
                lane = createClassErrorUpdate(lane);
                initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));
                enqueueCapturedUpdate(workInProgress, lane);
        }
        prepareToReadContext(workInProgress);
        if (null === workInProgress.stateNode) {
            state = emptyContextObject;
            _instance = Component.contextType;
            "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(Component) || "Component", lane));
            "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
            _instance = new Component(nextProps, state);
            if (workInProgress.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(!0);
                try {
                    _instance = new Component(nextProps, state);
                } finally{
                    setIsStrictModeForDevtools(!1);
                }
            }
            state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
            _instance.updater = classComponentUpdater;
            workInProgress.stateNode = _instance;
            _instance._reactInternals = workInProgress;
            _instance._reactInternalInstance = fakeInternalInstance;
            "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", state, null === _instance.state ? "null" : "undefined", state)));
            if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
                var foundWillUpdateName = lane = state = null;
                "function" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
                "function" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
                "function" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
                if (null !== state || null !== lane || null !== foundWillUpdateName) {
                    _instance = getComponentNameFromType(Component) || "Component";
                    var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                    didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles", _instance, newApiName, null !== state ? "\n  " + state : "", null !== lane ? "\n  " + lane : "", null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""));
                }
            }
            _instance = workInProgress.stateNode;
            state = getComponentNameFromType(Component) || "Component";
            _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", state) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", state));
            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", state);
            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", state);
            _instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", state);
            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", state));
            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", state));
            "function" === typeof _instance.componentShouldUpdate && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", state);
            Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(Component) || "A pure component");
            "function" === typeof _instance.componentDidUnmount && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", state);
            "function" === typeof _instance.componentDidReceiveProps && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", state);
            "function" === typeof _instance.componentWillRecieveProps && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", state);
            "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", state);
            lane = _instance.props !== nextProps;
            void 0 !== _instance.props && lane && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", state);
            _instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", state, state);
            "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(Component)));
            "function" === typeof _instance.getDerivedStateFromProps && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
            "function" === typeof _instance.getDerivedStateFromError && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
            "function" === typeof Component.getSnapshotBeforeUpdate && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", state);
            (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
            "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", state);
            _instance = workInProgress.stateNode;
            _instance.props = nextProps;
            _instance.state = workInProgress.memoizedState;
            _instance.refs = {};
            initializeUpdateQueue(workInProgress);
            state = Component.contextType;
            _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
            _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", state)));
            workInProgress.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);
            _instance.state = workInProgress.memoizedState;
            state = Component.getDerivedStateFromProps;
            "function" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);
            "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress) || "Component"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);
            "function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);
            (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864);
            _instance = !0;
        } else if (null === current$jscomp$0) {
            _instance = workInProgress.stateNode;
            var unresolvedOldProps = workInProgress.memoizedProps;
            lane = resolveClassComponentProps(Component, unresolvedOldProps);
            _instance.props = lane;
            var oldContext = _instance.context;
            foundWillUpdateName = Component.contextType;
            state = emptyContextObject;
            "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
            newApiName = Component.getDerivedStateFromProps;
            foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
            unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
            foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);
            hasForceUpdate = !1;
            var oldState = workInProgress.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
            suspendIfUpdateReadFromEntangledAsyncAction();
            oldContext = workInProgress.memoizedState;
            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864)) : ("function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864), _instance = !1);
        } else {
            _instance = workInProgress.stateNode;
            cloneUpdateQueue(current$jscomp$0, workInProgress);
            state = workInProgress.memoizedProps;
            foundWillUpdateName = resolveClassComponentProps(Component, state);
            _instance.props = foundWillUpdateName;
            newApiName = workInProgress.pendingProps;
            oldState = _instance.context;
            oldContext = Component.contextType;
            lane = emptyContextObject;
            "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
            unresolvedOldProps = Component.getDerivedStateFromProps;
            (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);
            hasForceUpdate = !1;
            oldState = workInProgress.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
            suspendIfUpdateReadFromEntangledAsyncAction();
            var newState = workInProgress.memoizedState;
            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), "function" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), _instance = !1);
        }
        lane = _instance;
        markRef(current$jscomp$0, workInProgress);
        state = 0 !== (workInProgress.flags & 128);
        if (lane || state) {
            lane = workInProgress.stateNode;
            ReactSharedInternals.getCurrentStack = null === workInProgress ? null : getCurrentFiberStackInDev;
            isRendering = !1;
            current = workInProgress;
            if (state && "function" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;
            else {
                markComponentRenderStarted(workInProgress);
                Component = callRenderInDEV(lane);
                if (workInProgress.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(!0);
                    try {
                        callRenderInDEV(lane);
                    } finally{
                        setIsStrictModeForDevtools(!1);
                    }
                }
                markComponentRenderStopped();
            }
            workInProgress.flags |= 1;
            null !== current$jscomp$0 && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current$jscomp$0.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current$jscomp$0, workInProgress, Component, renderLanes);
            workInProgress.memoizedState = lane.state;
            current$jscomp$0 = workInProgress.child;
        } else current$jscomp$0 = bailoutOnAlreadyFinishedWork(current$jscomp$0, workInProgress, renderLanes);
        renderLanes = workInProgress.stateNode;
        _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress) || "a component"), didWarnAboutReassigningProps = !0);
        return current$jscomp$0;
    }
    function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {
        resetHydrationState();
        workInProgress.flags |= 256;
        reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
    }
    function validateFunctionComponentInDev(workInProgress, Component) {
        Component && Component.childContextTypes && console.error("childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...", Component.displayName || Component.name || "Component");
        "function" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error("%s: Function components do not support getDerivedStateFromProps.", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));
        "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error("%s: Function components do not support contextType.", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));
    }
    function mountSuspenseOffscreenState(renderLanes) {
        return {
            baseLanes: renderLanes,
            cachePool: getSuspendedCache()
        };
    }
    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {
        current = null !== current ? current.childLanes & ~renderLanes : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
    }
    function updateSuspenseComponent(current, workInProgress, renderLanes) {
        var JSCompiler_object_inline_digest_2317;
        var JSCompiler_object_inline_stack_2318 = workInProgress.pendingProps;
        shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);
        var JSCompiler_object_inline_componentStack_2319 = !1;
        var didSuspend = 0 !== (workInProgress.flags & 128);
        (JSCompiler_object_inline_digest_2317 = didSuspend) || (JSCompiler_object_inline_digest_2317 = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
        JSCompiler_object_inline_digest_2317 && (JSCompiler_object_inline_componentStack_2319 = !0, workInProgress.flags &= -129);
        JSCompiler_object_inline_digest_2317 = 0 !== (workInProgress.flags & 32);
        workInProgress.flags &= -33;
        if (null === current) {
            if (isHydrating) {
                JSCompiler_object_inline_componentStack_2319 ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);
                if (isHydrating) {
                    var JSCompiler_object_inline_message_2316 = nextHydratableInstance;
                    var JSCompiler_temp;
                    if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2316)) {
                        c: {
                            var instance = JSCompiler_object_inline_message_2316;
                            for(JSCompiler_temp = rootOrSingletonContext; 8 !== instance.nodeType;){
                                if (!JSCompiler_temp) {
                                    JSCompiler_temp = null;
                                    break c;
                                }
                                instance = getNextHydratable(instance.nextSibling);
                                if (null === instance) {
                                    JSCompiler_temp = null;
                                    break c;
                                }
                            }
                            JSCompiler_temp = instance;
                        }
                        null !== JSCompiler_temp ? (warnIfNotHydrating(), workInProgress.memoizedState = {
                            dehydrated: JSCompiler_temp,
                            treeContext: null !== treeContextProvider ? {
                                id: treeContextId,
                                overflow: treeContextOverflow
                            } : null,
                            retryLane: 536870912
                        }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress, workInProgress.child = instance, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp = !0) : JSCompiler_temp = !1;
                        JSCompiler_temp = !JSCompiler_temp;
                    }
                    JSCompiler_temp && (warnNonHydratedInstance(workInProgress, JSCompiler_object_inline_message_2316), throwOnHydrationMismatch(workInProgress));
                }
                JSCompiler_object_inline_message_2316 = workInProgress.memoizedState;
                if (null !== JSCompiler_object_inline_message_2316 && (JSCompiler_object_inline_message_2316 = JSCompiler_object_inline_message_2316.dehydrated, null !== JSCompiler_object_inline_message_2316)) return JSCompiler_object_inline_message_2316.data === SUSPENSE_FALLBACK_START_DATA ? workInProgress.lanes = 16 : workInProgress.lanes = 536870912, null;
                popSuspenseHandler(workInProgress);
            }
            JSCompiler_object_inline_message_2316 = JSCompiler_object_inline_stack_2318.children;
            JSCompiler_object_inline_stack_2318 = JSCompiler_object_inline_stack_2318.fallback;
            if (JSCompiler_object_inline_componentStack_2319) return reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2319 = workInProgress.mode, JSCompiler_object_inline_message_2316 = mountWorkInProgressOffscreenFiber({
                mode: "hidden",
                children: JSCompiler_object_inline_message_2316
            }, JSCompiler_object_inline_componentStack_2319), JSCompiler_object_inline_stack_2318 = createFiberFromFragment(JSCompiler_object_inline_stack_2318, JSCompiler_object_inline_componentStack_2319, renderLanes, null), JSCompiler_object_inline_message_2316.return = workInProgress, JSCompiler_object_inline_stack_2318.return = workInProgress, JSCompiler_object_inline_message_2316.sibling = JSCompiler_object_inline_stack_2318, workInProgress.child = JSCompiler_object_inline_message_2316, JSCompiler_object_inline_componentStack_2319 = workInProgress.child, JSCompiler_object_inline_componentStack_2319.memoizedState = mountSuspenseOffscreenState(renderLanes), JSCompiler_object_inline_componentStack_2319.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2317, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2318;
            pushPrimaryTreeSuspenseHandler(workInProgress);
            return mountSuspensePrimaryChildren(workInProgress, JSCompiler_object_inline_message_2316);
        }
        var prevState = current.memoizedState;
        if (null !== prevState && (JSCompiler_object_inline_message_2316 = prevState.dehydrated, null !== JSCompiler_object_inline_message_2316)) {
            if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_stack_2318.fallback, JSCompiler_object_inline_message_2316 = workInProgress.mode, JSCompiler_object_inline_stack_2318 = mountWorkInProgressOffscreenFiber({
                mode: "visible",
                children: JSCompiler_object_inline_stack_2318.children
            }, JSCompiler_object_inline_message_2316), JSCompiler_object_inline_componentStack_2319 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_message_2316, renderLanes, null), JSCompiler_object_inline_componentStack_2319.flags |= 2, JSCompiler_object_inline_stack_2318.return = workInProgress, JSCompiler_object_inline_componentStack_2319.return = workInProgress, JSCompiler_object_inline_stack_2318.sibling = JSCompiler_object_inline_componentStack_2319, workInProgress.child = JSCompiler_object_inline_stack_2318, reconcileChildFibers(workInProgress, current.child, null, renderLanes), JSCompiler_object_inline_stack_2318 = workInProgress.child, JSCompiler_object_inline_stack_2318.memoizedState = mountSuspenseOffscreenState(renderLanes), JSCompiler_object_inline_stack_2318.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2317, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = JSCompiler_object_inline_componentStack_2319);
            else if (pushPrimaryTreeSuspenseHandler(workInProgress), isHydrating && console.error("We should not be hydrating here. This is a bug in React. Please file a bug."), JSCompiler_object_inline_message_2316.data === SUSPENSE_FALLBACK_START_DATA) {
                JSCompiler_object_inline_digest_2317 = JSCompiler_object_inline_message_2316.nextSibling && JSCompiler_object_inline_message_2316.nextSibling.dataset;
                if (JSCompiler_object_inline_digest_2317) {
                    JSCompiler_temp = JSCompiler_object_inline_digest_2317.dgst;
                    var message = JSCompiler_object_inline_digest_2317.msg;
                    instance = JSCompiler_object_inline_digest_2317.stck;
                    var componentStack = JSCompiler_object_inline_digest_2317.cstck;
                }
                JSCompiler_object_inline_message_2316 = message;
                JSCompiler_object_inline_digest_2317 = JSCompiler_temp;
                JSCompiler_object_inline_stack_2318 = instance;
                JSCompiler_temp = JSCompiler_object_inline_componentStack_2319 = componentStack;
                JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_message_2316 ? Error(JSCompiler_object_inline_message_2316) : Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
                JSCompiler_object_inline_componentStack_2319.stack = JSCompiler_object_inline_stack_2318 || "";
                JSCompiler_object_inline_componentStack_2319.digest = JSCompiler_object_inline_digest_2317;
                JSCompiler_object_inline_digest_2317 = void 0 === JSCompiler_temp ? null : JSCompiler_temp;
                JSCompiler_object_inline_stack_2318 = {
                    value: JSCompiler_object_inline_componentStack_2319,
                    source: null,
                    stack: JSCompiler_object_inline_digest_2317
                };
                "string" === typeof JSCompiler_object_inline_digest_2317 && CapturedStacks.set(JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_stack_2318);
                queueHydrationError(JSCompiler_object_inline_stack_2318);
                workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
            } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_object_inline_digest_2317 = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2317) {
                JSCompiler_object_inline_digest_2317 = workInProgressRoot;
                if (null !== JSCompiler_object_inline_digest_2317) {
                    JSCompiler_object_inline_stack_2318 = renderLanes & -renderLanes;
                    if (0 !== (JSCompiler_object_inline_stack_2318 & 42)) JSCompiler_object_inline_stack_2318 = 1;
                    else switch(JSCompiler_object_inline_stack_2318){
                        case 2:
                            JSCompiler_object_inline_stack_2318 = 1;
                            break;
                        case 8:
                            JSCompiler_object_inline_stack_2318 = 4;
                            break;
                        case 32:
                            JSCompiler_object_inline_stack_2318 = 16;
                            break;
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                            JSCompiler_object_inline_stack_2318 = 64;
                            break;
                        case 268435456:
                            JSCompiler_object_inline_stack_2318 = 134217728;
                            break;
                        default:
                            JSCompiler_object_inline_stack_2318 = 0;
                    }
                    JSCompiler_object_inline_stack_2318 = 0 !== (JSCompiler_object_inline_stack_2318 & (JSCompiler_object_inline_digest_2317.suspendedLanes | renderLanes)) ? 0 : JSCompiler_object_inline_stack_2318;
                    if (0 !== JSCompiler_object_inline_stack_2318 && JSCompiler_object_inline_stack_2318 !== prevState.retryLane) throw prevState.retryLane = JSCompiler_object_inline_stack_2318, enqueueConcurrentRenderForLane(current, JSCompiler_object_inline_stack_2318), scheduleUpdateOnFiber(JSCompiler_object_inline_digest_2317, current, JSCompiler_object_inline_stack_2318), SelectiveHydrationException;
                }
                JSCompiler_object_inline_message_2316.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
                workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
            } else JSCompiler_object_inline_message_2316.data === SUSPENSE_PENDING_START_DATA ? (workInProgress.flags |= 128, workInProgress.child = current.child, workInProgress = retryDehydratedSuspenseBoundary.bind(null, current), JSCompiler_object_inline_message_2316._reactRetry = workInProgress, workInProgress = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(JSCompiler_object_inline_message_2316.nextSibling), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress), workInProgress = mountSuspensePrimaryChildren(workInProgress, JSCompiler_object_inline_stack_2318.children), workInProgress.flags |= 4096);
            return workInProgress;
        }
        if (JSCompiler_object_inline_componentStack_2319) return reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_stack_2318.fallback, JSCompiler_object_inline_message_2316 = workInProgress.mode, JSCompiler_temp = current.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2318 = createWorkInProgress(JSCompiler_temp, {
            mode: "hidden",
            children: JSCompiler_object_inline_stack_2318.children
        }), JSCompiler_object_inline_stack_2318.subtreeFlags = JSCompiler_temp.subtreeFlags & 31457280, null !== instance ? JSCompiler_object_inline_componentStack_2319 = createWorkInProgress(instance, JSCompiler_object_inline_componentStack_2319) : (JSCompiler_object_inline_componentStack_2319 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_message_2316, renderLanes, null), JSCompiler_object_inline_componentStack_2319.flags |= 2), JSCompiler_object_inline_componentStack_2319.return = workInProgress, JSCompiler_object_inline_stack_2318.return = workInProgress, JSCompiler_object_inline_stack_2318.sibling = JSCompiler_object_inline_componentStack_2319, workInProgress.child = JSCompiler_object_inline_stack_2318, JSCompiler_object_inline_stack_2318 = JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_componentStack_2319 = workInProgress.child, JSCompiler_object_inline_message_2316 = current.child.memoizedState, null === JSCompiler_object_inline_message_2316 ? JSCompiler_object_inline_message_2316 = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp = JSCompiler_object_inline_message_2316.cachePool, null !== JSCompiler_temp ? (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent !== instance ? {
            parent: instance,
            pool: instance
        } : JSCompiler_temp) : JSCompiler_temp = getSuspendedCache(), JSCompiler_object_inline_message_2316 = {
            baseLanes: JSCompiler_object_inline_message_2316.baseLanes | renderLanes,
            cachePool: JSCompiler_temp
        }), JSCompiler_object_inline_componentStack_2319.memoizedState = JSCompiler_object_inline_message_2316, JSCompiler_object_inline_componentStack_2319.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2317, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2318;
        pushPrimaryTreeSuspenseHandler(workInProgress);
        renderLanes = current.child;
        current = renderLanes.sibling;
        renderLanes = createWorkInProgress(renderLanes, {
            mode: "visible",
            children: JSCompiler_object_inline_stack_2318.children
        });
        renderLanes.return = workInProgress;
        renderLanes.sibling = null;
        null !== current && (JSCompiler_object_inline_digest_2317 = workInProgress.deletions, null === JSCompiler_object_inline_digest_2317 ? (workInProgress.deletions = [
            current
        ], workInProgress.flags |= 16) : JSCompiler_object_inline_digest_2317.push(current));
        workInProgress.child = renderLanes;
        workInProgress.memoizedState = null;
        return renderLanes;
    }
    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber({
            mode: "visible",
            children: primaryChildren
        }, workInProgress.mode);
        primaryChildren.return = workInProgress;
        return workInProgress.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        return createFiberFromOffscreen(offscreenProps, mode, 0, null);
    }
    function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {
        reconcileChildFibers(workInProgress, current.child, null, renderLanes);
        current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);
        current.flags |= 2;
        workInProgress.memoizedState = null;
        return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
        fiber.lanes |= renderLanes;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
    }
    function validateSuspenseListNestedChild(childSlot, index) {
        var isAnArray = isArrayImpl(childSlot);
        childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
        return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", isAnArray, index, isAnArray), !1) : !0;
    }
    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress.memoizedState;
        null === renderState ? workInProgress.memoizedState = {
            isBackwards: isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail: tail,
            tailMode: tailMode
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
    }
    function updateSuspenseListComponent(current, workInProgress, renderLanes) {
        var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        nextProps = nextProps.children;
        if (void 0 !== revealOrder && "forwards" !== revealOrder && "backwards" !== revealOrder && "together" !== revealOrder && !didWarnAboutRevealOrder[revealOrder]) {
            if (didWarnAboutRevealOrder[revealOrder] = !0, "string" === typeof revealOrder) switch(revealOrder.toLowerCase()){
                case "together":
                case "forwards":
                case "backwards":
                    console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                case "forward":
                case "backward":
                    console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                default:
                    console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
            }
            else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
        }
        void 0 === tailMode || didWarnAboutTailOptions[tailMode] || ("collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[tailMode] = !0, console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode)) : "forwards" !== revealOrder && "backwards" !== revealOrder && (didWarnAboutTailOptions[tailMode] = !0, console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode)));
        a: if (("forwards" === revealOrder || "backwards" === revealOrder) && void 0 !== nextProps && null !== nextProps && !1 !== nextProps) {
            if (isArrayImpl(nextProps)) for(var i = 0; i < nextProps.length; i++){
                if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
            }
            else if (i = getIteratorFn(nextProps), "function" === typeof i) {
                if (i = i.call(nextProps)) for(var step = i.next(), _i = 0; !step.done; step = i.next()){
                    if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                    _i++;
                }
            } else console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
        }
        reconcileChildren(current, workInProgress, nextProps, renderLanes);
        nextProps = suspenseStackCursor.current;
        if (0 !== (nextProps & ForceSuspenseFallback)) nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128;
        else {
            if (null !== current && 0 !== (current.flags & 128)) a: for(current = workInProgress.child; null !== current;){
                if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
                else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
                else if (null !== current.child) {
                    current.child.return = current;
                    current = current.child;
                    continue;
                }
                if (current === workInProgress) break a;
                for(; null === current.sibling;){
                    if (null === current.return || current.return === workInProgress) break a;
                    current = current.return;
                }
                current.sibling.return = current.return;
                current = current.sibling;
            }
            nextProps &= SubtreeSuspenseContextMask;
        }
        push(suspenseStackCursor, nextProps, workInProgress);
        switch(revealOrder){
            case "forwards":
                renderLanes = workInProgress.child;
                for(revealOrder = null; null !== renderLanes;)current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;
                renderLanes = revealOrder;
                null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);
                initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);
                break;
            case "backwards":
                renderLanes = null;
                revealOrder = workInProgress.child;
                for(workInProgress.child = null; null !== revealOrder;){
                    current = revealOrder.alternate;
                    if (null !== current && null === findFirstSuspended(current)) {
                        workInProgress.child = revealOrder;
                        break;
                    }
                    current = revealOrder.sibling;
                    revealOrder.sibling = renderLanes;
                    renderLanes = revealOrder;
                    revealOrder = current;
                }
                initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);
                break;
            case "together":
                initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
                break;
            default:
                workInProgress.memoizedState = null;
        }
        return workInProgress.child;
    }
    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
        null !== current && (workInProgress.dependencies = current.dependencies);
        profilerStartTime = -1;
        workInProgressRootSkippedLanes |= workInProgress.lanes;
        if (0 === (renderLanes & workInProgress.childLanes)) {
            if (null !== current) {
                if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;
            } else return null;
        }
        if (null !== current && workInProgress.child !== current.child) throw Error("Resuming work not yet implemented.");
        if (null !== workInProgress.child) {
            current = workInProgress.child;
            renderLanes = createWorkInProgress(current, current.pendingProps);
            workInProgress.child = renderLanes;
            for(renderLanes.return = workInProgress; null !== current.sibling;)current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;
            renderLanes.sibling = null;
        }
        return workInProgress.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes) {
        if (0 !== (current.lanes & renderLanes)) return !0;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? !0 : !1;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {
        switch(workInProgress.tag){
            case 3:
                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
                resetHydrationState();
                break;
            case 27:
            case 5:
                pushHostContext(workInProgress);
                break;
            case 4:
                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                break;
            case 10:
                pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);
                break;
            case 12:
                0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);
                workInProgress.flags |= 2048;
                var stateNode = workInProgress.stateNode;
                stateNode.effectDuration = -0;
                stateNode.passiveEffectDuration = -0;
                break;
            case 13:
                stateNode = workInProgress.memoizedState;
                if (null !== stateNode) {
                    if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;
                    if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);
                    pushPrimaryTreeSuspenseHandler(workInProgress);
                    current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                    return null !== current ? current.sibling : null;
                }
                pushPrimaryTreeSuspenseHandler(workInProgress);
                break;
            case 19:
                var didSuspendBefore = 0 !== (current.flags & 128);
                stateNode = 0 !== (renderLanes & workInProgress.childLanes);
                stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));
                if (didSuspendBefore) {
                    if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);
                    workInProgress.flags |= 128;
                }
                didSuspendBefore = workInProgress.memoizedState;
                null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
                push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);
                if (stateNode) break;
                else return null;
            case 22:
            case 23:
                return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);
            case 24:
                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    function beginWork(current, workInProgress, renderLanes) {
        if (workInProgress._debugNeedsRemount && null !== current) {
            renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);
            var returnFiber = workInProgress.return;
            if (null === returnFiber) throw Error("Cannot swap the root fiber.");
            current.alternate = null;
            workInProgress.alternate = null;
            renderLanes.index = workInProgress.index;
            renderLanes.sibling = workInProgress.sibling;
            renderLanes.return = workInProgress.return;
            renderLanes.ref = workInProgress.ref;
            renderLanes._debugInfo = workInProgress._debugInfo;
            if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;
            else {
                var prevSibling = returnFiber.child;
                if (null === prevSibling) throw Error("Expected parent to have a child.");
                for(; prevSibling.sibling !== workInProgress;)if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error("Expected to find the previous sibling.");
                prevSibling.sibling = renderLanes;
            }
            workInProgress = returnFiber.deletions;
            null === workInProgress ? (returnFiber.deletions = [
                current
            ], returnFiber.flags |= 16) : workInProgress.push(current);
            renderLanes.flags |= 2;
            return renderLanes;
        }
        if (null !== current) {
            if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;
            else {
                if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);
                didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
            }
        } else {
            didReceiveUpdate = !1;
            if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);
            returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));
        }
        workInProgress.lanes = 0;
        switch(workInProgress.tag){
            case 16:
                a: if (returnFiber = workInProgress.pendingProps, current = callLazyInitInDEV(workInProgress.elementType), workInProgress.type = current, "function" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));
                else {
                    if (void 0 !== current && null !== current) {
                        if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                            workInProgress.tag = 11;
                            workInProgress.type = current = resolveForwardRefForHotReloading(current);
                            workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);
                            break a;
                        } else if (prevSibling === REACT_MEMO_TYPE) {
                            workInProgress.tag = 14;
                            workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);
                            break a;
                        }
                    }
                    workInProgress = "";
                    null !== current && "object" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = " Did you wrap a component in React.lazy() more than once?");
                    current = getComponentNameFromType(current) || current;
                    throw Error("Element type is invalid. Received a promise that resolves to: " + current + ". Lazy element type must resolve to a class or function." + workInProgress);
                }
                return workInProgress;
            case 0:
                return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
            case 1:
                return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);
            case 3:
                a: {
                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                    if (null === current) throw Error("Should have a current fiber. This is a bug in React.");
                    var nextProps = workInProgress.pendingProps;
                    prevSibling = workInProgress.memoizedState;
                    returnFiber = prevSibling.element;
                    cloneUpdateQueue(current, workInProgress);
                    processUpdateQueue(workInProgress, nextProps, null, renderLanes);
                    var nextState = workInProgress.memoizedState;
                    nextProps = nextState.cache;
                    pushProvider(workInProgress, CacheContext, nextProps);
                    nextProps !== prevSibling.cache && propagateContextChanges(workInProgress, [
                        CacheContext
                    ], renderLanes, !0);
                    suspendIfUpdateReadFromEntangledAsyncAction();
                    nextProps = nextState.element;
                    if (prevSibling.isDehydrated) {
                        if (prevSibling = {
                            element: nextProps,
                            isDehydrated: !1,
                            cache: nextState.cache
                        }, workInProgress.updateQueue.baseState = prevSibling, workInProgress.memoizedState = prevSibling, workInProgress.flags & 256) {
                            workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);
                            break a;
                        } else if (nextProps !== returnFiber) {
                            returnFiber = createCapturedValueAtFiber(Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress);
                            queueHydrationError(returnFiber);
                            workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);
                            break a;
                        } else for(nextHydratableInstance = getNextHydratable(workInProgress.stateNode.containerInfo.firstChild), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !0, current = mountChildFibers(workInProgress, null, nextProps, renderLanes), workInProgress.child = current; current;)current.flags = current.flags & -3 | 4096, current = current.sibling;
                    } else {
                        resetHydrationState();
                        if (nextProps === returnFiber) {
                            workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                            break a;
                        }
                        reconcileChildren(current, workInProgress, nextProps, renderLanes);
                    }
                    workInProgress = workInProgress.child;
                }
                return workInProgress;
            case 26:
                return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (current = workInProgress.type, renderLanes = workInProgress.pendingProps, returnFiber = requiredContext(rootInstanceStackCursor.current), returnFiber = getOwnerDocumentFromRootContainer(returnFiber).createElement(current), returnFiber[internalInstanceKey] = workInProgress, returnFiber[internalPropsKey] = renderLanes, setInitialProperties(returnFiber, current, renderLanes), markNodeAsHoistable(returnFiber), workInProgress.stateNode = returnFiber) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;
            case 27:
                return pushHostContext(workInProgress), null === current && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, prevSibling, returnFiber, !1), didSuspendOrErrorDEV || (returnFiber = diffHydratedProperties(prevSibling, workInProgress.type, workInProgress.pendingProps, returnFiber), null !== returnFiber && (buildHydrationDiffNode(workInProgress, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, nextHydratableInstance = getNextHydratable(prevSibling.firstChild)), returnFiber = workInProgress.pendingProps.children, null !== current || isHydrating ? reconcileChildren(current, workInProgress, returnFiber, renderLanes) : workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes), markRef(current, workInProgress), workInProgress.child;
            case 5:
                return null === current && isHydrating && (nextProps = getHostContext(), returnFiber = validateDOMNesting(workInProgress.type, nextProps.ancestorInfo), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedProperties(nextState, workInProgress.type, workInProgress.pendingProps, nextProps), null !== nextProps && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress, nextHydratableInstance = getNextHydratable(nextState.firstChild), rootOrSingletonContext = !1, nextProps = !0) : nextProps = !1, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, nextProps = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), HostTransitionContext._currentValue = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
            case 6:
                return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext().ancestorInfo.current, current = null != renderLanes ? validateTextNesting(current, renderLanes.tag) : !0, renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;
            case 13:
                return updateSuspenseComponent(current, workInProgress, renderLanes);
            case 4:
                return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
            case 11:
                return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
            case 7:
                return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;
            case 8:
                return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
            case 12:
                return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
            case 10:
                return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, nextProps = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), pushProvider(workInProgress, returnFiber, nextProps), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;
            case 9:
                return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, "function" !== typeof returnFiber && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), markComponentRenderStopped(), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
            case 14:
                return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
            case 15:
                return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
            case 19:
                return updateSuspenseListComponent(current, workInProgress, renderLanes);
            case 22:
                return updateOffscreenComponent(current, workInProgress, renderLanes);
            case 24:
                return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = nextProps), workInProgress.memoizedState = {
                    parent: returnFiber,
                    cache: prevSibling
                }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, nextProps = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
                    parent: returnFiber,
                    cache: returnFiber
                }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [
                    CacheContext
                ], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
            case 29:
                throw workInProgress.pendingProps;
        }
        throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function resetContextDependencies() {
        lastContextDependency = currentlyRenderingFiber = null;
        isDisallowedContextReadInDEV = !1;
    }
    function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue, providerFiber);
        context._currentValue = nextValue;
        push(rendererCursorDEV, context._currentRenderer, providerFiber);
        void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
        context._currentRenderer = rendererSigil;
    }
    function popProvider(context, providerFiber) {
        context._currentValue = valueCursor.current;
        var currentRenderer = rendererCursorDEV.current;
        pop(rendererCursorDEV, providerFiber);
        context._currentRenderer = currentRenderer;
        pop(valueCursor, providerFiber);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
        for(; null !== parent;){
            var alternate = parent.alternate;
            (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);
            if (parent === propagationRoot) break;
            parent = parent.return;
        }
        parent !== propagationRoot && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {
        var fiber = workInProgress.child;
        null !== fiber && (fiber.return = workInProgress);
        for(; null !== fiber;){
            var list = fiber.dependencies;
            if (null !== list) {
                var nextFiber = fiber.child;
                list = list.firstContext;
                a: for(; null !== list;){
                    var dependency = list;
                    list = fiber;
                    for(var i = 0; i < contexts.length; i++)if (dependency.context === contexts[i]) {
                        list.lanes |= renderLanes;
                        dependency = list.alternate;
                        null !== dependency && (dependency.lanes |= renderLanes);
                        scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);
                        forcePropagateEntireTree || (nextFiber = null);
                        break a;
                    }
                    list = dependency.next;
                }
            } else if (18 === fiber.tag) {
                nextFiber = fiber.return;
                if (null === nextFiber) throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");
                nextFiber.lanes |= renderLanes;
                list = nextFiber.alternate;
                null !== list && (list.lanes |= renderLanes);
                scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
                nextFiber = null;
            } else nextFiber = fiber.child;
            if (null !== nextFiber) nextFiber.return = fiber;
            else for(nextFiber = fiber; null !== nextFiber;){
                if (nextFiber === workInProgress) {
                    nextFiber = null;
                    break;
                }
                fiber = nextFiber.sibling;
                if (null !== fiber) {
                    fiber.return = nextFiber.return;
                    nextFiber = fiber;
                    break;
                }
                nextFiber = nextFiber.return;
            }
            fiber = nextFiber;
        }
    }
    function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {
        current = null;
        for(var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;){
            if (!isInsidePropagationBailout) {
                if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
                else if (0 !== (parent.flags & 262144)) break;
            }
            if (10 === parent.tag) {
                var currentParent = parent.alternate;
                if (null === currentParent) throw Error("Should have a current fiber. This is a bug in React.");
                currentParent = currentParent.memoizedProps;
                if (null !== currentParent) {
                    var context = parent.type;
                    objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [
                        context
                    ]);
                }
            } else if (parent === hostTransitionProviderCursor.current) {
                currentParent = parent.alternate;
                if (null === currentParent) throw Error("Should have a current fiber. This is a bug in React.");
                currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [
                    HostTransitionContext
                ]);
            }
            parent = parent.return;
        }
        null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);
        workInProgress.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
        for(currentDependencies = currentDependencies.firstContext; null !== currentDependencies;){
            if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue)) return !0;
            currentDependencies = currentDependencies.next;
        }
        return !1;
    }
    function prepareToReadContext(workInProgress) {
        currentlyRenderingFiber = workInProgress;
        lastContextDependency = null;
        workInProgress = workInProgress.dependencies;
        null !== workInProgress && (workInProgress.firstContext = null);
    }
    function readContext(context) {
        isDisallowedContextReadInDEV && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        return readContextForConsumer(currentlyRenderingFiber, context);
    }
    function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = {
            context: context,
            memoizedValue: value,
            next: null
        };
        if (null === lastContextDependency) {
            if (null === consumer) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            lastContextDependency = context;
            consumer.dependencies = {
                lanes: 0,
                firstContext: context,
                _debugThenableState: null
            };
            consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
    }
    function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                lanes: 0,
                hiddenCallbacks: null
            },
            callbacks: null
        };
    }
    function cloneUpdateQueue(current, workInProgress) {
        current = current.updateQueue;
        workInProgress.updateQueue === current && (workInProgress.updateQueue = {
            baseState: current.baseState,
            firstBaseUpdate: current.firstBaseUpdate,
            lastBaseUpdate: current.lastBaseUpdate,
            shared: current.shared,
            callbacks: null
        });
    }
    function createUpdate(lane) {
        return {
            lane: lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
        };
    }
    function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
            var componentName = getComponentNameFromFiber(fiber);
            console.error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s", componentName);
            didWarnUpdateInsideUpdate = !0;
        }
        if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {
            var queueLanes = fiber.lanes;
            queueLanes &= root.pendingLanes;
            lane |= queueLanes;
            fiber.lanes = lane;
            markRootEntangled(root, lane);
        }
    }
    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
        var queue = workInProgress.updateQueue, current = workInProgress.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
            var newFirst = null, newLast = null;
            queue = queue.firstBaseUpdate;
            if (null !== queue) {
                do {
                    var clone = {
                        lane: queue.lane,
                        tag: queue.tag,
                        payload: queue.payload,
                        callback: null,
                        next: null
                    };
                    null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
                    queue = queue.next;
                }while (null !== queue);
                null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
            } else newFirst = newLast = capturedUpdate;
            queue = {
                baseState: current.baseState,
                firstBaseUpdate: newFirst,
                lastBaseUpdate: newLast,
                shared: current.shared,
                callbacks: current.callbacks
            };
            workInProgress.updateQueue = queue;
            return;
        }
        workInProgress = queue.lastBaseUpdate;
        null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
    }
    function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
            var entangledActionThenable = currentEntangledActionThenable;
            if (null !== entangledActionThenable) throw entangledActionThenable;
        }
    }
    function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {
        didReadFromEntangledAsyncAction = !1;
        var queue = workInProgress.updateQueue;
        hasForceUpdate = !1;
        currentlyProcessingQueue = queue.shared;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate;
            var current = workInProgress.alternate;
            null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
            var newState = queue.baseState;
            lastBaseUpdate = 0;
            current = firstPendingUpdate = lastPendingUpdate = null;
            pendingQueue = firstBaseUpdate;
            do {
                var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
                if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                    0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
                    null !== current && (current = current.next = {
                        lane: 0,
                        tag: pendingQueue.tag,
                        payload: pendingQueue.payload,
                        callback: null,
                        next: null
                    });
                    a: {
                        updateLane = workInProgress;
                        var partialState = pendingQueue;
                        var nextProps = props, instance = instance$jscomp$0;
                        switch(partialState.tag){
                            case ReplaceState:
                                partialState = partialState.payload;
                                if ("function" === typeof partialState) {
                                    isDisallowedContextReadInDEV = !0;
                                    var nextState = partialState.call(instance, newState, nextProps);
                                    if (updateLane.mode & StrictLegacyMode) {
                                        setIsStrictModeForDevtools(!0);
                                        try {
                                            partialState.call(instance, newState, nextProps);
                                        } finally{
                                            setIsStrictModeForDevtools(!1);
                                        }
                                    }
                                    isDisallowedContextReadInDEV = !1;
                                    newState = nextState;
                                    break a;
                                }
                                newState = partialState;
                                break a;
                            case CaptureUpdate:
                                updateLane.flags = updateLane.flags & -65537 | 128;
                            case UpdateState:
                                nextState = partialState.payload;
                                if ("function" === typeof nextState) {
                                    isDisallowedContextReadInDEV = !0;
                                    partialState = nextState.call(instance, newState, nextProps);
                                    if (updateLane.mode & StrictLegacyMode) {
                                        setIsStrictModeForDevtools(!0);
                                        try {
                                            nextState.call(instance, newState, nextProps);
                                        } finally{
                                            setIsStrictModeForDevtools(!1);
                                        }
                                    }
                                    isDisallowedContextReadInDEV = !1;
                                } else partialState = nextState;
                                if (null === partialState || void 0 === partialState) break a;
                                newState = assign({}, newState, partialState);
                                break a;
                            case ForceUpdate:
                                hasForceUpdate = !0;
                        }
                    }
                    updateLane = pendingQueue.callback;
                    null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [
                        updateLane
                    ] : isHiddenUpdate.push(updateLane));
                } else isHiddenUpdate = {
                    lane: updateLane,
                    tag: pendingQueue.tag,
                    payload: pendingQueue.payload,
                    callback: pendingQueue.callback,
                    next: null
                }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
                pendingQueue = pendingQueue.next;
                if (null === pendingQueue) {
                    if (pendingQueue = queue.shared.pending, null === pendingQueue) break;
                    else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
                }
            }while (1);
            null === current && (lastPendingUpdate = newState);
            queue.baseState = lastPendingUpdate;
            queue.firstBaseUpdate = firstPendingUpdate;
            queue.lastBaseUpdate = current;
            null === firstBaseUpdate && (queue.shared.lanes = 0);
            workInProgressRootSkippedLanes |= lastBaseUpdate;
            workInProgress.lanes = lastBaseUpdate;
            workInProgress.memoizedState = newState;
        }
        currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
        if ("function" !== typeof callback) throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
        callback.call(context);
    }
    function commitHiddenCallbacks(updateQueue, context) {
        var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
        if (null !== hiddenCallbacks) for(updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)callCallback(hiddenCallbacks[updateQueue], context);
    }
    function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks) for(updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)callCallback(callbacks[updateQueue], context);
    }
    function shouldProfile(current) {
        return (current.mode & ProfileMode) !== NoMode;
    }
    function commitHookLayoutEffects(finishedWork, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitHookEffectListMount(flags, finishedWork) {
        try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
                var firstEffect = lastEffect.next;
                updateQueue = firstEffect;
                do {
                    if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                        var hookName = void 0;
                        hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                        var addendum = void 0;
                        addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                        runWithFiberInDEV(finishedWork, function(n, a) {
                            console.error("%s must not return anything besides a function, which is used for clean-up.%s", n, a);
                        }, hookName, addendum);
                    }
                    updateQueue = updateQueue.next;
                }while (updateQueue !== firstEffect);
            }
        } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
        try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
                var firstEffect = lastEffect.next;
                updateQueue = firstEffect;
                do {
                    if ((updateQueue.tag & flags) === flags) {
                        var inst = updateQueue.inst, destroy = inst.destroy;
                        void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), runWithFiberInDEV(finishedWork, callDestroyInDEV, finishedWork, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
                    }
                    updateQueue = updateQueue.next;
                }while (updateQueue !== firstEffect);
            }
        } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
            var instance = finishedWork.stateNode;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
            try {
                runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);
            } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
    }
    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
        return instance.getSnapshotBeforeUpdate(prevProps, prevState);
    }
    function commitClassSnapshot(finishedWork, current) {
        var prevProps = current.memoizedProps, prevState = current.memoizedState;
        current = finishedWork.stateNode;
        finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), current.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
        try {
            var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);
            var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);
            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
                console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
            }));
            current.__reactInternalSnapshotBeforeUpdate = snapshot;
        } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
        instance.state = current.memoizedState;
        shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);
    }
    function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;
        if (null !== ref) {
            var instance = finishedWork.stateNode;
            if ("function" === typeof ref) {
                if (shouldProfile(finishedWork)) try {
                    startEffectTimer(), finishedWork.refCleanup = ref(instance);
                } finally{
                    recordEffectDuration();
                }
                else finishedWork.refCleanup = ref(instance);
            } else "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork)), ref.current = instance;
        }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
        try {
            runWithFiberInDEV(current, commitAttachRef, current);
        } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref, refCleanup = current.refCleanup;
        if (null !== ref) {
            if ("function" === typeof refCleanup) try {
                if (shouldProfile(current)) try {
                    startEffectTimer(), runWithFiberInDEV(current, refCleanup);
                } finally{
                    recordEffectDuration(current);
                }
                else runWithFiberInDEV(current, refCleanup);
            } catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally{
                current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
            else if ("function" === typeof ref) try {
                if (shouldProfile(current)) try {
                    startEffectTimer(), runWithFiberInDEV(current, ref, null);
                } finally{
                    recordEffectDuration(current);
                }
                else runWithFiberInDEV(current, ref, null);
            } catch (error$6) {
                captureCommitPhaseError(current, nearestMountedAncestor, error$6);
            }
            else ref.current = null;
        }
    }
    function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {
        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
        _finishedWork$memoize = _finishedWork$memoize.onRender;
        current = null === current ? "mount" : "update";
        currentUpdateIsNested && (current = "nested-update");
        "function" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);
        "function" === typeof onCommit && onCommit(finishedWork.memoizedProps.id, current, effectDuration, commitStartTime);
    }
    function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {
        var _finishedWork$memoize2 = finishedWork.memoizedProps;
        finishedWork = _finishedWork$memoize2.id;
        _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
        current = null === current ? "mount" : "update";
        currentUpdateIsNested && (current = "nested-update");
        "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);
    }
    function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
            runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);
        } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
            runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);
        } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag || 4 === fiber.tag;
    }
    function getHostSibling(fiber) {
        a: for(;;){
            for(; null === fiber.sibling;){
                if (null === fiber.return || isHostParent(fiber.return)) return null;
                fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for(fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 27 !== fiber.tag && 18 !== fiber.tag;){
                if (fiber.flags & 2) continue a;
                if (null === fiber.child || 4 === fiber.tag) continue a;
                else fiber.child.return = fiber, fiber = fiber.child;
            }
            if (!(fiber.flags & 2)) return fiber.stateNode;
        }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag) node = node.stateNode, before ? 8 === parent.nodeType ? parent.parentNode.insertBefore(node, before) : parent.insertBefore(node, before) : (8 === parent.nodeType ? (before = parent.parentNode, before.insertBefore(node, parent)) : (before = parent, before.appendChild(node)), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
        else if (4 !== tag && 27 !== tag && (node = node.child, null !== node)) for(insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
    function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag) node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
        else if (4 !== tag && 27 !== tag && (node = node.child, null !== node)) for(insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
    function commitPlacement(finishedWork) {
        if (27 !== finishedWork.tag) {
            a: {
                for(var parent = finishedWork.return; null !== parent;){
                    if (isHostParent(parent)) {
                        var parentFiber = parent;
                        break a;
                    }
                    parent = parent.return;
                }
                throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            }
            switch(parentFiber.tag){
                case 27:
                    parent = parentFiber.stateNode;
                    parentFiber = getHostSibling(finishedWork);
                    insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
                    break;
                case 5:
                    parent = parentFiber.stateNode;
                    parentFiber.flags & 32 && (resetTextContent(parent), parentFiber.flags &= -33);
                    parentFiber = getHostSibling(finishedWork);
                    insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
                    break;
                case 3:
                case 4:
                    parent = parentFiber.stateNode.containerInfo;
                    parentFiber = getHostSibling(finishedWork);
                    insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, parent);
                    break;
                default:
                    throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
            }
        }
    }
    function commitBeforeMutationEffects(root, firstChild) {
        root = root.containerInfo;
        eventsEnabled = _enabled;
        root = getActiveElementDeep(root);
        if (hasSelectionCapabilities(root)) {
            if ("selectionStart" in root) var JSCompiler_temp = {
                start: root.selectionStart,
                end: root.selectionEnd
            };
            else a: {
                JSCompiler_temp = (JSCompiler_temp = root.ownerDocument) && JSCompiler_temp.defaultView || window;
                var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                if (selection && 0 !== selection.rangeCount) {
                    JSCompiler_temp = selection.anchorNode;
                    var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                    selection = selection.focusOffset;
                    try {
                        JSCompiler_temp.nodeType, focusNode.nodeType;
                    } catch (e$2) {
                        JSCompiler_temp = null;
                        break a;
                    }
                    var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root, parentNode = null;
                    b: for(;;){
                        for(var next;;){
                            node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                            node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                            3 === node.nodeType && (length += node.nodeValue.length);
                            if (null === (next = node.firstChild)) break;
                            parentNode = node;
                            node = next;
                        }
                        for(;;){
                            if (node === root) break b;
                            parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                            parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                            if (null !== (next = node.nextSibling)) break;
                            node = parentNode;
                            parentNode = node.parentNode;
                        }
                        node = next;
                    }
                    JSCompiler_temp = -1 === start || -1 === end ? null : {
                        start: start,
                        end: end
                    };
                } else JSCompiler_temp = null;
            }
            JSCompiler_temp = JSCompiler_temp || {
                start: 0,
                end: 0
            };
        } else JSCompiler_temp = null;
        selectionInformation = {
            focusedElem: root,
            selectionRange: JSCompiler_temp
        };
        _enabled = !1;
        for(nextEffect = firstChild; null !== nextEffect;)if (firstChild = nextEffect, root = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root) root.return = firstChild, nextEffect = root;
        else for(; null !== nextEffect;){
            root = firstChild = nextEffect;
            JSCompiler_temp = root.alternate;
            anchorOffset = root.flags;
            switch(root.tag){
                case 0:
                    break;
                case 11:
                case 15:
                    break;
                case 1:
                    0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root, JSCompiler_temp);
                    break;
                case 3:
                    if (0 !== (anchorOffset & 1024)) {
                        if (root = root.stateNode.containerInfo, JSCompiler_temp = root.nodeType, 9 === JSCompiler_temp) clearContainerSparingly(root);
                        else if (1 === JSCompiler_temp) switch(root.nodeName){
                            case "HEAD":
                            case "HTML":
                            case "BODY":
                                clearContainerSparingly(root);
                                break;
                            default:
                                root.textContent = "";
                        }
                    }
                    break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                    break;
                default:
                    if (0 !== (anchorOffset & 1024)) throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
            root = firstChild.sibling;
            if (null !== root) {
                root.return = firstChild.return;
                nextEffect = root;
                break;
            }
            nextEffect = firstChild.return;
        }
        firstChild = shouldFireAfterActiveInstanceBlur;
        shouldFireAfterActiveInstanceBlur = !1;
        return firstChild;
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch(finishedWork.tag){
            case 0:
            case 11:
            case 15:
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
                break;
            case 1:
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                if (flags & 4) {
                    if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);
                    else {
                        var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);
                        current = current.memoizedState;
                        finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
                        shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);
                    }
                }
                flags & 64 && commitClassCallbacks(finishedWork);
                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
                break;
            case 3:
                current = pushNestedEffectDurations();
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                    prevProps = null;
                    if (null !== finishedWork.child) switch(finishedWork.child.tag){
                        case 27:
                        case 5:
                            prevProps = finishedWork.child.stateNode;
                            break;
                        case 1:
                            prevProps = finishedWork.child.stateNode;
                    }
                    try {
                        runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);
                    } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                }
                finishedRoot.effectDuration += popNestedEffectDurations(current);
                break;
            case 26:
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
                break;
            case 27:
            case 5:
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                null === current && flags & 4 && commitHostMount(finishedWork);
                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
                break;
            case 12:
                if (flags & 4) {
                    flags = pushNestedEffectDurations();
                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                    finishedRoot = finishedWork.stateNode;
                    finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
                    try {
                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);
                    } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                break;
            case 13:
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                break;
            case 22:
                prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
                if (!prevProps) {
                    current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
                    var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                    offscreenSubtreeIsHidden = prevProps;
                    (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                    offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                }
                flags & 512 && ("manual" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));
                break;
            default:
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
    }
    function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber._debugOwner = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
    }
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for(parent = parent.child; null !== parent;)commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
            hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
        }
        switch(deletedFiber.tag){
            case 26:
                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
                break;
            case 27:
                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
                hostParent = deletedFiber.stateNode;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                deletedFiber = deletedFiber.stateNode;
                for(finishedRoot = deletedFiber.attributes; finishedRoot.length;)deletedFiber.removeAttributeNode(finishedRoot[0]);
                detachDeletedInstance(deletedFiber);
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                break;
            case 5:
                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            case 6:
                prevHostParent = hostParent;
                prevHostParentIsContainer = hostParentIsContainer;
                hostParent = null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                if (null !== hostParent) {
                    if (hostParentIsContainer) try {
                        runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);
                    } catch (error) {
                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
                    }
                    else try {
                        runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);
                    } catch (error) {
                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
                    }
                }
                break;
            case 18:
                null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, deletedFiber = deletedFiber.stateNode, 8 === finishedRoot.nodeType ? clearSuspenseBoundary(finishedRoot.parentNode, deletedFiber) : 1 === finishedRoot.nodeType && clearSuspenseBoundary(finishedRoot, deletedFiber), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
                break;
            case 4:
                prevHostParent = hostParent;
                prevHostParentIsContainer = hostParentIsContainer;
                hostParent = deletedFiber.stateNode.containerInfo;
                hostParentIsContainer = !0;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                break;
            case 0:
            case 11:
            case 14:
            case 15:
                offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);
                offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                break;
            case 1:
                offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                break;
            case 21:
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                break;
            case 22:
                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                offscreenSubtreeWasHidden = prevHostParent;
                break;
            default:
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {
            runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);
        } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
        switch(finishedWork.tag){
            case 13:
            case 19:
                var retryCache = finishedWork.stateNode;
                null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
                return retryCache;
            case 22:
                return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
            default:
                throw Error("Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React.");
        }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            if (!retryCache.has(wakeable)) {
                retryCache.add(wakeable);
                if (isDevToolsPresent) {
                    if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);
                    else throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                }
                wakeable.then(retry, retry);
            }
        });
    }
    function commitMutationEffects(root, finishedWork, committedLanes) {
        inProgressLanes = committedLanes;
        inProgressRoot = root;
        commitMutationEffectsOnFiber(finishedWork, root);
        inProgressRoot = inProgressLanes = null;
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions) for(var i = 0; i < deletions.length; i++){
            var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], parent = returnFiber;
            a: for(; null !== parent;){
                switch(parent.tag){
                    case 27:
                    case 5:
                        hostParent = parent.stateNode;
                        hostParentIsContainer = !1;
                        break a;
                    case 3:
                        hostParent = parent.stateNode.containerInfo;
                        hostParentIsContainer = !0;
                        break a;
                    case 4:
                        hostParent = parent.stateNode.containerInfo;
                        hostParentIsContainer = !0;
                        break a;
                }
                parent = parent.return;
            }
            if (null === hostParent) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
            hostParent = null;
            hostParentIsContainer = !1;
            root = deletedFiber;
            returnFiber = root.alternate;
            null !== returnFiber && (returnFiber.return = null);
            root.return = null;
        }
        if (parentFiber.subtreeFlags & 13878) for(parentFiber = parentFiber.child; null !== parentFiber;)commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    function commitMutationEffectsOnFiber(finishedWork, root) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch(finishedWork.tag){
            case 0:
            case 11:
            case 14:
            case 15:
                recursivelyTraverseMutationEffects(root, finishedWork);
                commitReconciliationEffects(finishedWork);
                flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));
                break;
            case 1:
                recursivelyTraverseMutationEffects(root, finishedWork);
                commitReconciliationEffects(finishedWork);
                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
                break;
            case 26:
                var hoistableRoot = currentHoistableRoot;
                recursivelyTraverseMutationEffects(root, finishedWork);
                commitReconciliationEffects(finishedWork);
                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                if (flags & 4) {
                    if (root = null !== current ? current.memoizedState : null, flags = finishedWork.memoizedState, null === current) {
                        if (null === flags) {
                            if (null === finishedWork.stateNode) {
                                a: {
                                    flags = finishedWork.type;
                                    current = finishedWork.memoizedProps;
                                    root = hoistableRoot.ownerDocument || hoistableRoot;
                                    b: switch(flags){
                                        case "title":
                                            hoistableRoot = root.getElementsByTagName("title")[0];
                                            if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute("itemprop")) hoistableRoot = root.createElement(flags), root.head.insertBefore(hoistableRoot, root.querySelector("head > title"));
                                            setInitialProperties(hoistableRoot, flags, current);
                                            hoistableRoot[internalInstanceKey] = finishedWork;
                                            markNodeAsHoistable(hoistableRoot);
                                            flags = hoistableRoot;
                                            break a;
                                        case "link":
                                            var maybeNodes = getHydratableHoistableCache("link", "href", root).get(flags + (current.href || ""));
                                            if (maybeNodes) {
                                                for(var i = 0; i < maybeNodes.length; i++)if (hoistableRoot = maybeNodes[i], hoistableRoot.getAttribute("href") === (null == current.href ? null : current.href) && hoistableRoot.getAttribute("rel") === (null == current.rel ? null : current.rel) && hoistableRoot.getAttribute("title") === (null == current.title ? null : current.title) && hoistableRoot.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                                    maybeNodes.splice(i, 1);
                                                    break b;
                                                }
                                            }
                                            hoistableRoot = root.createElement(flags);
                                            setInitialProperties(hoistableRoot, flags, current);
                                            root.head.appendChild(hoistableRoot);
                                            break;
                                        case "meta":
                                            if (maybeNodes = getHydratableHoistableCache("meta", "content", root).get(flags + (current.content || ""))) {
                                                for(i = 0; i < maybeNodes.length; i++)if (hoistableRoot = maybeNodes[i], checkAttributeStringCoercion(current.content, "content"), hoistableRoot.getAttribute("content") === (null == current.content ? null : "" + current.content) && hoistableRoot.getAttribute("name") === (null == current.name ? null : current.name) && hoistableRoot.getAttribute("property") === (null == current.property ? null : current.property) && hoistableRoot.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && hoistableRoot.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                                    maybeNodes.splice(i, 1);
                                                    break b;
                                                }
                                            }
                                            hoistableRoot = root.createElement(flags);
                                            setInitialProperties(hoistableRoot, flags, current);
                                            root.head.appendChild(hoistableRoot);
                                            break;
                                        default:
                                            throw Error('getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.');
                                    }
                                    hoistableRoot[internalInstanceKey] = finishedWork;
                                    markNodeAsHoistable(hoistableRoot);
                                    flags = hoistableRoot;
                                }
                                finishedWork.stateNode = flags;
                            } else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
                        } else finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);
                    } else root !== flags ? (null === root ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : root.count--, null === flags ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
                }
                break;
            case 27:
                if (flags & 4 && null === finishedWork.alternate) {
                    hoistableRoot = finishedWork.stateNode;
                    maybeNodes = finishedWork.memoizedProps;
                    try {
                        for(i = hoistableRoot.firstChild; i;){
                            var nextNode = i.nextSibling, nodeName = i.nodeName;
                            i[internalHoistableMarker] || "HEAD" === nodeName || "BODY" === nodeName || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === i.rel.toLowerCase() || hoistableRoot.removeChild(i);
                            i = nextNode;
                        }
                        runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, maybeNodes, hoistableRoot, finishedWork);
                    } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                }
            case 5:
                recursivelyTraverseMutationEffects(root, finishedWork);
                commitReconciliationEffects(finishedWork);
                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                if (finishedWork.flags & 32) {
                    root = finishedWork.stateNode;
                    try {
                        runWithFiberInDEV(finishedWork, resetTextContent, root);
                    } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                }
                flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));
                flags & 1024 && (needsFormReset = !0, "form" !== finishedWork.type && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
                break;
            case 6:
                recursivelyTraverseMutationEffects(root, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & 4) {
                    if (null === finishedWork.stateNode) throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                    flags = finishedWork.memoizedProps;
                    current = null !== current ? current.memoizedProps : flags;
                    root = finishedWork.stateNode;
                    try {
                        runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);
                    } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                }
                break;
            case 3:
                hoistableRoot = pushNestedEffectDurations();
                tagCaches = null;
                maybeNodes = currentHoistableRoot;
                currentHoistableRoot = getHoistableRoot(root.containerInfo);
                recursivelyTraverseMutationEffects(root, finishedWork);
                currentHoistableRoot = maybeNodes;
                commitReconciliationEffects(finishedWork);
                if (flags & 4 && null !== current && current.memoizedState.isDehydrated) try {
                    runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);
                } catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
                needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));
                root.effectDuration += popNestedEffectDurations(hoistableRoot);
                break;
            case 4:
                flags = currentHoistableRoot;
                currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
                recursivelyTraverseMutationEffects(root, finishedWork);
                commitReconciliationEffects(finishedWork);
                currentHoistableRoot = flags;
                break;
            case 12:
                flags = pushNestedEffectDurations();
                recursivelyTraverseMutationEffects(root, finishedWork);
                commitReconciliationEffects(finishedWork);
                finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
                break;
            case 13:
                recursivelyTraverseMutationEffects(root, finishedWork);
                commitReconciliationEffects(finishedWork);
                finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());
                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
                break;
            case 22:
                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                i = null !== finishedWork.memoizedState;
                nextNode = null !== current && null !== current.memoizedState;
                nodeName = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = nodeName || i;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || nextNode;
                recursivelyTraverseMutationEffects(root, finishedWork);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = nodeName;
                commitReconciliationEffects(finishedWork);
                root = finishedWork.stateNode;
                root._current = finishedWork;
                root._visibility &= ~OffscreenDetached;
                root._visibility |= root._pendingVisibility & OffscreenDetached;
                if (flags & 8192 && (root._visibility = i ? root._visibility & ~OffscreenVisible : root._visibility | OffscreenVisible, i && (root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || nextNode || root || recursivelyTraverseDisappearLayoutEffects(finishedWork)), null === finishedWork.memoizedProps || "manual" !== finishedWork.memoizedProps.mode)) a: for(current = null, root = finishedWork;;){
                    if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
                        if (null === current) {
                            nextNode = current = root;
                            try {
                                hoistableRoot = nextNode.stateNode, i ? runWithFiberInDEV(nextNode, hideInstance, hoistableRoot) : runWithFiberInDEV(nextNode, unhideInstance, nextNode.stateNode, nextNode.memoizedProps);
                            } catch (error) {
                                captureCommitPhaseError(nextNode, nextNode.return, error);
                            }
                        }
                    } else if (6 === root.tag) {
                        if (null === current) {
                            nextNode = root;
                            try {
                                maybeNodes = nextNode.stateNode, i ? runWithFiberInDEV(nextNode, hideTextInstance, maybeNodes) : runWithFiberInDEV(nextNode, unhideTextInstance, maybeNodes, nextNode.memoizedProps);
                            } catch (error) {
                                captureCommitPhaseError(nextNode, nextNode.return, error);
                            }
                        }
                    } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {
                        root.child.return = root;
                        root = root.child;
                        continue;
                    }
                    if (root === finishedWork) break a;
                    for(; null === root.sibling;){
                        if (null === root.return || root.return === finishedWork) break a;
                        current === root && (current = null);
                        root = root.return;
                    }
                    current === root && (current = null);
                    root.sibling.return = root.return;
                    root = root.sibling;
                }
                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
                break;
            case 19:
                recursivelyTraverseMutationEffects(root, finishedWork);
                commitReconciliationEffects(finishedWork);
                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
                break;
            case 21:
                break;
            default:
                recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
        }
    }
    function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
            try {
                runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
            } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
            finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024) for(parentFiber = parentFiber.child; null !== parentFiber;){
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
        }
    }
    function commitLayoutEffects(finishedWork, root, committedLanes) {
        inProgressLanes = committedLanes;
        inProgressRoot = root;
        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
        inProgressRoot = inProgressLanes = null;
    }
    function recursivelyTraverseLayoutEffects(root, parentFiber) {
        if (parentFiber.subtreeFlags & 8772) for(parentFiber = parentFiber.child; null !== parentFiber;)commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function disappearLayoutEffects(finishedWork) {
        switch(finishedWork.tag){
            case 0:
            case 11:
            case 14:
            case 15:
                commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
            case 1:
                safelyDetachRef(finishedWork, finishedWork.return);
                var instance = finishedWork.stateNode;
                "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
            case 26:
            case 27:
            case 5:
                safelyDetachRef(finishedWork, finishedWork.return);
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
            case 22:
                safelyDetachRef(finishedWork, finishedWork.return);
                null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
            default:
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for(parentFiber = parentFiber.child; null !== parentFiber;)disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
    }
    function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {
        var flags = finishedWork.flags;
        switch(finishedWork.tag){
            case 0:
            case 11:
            case 15:
                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                commitHookLayoutEffects(finishedWork, Layout);
                break;
            case 1:
                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                current = finishedWork.stateNode;
                "function" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);
                current = finishedWork.updateQueue;
                if (null !== current) {
                    finishedRoot = finishedWork.stateNode;
                    try {
                        runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);
                    } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                }
                includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
                safelyAttachRef(finishedWork, finishedWork.return);
                break;
            case 26:
            case 27:
            case 5:
                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
                safelyAttachRef(finishedWork, finishedWork.return);
                break;
            case 12:
                if (includeWorkInProgressEffects && flags & 4) {
                    flags = pushNestedEffectDurations();
                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                    includeWorkInProgressEffects = finishedWork.stateNode;
                    includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
                    try {
                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);
                    } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                break;
            case 13:
                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                break;
            case 22:
                null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                safelyAttachRef(finishedWork, finishedWork.return);
                break;
            default:
                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        }
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for(parentFiber = parentFiber.child; null !== parentFiber;)reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch(finishedWork.tag){
            case 0:
            case 11:
            case 15:
                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
                break;
            case 3:
                var prevEffectDuration = pushNestedEffectDurations();
                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));
                finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
                break;
            case 12:
                if (flags & 2048) {
                    prevEffectDuration = pushNestedEffectDurations();
                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                    finishedRoot = finishedWork.stateNode;
                    finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
                    try {
                        runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);
                    } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                break;
            case 23:
                break;
            case 22:
                prevEffectDuration = finishedWork.stateNode;
                null !== finishedWork.memoizedState ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (prevEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));
                flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
                break;
            case 24:
                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
            default:
                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        }
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
        for(parentFiber = parentFiber.child; null !== parentFiber;)reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
    }
    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
        var flags = finishedWork.flags;
        switch(finishedWork.tag){
            case 0:
            case 11:
            case 15:
                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
                commitHookPassiveMountEffects(finishedWork, Passive);
                break;
            case 23:
                break;
            case 22:
                var _instance2 = finishedWork.stateNode;
                null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));
                includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
                break;
            case 24:
                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
                includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
            default:
                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
        }
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;){
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch(finishedWork.tag){
                case 22:
                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                    flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
                    break;
                case 24:
                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                    flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                    break;
                default:
                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyAccumulateSuspenseyCommit(parentFiber) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag) for(parentFiber = parentFiber.child; null !== parentFiber;)accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber) {
        switch(fiber.tag){
            case 26:
                recursivelyAccumulateSuspenseyCommit(fiber);
                fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
                break;
            case 5:
                recursivelyAccumulateSuspenseyCommit(fiber);
                break;
            case 3:
            case 4:
                var previousHoistableRoot = currentHoistableRoot;
                currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
                recursivelyAccumulateSuspenseyCommit(fiber);
                currentHoistableRoot = previousHoistableRoot;
                break;
            case 22:
                null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
                break;
            default:
                recursivelyAccumulateSuspenseyCommit(fiber);
        }
    }
    function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
            previousFiber.child = null;
            do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
            while (null !== parentFiber);
        }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions) for(var i = 0; i < deletions.length; i++){
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
            }
            detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
        switch(finishedWork.tag){
            case 0:
            case 11:
            case 15:
                recursivelyTraversePassiveUnmountEffects(finishedWork);
                finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);
                break;
            case 3:
                var prevEffectDuration = pushNestedEffectDurations();
                recursivelyTraversePassiveUnmountEffects(finishedWork);
                finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
                break;
            case 12:
                prevEffectDuration = pushNestedEffectDurations();
                recursivelyTraversePassiveUnmountEffects(finishedWork);
                finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
                break;
            case 22:
                prevEffectDuration = finishedWork.stateNode;
                null !== finishedWork.memoizedState && prevEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
                break;
            default:
                recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions) for(var i = 0; i < deletions.length; i++){
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
            }
            detachAlternateSiblings(parentFiber);
        }
        for(parentFiber = parentFiber.child; null !== parentFiber;)disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
    }
    function disconnectPassiveEffect(finishedWork) {
        switch(finishedWork.tag){
            case 0:
            case 11:
            case 15:
                commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);
                recursivelyTraverseDisconnectPassiveEffects(finishedWork);
                break;
            case 22:
                var instance = finishedWork.stateNode;
                instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
                break;
            default:
                recursivelyTraverseDisconnectPassiveEffects(finishedWork);
        }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for(; null !== nextEffect;){
            var fiber = nextEffect, current = fiber;
            switch(current.tag){
                case 0:
                case 11:
                case 15:
                    commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);
                    break;
                case 23:
                case 22:
                    null !== current.memoizedState && null !== current.memoizedState.cachePool && (current = current.memoizedState.cachePool.pool, null != current && retainCache(current));
                    break;
                case 24:
                    releaseCache(current.memoizedState.cache);
            }
            current = fiber.child;
            if (null !== current) current.return = fiber, nextEffect = current;
            else a: for(fiber = deletedSubtreeRoot; null !== nextEffect;){
                current = nextEffect;
                var sibling = current.sibling, returnFiber = current.return;
                detachFiberAfterEffects(current);
                if (current === fiber) {
                    nextEffect = null;
                    break a;
                }
                if (null !== sibling) {
                    sibling.return = returnFiber;
                    nextEffect = sibling;
                    break a;
                }
                nextEffect = returnFiber;
            }
        }
    }
    function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
        this.actualDuration = -0;
        this.actualStartTime = -1.1;
        this.treeBaseDuration = this.selfBaseDuration = -0;
        this._debugOwner = this._debugInfo = null;
        this._debugNeedsRemount = !1;
        this._debugHookTypes = null;
        hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
    }
    function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
        var workInProgress = current.alternate;
        null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);
        workInProgress.flags = current.flags & 31457280;
        workInProgress.childLanes = current.childLanes;
        workInProgress.lanes = current.lanes;
        workInProgress.child = current.child;
        workInProgress.memoizedProps = current.memoizedProps;
        workInProgress.memoizedState = current.memoizedState;
        workInProgress.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress.dependencies = null === pendingProps ? null : {
            lanes: pendingProps.lanes,
            firstContext: pendingProps.firstContext,
            _debugThenableState: pendingProps._debugThenableState
        };
        workInProgress.sibling = current.sibling;
        workInProgress.index = current.index;
        workInProgress.ref = current.ref;
        workInProgress.refCleanup = current.refCleanup;
        workInProgress.selfBaseDuration = current.selfBaseDuration;
        workInProgress.treeBaseDuration = current.treeBaseDuration;
        workInProgress._debugInfo = current._debugInfo;
        workInProgress._debugNeedsRemount = current._debugNeedsRemount;
        switch(workInProgress.tag){
            case 0:
            case 15:
                workInProgress.type = resolveFunctionForHotReloading(current.type);
                break;
            case 1:
                workInProgress.type = resolveFunctionForHotReloading(current.type);
                break;
            case 11:
                workInProgress.type = resolveForwardRefForHotReloading(current.type);
        }
        return workInProgress;
    }
    function resetWorkInProgress(workInProgress, renderLanes) {
        workInProgress.flags &= 31457282;
        var current = workInProgress.alternate;
        null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {
            lanes: renderLanes.lanes,
            firstContext: renderLanes.firstContext,
            _debugThenableState: renderLanes._debugThenableState
        }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);
        return workInProgress;
    }
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0, resolvedType = type;
        if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
        else if ("string" === typeof type) fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else a: switch(type){
            case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= StrictLegacyMode;
                mode |= StrictEffectsMode;
                break;
            case REACT_PROFILER_TYPE:
                return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {
                    effectDuration: 0,
                    passiveEffectDuration: 0
                }, key;
            case REACT_SUSPENSE_TYPE:
                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
            case REACT_SUSPENSE_LIST_TYPE:
                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
            case REACT_OFFSCREEN_TYPE:
                return createFiberFromOffscreen(pendingProps, mode, lanes, key);
            default:
                if ("object" === typeof type && null !== type) switch(type.$$typeof){
                    case REACT_PROVIDER_TYPE:
                    case REACT_CONTEXT_TYPE:
                        fiberTag = 10;
                        break a;
                    case REACT_CONSUMER_TYPE:
                        fiberTag = 9;
                        break a;
                    case REACT_FORWARD_REF_TYPE:
                        fiberTag = 11;
                        resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        break a;
                    case REACT_MEMO_TYPE:
                        fiberTag = 14;
                        break a;
                    case REACT_LAZY_TYPE:
                        fiberTag = 16;
                        resolvedType = null;
                        break a;
                }
                resolvedType = "";
                if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
                (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
                fiberTag = 29;
                pendingProps = Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType));
                resolvedType = null;
        }
        key = createFiber(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = resolvedType;
        key.lanes = lanes;
        key._debugOwner = owner;
        return key;
    }
    function createFiberFromElement(element, mode, lanes) {
        mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);
        mode._debugOwner = element._owner;
        return mode;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiber(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
    }
    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
        pendingProps = createFiber(22, pendingProps, key, mode);
        pendingProps.elementType = REACT_OFFSCREEN_TYPE;
        pendingProps.lanes = lanes;
        var primaryChildInstance = {
            _visibility: OffscreenVisible,
            _pendingVisibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null,
            _current: null,
            detach: function() {
                var instance = primaryChildInstance, fiber = instance._current;
                if (null === fiber) throw Error("Calling Offscreen.detach before instance handle has been set.");
                if (0 === (instance._pendingVisibility & OffscreenDetached)) {
                    var root = enqueueConcurrentRenderForLane(fiber, 2);
                    null !== root && (instance._pendingVisibility |= OffscreenDetached, scheduleUpdateOnFiber(root, fiber, 2));
                }
            },
            attach: function() {
                var instance = primaryChildInstance, fiber = instance._current;
                if (null === fiber) throw Error("Calling Offscreen.detach before instance handle has been set.");
                if (0 !== (instance._pendingVisibility & OffscreenDetached)) {
                    var root = enqueueConcurrentRenderForLane(fiber, 2);
                    null !== root && (instance._pendingVisibility &= ~OffscreenDetached, scheduleUpdateOnFiber(root, fiber, 2));
                }
            }
        };
        pendingProps.stateNode = primaryChildInstance;
        return pendingProps;
    }
    function createFiberFromText(content, mode, lanes) {
        content = createFiber(6, content, null, mode);
        content.lanes = lanes;
        return content;
    }
    function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);
        mode.lanes = lanes;
        mode.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
        };
        return mode;
    }
    function markUpdate(workInProgress) {
        workInProgress.flags |= 4;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
        if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded) workInProgress.flags &= -16777217;
        else if (workInProgress.flags |= 16777216, !preloadResource(resource)) {
            resource = suspenseHandlerStackCursor.current;
            if (null !== resource && ((workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary)) throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
            workInProgress.flags |= 8192;
        }
    }
    function scheduleRetryEffect(workInProgress, retryQueue) {
        null !== retryQueue && (workInProgress.flags |= 4);
        workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating) switch(renderState.tailMode){
            case "hidden":
                hasRenderedATailFallback = renderState.tail;
                for(var lastTailNode = null; null !== hasRenderedATailFallback;)null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                break;
            case "collapsed":
                lastTailNode = renderState.tail;
                for(var _lastTailNode = null; null !== lastTailNode;)null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
        }
    }
    function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout) {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
                for(var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;)newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 31457280, subtreeFlags |= _child2.flags & 31457280, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
                completedWork.treeBaseDuration = _treeBaseDuration;
            } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280, subtreeFlags |= _treeBaseDuration.flags & 31457280, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
        } else if ((completedWork.mode & ProfileMode) !== NoMode) {
            _treeBaseDuration = completedWork.actualDuration;
            _child2 = completedWork.selfBaseDuration;
            for(var child = completedWork.child; null !== child;)newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
            completedWork.actualDuration = _treeBaseDuration;
            completedWork.treeBaseDuration = _child2;
        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
    }
    function completeWork(current, workInProgress, renderLanes) {
        var newProps = workInProgress.pendingProps;
        popTreeContext(workInProgress);
        switch(workInProgress.tag){
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
                return bubbleProperties(workInProgress), null;
            case 1:
                return bubbleProperties(workInProgress), null;
            case 3:
                newProps = workInProgress.stateNode;
                renderLanes = null;
                null !== current && (renderLanes = current.memoizedState.cache);
                workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048);
                popProvider(CacheContext, workInProgress);
                popHostContainer(workInProgress);
                newProps.pendingContext && (newProps.context = newProps.pendingContext, newProps.pendingContext = null);
                if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));
                bubbleProperties(workInProgress);
                return null;
            case 26:
                return renderLanes = workInProgress.memoizedState, null === current ? (markUpdate(workInProgress), null !== renderLanes ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217)) : renderLanes ? renderLanes !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress), bubbleProperties(workInProgress), workInProgress.flags &= -16777217), null;
            case 27:
                popHostContext(workInProgress);
                renderLanes = requiredContext(rootInstanceStackCursor.current);
                var _type = workInProgress.type;
                if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);
                else {
                    if (!newProps) {
                        if (null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                        bubbleProperties(workInProgress);
                        return null;
                    }
                    current = getHostContext();
                    popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(_type, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));
                }
                bubbleProperties(workInProgress);
                return null;
            case 5:
                popHostContext(workInProgress);
                renderLanes = workInProgress.type;
                if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);
                else {
                    if (!newProps) {
                        if (null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                        bubbleProperties(workInProgress);
                        return null;
                    }
                    _type = getHostContext();
                    if (popHydrationState(workInProgress)) prepareToHydrateHostInstance(workInProgress, _type);
                    else {
                        current = requiredContext(rootInstanceStackCursor.current);
                        validateDOMNesting(renderLanes, _type.ancestorInfo);
                        _type = _type.context;
                        current = getOwnerDocumentFromRootContainer(current);
                        switch(_type){
                            case HostContextNamespaceSvg:
                                current = current.createElementNS(SVG_NAMESPACE, renderLanes);
                                break;
                            case HostContextNamespaceMath:
                                current = current.createElementNS(MATH_NAMESPACE, renderLanes);
                                break;
                            default:
                                switch(renderLanes){
                                    case "svg":
                                        current = current.createElementNS(SVG_NAMESPACE, renderLanes);
                                        break;
                                    case "math":
                                        current = current.createElementNS(MATH_NAMESPACE, renderLanes);
                                        break;
                                    case "script":
                                        current = current.createElement("div");
                                        current.innerHTML = "<script></script>";
                                        current = current.removeChild(current.firstChild);
                                        break;
                                    case "select":
                                        current = "string" === typeof newProps.is ? current.createElement("select", {
                                            is: newProps.is
                                        }) : current.createElement("select");
                                        newProps.multiple ? current.multiple = !0 : newProps.size && (current.size = newProps.size);
                                        break;
                                    default:
                                        current = "string" === typeof newProps.is ? current.createElement(renderLanes, {
                                            is: newProps.is
                                        }) : current.createElement(renderLanes), -1 === renderLanes.indexOf("-") && (renderLanes !== renderLanes.toLowerCase() && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", renderLanes), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(current) || hasOwnProperty.call(warnedUnknownTags, renderLanes) || (warnedUnknownTags[renderLanes] = !0, console.error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", renderLanes)));
                                }
                        }
                        current[internalInstanceKey] = workInProgress;
                        current[internalPropsKey] = newProps;
                        a: for(_type = workInProgress.child; null !== _type;){
                            if (5 === _type.tag || 6 === _type.tag) current.appendChild(_type.stateNode);
                            else if (4 !== _type.tag && 27 !== _type.tag && null !== _type.child) {
                                _type.child.return = _type;
                                _type = _type.child;
                                continue;
                            }
                            if (_type === workInProgress) break a;
                            for(; null === _type.sibling;){
                                if (null === _type.return || _type.return === workInProgress) break a;
                                _type = _type.return;
                            }
                            _type.sibling.return = _type.return;
                            _type = _type.sibling;
                        }
                        workInProgress.stateNode = current;
                        a: switch(setInitialProperties(current, renderLanes, newProps), renderLanes){
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                current = !!newProps.autoFocus;
                                break a;
                            case "img":
                                current = !0;
                                break a;
                            default:
                                current = !1;
                        }
                        current && markUpdate(workInProgress);
                    }
                }
                bubbleProperties(workInProgress);
                workInProgress.flags &= -16777217;
                return null;
            case 6:
                if (current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);
                else {
                    if ("string" !== typeof newProps && null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    current = requiredContext(rootInstanceStackCursor.current);
                    renderLanes = getHostContext();
                    if (popHydrationState(workInProgress)) {
                        current = workInProgress.stateNode;
                        newProps = workInProgress.memoizedProps;
                        _type = !didSuspendOrErrorDEV;
                        renderLanes = null;
                        var returnFiber = hydrationParentFiber;
                        if (null !== returnFiber) switch(returnFiber.tag){
                            case 3:
                                _type && (_type = diffHydratedTextForDevWarnings(current, newProps, renderLanes), null !== _type && (buildHydrationDiffNode(workInProgress, 0).serverProps = _type));
                                break;
                            case 27:
                            case 5:
                                renderLanes = returnFiber.memoizedProps, _type && (_type = diffHydratedTextForDevWarnings(current, newProps, renderLanes), null !== _type && (buildHydrationDiffNode(workInProgress, 0).serverProps = _type));
                        }
                        current[internalInstanceKey] = workInProgress;
                        current = current.nodeValue === newProps || null !== renderLanes && !0 === renderLanes.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, newProps) ? !0 : !1;
                        current || throwOnHydrationMismatch(workInProgress);
                    } else renderLanes = renderLanes.ancestorInfo.current, null != renderLanes && validateTextNesting(newProps, renderLanes.tag), current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps), current[internalInstanceKey] = workInProgress, workInProgress.stateNode = current;
                }
                bubbleProperties(workInProgress);
                return null;
            case 13:
                newProps = workInProgress.memoizedState;
                if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
                    _type = popHydrationState(workInProgress);
                    if (null !== newProps && null !== newProps.dehydrated) {
                        if (null === current) {
                            if (!_type) throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                            _type = workInProgress.memoizedState;
                            _type = null !== _type ? _type.dehydrated : null;
                            if (!_type) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
                            _type[internalInstanceKey] = workInProgress;
                            bubbleProperties(workInProgress);
                            (workInProgress.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress.child, null !== _type && (workInProgress.treeBaseDuration -= _type.treeBaseDuration));
                        } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress.child, null !== _type && (workInProgress.treeBaseDuration -= _type.treeBaseDuration));
                        _type = !1;
                    } else null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), _type = !0;
                    if (!_type) {
                        if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;
                        popSuspenseHandler(workInProgress);
                        return null;
                    }
                }
                popSuspenseHandler(workInProgress);
                if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress;
                newProps = null !== newProps;
                current = null !== current && null !== current.memoizedState;
                newProps && (renderLanes = workInProgress.child, _type = null, null !== renderLanes.alternate && null !== renderLanes.alternate.memoizedState && null !== renderLanes.alternate.memoizedState.cachePool && (_type = renderLanes.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== renderLanes.memoizedState && null !== renderLanes.memoizedState.cachePool && (returnFiber = renderLanes.memoizedState.cachePool.pool), returnFiber !== _type && (renderLanes.flags |= 2048));
                newProps !== current && newProps && (workInProgress.child.flags |= 8192);
                scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
                bubbleProperties(workInProgress);
                (workInProgress.mode & ProfileMode) !== NoMode && newProps && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));
                return null;
            case 4:
                return popHostContainer(workInProgress), null === current && listenToAllSupportedEvents(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;
            case 10:
                return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;
            case 19:
                pop(suspenseStackCursor, workInProgress);
                _type = workInProgress.memoizedState;
                if (null === _type) return bubbleProperties(workInProgress), null;
                newProps = 0 !== (workInProgress.flags & 128);
                returnFiber = _type.rendering;
                if (null === returnFiber) {
                    if (newProps) cutOffTailIfNeeded(_type, !1);
                    else {
                        if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for(current = workInProgress.child; null !== current;){
                            returnFiber = findFirstSuspended(current);
                            if (null !== returnFiber) {
                                workInProgress.flags |= 128;
                                cutOffTailIfNeeded(_type, !1);
                                current = returnFiber.updateQueue;
                                workInProgress.updateQueue = current;
                                scheduleRetryEffect(workInProgress, current);
                                workInProgress.subtreeFlags = 0;
                                current = renderLanes;
                                for(newProps = workInProgress.child; null !== newProps;)resetWorkInProgress(newProps, current), newProps = newProps.sibling;
                                push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);
                                return workInProgress.child;
                            }
                            current = current.sibling;
                        }
                        null !== _type.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(_type, !1), workInProgress.lanes = 4194304);
                    }
                } else {
                    if (!newProps) {
                        if (current = findFirstSuspended(returnFiber), null !== current) {
                            if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(_type, !0), null === _type.tail && "hidden" === _type.tailMode && !returnFiber.alternate && !isHydrating) return bubbleProperties(workInProgress), null;
                        } else 2 * now$1() - _type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(_type, !1), workInProgress.lanes = 4194304);
                    }
                    _type.isBackwards ? (returnFiber.sibling = workInProgress.child, workInProgress.child = returnFiber) : (current = _type.last, null !== current ? current.sibling = returnFiber : workInProgress.child = returnFiber, _type.last = returnFiber);
                }
                if (null !== _type.tail) return current = _type.tail, _type.rendering = current, _type.tail = current.sibling, _type.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = newProps ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), current;
                bubbleProperties(workInProgress);
                return null;
            case 22:
            case 23:
                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), newProps = workInProgress.updateQueue, null !== newProps && scheduleRetryEffect(workInProgress, newProps.retryQueue), newProps = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (newProps = current.memoizedState.cachePool.pool), renderLanes = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (renderLanes = workInProgress.memoizedState.cachePool.pool), renderLanes !== newProps && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;
            case 24:
                return newProps = null, null !== current && (newProps = current.memoizedState.cache), workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;
            case 25:
                return null;
        }
        throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function unwindWork(current, workInProgress) {
        popTreeContext(workInProgress);
        switch(workInProgress.tag){
            case 1:
                return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
            case 3:
                return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
            case 26:
            case 27:
            case 5:
                return popHostContext(workInProgress), null;
            case 13:
                popSuspenseHandler(workInProgress);
                current = workInProgress.memoizedState;
                if (null !== current && null !== current.dehydrated) {
                    if (null === workInProgress.alternate) throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                    resetHydrationState();
                }
                current = workInProgress.flags;
                return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
            case 19:
                return pop(suspenseStackCursor, workInProgress), null;
            case 4:
                return popHostContainer(workInProgress), null;
            case 10:
                return popProvider(workInProgress.type, workInProgress), null;
            case 22:
            case 23:
                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
            case 24:
                return popProvider(CacheContext, workInProgress), null;
            case 25:
                return null;
            default:
                return null;
        }
    }
    function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch(interruptedWork.tag){
            case 3:
                popProvider(CacheContext, interruptedWork);
                popHostContainer(interruptedWork);
                break;
            case 26:
            case 27:
            case 5:
                popHostContext(interruptedWork);
                break;
            case 4:
                popHostContainer(interruptedWork);
                break;
            case 13:
                popSuspenseHandler(interruptedWork);
                break;
            case 19:
                pop(suspenseStackCursor, interruptedWork);
                break;
            case 10:
                popProvider(interruptedWork.type, interruptedWork);
                break;
            case 22:
            case 23:
                popSuspenseHandler(interruptedWork);
                popHiddenContext(interruptedWork);
                null !== current && pop(resumedCache, interruptedWork);
                break;
            case 24:
                popProvider(CacheContext, interruptedWork);
        }
    }
    function onCommitRoot() {
        commitHooks.forEach(function(commitHook) {
            return commitHook();
        });
    }
    function isConcurrentActEnvironment() {
        var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
        isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error("The current testing environment is not configured to support act(...)");
        return isReactActEnvironmentGlobal;
    }
    function requestUpdateLane(fiber) {
        if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
        var transition = ReactSharedInternals.T;
        return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();
    }
    function requestDeferredLane() {
        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
        var suspenseHandler = suspenseHandlerStackCursor.current;
        null !== suspenseHandler && (suspenseHandler.flags |= 32);
        return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root, fiber, lane) {
        isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
        isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);
        if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
        markRootUpdated$1(root, lane);
        if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {
            if (isRendering) switch(fiber.tag){
                case 0:
                case 11:
                case 15:
                    root = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                    didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", fiber, root, root));
                    break;
                case 1:
                    didWarnAboutUpdateInRender || (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), didWarnAboutUpdateInRender = !0);
            }
        } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);
    }
    function performWorkOnRoot(root, lanes, forceSync) {
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Should not already be working.");
        var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0), renderWasConcurrent = shouldTimeSlice;
        do {
            if (exitStatus === RootInProgress) {
                workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, !1);
                break;
            } else if (exitStatus === RootDidNotComplete) markRootSuspended(root, lanes, 0, !workInProgressRootDidSkipSuspendedSiblings);
            else {
                forceSync = root.current.alternate;
                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
                    exitStatus = renderRootSync(root, lanes, !1);
                    renderWasConcurrent = !1;
                    continue;
                }
                if (exitStatus === RootErrored) {
                    renderWasConcurrent = lanes;
                    if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;
                    else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
                    if (0 !== errorRetryLanes) {
                        lanes = errorRetryLanes;
                        a: {
                            exitStatus = root;
                            var errorRetryLanes$jscomp$0 = errorRetryLanes;
                            errorRetryLanes = workInProgressRootConcurrentErrors;
                            var wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;
                            wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);
                            errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, !1);
                            if (errorRetryLanes$jscomp$0 !== RootErrored) {
                                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                                    exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
                                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                                    exitStatus = RootSuspendedWithDelay;
                                    break a;
                                }
                                exitStatus = workInProgressRootRecoverableErrors;
                                workInProgressRootRecoverableErrors = errorRetryLanes;
                                null !== exitStatus && queueRecoverableErrors(exitStatus);
                            }
                            exitStatus = errorRetryLanes$jscomp$0;
                        }
                        renderWasConcurrent = !1;
                        if (exitStatus !== RootErrored) continue;
                    }
                }
                if (exitStatus === RootFatalErrored) {
                    prepareFreshStack(root, 0);
                    markRootSuspended(root, lanes, 0, !0);
                    break;
                }
                a: {
                    shouldTimeSlice = root;
                    switch(exitStatus){
                        case RootInProgress:
                        case RootFatalErrored:
                            throw Error("Root did not complete. This is a bug in React.");
                        case RootSuspendedWithDelay:
                            if ((lanes & 4194176) === lanes) {
                                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                                break a;
                            }
                            break;
                        case RootErrored:
                            workInProgressRootRecoverableErrors = null;
                            break;
                        case RootSuspended:
                        case RootCompleted:
                            break;
                        default:
                            throw Error("Unknown root exit status.");
                    }
                    shouldTimeSlice.finishedWork = forceSync;
                    shouldTimeSlice.finishedLanes = lanes;
                    if (null !== ReactSharedInternals.actQueue) commitRoot(shouldTimeSlice, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, IMMEDIATE_COMMIT, renderStartTime, 0);
                    else {
                        if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < exitStatus)) {
                            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                            if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;
                            shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, THROTTLED_COMMIT, renderStartTime, 0), exitStatus);
                            break a;
                        }
                        commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, IMMEDIATE_COMMIT, renderStartTime, 0);
                    }
                }
            }
            break;
        }while (1);
        ensureRootIsScheduled(root);
    }
    function queueRecoverableErrors(errors) {
        null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
    }
    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        var subtreeFlags = finishedWork.subtreeFlags;
        if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {
            if (suspendedState = {
                stylesheets: null,
                count: 0,
                unsuspend: noop
            }, accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {
                root.cancelPendingCommit = finishedWork(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));
                markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
                return;
            }
        }
        commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
        for(var node = finishedWork;;){
            var tag = node.tag;
            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for(var i = 0; i < tag.length; i++){
                var check = tag[i], getSnapshot = check.getSnapshot;
                check = check.value;
                try {
                    if (!objectIs(getSnapshot(), check)) return !1;
                } catch (error) {
                    return !1;
                }
            }
            tag = node.child;
            if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;
            else {
                if (node === finishedWork) break;
                for(; null === node.sibling;){
                    if (null === node.return || node.return === finishedWork) return !0;
                    node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
            }
        }
        return !0;
    }
    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root.suspendedLanes |= suspendedLanes;
        root.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root.expirationTimes;
        for(var lanes = suspendedLanes; 0 < lanes;){
            var index = 31 - clz32(lanes), lane = 1 << index;
            didAttemptEntireTree[index] = -1;
            lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
        return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;
    }
    function resetWorkInProgressStack() {
        if (null !== workInProgress) {
            if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;
            else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
            for(; null !== interruptedWork;)unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
            workInProgress = null;
        }
    }
    function prepareFreshStack(root, lanes) {
        root.finishedWork = null;
        root.finishedLanes = 0;
        var timeoutHandle = root.timeoutHandle;
        timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
        timeoutHandle = root.cancelPendingCommit;
        null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());
        resetWorkInProgressStack();
        workInProgressRoot = root;
        workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = NotSuspended;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = !1;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
        workInProgressRootDidAttachPingListener = !1;
        workInProgressRootExitStatus = RootInProgress;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root.entangledLanes;
        if (0 !== allEntangledLanes) for(root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;){
            var index = 31 - clz32(allEntangledLanes), lane = 1 << index;
            lanes |= root[index];
            allEntangledLanes &= ~lane;
        }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        ReactStrictModeWarnings.discardPendingWarnings();
        return timeoutHandle;
    }
    function handleThrow(root, thrownValue) {
        currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        ReactSharedInternals.getCurrentStack = null;
        isRendering = !1;
        current = null;
        thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
        workInProgressThrownValue = thrownValue;
        var erroredWork = workInProgress;
        if (null === erroredWork) workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
        else switch(erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason){
            case SuspendedOnError:
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                break;
            case SuspendedOnData:
            case SuspendedOnImmediate:
            case SuspendedOnDeprecatedThrowPromise:
            case SuspendedAndReadyToContinue:
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);
        }
    }
    function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = RootSuspendedWithDelay;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
    }
    function renderRootSync(root, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
                var memoizedUpdaters = root.memoizedUpdaters;
                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
                movePendingFibersToMemoized(root, lanes);
            }
            workInProgressTransitions = null;
            prepareFreshStack(root, lanes);
        }
        markRenderStarted(lanes);
        lanes = !1;
        memoizedUpdaters = workInProgressRootExitStatus;
        a: do try {
            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                switch(workInProgressSuspendedReason){
                    case SuspendedOnHydration:
                        resetWorkInProgressStack();
                        memoizedUpdaters = RootDidNotComplete;
                        break a;
                    case SuspendedOnImmediate:
                    case SuspendedOnData:
                    case SuspendedOnDeprecatedThrowPromise:
                        null === suspenseHandlerStackCursor.current && (lanes = !0);
                        var reason = workInProgressSuspendedReason;
                        workInProgressSuspendedReason = NotSuspended;
                        workInProgressThrownValue = null;
                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                        if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                            memoizedUpdaters = RootInProgress;
                            break a;
                        }
                        break;
                    default:
                        reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                }
            }
            workLoopSync();
            memoizedUpdaters = workInProgressRootExitStatus;
            break;
        } catch (thrownValue$8) {
            handleThrow(root, thrownValue$8);
        }
        while (1);
        lanes && root.shellSuspendCounter++;
        resetContextDependencies();
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        markRenderStopped();
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return memoizedUpdaters;
    }
    function workLoopSync() {
        for(; null !== workInProgress;)performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
                var memoizedUpdaters = root.memoizedUpdaters;
                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
                movePendingFibersToMemoized(root, lanes);
            }
            workInProgressTransitions = null;
            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
            prepareFreshStack(root, lanes);
        } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
        markRenderStarted(lanes);
        a: do try {
            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch(lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason){
                case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);
                    break;
                case SuspendedOnData:
                    if (isThenableResolved(memoizedUpdaters)) {
                        workInProgressSuspendedReason = NotSuspended;
                        workInProgressThrownValue = null;
                        replaySuspendedUnitOfWork(lanes);
                        break;
                    }
                    lanes = function() {
                        workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root && (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                        ensureRootIsScheduled(root);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));
                    break;
                case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch(workInProgress.tag){
                        case 26:
                            resource = workInProgress.memoizedState;
                        case 5:
                        case 27:
                            var hostFiber = workInProgress;
                            if (resource ? preloadResource(resource) : 1) {
                                workInProgressSuspendedReason = NotSuspended;
                                workInProgressThrownValue = null;
                                var sibling = hostFiber.sibling;
                                if (null !== sibling) workInProgress = sibling;
                                else {
                                    var returnFiber = hostFiber.return;
                                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                                }
                                break b;
                            }
                            break;
                        default:
                            console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);
                    break;
                case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);
                    break;
                case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootDidNotComplete;
                    break a;
                default:
                    throw Error("Unexpected SuspendedReason. This is a bug in React.");
            }
            null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrent();
            break;
        } catch (thrownValue$9) {
            handleThrow(root, thrownValue$9);
        }
        while (1);
        resetContextDependencies();
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;
        markRenderStopped();
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
    }
    function workLoopConcurrent() {
        for(; null !== workInProgress && !shouldYield();)performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
        var current = unitOfWork.alternate;
        (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
        var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function replayBeginWork(unitOfWork) {
        var current = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
        isProfilingMode && startProfilerTimer(unitOfWork);
        switch(unitOfWork.tag){
            case 15:
            case 0:
                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);
                break;
            case 11:
                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);
                break;
            case 5:
                resetHooksOnUnwind(unitOfWork);
            default:
                unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);
        }
        isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
        return current;
    }
    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
        resetContextDependencies();
        resetHooksOnUnwind(unitOfWork);
        thenableState$1 = null;
        thenableIndexCounter$1 = 0;
        var returnFiber = unitOfWork.return;
        try {
            if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
                workInProgressRootExitStatus = RootFatalErrored;
                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
                workInProgress = null;
                return;
            }
        } catch (error) {
            if (null !== returnFiber) throw workInProgress = returnFiber, error;
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
            workInProgress = null;
            return;
        }
        if (unitOfWork.flags & 32768) {
            if (isHydrating || suspendedReason === SuspendedOnError) root = !0;
            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;
            else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
            unwindUnitOfWork(unitOfWork, root);
        } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
            if (0 !== (completedWork.flags & 32768)) {
                unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
                return;
            }
            var current = completedWork.alternate;
            unitOfWork = completedWork.return;
            startProfilerTimer(completedWork);
            current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);
            (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
            if (null !== current) {
                workInProgress = current;
                return;
            }
            completedWork = completedWork.sibling;
            if (null !== completedWork) {
                workInProgress = completedWork;
                return;
            }
            workInProgress = completedWork = unitOfWork;
        }while (null !== completedWork);
        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
            var next = unwindWork(unitOfWork.alternate, unitOfWork);
            if (null !== next) {
                next.flags &= 32767;
                workInProgress = next;
                return;
            }
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
                stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
                next = unitOfWork.actualDuration;
                for(var child = unitOfWork.child; null !== child;)next += child.actualDuration, child = child.sibling;
                unitOfWork.actualDuration = next;
            }
            next = unitOfWork.return;
            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
                workInProgress = unitOfWork;
                return;
            }
            workInProgress = unitOfWork = next;
        }while (null !== unitOfWork);
        workInProgressRootExitStatus = RootDidNotComplete;
        workInProgress = null;
    }
    function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        var prevTransition = ReactSharedInternals.T, previousUpdateLanePriority = ReactDOMSharedInternals.p;
        try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, ReactSharedInternals.T = null, commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);
        } finally{
            ReactSharedInternals.T = prevTransition, ReactDOMSharedInternals.p = previousUpdateLanePriority;
        }
    }
    function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {
        do flushPassiveEffects();
        while (null !== rootWithPendingPassiveEffects);
        ReactStrictModeWarnings.flushLegacyContextWarning();
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Should not already be working.");
        var finishedWork = root.finishedWork;
        didIncludeRenderPhaseUpdate = root.finishedLanes;
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);
        if (null === finishedWork) return markCommitStopped(), null;
        0 === didIncludeRenderPhaseUpdate && console.error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
        root.finishedWork = null;
        root.finishedLanes = 0;
        if (finishedWork === root.current) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        root.callbackNode = null;
        root.callbackPriority = 0;
        root.cancelPendingCommit = null;
        var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
        remainingLanes |= concurrentlyUpdatedLanes;
        markRootFinished(root, didIncludeRenderPhaseUpdate, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes);
        root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects(!0);
            return null;
        }));
        commitStartTime = now();
        transitions = 0 !== (finishedWork.flags & 15990);
        0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = ReactDOMSharedInternals.p, ReactDOMSharedInternals.p = DiscreteEventPriority, updatedLanes = executionContext, executionContext |= CommitContext, commitBeforeMutationEffects(root, finishedWork), commitMutationEffects(root, finishedWork, didIncludeRenderPhaseUpdate), restoreSelection(selectionInformation, root.containerInfo), _enabled = !!eventsEnabled, selectionInformation = eventsEnabled = null, root.current = finishedWork, null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(didIncludeRenderPhaseUpdate), commitLayoutEffects(finishedWork, root, didIncludeRenderPhaseUpdate), null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped(), requestPaint(), executionContext = updatedLanes, ReactDOMSharedInternals.p = spawnedLane, ReactSharedInternals.T = transitions) : root.current = finishedWork;
        (transitions = rootDoesHavePassiveEffects) ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : (releaseRootPooledCache(root, remainingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
        remainingLanes = root.pendingLanes;
        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
        transitions || commitDoubleInvokeEffectsInDEV(root);
        onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);
        isDevToolsPresent && root.memoizedUpdaters.clear();
        onCommitRoot();
        ensureRootIsScheduled(root);
        if (null !== recoverableErrors) for(renderPriorityLevel = root.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++)remainingLanes = recoverableErrors[finishedWork], transitions = makeErrorInfo(remainingLanes.stack), runWithFiberInDEV(remainingLanes.source, renderPriorityLevel, remainingLanes.value, transitions);
        0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
        remainingLanes = root.pendingLanes;
        0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;
        flushSyncWorkAcrossRoots_impl(0, !1);
        markCommitStopped();
        return null;
    }
    function makeErrorInfo(componentStack) {
        componentStack = {
            componentStack: componentStack
        };
        Object.defineProperty(componentStack, "digest", {
            get: function() {
                console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');
            }
        });
        return componentStack;
    }
    function releaseRootPooledCache(root, remainingLanes) {
        0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPassiveEffects() {
        if (null !== rootWithPendingPassiveEffects) {
            var root = rootWithPendingPassiveEffects, remainingLanes = pendingPassiveEffectsRemainingLanes;
            pendingPassiveEffectsRemainingLanes = 0;
            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
            renderPriority = ReactSharedInternals.T;
            var previousPriority = ReactDOMSharedInternals.p;
            try {
                ReactDOMSharedInternals.p = priority;
                ReactSharedInternals.T = null;
                if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = !1;
                else {
                    priority = pendingPassiveTransitions;
                    pendingPassiveTransitions = null;
                    var root$jscomp$0 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;
                    rootWithPendingPassiveEffects = null;
                    pendingPassiveEffectsLanes = 0;
                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Cannot flush passive effects while already rendering.");
                    isFlushingPassiveEffects = !0;
                    didScheduleUpdateDuringPassiveEffects = !1;
                    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
                    var prevExecutionContext = executionContext;
                    executionContext |= CommitContext;
                    commitPassiveUnmountOnFiber(root$jscomp$0.current);
                    commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);
                    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();
                    commitDoubleInvokeEffectsInDEV(root$jscomp$0);
                    executionContext = prevExecutionContext;
                    flushSyncWorkAcrossRoots_impl(0, !1);
                    didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;
                    didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;
                    if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
                        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
                    } catch (err) {
                        hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
                    }
                    var stateNode = root$jscomp$0.current.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                    JSCompiler_inline_result = !0;
                }
                return JSCompiler_inline_result;
            } finally{
                ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);
            }
        }
        return !1;
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        isRunningInsertionEffect = !1;
        if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else {
            for(; null !== nearestMountedAncestor;){
                if (3 === nearestMountedAncestor.tag) {
                    captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
                    return;
                }
                if (1 === nearestMountedAncestor.tag) {
                    var instance = nearestMountedAncestor.stateNode;
                    if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                        error = createClassErrorUpdate(2);
                        instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                        null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                        return;
                    }
                }
                nearestMountedAncestor = nearestMountedAncestor.return;
            }
            console.error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error);
        }
    }
    function attachPingListener(root, wakeable, lanes) {
        var pingCache = root.pingCache;
        if (null === pingCache) {
            pingCache = root.pingCache = new PossiblyWeakMap();
            var threadIDs = new Set();
            pingCache.set(wakeable, threadIDs);
        } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));
    }
    function pingSuspendedRoot(root, wakeable, pingedLanes) {
        var pingCache = root.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root.pingedLanes |= root.suspendedLanes & pingedLanes;
        root.warmLanes &= ~pingedLanes;
        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act");
        workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch(boundaryFiber.tag){
            case 13:
                var retryCache = boundaryFiber.stateNode;
                var suspenseState = boundaryFiber.memoizedState;
                null !== suspenseState && (retryLane = suspenseState.retryLane);
                break;
            case 19:
                retryCache = boundaryFiber.stateNode;
                break;
            case 22:
                retryCache = boundaryFiber.stateNode._retryCache;
                break;
            default:
                throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
        if (0 !== (parentFiber.subtreeFlags & 33562624)) for(parentFiber = parentFiber.child; null !== parentFiber;){
            var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
            isStrictModeFiber = isInStrictMode || isStrictModeFiber;
            22 !== fiber.tag ? fiber.flags & 33554432 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & NoStrictPassiveEffectsMode) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 33554432 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));
            parentFiber = parentFiber.sibling;
        }
    }
    function doubleInvokeEffectsOnFiber(root, fiber) {
        var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;
        setIsStrictModeForDevtools(!0);
        try {
            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, !1);
        } finally{
            setIsStrictModeForDevtools(!1);
        }
    }
    function commitDoubleInvokeEffectsInDEV(root) {
        var doubleInvokeEffects = !0;
        root.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = !1);
        recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);
    }
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
        if ((executionContext & RenderContext) === NoContext) {
            var tag = fiber.tag;
            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
                tag = getComponentNameFromFiber(fiber) || "ReactComponent";
                if (null !== didWarnStateUpdateForNotYetMountedComponent) {
                    if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
                    didWarnStateUpdateForNotYetMountedComponent.add(tag);
                } else didWarnStateUpdateForNotYetMountedComponent = new Set([
                    tag
                ]);
                runWithFiberInDEV(fiber, function() {
                    console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
                });
            }
        }
    }
    function restorePendingUpdaters(root, lanes) {
        isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {
            addFiberToLanesMap(root, schedulingFiber, lanes);
        });
    }
    function scheduleCallback$1(priorityLevel, callback) {
        var actQueue = ReactSharedInternals.actQueue;
        return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
    }
    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
            console.error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
        });
    }
    function ensureRootIsScheduled(root) {
        root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
        mightHavePendingSyncWork = !0;
        null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateTask(processRootScheduleInMicrotask)) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateTask(processRootScheduleInMicrotask));
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
            isFlushingWork = !0;
            do {
                var didPerformSomeWork = !1;
                for(var root = firstScheduledRoot; null !== root;){
                    if (!onlyLegacy) {
                        if (0 !== syncTransitionLanes) {
                            var pendingLanes = root.pendingLanes;
                            if (0 === pendingLanes) var nextLanes = 0;
                            else {
                                var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
                                nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                                nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                                nextLanes = nextLanes & 201326677 ? nextLanes & 201326677 | 1 : nextLanes ? nextLanes | 2 : 0;
                            }
                            0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));
                        } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));
                    }
                    root = root.next;
                }
            }while (didPerformSomeWork);
            isFlushingWork = !1;
        }
    }
    function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
        for(var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;){
            var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
            if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
            else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;
            root = next;
        }
        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
    }
    function scheduleTaskForRootDuringMicrotask(root, currentTime) {
        for(var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;){
            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
            if (-1 === expirationTime) {
                if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);
            } else expirationTime <= currentTime && (root.expiredLanes |= lane);
            lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0);
        pingedLanes = root.callbackNode;
        if (0 === suspendedLanes || root === currentTime && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
            currentTime = suspendedLanes & -suspendedLanes;
            if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode) cancelCallback(pingedLanes);
            else return currentTime;
            switch(lanesToEventPriority(suspendedLanes)){
                case DiscreteEventPriority:
                case ContinuousEventPriority:
                    suspendedLanes = UserBlockingPriority;
                    break;
                case DefaultEventPriority:
                    suspendedLanes = NormalPriority$1;
                    break;
                case IdleEventPriority:
                    suspendedLanes = IdlePriority;
                    break;
                default:
                    suspendedLanes = NormalPriority$1;
            }
            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
            root.callbackPriority = currentTime;
            root.callbackNode = suspendedLanes;
            return currentTime;
        }
        null !== pingedLanes && cancelCallback(pingedLanes);
        root.callbackPriority = 2;
        root.callbackNode = null;
        return 2;
    }
    function performWorkOnRootViaSchedulerTask(root, didTimeout) {
        nestedUpdateScheduled = currentUpdateIsNested = !1;
        var originalCallbackNode = root.callbackNode;
        if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0);
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root, now$1());
        return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
    }
    function performSyncWorkOnRoot(root, lanes) {
        if (flushPassiveEffects()) return null;
        currentUpdateIsNested = nestedUpdateScheduled;
        nestedUpdateScheduled = !1;
        performWorkOnRoot(root, lanes, !0);
    }
    function cancelCallback(callbackNode) {
        callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
    }
    function scheduleImmediateTask(cb) {
        null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
            cb();
            return null;
        });
        scheduleMicrotask(function() {
            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, cb) : cb();
        });
    }
    function requestTransitionLane() {
        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
        return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
        if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp) return null;
        if ("function" === typeof actionProp) return actionProp;
        checkAttributeStringCoercion(actionProp, "action");
        return sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
            var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action), submitter = nativeEvent.submitter;
            submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
            var event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
                event: event,
                listeners: [
                    {
                        instance: null,
                        listener: function() {
                            if (nativeEvent.defaultPrevented) {
                                if (0 !== currentEventTransitionLane) {
                                    var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), pendingState = {
                                        pending: !0,
                                        data: formData,
                                        method: nativeEventTarget.method,
                                        action: action
                                    };
                                    Object.freeze(pendingState);
                                    startHostTransition(maybeTargetInst, pendingState, null, formData);
                                }
                            } else "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), pendingState = {
                                pending: !0,
                                data: formData,
                                method: nativeEventTarget.method,
                                action: action
                            }, Object.freeze(pendingState), startHostTransition(maybeTargetInst, pendingState, action, formData));
                        },
                        currentTarget: nativeEventTarget
                    }
                ]
            });
        }
    }
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for(var i = 0; i < dispatchQueue.length; i++){
            var _dispatchQueue$i = dispatchQueue[i];
            a: {
                var previousInstance = void 0, event = _dispatchQueue$i.event;
                _dispatchQueue$i = _dispatchQueue$i.listeners;
                if (eventSystemFlags) for(var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--){
                    var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                    _dispatchListeners$i = _dispatchListeners$i.listener;
                    if (instance !== previousInstance && event.isPropagationStopped()) break a;
                    previousInstance = event;
                    previousInstance.currentTarget = currentTarget;
                    try {
                        _dispatchListeners$i(previousInstance);
                    } catch (error) {
                        reportGlobalError(error);
                    }
                    previousInstance.currentTarget = null;
                    previousInstance = instance;
                }
                else for(i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++){
                    _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                    instance = _dispatchListeners$i.instance;
                    currentTarget = _dispatchListeners$i.currentTarget;
                    _dispatchListeners$i = _dispatchListeners$i.listener;
                    if (instance !== previousInstance && event.isPropagationStopped()) break a;
                    previousInstance = event;
                    previousInstance.currentTarget = currentTarget;
                    try {
                        _dispatchListeners$i(previousInstance);
                    } catch (error) {
                        reportGlobalError(error);
                    }
                    previousInstance.currentTarget = null;
                    previousInstance = instance;
                }
            }
        }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
        nonDelegatedEvents.has(domEventName) || console.error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
        var listenerSet = targetElement[internalEventHandlersKey];
        void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = new Set());
        var listenerSetKey = domEventName + "__bubble";
        listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, !1), listenerSet.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
    }
    function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = !0;
            allNativeEvents.forEach(function(domEventName) {
                "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, !1, rootContainerElement), listenToNativeEvent(domEventName, !0, rootContainerElement));
            });
            var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
            null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = !0, listenToNativeEvent("selectionchange", !1, ownerDocument));
        }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch(getEventPriority(domEventName)){
            case DiscreteEventPriority:
                var listenerWrapper = dispatchDiscreteEvent;
                break;
            case ContinuousEventPriority:
                listenerWrapper = dispatchContinuousEvent;
                break;
            default:
                listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = !0);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            capture: !0,
            passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !0) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0) a: for(;;){
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer || 8 === container.nodeType && container.parentNode === targetContainer) break;
                if (4 === nodeTag) for(nodeTag = targetInst$jscomp$0.return; null !== nodeTag;){
                    var grandTag = nodeTag.tag;
                    if (3 === grandTag || 4 === grandTag) {
                        if (grandTag = nodeTag.stateNode.containerInfo, grandTag === targetContainer || 8 === grandTag.nodeType && grandTag.parentNode === targetContainer) return;
                    }
                    nodeTag = nodeTag.return;
                }
                for(; null !== container;){
                    nodeTag = getClosestInstanceFromNode(container);
                    if (null === nodeTag) return;
                    grandTag = nodeTag.tag;
                    if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                        targetInst$jscomp$0 = ancestorInst = nodeTag;
                        continue a;
                    }
                    container = container.parentNode;
                }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
        batchedUpdates$1(function() {
            var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
            a: {
                var reactName = topLevelEventsToReactNames.get(domEventName);
                if (void 0 !== reactName) {
                    var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                    switch(domEventName){
                        case "keypress":
                            if (0 === getEventCharCode(nativeEvent)) break a;
                        case "keydown":
                        case "keyup":
                            SyntheticEventCtor = SyntheticKeyboardEvent;
                            break;
                        case "focusin":
                            reactEventType = "focus";
                            SyntheticEventCtor = SyntheticFocusEvent;
                            break;
                        case "focusout":
                            reactEventType = "blur";
                            SyntheticEventCtor = SyntheticFocusEvent;
                            break;
                        case "beforeblur":
                        case "afterblur":
                            SyntheticEventCtor = SyntheticFocusEvent;
                            break;
                        case "click":
                            if (2 === nativeEvent.button) break a;
                        case "auxclick":
                        case "dblclick":
                        case "mousedown":
                        case "mousemove":
                        case "mouseup":
                        case "mouseout":
                        case "mouseover":
                        case "contextmenu":
                            SyntheticEventCtor = SyntheticMouseEvent;
                            break;
                        case "drag":
                        case "dragend":
                        case "dragenter":
                        case "dragexit":
                        case "dragleave":
                        case "dragover":
                        case "dragstart":
                        case "drop":
                            SyntheticEventCtor = SyntheticDragEvent;
                            break;
                        case "touchcancel":
                        case "touchend":
                        case "touchmove":
                        case "touchstart":
                            SyntheticEventCtor = SyntheticTouchEvent;
                            break;
                        case ANIMATION_END:
                        case ANIMATION_ITERATION:
                        case ANIMATION_START:
                            SyntheticEventCtor = SyntheticAnimationEvent;
                            break;
                        case TRANSITION_END:
                            SyntheticEventCtor = SyntheticTransitionEvent;
                            break;
                        case "scroll":
                        case "scrollend":
                            SyntheticEventCtor = SyntheticUIEvent;
                            break;
                        case "wheel":
                            SyntheticEventCtor = SyntheticWheelEvent;
                            break;
                        case "copy":
                        case "cut":
                        case "paste":
                            SyntheticEventCtor = SyntheticClipboardEvent;
                            break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "pointerup":
                            SyntheticEventCtor = SyntheticPointerEvent;
                            break;
                        case "toggle":
                        case "beforetoggle":
                            SyntheticEventCtor = SyntheticToggleEvent;
                    }
                    var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                    inCapturePhase = [];
                    for(var instance = targetInst, lastHostComponent; null !== instance;){
                        var _instance2 = instance;
                        lastHostComponent = _instance2.stateNode;
                        _instance2 = _instance2.tag;
                        5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(createDispatchListener(instance, _instance2, lastHostComponent)));
                        if (accumulateTargetOnly) break;
                        instance = instance.return;
                    }
                    0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
                        event: reactName,
                        listeners: inCapturePhase
                    }));
                }
            }
            if (0 === (eventSystemFlags & 7)) {
                a: {
                    reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                    SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                    if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey])) break a;
                    if (SyntheticEventCtor || reactName) {
                        reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                        if (SyntheticEventCtor) {
                            if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase)) reactEventType = null;
                        } else SyntheticEventCtor = null, reactEventType = targetInst;
                        if (SyntheticEventCtor !== reactEventType) {
                            inCapturePhase = SyntheticMouseEvent;
                            _instance2 = "onMouseLeave";
                            reactEventName = "onMouseEnter";
                            instance = "mouse";
                            if ("pointerout" === domEventName || "pointerover" === domEventName) inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                            accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                            lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                            reactName = new inCapturePhase(_instance2, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
                            reactName.target = accumulateTargetOnly;
                            reactName.relatedTarget = lastHostComponent;
                            _instance2 = null;
                            getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                            accumulateTargetOnly = _instance2;
                            if (SyntheticEventCtor && reactEventType) b: {
                                inCapturePhase = SyntheticEventCtor;
                                reactEventName = reactEventType;
                                instance = 0;
                                for(lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))instance++;
                                lastHostComponent = 0;
                                for(_instance2 = reactEventName; _instance2; _instance2 = getParent(_instance2))lastHostComponent++;
                                for(; 0 < instance - lastHostComponent;)inCapturePhase = getParent(inCapturePhase), instance--;
                                for(; 0 < lastHostComponent - instance;)reactEventName = getParent(reactEventName), lastHostComponent--;
                                for(; instance--;){
                                    if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate) break b;
                                    inCapturePhase = getParent(inCapturePhase);
                                    reactEventName = getParent(reactEventName);
                                }
                                inCapturePhase = null;
                            }
                            else inCapturePhase = null;
                            null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, !1);
                            null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, !0);
                        }
                    }
                }
                a: {
                    reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                    SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                    if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type) var getTargetInstFunc = getTargetInstForChangeEvent;
                    else if (isTextInputElement(reactName)) {
                        if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                        else {
                            getTargetInstFunc = getTargetInstForInputEventPolyfill;
                            var handleEventFunc = handleEventsForInputEventPolyfill;
                        }
                    } else SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                    if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                        createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);
                        break a;
                    }
                    handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                    "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
                }
                handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
                switch(domEventName){
                    case "focusin":
                        if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable) activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                        break;
                    case "focusout":
                        lastSelection = activeElementInst = activeElement = null;
                        break;
                    case "mousedown":
                        mouseDown = !0;
                        break;
                    case "contextmenu":
                    case "mouseup":
                    case "dragend":
                        mouseDown = !1;
                        constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                        break;
                    case "selectionchange":
                        if (skipSelectionChangeEvent) break;
                    case "keydown":
                    case "keyup":
                        constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                }
                var fallbackData;
                if (canUseCompositionEvent) b: {
                    switch(domEventName){
                        case "compositionstart":
                            var eventType = "onCompositionStart";
                            break b;
                        case "compositionend":
                            eventType = "onCompositionEnd";
                            break b;
                        case "compositionupdate":
                            eventType = "onCompositionUpdate";
                            break b;
                    }
                    eventType = void 0;
                }
                else isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
                eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = !0)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
                    event: eventType,
                    listeners: handleEventFunc
                }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
                if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent)) eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
                    event: handleEventFunc,
                    listeners: eventType
                }), handleEventFunc.data = fallbackData);
                extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
            processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
    }
    function createDispatchListener(instance, listener, currentTarget) {
        return {
            instance: instance,
            listener: listener,
            currentTarget: currentTarget
        };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for(var captureName = reactName + "Capture", listeners = []; null !== targetFiber;){
            var _instance3 = targetFiber, stateNode = _instance3.stateNode;
            _instance3 = _instance3.tag;
            5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(createDispatchListener(targetFiber, _instance3, stateNode)), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(createDispatchListener(targetFiber, _instance3, stateNode)));
            targetFiber = targetFiber.return;
        }
        return listeners;
    }
    function getParent(inst) {
        if (null === inst) return null;
        do inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        for(var registrationName = event._reactName, listeners = []; null !== target && target !== common;){
            var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
            _instance4 = _instance4.tag;
            if (null !== alternate && alternate === common) break;
            5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(createDispatchListener(target, stateNode, alternate))));
            target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({
            event: event,
            listeners: listeners
        });
    }
    function validatePropertiesInDevelopment(type, props) {
        validateProperties$2(type, props);
        "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = !0, "select" === type && props.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
        var eventRegistry = {
            registrationNameDependencies: registrationNameDependencies,
            possibleRegistrationNames: possibleRegistrationNames
        };
        isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
        props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
    }
    function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
        serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
    }
    function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
        attributeNames.forEach(function(attributeName) {
            serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
        });
    }
    function warnForInvalidEventListener(registrationName, listener) {
        !1 === listener ? console.error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName) : console.error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
    }
    function normalizeHTML(parent, html) {
        parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName) : parent.ownerDocument.createElement(parent.tagName);
        parent.innerHTML = html;
        return parent.innerHTML;
    }
    function normalizeMarkupForTextOrAttribute(markup) {
        willCoercionThrow(markup) && (console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName(markup)), testStringCoercion(markup));
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
    }
    function noop$1() {}
    function setProp(domElement, tag, key, value, props, prevValue) {
        switch(key){
            case "children":
                if ("string" === typeof value) validateTextNesting(value, tag), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
                else if ("number" === typeof value || "bigint" === typeof value) validateTextNesting("" + value, tag), "body" !== tag && setTextContent(domElement, "" + value);
                break;
            case "className":
                setValueForKnownAttribute(domElement, "class", value);
                break;
            case "tabIndex":
                setValueForKnownAttribute(domElement, "tabindex", value);
                break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
                setValueForKnownAttribute(domElement, key, value);
                break;
            case "style":
                setValueForStyles(domElement, value, prevValue);
                break;
            case "data":
                if ("object" !== tag) {
                    setValueForKnownAttribute(domElement, "data", value);
                    break;
                }
            case "src":
            case "href":
                if ("" === value && ("a" !== tag || "href" !== key)) {
                    "src" === key ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key);
                    domElement.removeAttribute(key);
                    break;
                }
                if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                    domElement.removeAttribute(key);
                    break;
                }
                checkAttributeStringCoercion(value, key);
                value = sanitizeURL("" + value);
                domElement.setAttribute(key, value);
                break;
            case "action":
            case "formAction":
                null != value && ("form" === tag ? "formAction" === key ? console.error("You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>.") : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.")), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."))) : "input" === tag || "button" === tag ? "action" === key ? console.error("You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>.") : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = !0, console.error('Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.')), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.")), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."))) : (didWarnFormActionType = !0, console.error('A button can only specify a formAction along with type="submit" or no type.')) : (didWarnFormActionType = !0, console.error('An input can only specify a formAction along with type="submit" or type="image".')) : "action" === key ? console.error("You can only pass the action prop to <form>.") : console.error("You can only pass the formAction prop to <input> or <button>."));
                if ("function" === typeof value) {
                    domElement.setAttribute(key, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                    break;
                } else "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(domElement, tag, "formEncType", props.formEncType, props, null), setProp(domElement, tag, "formMethod", props.formMethod, props, null), setProp(domElement, tag, "formTarget", props.formTarget, props, null)) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
                if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                    domElement.removeAttribute(key);
                    break;
                }
                checkAttributeStringCoercion(value, key);
                value = sanitizeURL("" + value);
                domElement.setAttribute(key, value);
                break;
            case "onClick":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
                break;
            case "onScroll":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
                break;
            case "onScrollEnd":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
                break;
            case "dangerouslySetInnerHTML":
                if (null != value) {
                    if ("object" !== typeof value || !("__html" in value)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
                    key = value.__html;
                    if (null != key) {
                        if (null != props.children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
                        domElement.innerHTML = key;
                    }
                }
                break;
            case "multiple":
                domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
                break;
            case "muted":
                domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
                break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
                break;
            case "autoFocus":
                break;
            case "xlinkHref":
                if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                    domElement.removeAttribute("xlink:href");
                    break;
                }
                checkAttributeStringCoercion(value, key);
                key = sanitizeURL("" + value);
                domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
                break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
                null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
                break;
            case "inert":
                "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", key));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
                value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
                break;
            case "capture":
            case "download":
                !0 === value ? domElement.setAttribute(key, "") : !1 !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
                break;
            case "cols":
            case "rows":
            case "size":
            case "span":
                null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
                break;
            case "rowSpan":
            case "start":
                null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
                break;
            case "popover":
                listenToNonDelegatedEvent("beforetoggle", domElement);
                listenToNonDelegatedEvent("toggle", domElement);
                setValueForAttribute(domElement, "popover", value);
                break;
            case "xlinkActuate":
                setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:actuate", value);
                break;
            case "xlinkArcrole":
                setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:arcrole", value);
                break;
            case "xlinkRole":
                setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:role", value);
                break;
            case "xlinkShow":
                setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:show", value);
                break;
            case "xlinkTitle":
                setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:title", value);
                break;
            case "xlinkType":
                setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:type", value);
                break;
            case "xmlBase":
                setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:base", value);
                break;
            case "xmlLang":
                setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:lang", value);
                break;
            case "xmlSpace":
                setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:space", value);
                break;
            case "is":
                null != prevValue && console.error('Cannot update the "is" prop after it has been initialized.');
                setValueForAttribute(domElement, "is", value);
                break;
            case "innerText":
            case "textContent":
                break;
            case "popoverTarget":
                didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = !0, console.error("The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.", value));
            default:
                !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
        }
    }
    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch(key){
            case "style":
                setValueForStyles(domElement, value, prevValue);
                break;
            case "dangerouslySetInnerHTML":
                if (null != value) {
                    if ("object" !== typeof value || !("__html" in value)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
                    key = value.__html;
                    if (null != key) {
                        if (null != props.children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
                        domElement.innerHTML = key;
                    }
                }
                break;
            case "children":
                "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
                break;
            case "onScroll":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
                break;
            case "onScrollEnd":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
                break;
            case "onClick":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
                break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
                break;
            case "innerText":
            case "textContent":
                break;
            default:
                if (registrationNameDependencies.hasOwnProperty(key)) null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
                else a: {
                    if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                        "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                        domElement.addEventListener(tag, value, props);
                        break a;
                    }
                    key in domElement ? domElement[key] = value : !0 === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                }
        }
    }
    function setInitialProperties(domElement, tag, props) {
        validatePropertiesInDevelopment(tag, props);
        switch(tag){
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
                break;
            case "img":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                var hasSrc = !1, hasSrcSet = !1, propKey;
                for(propKey in props)if (props.hasOwnProperty(propKey)) {
                    var propValue = props[propKey];
                    if (null != propValue) switch(propKey){
                        case "src":
                            hasSrc = !0;
                            break;
                        case "srcSet":
                            hasSrcSet = !0;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                        default:
                            setProp(domElement, tag, propKey, propValue, props, null);
                    }
                }
                hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
                hasSrc && setProp(domElement, tag, "src", props.src, props, null);
                return;
            case "input":
                checkControlledValueProps("input", props);
                listenToNonDelegatedEvent("invalid", domElement);
                var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
                for(hasSrc in props)if (props.hasOwnProperty(hasSrc)) {
                    var _propValue = props[hasSrc];
                    if (null != _propValue) switch(hasSrc){
                        case "name":
                            hasSrcSet = _propValue;
                            break;
                        case "type":
                            propValue = _propValue;
                            break;
                        case "checked":
                            checked = _propValue;
                            break;
                        case "defaultChecked":
                            defaultChecked = _propValue;
                            break;
                        case "value":
                            propKey = _propValue;
                            break;
                        case "defaultValue":
                            defaultValue = _propValue;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (null != _propValue) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                            break;
                        default:
                            setProp(domElement, tag, hasSrc, _propValue, props, null);
                    }
                }
                validateInputProps(domElement, props);
                initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, !1);
                track(domElement);
                return;
            case "select":
                checkControlledValueProps("select", props);
                listenToNonDelegatedEvent("invalid", domElement);
                hasSrc = propValue = propKey = null;
                for(hasSrcSet in props)if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue)) switch(hasSrcSet){
                    case "value":
                        propKey = defaultValue;
                        break;
                    case "defaultValue":
                        propValue = defaultValue;
                        break;
                    case "multiple":
                        hasSrc = defaultValue;
                    default:
                        setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
                validateSelectProps(domElement, props);
                tag = propKey;
                props = propValue;
                domElement.multiple = !!hasSrc;
                null != tag ? updateOptions(domElement, !!hasSrc, tag, !1) : null != props && updateOptions(domElement, !!hasSrc, props, !0);
                return;
            case "textarea":
                checkControlledValueProps("textarea", props);
                listenToNonDelegatedEvent("invalid", domElement);
                propKey = hasSrcSet = hasSrc = null;
                for(propValue in props)if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue)) switch(propValue){
                    case "value":
                        hasSrc = defaultValue;
                        break;
                    case "defaultValue":
                        hasSrcSet = defaultValue;
                        break;
                    case "children":
                        propKey = defaultValue;
                        break;
                    case "dangerouslySetInnerHTML":
                        if (null != defaultValue) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                        break;
                    default:
                        setProp(domElement, tag, propValue, defaultValue, props, null);
                }
                validateTextareaProps(domElement, props);
                initTextarea(domElement, hasSrc, hasSrcSet, propKey);
                track(domElement);
                return;
            case "option":
                validateOptionProps(domElement, props);
                for(checked in props)if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc)) switch(checked){
                    case "selected":
                        domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                        break;
                    default:
                        setProp(domElement, tag, checked, hasSrc, props, null);
                }
                return;
            case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
            case "iframe":
            case "object":
                listenToNonDelegatedEvent("load", domElement);
                break;
            case "video":
            case "audio":
                for(hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
                break;
            case "image":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
            case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
            case "embed":
            case "source":
            case "link":
                listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
                for(defaultChecked in props)if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc)) switch(defaultChecked){
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                    default:
                        setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
                return;
            default:
                if (isCustomElement(tag)) {
                    for(_propValue in props)props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(domElement, tag, _propValue, hasSrc, props, void 0));
                    return;
                }
        }
        for(defaultValue in props)props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
        validatePropertiesInDevelopment(tag, nextProps);
        switch(tag){
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
                break;
            case "input":
                var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
                for(propKey in lastProps){
                    var lastProp = lastProps[propKey];
                    if (lastProps.hasOwnProperty(propKey) && null != lastProp) switch(propKey){
                        case "checked":
                            break;
                        case "value":
                            break;
                        case "defaultValue":
                            lastDefaultValue = lastProp;
                        default:
                            nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                    }
                }
                for(var _propKey8 in nextProps){
                    var propKey = nextProps[_propKey8];
                    lastProp = lastProps[_propKey8];
                    if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp)) switch(_propKey8){
                        case "type":
                            type = propKey;
                            break;
                        case "name":
                            name = propKey;
                            break;
                        case "checked":
                            checked = propKey;
                            break;
                        case "defaultChecked":
                            defaultChecked = propKey;
                            break;
                        case "value":
                            value = propKey;
                            break;
                        case "defaultValue":
                            defaultValue = propKey;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (null != propKey) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                            break;
                        default:
                            propKey !== lastProp && setProp(domElement, tag, _propKey8, propKey, nextProps, lastProp);
                    }
                }
                tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
                nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
                tag || !nextProps || didWarnUncontrolledToControlled || (console.error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnUncontrolledToControlled = !0);
                !tag || nextProps || didWarnControlledToUncontrolled || (console.error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnControlledToUncontrolled = !0);
                updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
                return;
            case "select":
                propKey = value = defaultValue = _propKey8 = null;
                for(type in lastProps)if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue) switch(type){
                    case "value":
                        break;
                    case "multiple":
                        propKey = lastDefaultValue;
                    default:
                        nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
                }
                for(name in nextProps)if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue)) switch(name){
                    case "value":
                        _propKey8 = type;
                        break;
                    case "defaultValue":
                        defaultValue = type;
                        break;
                    case "multiple":
                        value = type;
                    default:
                        type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
                }
                nextProps = defaultValue;
                tag = value;
                lastProps = propKey;
                null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, !1) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, !0) : updateOptions(domElement, !!tag, tag ? [] : "", !1));
                return;
            case "textarea":
                propKey = _propKey8 = null;
                for(defaultValue in lastProps)if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue)) switch(defaultValue){
                    case "value":
                        break;
                    case "children":
                        break;
                    default:
                        setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
                for(value in nextProps)if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type)) switch(value){
                    case "value":
                        _propKey8 = name;
                        break;
                    case "defaultValue":
                        propKey = name;
                        break;
                    case "children":
                        break;
                    case "dangerouslySetInnerHTML":
                        if (null != name) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                        break;
                    default:
                        name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
                updateTextarea(domElement, _propKey8, propKey);
                return;
            case "option":
                for(var _propKey13 in lastProps)if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13)) switch(_propKey13){
                    case "selected":
                        domElement.selected = !1;
                        break;
                    default:
                        setProp(domElement, tag, _propKey13, null, nextProps, _propKey8);
                }
                for(lastDefaultValue in nextProps)if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey)) switch(lastDefaultValue){
                    case "selected":
                        domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                        break;
                    default:
                        setProp(domElement, tag, lastDefaultValue, _propKey8, nextProps, propKey);
                }
                return;
            case "img":
            case "link":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
            case "menuitem":
                for(var _propKey15 in lastProps)_propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(domElement, tag, _propKey15, null, nextProps, _propKey8);
                for(checked in nextProps)if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey)) switch(checked){
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (null != _propKey8) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                        break;
                    default:
                        setProp(domElement, tag, checked, _propKey8, nextProps, propKey);
                }
                return;
            default:
                if (isCustomElement(tag)) {
                    for(var _propKey17 in lastProps)_propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(domElement, tag, _propKey17, void 0, nextProps, _propKey8);
                    for(defaultChecked in nextProps)_propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(domElement, tag, defaultChecked, _propKey8, nextProps, propKey);
                    return;
                }
        }
        for(var _propKey19 in lastProps)_propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
        for(lastProp in nextProps)_propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
    }
    function getPropNameFromAttributeName(attrName) {
        switch(attrName){
            case "class":
                return "className";
            case "for":
                return "htmlFor";
            default:
                return attrName;
        }
    }
    function getStylesObjectFromElement(domElement) {
        var serverValueInObjectForm = {};
        domElement = domElement.style;
        for(var i = 0; i < domElement.length; i++){
            var styleName = domElement[i];
            serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
        }
        return serverValueInObjectForm;
    }
    function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
        if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0) console.error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        else if (canDiffStyleForHydrationWarning) {
            var clientValue;
            var delimiter = clientValue = "", styleName;
            for(styleName in value$jscomp$0)if (value$jscomp$0.hasOwnProperty(styleName)) {
                var value = value$jscomp$0[styleName];
                null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
            }
            clientValue = clientValue || null;
            value$jscomp$0 = domElement.getAttribute("style");
            value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
        }
    }
    function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
        extraAttributes.delete(attributeName);
        domElement = domElement.getAttribute(attributeName);
        if (null === domElement) switch(typeof value){
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                return;
        }
        else if (null != value) switch(typeof value){
            case "function":
            case "symbol":
            case "boolean":
                break;
            default:
                if (checkAttributeStringCoercion(value, propKey), domElement === "" + value) return;
        }
        warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
        extraAttributes.delete(attributeName);
        domElement = domElement.getAttribute(attributeName);
        if (null === domElement) {
            switch(typeof value){
                case "function":
                case "symbol":
                    return;
            }
            if (!value) return;
        } else switch(typeof value){
            case "function":
            case "symbol":
                break;
            default:
                if (value) return;
        }
        warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
        extraAttributes.delete(attributeName);
        domElement = domElement.getAttribute(attributeName);
        if (null === domElement) switch(typeof value){
            case "undefined":
            case "function":
            case "symbol":
                return;
        }
        else if (null != value) switch(typeof value){
            case "function":
            case "symbol":
                break;
            default:
                if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value) return;
        }
        warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
        extraAttributes.delete(attributeName);
        domElement = domElement.getAttribute(attributeName);
        if (null === domElement) switch(typeof value){
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                return;
            default:
                if (isNaN(value)) return;
        }
        else if (null != value) switch(typeof value){
            case "function":
            case "symbol":
            case "boolean":
                break;
            default:
                if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value)) return;
        }
        warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
        extraAttributes.delete(attributeName);
        domElement = domElement.getAttribute(attributeName);
        if (null === domElement) switch(typeof value){
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                return;
        }
        else if (null != value) switch(typeof value){
            case "function":
            case "symbol":
            case "boolean":
                break;
            default:
                if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName) return;
        }
        warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function diffHydratedProperties(domElement, tag, props, hostContext) {
        for(var serverDifferences = {}, extraAttributes = new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++)switch(attributes[i].name.toLowerCase()){
            case "value":
                break;
            case "checked":
                break;
            case "selected":
                break;
            default:
                extraAttributes.add(attributes[i].name);
        }
        if (isCustomElement(tag)) {
            for(var propKey in props)if (props.hasOwnProperty(propKey)) {
                var value = props[propKey];
                if (null != value) {
                    if (registrationNameDependencies.hasOwnProperty(propKey)) "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                    else if (!0 !== props.suppressHydrationWarning) switch(propKey){
                        case "children":
                            "string" !== typeof value && "number" !== typeof value || warnForPropDifference("children", domElement.textContent, value, serverDifferences);
                            continue;
                        case "suppressContentEditableWarning":
                        case "suppressHydrationWarning":
                        case "defaultValue":
                        case "defaultChecked":
                        case "innerHTML":
                        case "ref":
                            continue;
                        case "dangerouslySetInnerHTML":
                            attributes = domElement.innerHTML;
                            value = value ? value.__html : void 0;
                            null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(propKey, attributes, value, serverDifferences));
                            continue;
                        case "style":
                            extraAttributes.delete(propKey);
                            diffHydratedStyles(domElement, value, serverDifferences);
                            continue;
                        case "offsetParent":
                        case "offsetTop":
                        case "offsetLeft":
                        case "offsetWidth":
                        case "offsetHeight":
                        case "isContentEditable":
                        case "outerText":
                        case "outerHTML":
                            extraAttributes.delete(propKey.toLowerCase());
                            console.error("Assignment to read-only property will result in a no-op: `%s`", propKey);
                            continue;
                        case "className":
                            extraAttributes.delete("class");
                            attributes = getValueForAttributeOnCustomComponent(domElement, "class", value);
                            warnForPropDifference("className", attributes, value, serverDifferences);
                            continue;
                        default:
                            hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(domElement, propKey, value), warnForPropDifference(propKey, attributes, value, serverDifferences);
                    }
                }
            }
        } else for(value in props)if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
            if (registrationNameDependencies.hasOwnProperty(value)) "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
            else if (!0 !== props.suppressHydrationWarning) switch(value){
                case "children":
                    "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference("children", domElement.textContent, propKey, serverDifferences);
                    continue;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                    continue;
                case "dangerouslySetInnerHTML":
                    attributes = domElement.innerHTML;
                    propKey = propKey ? propKey.__html : void 0;
                    null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = {
                        __html: attributes
                    }));
                    continue;
                case "className":
                    hydrateAttribute(domElement, value, "class", propKey, extraAttributes, serverDifferences);
                    continue;
                case "tabIndex":
                    hydrateAttribute(domElement, value, "tabindex", propKey, extraAttributes, serverDifferences);
                    continue;
                case "style":
                    extraAttributes.delete(value);
                    diffHydratedStyles(domElement, propKey, serverDifferences);
                    continue;
                case "multiple":
                    extraAttributes.delete(value);
                    warnForPropDifference(value, domElement.multiple, propKey, serverDifferences);
                    continue;
                case "muted":
                    extraAttributes.delete(value);
                    warnForPropDifference(value, domElement.muted, propKey, serverDifferences);
                    continue;
                case "autoFocus":
                    extraAttributes.delete("autofocus");
                    warnForPropDifference(value, domElement.autofocus, propKey, serverDifferences);
                    continue;
                case "data":
                    if ("object" !== tag) {
                        extraAttributes.delete(value);
                        attributes = domElement.getAttribute("data");
                        warnForPropDifference(value, attributes, propKey, serverDifferences);
                        continue;
                    }
                case "src":
                case "href":
                    if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                        "src" === value ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value);
                        hydrateSanitizedAttribute(domElement, value, value, null, extraAttributes, serverDifferences);
                        continue;
                    }
                    hydrateSanitizedAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
                    continue;
                case "action":
                case "formAction":
                    attributes = domElement.getAttribute(value);
                    if ("function" === typeof propKey) {
                        extraAttributes.delete(value.toLowerCase());
                        "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                        continue;
                    } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                        extraAttributes.delete(value.toLowerCase());
                        warnForPropDifference(value, "function", propKey, serverDifferences);
                        continue;
                    }
                    hydrateSanitizedAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);
                    continue;
                case "xlinkHref":
                    hydrateSanitizedAttribute(domElement, value, "xlink:href", propKey, extraAttributes, serverDifferences);
                    continue;
                case "contentEditable":
                    hydrateBooleanishAttribute(domElement, value, "contenteditable", propKey, extraAttributes, serverDifferences);
                    continue;
                case "spellCheck":
                    hydrateBooleanishAttribute(domElement, value, "spellcheck", propKey, extraAttributes, serverDifferences);
                    continue;
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                    hydrateBooleanishAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
                    continue;
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                    hydrateBooleanAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);
                    continue;
                case "capture":
                case "download":
                    a: {
                        i = domElement;
                        var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i) switch(typeof propKey){
                            case "undefined":
                            case "function":
                            case "symbol":
                                break a;
                            default:
                                if (!1 === propKey) break a;
                        }
                        else if (null != propKey) switch(typeof propKey){
                            case "function":
                            case "symbol":
                                break;
                            case "boolean":
                                if (!0 === propKey && "" === i) break a;
                                break;
                            default:
                                if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey) break a;
                        }
                        warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);
                    }
                    continue;
                case "cols":
                case "rows":
                case "size":
                case "span":
                    a: {
                        i = domElement;
                        attributeName = attributes = value;
                        serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i) switch(typeof propKey){
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                                break a;
                            default:
                                if (isNaN(propKey) || 1 > propKey) break a;
                        }
                        else if (null != propKey) switch(typeof propKey){
                            case "function":
                            case "symbol":
                            case "boolean":
                                break;
                            default:
                                if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)) break a;
                        }
                        warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);
                    }
                    continue;
                case "rowSpan":
                    hydrateNumericAttribute(domElement, value, "rowspan", propKey, extraAttributes, serverDifferences);
                    continue;
                case "start":
                    hydrateNumericAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
                    continue;
                case "xHeight":
                    hydrateAttribute(domElement, value, "x-height", propKey, extraAttributes, serverDifferences);
                    continue;
                case "xlinkActuate":
                    hydrateAttribute(domElement, value, "xlink:actuate", propKey, extraAttributes, serverDifferences);
                    continue;
                case "xlinkArcrole":
                    hydrateAttribute(domElement, value, "xlink:arcrole", propKey, extraAttributes, serverDifferences);
                    continue;
                case "xlinkRole":
                    hydrateAttribute(domElement, value, "xlink:role", propKey, extraAttributes, serverDifferences);
                    continue;
                case "xlinkShow":
                    hydrateAttribute(domElement, value, "xlink:show", propKey, extraAttributes, serverDifferences);
                    continue;
                case "xlinkTitle":
                    hydrateAttribute(domElement, value, "xlink:title", propKey, extraAttributes, serverDifferences);
                    continue;
                case "xlinkType":
                    hydrateAttribute(domElement, value, "xlink:type", propKey, extraAttributes, serverDifferences);
                    continue;
                case "xmlBase":
                    hydrateAttribute(domElement, value, "xml:base", propKey, extraAttributes, serverDifferences);
                    continue;
                case "xmlLang":
                    hydrateAttribute(domElement, value, "xml:lang", propKey, extraAttributes, serverDifferences);
                    continue;
                case "xmlSpace":
                    hydrateAttribute(domElement, value, "xml:space", propKey, extraAttributes, serverDifferences);
                    continue;
                case "inert":
                    "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", value));
                    hydrateBooleanAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
                    continue;
                default:
                    if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                        i = getAttributeAlias(value);
                        attributes = !1;
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(attributeName) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = !0, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
                        a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0)) {
                            if (attributeName.hasAttribute(serverDifferences$jscomp$0)) attributeName = attributeName.getAttribute(serverDifferences$jscomp$0), checkAttributeStringCoercion(i, serverDifferences$jscomp$0), i = attributeName === "" + i ? i : attributeName;
                            else {
                                switch(typeof i){
                                    case "function":
                                    case "symbol":
                                        break a;
                                    case "boolean":
                                        if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName) break a;
                                }
                                i = void 0 === i ? void 0 : null;
                            }
                        } else i = void 0;
                        attributes || warnForPropDifference(value, i, propKey, serverDifferences);
                    }
            }
        }
        0 < extraAttributes.size && !0 !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
        return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
    }
    function propNamesListJoin(list, combinator) {
        switch(list.length){
            case 0:
                return "";
            case 1:
                return list[0];
            case 2:
                return list[0] + " " + combinator + " " + list[1];
            default:
                return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
        }
    }
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
        switch(namespaceURI){
            case SVG_NAMESPACE:
                return HostContextNamespaceSvg;
            case MATH_NAMESPACE:
                return HostContextNamespaceMath;
            default:
                return HostContextNamespaceNone;
        }
    }
    function getChildHostContextProd(parentNamespace, type) {
        if (parentNamespace === HostContextNamespaceNone) switch(type){
            case "svg":
                return HostContextNamespaceSvg;
            case "math":
                return HostContextNamespaceMath;
            default:
                return HostContextNamespaceNone;
        }
        return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
    }
    function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
            if (event === currentPopstateTransitionEvent) return !1;
            currentPopstateTransitionEvent = event;
            return !0;
        }
        currentPopstateTransitionEvent = null;
        return !1;
    }
    function handleErrorInNextTick(error) {
        setTimeout(function() {
            throw error;
        });
    }
    function commitMount(domElement, type, newProps) {
        switch(type){
            case "button":
            case "input":
            case "select":
            case "textarea":
                newProps.autoFocus && domElement.focus();
                break;
            case "img":
                newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
        }
    }
    function commitUpdate(domElement, type, oldProps, newProps) {
        updateProperties(domElement, type, oldProps, newProps);
        domElement[internalPropsKey] = newProps;
    }
    function resetTextContent(domElement) {
        setTextContent(domElement, "");
    }
    function commitTextUpdate(textInstance, oldText, newText) {
        textInstance.nodeValue = newText;
    }
    function removeChild(parentInstance, child) {
        parentInstance.removeChild(child);
    }
    function removeChildFromContainer(container, child) {
        8 === container.nodeType ? container.parentNode.removeChild(child) : container.removeChild(child);
    }
    function clearSuspenseBoundary(parentInstance, suspenseInstance) {
        var node = suspenseInstance, depth = 0;
        do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && 8 === nextNode.nodeType) {
                if (node = nextNode.data, node === SUSPENSE_END_DATA) {
                    if (0 === depth) {
                        parentInstance.removeChild(nextNode);
                        retryIfBlockedOn(suspenseInstance);
                        return;
                    }
                    depth--;
                } else node !== SUSPENSE_START_DATA && node !== SUSPENSE_PENDING_START_DATA && node !== SUSPENSE_FALLBACK_START_DATA || depth++;
            }
            node = nextNode;
        }while (node);
        retryIfBlockedOn(suspenseInstance);
    }
    function hideInstance(instance) {
        instance = instance.style;
        "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
    }
    function hideTextInstance(textInstance) {
        textInstance.nodeValue = "";
    }
    function unhideInstance(instance, props) {
        props = props[STYLE];
        props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
        instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
    }
    function unhideTextInstance(textInstance, text) {
        textInstance.nodeValue = text;
    }
    function clearContainerSparingly(container) {
        var nextNode = container.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for(; nextNode;){
            var node = nextNode;
            nextNode = nextNode.nextSibling;
            switch(node.nodeName){
                case "HTML":
                case "HEAD":
                case "BODY":
                    clearContainerSparingly(node);
                    detachDeletedInstance(node);
                    continue;
                case "SCRIPT":
                case "STYLE":
                    continue;
                case "LINK":
                    if ("stylesheet" === node.rel.toLowerCase()) continue;
            }
            container.removeChild(node);
        }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
        for(; 1 === instance.nodeType;){
            var anyProps = props;
            if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
                if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type)) break;
            } else if (!inRootOrSingleton) {
                if ("input" === type && "hidden" === instance.type) {
                    checkAttributeStringCoercion(anyProps.name, "name");
                    var name = null == anyProps.name ? null : "" + anyProps.name;
                    if ("hidden" === anyProps.type && instance.getAttribute("name") === name) return instance;
                } else return instance;
            } else if (!instance[internalHoistableMarker]) switch(type){
                case "meta":
                    if (!instance.hasAttribute("itemprop")) break;
                    return instance;
                case "link":
                    name = instance.getAttribute("rel");
                    if ("stylesheet" === name && instance.hasAttribute("data-precedence")) break;
                    else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title)) break;
                    return instance;
                case "style":
                    if (instance.hasAttribute("data-precedence")) break;
                    return instance;
                case "script":
                    name = instance.getAttribute("src");
                    if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop")) break;
                    return instance;
                default:
                    return instance;
            }
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) break;
        }
        return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
        if ("" === text) return null;
        for(; 3 !== instance.nodeType;){
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton) return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
        }
        return instance;
    }
    function getNextHydratable(node) {
        for(; null != node; node = node.nextSibling){
            var nodeType = node.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
            if (8 === nodeType) {
                nodeType = node.data;
                if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING) break;
                if (nodeType === SUSPENSE_END_DATA) return null;
            }
        }
        return node;
    }
    function describeHydratableInstanceForDevWarnings(instance) {
        if (1 === instance.nodeType) {
            for(var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++){
                var attr = attributes[i];
                serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
            }
            return {
                type: JSCompiler_temp_const,
                props: serverDifferences
            };
        }
        return 8 === instance.nodeType ? {
            type: "Suspense",
            props: {}
        } : instance.nodeValue;
    }
    function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
        return null === parentProps || !0 !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
    }
    function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
        suspenseInstance = suspenseInstance.nextSibling;
        for(var depth = 0; suspenseInstance;){
            if (8 === suspenseInstance.nodeType) {
                var data = suspenseInstance.data;
                if (data === SUSPENSE_END_DATA) {
                    if (0 === depth) return getNextHydratable(suspenseInstance.nextSibling);
                    depth--;
                } else data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA || depth++;
            }
            suspenseInstance = suspenseInstance.nextSibling;
        }
        return null;
    }
    function getParentSuspenseInstance(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for(var depth = 0; targetInstance;){
            if (8 === targetInstance.nodeType) {
                var data = targetInstance.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                    if (0 === depth) return targetInstance;
                    depth--;
                } else data === SUSPENSE_END_DATA && depth++;
            }
            targetInstance = targetInstance.previousSibling;
        }
        return null;
    }
    function commitHydratedContainer(container) {
        retryIfBlockedOn(container);
    }
    function commitHydratedSuspenseInstance(suspenseInstance) {
        retryIfBlockedOn(suspenseInstance);
    }
    function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
        validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch(type){
            case "html":
                type = props.documentElement;
                if (!type) throw Error("React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page.");
                return type;
            case "head":
                type = props.head;
                if (!type) throw Error("React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page.");
                return type;
            case "body":
                type = props.body;
                if (!type) throw Error("React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page.");
                return type;
            default:
                throw Error("resolveSingletonInstance was called with an element type that is not supported. This is a bug in React.");
        }
    }
    function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
        if (getInstanceFromNode(instance)) {
            var tagName = instance.tagName.toLowerCase();
            console.error("You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.", tagName, tagName, tagName);
        }
        switch(type){
            case "html":
            case "head":
            case "body":
                break;
            default:
                console.error("acquireSingletonInstance was called with an element type that is not supported. This is a bug in React.");
        }
        for(tagName = instance.attributes; tagName.length;)instance.removeAttributeNode(tagName[0]);
        setInitialProperties(instance, type, props);
        instance[internalInstanceKey] = internalInstanceHandle;
        instance[internalPropsKey] = props;
    }
    function getHoistableRoot(container) {
        return "function" === typeof container.getRootNode ? container.getRootNode() : container.ownerDocument;
    }
    function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && "string" === typeof href && href) {
            var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
            limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
            "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
            preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = {
                rel: rel,
                crossOrigin: crossOrigin,
                href: href
            }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
        }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
        var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
        if (!resourceRoot) throw Error('"resourceRoot" was expected to exist. This is a bug in React.');
        switch(type){
            case "meta":
            case "title":
                return null;
            case "style":
                return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                    type: "style",
                    instance: null,
                    count: 0,
                    state: null
                }, currentProps.set(pendingProps, currentResource)), currentResource) : {
                    type: "void",
                    instance: null,
                    count: 0,
                    state: null
                };
            case "link":
                if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                    type = getStyleKey(pendingProps.href);
                    var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
                    if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                        type: "stylesheet",
                        instance: null,
                        count: 0,
                        state: {
                            loading: NotLoaded,
                            preload: null
                        }
                    }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(getStylesheetSelectorFromKey(type))) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
                        var preloadProps = {
                            rel: "preload",
                            as: "style",
                            href: pendingProps.href,
                            crossOrigin: pendingProps.crossOrigin,
                            integrity: pendingProps.integrity,
                            media: pendingProps.media,
                            hrefLang: pendingProps.hrefLang,
                            referrerPolicy: pendingProps.referrerPolicy
                        };
                        preloadPropsMap.set(type, preloadProps);
                        _styles || preloadStylesheet(resourceRoot, type, preloadProps, _resource.state);
                    }
                    if (currentProps && null === currentResource) throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error("Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps);
                    return _resource;
                }
                if (currentProps && null !== currentResource) throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error("Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps);
                return null;
            case "script":
                return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                    type: "script",
                    instance: null,
                    count: 0,
                    state: null
                }, currentProps.set(pendingProps, currentResource)), currentResource) : {
                    type: "void",
                    instance: null,
                    count: 0,
                    state: null
                };
            default:
                throw Error('getResource encountered a type it did not expect: "' + type + '". this is a bug in React.');
        }
    }
    function describeLinkForResourceErrorDEV(props) {
        var describedProps = 0, description = "<link";
        "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
        "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
        "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
        Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
        return description + " />";
    }
    function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
            "data-precedence": rawProps.precedence,
            precedence: null
        });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
            return state.loading |= Loaded;
        }), key.addEventListener("error", function() {
            return state.loading |= Errored;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
    }
    function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance) switch(resource.type){
            case "style":
                var instance = hoistableRoot.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]');
                if (instance) return resource.instance = instance, markNodeAsHoistable(instance), instance;
                var styleProps = assign({}, props, {
                    "data-href": props.href,
                    "data-precedence": props.precedence,
                    href: null,
                    precedence: null
                });
                instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                markNodeAsHoistable(instance);
                setInitialProperties(instance, "style", styleProps);
                insertStylesheet(instance, props.precedence, hoistableRoot);
                return resource.instance = instance;
            case "stylesheet":
                styleProps = getStyleKey(props.href);
                var _instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));
                if (_instance) return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
                instance = stylesheetPropsFromRawProps(props);
                (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                markNodeAsHoistable(_instance);
                var linkInstance = _instance;
                linkInstance._p = new Promise(function(resolve, reject) {
                    linkInstance.onload = resolve;
                    linkInstance.onerror = reject;
                });
                setInitialProperties(_instance, "link", instance);
                resource.state.loading |= Inserted;
                insertStylesheet(_instance, props.precedence, hoistableRoot);
                return resource.instance = _instance;
            case "script":
                _instance = getScriptKey(props.src);
                if (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(_instance))) return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                instance = props;
                if (styleProps = preloadPropsMap.get(_instance)) instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                styleProps = hoistableRoot.createElement("script");
                markNodeAsHoistable(styleProps);
                setInitialProperties(styleProps, "link", instance);
                hoistableRoot.head.appendChild(styleProps);
                return resource.instance = styleProps;
            case "void":
                return null;
            default:
                throw Error('acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.');
        }
        else "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
        return resource.instance;
    }
    function insertStylesheet(instance, precedence, root) {
        for(var nodes = root.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++){
            var node = nodes[i];
            if (node.dataset.precedence === precedence) prior = node;
            else if (prior !== last) break;
        }
        prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root.nodeType ? root.head : root, precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
    }
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
            var cache = new Map();
            var caches = tagCaches = new Map();
            caches.set(ownerDocument, cache);
        } else caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = new Map(), caches.set(ownerDocument, cache));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for(caches = 0; caches < ownerDocument.length; caches++){
            var node = ownerDocument[caches];
            if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
                var nodeKey = node.getAttribute(keyAttribute) || "";
                nodeKey = type + nodeKey;
                var existing = cache.get(nodeKey);
                existing ? existing.push(node) : cache.set(nodeKey, [
                    node
                ]);
            }
        }
        return cache;
    }
    function mountHoistable(hoistableRoot, type, instance) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(instance, "title" === type ? hoistableRoot.querySelector("head > title") : null);
    }
    function isHostHoistableType(type, props, hostContext) {
        var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
        if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp) return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error("Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.", type, type), !1;
        switch(type){
            case "meta":
            case "title":
                return !0;
            case "style":
                if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
                    outsideHostContainerContext && console.error('Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflic with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`, or move the <style> to the <style> tag.');
                    break;
                }
                return !0;
            case "link":
                if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
                    if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                        type = props.href;
                        var onError = props.onError, disabled = props.disabled;
                        hostContext = [];
                        props.onLoad && hostContext.push("`onLoad`");
                        onError && hostContext.push("`onError`");
                        null != disabled && hostContext.push("`disabled`");
                        onError = propNamesListJoin(hostContext, "and");
                        onError += 1 === hostContext.length ? " prop" : " props";
                        disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
                        hostContext.length && console.error('React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', type, disabled, onError);
                    }
                    outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error("Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag") : (props.onError || props.onLoad) && console.error("Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."));
                    break;
                }
                switch(props.rel){
                    case "stylesheet":
                        return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error('Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'), "string" === typeof type && null == props;
                    default:
                        return !0;
                }
            case "script":
                type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
                if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
                    outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error("Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>.") : console.error("Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>.") : console.error('Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'));
                    break;
                }
                return !0;
            case "noscript":
            case "template":
                outsideHostContainerContext && console.error("Cannot render <%s> outside the main document. Try moving it into the root <head> tag.", type);
        }
        return !1;
    }
    function preloadResource(resource) {
        return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? !1 : !0;
    }
    function noop() {}
    function suspendResource(hoistableRoot, resource, props) {
        if (null === suspendedState) throw Error("Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.");
        var state = suspendedState;
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || !1 !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
            if (null === resource.instance) {
                var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
                if (instance) {
                    hoistableRoot = instance._p;
                    null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                    resource.state.loading |= Inserted;
                    resource.instance = instance;
                    markNodeAsHoistable(instance);
                    return;
                }
                instance = hoistableRoot.ownerDocument || hoistableRoot;
                props = stylesheetPropsFromRawProps(props);
                (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
                instance = instance.createElement("link");
                markNodeAsHoistable(instance);
                var linkInstance = instance;
                linkInstance._p = new Promise(function(resolve, reject) {
                    linkInstance.onload = resolve;
                    linkInstance.onerror = reject;
                });
                setInitialProperties(instance, "link", props);
                resource.instance = instance;
            }
            null === state.stylesheets && (state.stylesheets = new Map());
            state.stylesheets.set(resource, hoistableRoot);
            (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
    }
    function waitForCommitToBeReady() {
        if (null === suspendedState) throw Error("Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.");
        var state = suspendedState;
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count ? function(commit) {
            var stylesheetTimer = setTimeout(function() {
                state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
                if (state.unsuspend) {
                    var unsuspend = state.unsuspend;
                    state.unsuspend = null;
                    unsuspend();
                }
            }, 6e4);
            state.unsuspend = commit;
            return function() {
                state.unsuspend = null;
                clearTimeout(stylesheetTimer);
            };
        } : null;
    }
    function onUnsuspend() {
        this.count--;
        if (0 === this.count) {
            if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
                var unsuspend = this.unsuspend;
                this.unsuspend = null;
                unsuspend();
            }
        }
    }
    function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root, resource) {
        if (!(resource.state.loading & Inserted)) {
            var precedences = precedencesByRoot.get(root);
            if (precedences) var last = precedences.get(LAST_PRECEDENCE);
            else {
                precedences = new Map();
                precedencesByRoot.set(root, precedences);
                for(var nodes = root.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0; i < nodes.length; i++){
                    var node = nodes[i];
                    if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media")) precedences.set(node.dataset.precedence, node), last = node;
                }
                last && precedences.set(LAST_PRECEDENCE, last);
            }
            nodes = resource.instance;
            node = nodes.getAttribute("data-precedence");
            i = precedences.get(node) || last;
            i === last && precedences.set(LAST_PRECEDENCE, nodes);
            precedences.set(node, nodes);
            this.count++;
            last = onUnsuspend.bind(this);
            nodes.addEventListener("load", last);
            nodes.addEventListener("error", last);
            i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root = 9 === root.nodeType ? root.head : root, root.insertBefore(nodes, root.firstChild));
            resource.state.loading |= Inserted;
        }
    }
    function bindToConsole(methodName, args, badgeName) {
        var offset = 0;
        switch(methodName){
            case "dir":
            case "dirxml":
            case "groupEnd":
            case "table":
                return bind.apply(console[methodName], [
                    console
                ].concat(args));
            case "assert":
                offset = 1;
        }
        args = args.slice(0);
        "string" === typeof args[offset] ? args.splice(offset, 1, badgeFormat + args[offset], badgeStyle, pad + badgeName + pad, resetStyle) : args.splice(offset, 0, badgeFormat, badgeStyle, pad + badgeName + pad, resetStyle);
        args.unshift(console);
        return bind.apply(console[methodName], args);
    }
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = noTimeout;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = new Map();
        this.passiveEffectDuration = this.effectDuration = -0;
        this.memoizedUpdaters = new Set();
        containerInfo = this.pendingUpdatersLaneMap = [];
        for(tag = 0; 31 > tag; tag++)containerInfo.push(new Set());
        this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
        containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);
        tag = ConcurrentMode;
        !0 === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
        isDevToolsPresent && (tag |= ProfileMode);
        isStrictMode = createFiber(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        retainCache(tag);
        containerInfo.pooledCache = tag;
        retainCache(tag);
        isStrictMode.memoizedState = {
            element: initialChildren,
            isDehydrated: hydrate,
            cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
    }
    function updateContainerSync(element, container, parentComponent, callback) {
        0 === container.tag && flushPassiveEffects();
        updateContainerImpl(container.current, 2, element, container, parentComponent, callback);
        return 2;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
        if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot) try {
            injectedHook.onScheduleFiberRoot(rendererID, container, element);
        } catch (err) {
            hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
        }
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);
        parentComponent = getContextForSubtree(parentComponent);
        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
        isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown"));
        container = createUpdate(lane);
        container.payload = {
            element: element
        };
        callback = void 0 === callback ? null : callback;
        null !== callback && ("function" !== typeof callback && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback), container.callback = callback);
        element = enqueueUpdate(rootFiber, container, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
            var a = fiber.retryLane;
            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag) {
            var root = enqueueConcurrentRenderForLane(fiber, 67108864);
            null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
            markRetryLaneIfNotHydrated(fiber, 67108864);
        }
    }
    function getCurrentFiberForDevTools() {
        return current;
    }
    function getLaneLabelMap() {
        for(var map = new Map(), lane = 1, index = 0; 31 > index; index++){
            var label = getLabelForLane(lane);
            map.set(lane, label);
            lane *= 2;
        }
        return map;
    }
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally{
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
            ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally{
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
            var blockedOn = findInstanceBlockingEvent(nativeEvent);
            if (null === blockedOn) dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);
            else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) nativeEvent.stopPropagation();
            else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
                for(; null !== blockedOn;){
                    var fiber = getInstanceFromNode(blockedOn);
                    if (null !== fiber) switch(fiber.tag){
                        case 3:
                            fiber = fiber.stateNode;
                            if (fiber.current.memoizedState.isDehydrated) {
                                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                                if (0 !== lanes) {
                                    var root = fiber;
                                    root.pendingLanes |= 2;
                                    for(root.entangledLanes |= 2; lanes;){
                                        var lane = 1 << 31 - clz32(lanes);
                                        root.entanglements[1] |= lane;
                                        lanes &= ~lane;
                                    }
                                    ensureRootIsScheduled(fiber);
                                    (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));
                                }
                            }
                            break;
                        case 13:
                            root = enqueueConcurrentRenderForLane(fiber, 2), null !== root && scheduleUpdateOnFiber(root, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                    }
                    fiber = findInstanceBlockingEvent(nativeEvent);
                    null === fiber && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                    if (fiber === blockedOn) break;
                    blockedOn = fiber;
                }
                null !== blockedOn && nativeEvent.stopPropagation();
            } else dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
        }
    }
    function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
    }
    function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
            var nearestMounted = getNearestMountedFiber(targetNode);
            if (null === nearestMounted) targetNode = null;
            else {
                var tag = nearestMounted.tag;
                if (13 === tag) {
                    targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                    if (null !== targetNode) return targetNode;
                    targetNode = null;
                } else if (3 === tag) {
                    if (nearestMounted.stateNode.current.memoizedState.isDehydrated) return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                    targetNode = null;
                } else nearestMounted !== targetNode && (targetNode = null);
            }
        }
        return_targetInst = targetNode;
        return null;
    }
    function getEventPriority(domEventName) {
        switch(domEventName){
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
                return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
                return ContinuousEventPriority;
            case "message":
                switch(getCurrentPriorityLevel()){
                    case ImmediatePriority:
                        return DiscreteEventPriority;
                    case UserBlockingPriority:
                        return ContinuousEventPriority;
                    case NormalPriority$1:
                    case LowPriority:
                        return DefaultEventPriority;
                    case IdlePriority:
                        return IdleEventPriority;
                    default:
                        return DefaultEventPriority;
                }
            default:
                return DefaultEventPriority;
        }
    }
    function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch(domEventName){
            case "focusin":
            case "focusout":
                queuedFocus = null;
                break;
            case "dragenter":
            case "dragleave":
                queuedDrag = null;
                break;
            case "mouseover":
            case "mouseout":
                queuedMouse = null;
                break;
            case "pointerover":
            case "pointerout":
                queuedPointers.delete(nativeEvent.pointerId);
                break;
            case "gotpointercapture":
            case "lostpointercapture":
                queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent) return existingQueuedEvent = {
            blockedOn: blockedOn,
            domEventName: domEventName,
            eventSystemFlags: eventSystemFlags,
            nativeEvent: nativeEvent,
            targetContainers: [
                targetContainer
            ]
        }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch(domEventName){
            case "focusin":
                return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
            case "dragenter":
                return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
            case "mouseover":
                return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
            case "pointerover":
                var pointerId = nativeEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
                return !0;
            case "gotpointercapture":
                return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), !0;
        }
        return !1;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted) {
                if (targetInst = nearestMounted.tag, 13 === targetInst) {
                    if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                        queuedTarget.blockedOn = targetInst;
                        runWithPriority(queuedTarget.priority, function() {
                            if (13 === nearestMounted.tag) {
                                var lane = requestUpdateLane(nearestMounted), root = enqueueConcurrentRenderForLane(nearestMounted, lane);
                                null !== root && scheduleUpdateOnFiber(root, nearestMounted, lane);
                                markRetryLaneIfNotHydrated(nearestMounted, lane);
                            }
                        });
                        return;
                    }
                } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                    queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                    return;
                }
            }
        }
        queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return !1;
        for(var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length;){
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
            if (null === nextBlockedOn) {
                nextBlockedOn = queuedEvent.nativeEvent;
                var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn), event = nativeEventClone;
                null !== currentReplayingEvent && console.error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
                currentReplayingEvent = event;
                nextBlockedOn.target.dispatchEvent(nativeEventClone);
                null === currentReplayingEvent && console.error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
                currentReplayingEvent = null;
            } else return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, !1;
            targetContainers.shift();
        }
        return !0;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
        hasScheduledReplayAttempt = !1;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = !0, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
    }
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for(var i = 0; i < formReplayingQueue.length; i += 3){
                var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
                if ("function" !== typeof submitterOrAction) {
                    if (null === findInstanceBlockingTarget(submitterOrAction || form)) continue;
                    else break;
                }
                var formInst = getInstanceFromNode(form);
                null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
                    pending: !0,
                    data: formData,
                    method: form.method,
                    action: submitterOrAction
                }, Object.freeze(form), startHostTransition(formInst, form, submitterOrAction, formData));
            }
        }));
    }
    function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for(var i = 0; i < queuedExplicitHydrationTargets.length; i++){
            var queuedTarget = queuedExplicitHydrationTargets[i];
            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for(; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn);)attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i) for(queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3){
            var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction) formProps || scheduleReplayQueueIfNeeded(i);
            else if (formProps) {
                var action = null;
                if (submitterOrAction && submitterOrAction.hasAttribute("formAction")) {
                    if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null) action = formProps.formAction;
                    else {
                        if (null !== findInstanceBlockingTarget(form)) continue;
                    }
                } else action = formProps.action;
                "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
                scheduleReplayQueueIfNeeded(i);
            }
        }
    }
    function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
    }
    function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
    }
    function warnIfReactDOMContainerInDEV(container) {
        container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : console.error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Scheduler = require("c31f9b99c1e288cf"), React = require("c4c4bc2113e5c77f"), ReactDOM = require("772d609564cfd8f6"), REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    Symbol.for("react.debug_trace_mode");
    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, assign = Object.assign, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix, suffix, reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var current = null, isRendering = !1, isArrayImpl = Array.isArray, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
        pending: !1,
        data: null,
        method: null,
        action: null
    }), valueStack = [];
    var fiberStack = [];
    var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = !1, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionLane = 128, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
    }, VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = !1, didWarnCheckedDefaultChecked = !1, didWarnSelectedSetOnOption = !1, didWarnInvalidChild = !1, didWarnInvalidInnerHTML = !1;
    var didWarnValueDefaultValue = !1;
    var valuePropNames = [
        "value",
        "defaultValue"
    ], didWarnValDefaultVal = !1, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(" "), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(" "), buttonScopeTags = inScopeTags.concat([
        "button"
    ]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null,
        containerTagInScope: null
    }, didWarn = {}, MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", shorthandToLonghand = {
        animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(" "),
        background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(" "),
        backgroundPosition: [
            "backgroundPositionX",
            "backgroundPositionY"
        ],
        border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(" "),
        borderBlockEnd: [
            "borderBlockEndColor",
            "borderBlockEndStyle",
            "borderBlockEndWidth"
        ],
        borderBlockStart: [
            "borderBlockStartColor",
            "borderBlockStartStyle",
            "borderBlockStartWidth"
        ],
        borderBottom: [
            "borderBottomColor",
            "borderBottomStyle",
            "borderBottomWidth"
        ],
        borderColor: [
            "borderBottomColor",
            "borderLeftColor",
            "borderRightColor",
            "borderTopColor"
        ],
        borderImage: [
            "borderImageOutset",
            "borderImageRepeat",
            "borderImageSlice",
            "borderImageSource",
            "borderImageWidth"
        ],
        borderInlineEnd: [
            "borderInlineEndColor",
            "borderInlineEndStyle",
            "borderInlineEndWidth"
        ],
        borderInlineStart: [
            "borderInlineStartColor",
            "borderInlineStartStyle",
            "borderInlineStartWidth"
        ],
        borderLeft: [
            "borderLeftColor",
            "borderLeftStyle",
            "borderLeftWidth"
        ],
        borderRadius: [
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
            "borderTopLeftRadius",
            "borderTopRightRadius"
        ],
        borderRight: [
            "borderRightColor",
            "borderRightStyle",
            "borderRightWidth"
        ],
        borderStyle: [
            "borderBottomStyle",
            "borderLeftStyle",
            "borderRightStyle",
            "borderTopStyle"
        ],
        borderTop: [
            "borderTopColor",
            "borderTopStyle",
            "borderTopWidth"
        ],
        borderWidth: [
            "borderBottomWidth",
            "borderLeftWidth",
            "borderRightWidth",
            "borderTopWidth"
        ],
        columnRule: [
            "columnRuleColor",
            "columnRuleStyle",
            "columnRuleWidth"
        ],
        columns: [
            "columnCount",
            "columnWidth"
        ],
        flex: [
            "flexBasis",
            "flexGrow",
            "flexShrink"
        ],
        flexFlow: [
            "flexDirection",
            "flexWrap"
        ],
        font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(" "),
        fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(" "),
        gap: [
            "columnGap",
            "rowGap"
        ],
        grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(" "),
        gridArea: [
            "gridColumnEnd",
            "gridColumnStart",
            "gridRowEnd",
            "gridRowStart"
        ],
        gridColumn: [
            "gridColumnEnd",
            "gridColumnStart"
        ],
        gridColumnGap: [
            "columnGap"
        ],
        gridGap: [
            "columnGap",
            "rowGap"
        ],
        gridRow: [
            "gridRowEnd",
            "gridRowStart"
        ],
        gridRowGap: [
            "rowGap"
        ],
        gridTemplate: [
            "gridTemplateAreas",
            "gridTemplateColumns",
            "gridTemplateRows"
        ],
        listStyle: [
            "listStyleImage",
            "listStylePosition",
            "listStyleType"
        ],
        margin: [
            "marginBottom",
            "marginLeft",
            "marginRight",
            "marginTop"
        ],
        marker: [
            "markerEnd",
            "markerMid",
            "markerStart"
        ],
        mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(" "),
        maskPosition: [
            "maskPositionX",
            "maskPositionY"
        ],
        outline: [
            "outlineColor",
            "outlineStyle",
            "outlineWidth"
        ],
        overflow: [
            "overflowX",
            "overflowY"
        ],
        padding: [
            "paddingBottom",
            "paddingLeft",
            "paddingRight",
            "paddingTop"
        ],
        placeContent: [
            "alignContent",
            "justifyContent"
        ],
        placeItems: [
            "alignItems",
            "justifyItems"
        ],
        placeSelf: [
            "alignSelf",
            "justifySelf"
        ],
        textDecoration: [
            "textDecorationColor",
            "textDecorationLine",
            "textDecorationStyle"
        ],
        textEmphasis: [
            "textEmphasisColor",
            "textEmphasisStyle"
        ],
        transition: [
            "transitionDelay",
            "transitionDuration",
            "transitionProperty",
            "transitionTimingFunction"
        ],
        wordWrap: [
            "overflowWrap"
        ]
    }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = !1, warnedForInfinityValue = !1, unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), aliases = new Map([
        [
            "acceptCharset",
            "accept-charset"
        ],
        [
            "htmlFor",
            "for"
        ],
        [
            "httpEquiv",
            "http-equiv"
        ],
        [
            "crossOrigin",
            "crossorigin"
        ],
        [
            "accentHeight",
            "accent-height"
        ],
        [
            "alignmentBaseline",
            "alignment-baseline"
        ],
        [
            "arabicForm",
            "arabic-form"
        ],
        [
            "baselineShift",
            "baseline-shift"
        ],
        [
            "capHeight",
            "cap-height"
        ],
        [
            "clipPath",
            "clip-path"
        ],
        [
            "clipRule",
            "clip-rule"
        ],
        [
            "colorInterpolation",
            "color-interpolation"
        ],
        [
            "colorInterpolationFilters",
            "color-interpolation-filters"
        ],
        [
            "colorProfile",
            "color-profile"
        ],
        [
            "colorRendering",
            "color-rendering"
        ],
        [
            "dominantBaseline",
            "dominant-baseline"
        ],
        [
            "enableBackground",
            "enable-background"
        ],
        [
            "fillOpacity",
            "fill-opacity"
        ],
        [
            "fillRule",
            "fill-rule"
        ],
        [
            "floodColor",
            "flood-color"
        ],
        [
            "floodOpacity",
            "flood-opacity"
        ],
        [
            "fontFamily",
            "font-family"
        ],
        [
            "fontSize",
            "font-size"
        ],
        [
            "fontSizeAdjust",
            "font-size-adjust"
        ],
        [
            "fontStretch",
            "font-stretch"
        ],
        [
            "fontStyle",
            "font-style"
        ],
        [
            "fontVariant",
            "font-variant"
        ],
        [
            "fontWeight",
            "font-weight"
        ],
        [
            "glyphName",
            "glyph-name"
        ],
        [
            "glyphOrientationHorizontal",
            "glyph-orientation-horizontal"
        ],
        [
            "glyphOrientationVertical",
            "glyph-orientation-vertical"
        ],
        [
            "horizAdvX",
            "horiz-adv-x"
        ],
        [
            "horizOriginX",
            "horiz-origin-x"
        ],
        [
            "imageRendering",
            "image-rendering"
        ],
        [
            "letterSpacing",
            "letter-spacing"
        ],
        [
            "lightingColor",
            "lighting-color"
        ],
        [
            "markerEnd",
            "marker-end"
        ],
        [
            "markerMid",
            "marker-mid"
        ],
        [
            "markerStart",
            "marker-start"
        ],
        [
            "overlinePosition",
            "overline-position"
        ],
        [
            "overlineThickness",
            "overline-thickness"
        ],
        [
            "paintOrder",
            "paint-order"
        ],
        [
            "panose-1",
            "panose-1"
        ],
        [
            "pointerEvents",
            "pointer-events"
        ],
        [
            "renderingIntent",
            "rendering-intent"
        ],
        [
            "shapeRendering",
            "shape-rendering"
        ],
        [
            "stopColor",
            "stop-color"
        ],
        [
            "stopOpacity",
            "stop-opacity"
        ],
        [
            "strikethroughPosition",
            "strikethrough-position"
        ],
        [
            "strikethroughThickness",
            "strikethrough-thickness"
        ],
        [
            "strokeDasharray",
            "stroke-dasharray"
        ],
        [
            "strokeDashoffset",
            "stroke-dashoffset"
        ],
        [
            "strokeLinecap",
            "stroke-linecap"
        ],
        [
            "strokeLinejoin",
            "stroke-linejoin"
        ],
        [
            "strokeMiterlimit",
            "stroke-miterlimit"
        ],
        [
            "strokeOpacity",
            "stroke-opacity"
        ],
        [
            "strokeWidth",
            "stroke-width"
        ],
        [
            "textAnchor",
            "text-anchor"
        ],
        [
            "textDecoration",
            "text-decoration"
        ],
        [
            "textRendering",
            "text-rendering"
        ],
        [
            "transformOrigin",
            "transform-origin"
        ],
        [
            "underlinePosition",
            "underline-position"
        ],
        [
            "underlineThickness",
            "underline-thickness"
        ],
        [
            "unicodeBidi",
            "unicode-bidi"
        ],
        [
            "unicodeRange",
            "unicode-range"
        ],
        [
            "unitsPerEm",
            "units-per-em"
        ],
        [
            "vAlphabetic",
            "v-alphabetic"
        ],
        [
            "vHanging",
            "v-hanging"
        ],
        [
            "vIdeographic",
            "v-ideographic"
        ],
        [
            "vMathematical",
            "v-mathematical"
        ],
        [
            "vectorEffect",
            "vector-effect"
        ],
        [
            "vertAdvY",
            "vert-adv-y"
        ],
        [
            "vertOriginX",
            "vert-origin-x"
        ],
        [
            "vertOriginY",
            "vert-origin-y"
        ],
        [
            "wordSpacing",
            "word-spacing"
        ],
        [
            "writingMode",
            "writing-mode"
        ],
        [
            "xmlnsXlink",
            "xmlns:xlink"
        ],
        [
            "xHeight",
            "x-height"
        ]
    ]), possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
    }, ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
    }, warnedProperties$1 = {}, rARIA$1 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel$1 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), didWarnValueNull = !1, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = !1, passiveBrowserEventsSupported = !1;
    if (canUseDOM) try {
        var options$jscomp$0 = {};
        Object.defineProperty(options$jscomp$0, "passive", {
            get: function() {
                passiveBrowserEventsSupported = !0;
            }
        });
        window.addEventListener("test", options$jscomp$0, options$jscomp$0);
        window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
    } catch (e) {
        passiveBrowserEventsSupported = !1;
    }
    var root = null, startText = null, fallbackText = null, EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
            return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, {
        view: 0,
        detail: 0
    }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
            return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
            if ("movementX" in event) return event.movementX;
            event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
            return lastMovementX;
        },
        movementY: function(event) {
            return "movementY" in event ? event.movementY : lastMovementY;
        }
    }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, {
        dataTransfer: 0
    }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, {
        relatedTarget: 0
    }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
    }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, {
        data: 0
    }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    }, KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
            if (nativeEvent.key) {
                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                if ("Unidentified" !== key) return key;
            }
            return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
            return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
    }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
    }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
    }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
    }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [
        9,
        13,
        27,
        32
    ], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
    canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = !1, isComposing = !1, supportedInputTypes = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = !1;
    canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
    var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = !1, vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
    }, prefixedEventNames = {}, style = {};
    canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
    var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(" "), OffscreenVisible = 1, OffscreenDetached = 2, OffscreenPassiveEffectsConnected = 4, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
    Object.freeze(emptyContextObject);
    var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, NoStrictPassiveEffectsMode = 64, now = Scheduler.unstable_now, renderStartTime = -0, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = !1, nestedUpdateScheduled = !1, ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function() {},
        flushPendingUnsafeLifecycleWarnings: function() {},
        recordLegacyContextWarning: function() {},
        flushLegacyContextWarning: function() {},
        discardPendingWarnings: function() {}
    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set();
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
        didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
        var componentWillMountUniqueNames = new Set();
        0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillMountWarnings = []);
        var UNSAFE_componentWillMountUniqueNames = new Set();
        0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingUNSAFE_ComponentWillMountWarnings = []);
        var componentWillReceivePropsUniqueNames = new Set();
        0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillReceivePropsWarnings = []);
        var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
        0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
        var componentWillUpdateUniqueNames = new Set();
        0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillUpdateWarnings = []);
        var UNSAFE_componentWillUpdateUniqueNames = new Set();
        0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
        if (0 < UNSAFE_componentWillMountUniqueNames.size) {
            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
            console.error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
        }
        0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s", sortedNames));
        0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", sortedNames));
        0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn("componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
        0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
        0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn("componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
    };
    var pendingLegacyContextWarning = new Map(), didWarnAboutLegacyContext = new Set();
    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
        var strictRoot = null;
        for(var node = fiber; null !== node;)node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
        null === strictRoot ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function() {
        pendingLegacyContextWarning.forEach(function(fiberArray) {
            if (0 !== fiberArray.length) {
                var firstFiber = fiberArray[0], uniqueNames = new Set();
                fiberArray.forEach(function(fiber) {
                    uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                    didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                runWithFiberInDEV(firstFiber, function() {
                    console.error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context", sortedNames);
                });
            }
        });
    };
    ReactStrictModeWarnings.discardPendingWarnings = function() {
        pendingComponentWillMountWarnings = [];
        pendingUNSAFE_ComponentWillMountWarnings = [];
        pendingComponentWillReceivePropsWarnings = [];
        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        pendingComponentWillUpdateWarnings = [];
        pendingUNSAFE_ComponentWillUpdateWarnings = [];
        pendingLegacyContextWarning = new Map();
    };
    var CapturedStacks = new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error("Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"), SuspenseyCommitException = Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), noopSuspenseyCommitThenable = {
        then: function() {
            console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.');
        }
    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = !1, callComponent = {
        "react-stack-bottom-frame": function(Component, props, secondArg) {
            var wasRendering = isRendering;
            isRendering = !0;
            try {
                return Component(props, secondArg);
            } finally{
                isRendering = wasRendering;
            }
        }
    }, callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent), callRender = {
        "react-stack-bottom-frame": function(instance) {
            var wasRendering = isRendering;
            isRendering = !0;
            try {
                return instance.render();
            } finally{
                isRendering = wasRendering;
            }
        }
    }, callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender), callComponentDidMount = {
        "react-stack-bottom-frame": function(finishedWork, instance) {
            try {
                instance.componentDidMount();
            } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
    }, callComponentDidMountInDEV = callComponentDidMount["react-stack-bottom-frame"].bind(callComponentDidMount), callComponentDidUpdate = {
        "react-stack-bottom-frame": function(finishedWork, instance, prevProps, prevState, snapshot) {
            try {
                instance.componentDidUpdate(prevProps, prevState, snapshot);
            } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
    }, callComponentDidUpdateInDEV = callComponentDidUpdate["react-stack-bottom-frame"].bind(callComponentDidUpdate), callComponentDidCatch = {
        "react-stack-bottom-frame": function(instance, errorInfo) {
            var stack = errorInfo.stack;
            instance.componentDidCatch(errorInfo.value, {
                componentStack: null !== stack ? stack : ""
            });
        }
    }, callComponentDidCatchInDEV = callComponentDidCatch["react-stack-bottom-frame"].bind(callComponentDidCatch), callComponentWillUnmount = {
        "react-stack-bottom-frame": function(current, nearestMountedAncestor, instance) {
            try {
                instance.componentWillUnmount();
            } catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
            }
        }
    }, callComponentWillUnmountInDEV = callComponentWillUnmount["react-stack-bottom-frame"].bind(callComponentWillUnmount), callCreate = {
        "react-stack-bottom-frame": function(effect) {
            var create = effect.create;
            effect = effect.inst;
            create = create();
            return effect.destroy = create;
        }
    }, callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate), callDestroy = {
        "react-stack-bottom-frame": function(current, nearestMountedAncestor, destroy) {
            try {
                destroy();
            } catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
            }
        }
    }, callDestroyInDEV = callDestroy["react-stack-bottom-frame"].bind(callDestroy), callLazyInit = {
        "react-stack-bottom-frame": function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
        }
    }, callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit), thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;
    var didWarnAboutGenerators = didWarnAboutMaps = !1;
    var ownerHasKeyUseWarning = {};
    var ownerHasFunctionTypeWarning = {};
    var ownerHasSymbolTypeWarning = {};
    warnForMissingKey = function(returnFiber, workInProgress, child) {
        if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store) throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
            child._store.validated = 1;
            var componentName = getComponentNameFromFiber(returnFiber), componentKey = componentName || "null";
            if (!ownerHasKeyUseWarning[componentKey]) {
                ownerHasKeyUseWarning[componentKey] = !0;
                child = child._owner;
                returnFiber = returnFiber._debugOwner;
                var currentComponentErrorInfo = "";
                returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
                currentComponentErrorInfo || componentName && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName + ">.");
                var childOwnerAppendix = "";
                null != child && returnFiber !== child && (componentName = null, "number" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = " It was passed a child from " + componentName + "."));
                runWithFiberInDEV(workInProgress, function() {
                    console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);
                });
            }
        }
    };
    var reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
            aborted: !1,
            addEventListener: function(type, listener) {
                listeners.push(listener);
            }
        };
        this.abort = function() {
            signal.aborted = !0;
            listeners.forEach(function(listener) {
                return listener();
            });
        };
    }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
        _currentRenderer: null,
        _currentRenderer2: null
    }, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null), didWarnUncachedGetSnapshot;
    var didWarnAboutMismatchedHooksForComponent = new Set();
    var didWarnAboutUseWrappedInTryCatch = new Set();
    var didWarnAboutAsyncClientComponent = new Set();
    var didWarnAboutUseFormState = new Set();
    var renderLanes = 0, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1;
    var createFunctionComponentUpdateQueue = function() {
        return {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
        };
    };
    var ContextOnlyDispatcher = {
        readContext: readContext,
        use: use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError
    };
    ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
    ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
    ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
    ContextOnlyDispatcher.useFormState = throwInvalidHookError;
    ContextOnlyDispatcher.useActionState = throwInvalidHookError;
    ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
    var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    HooksDispatcherOnMountInDEV = {
        readContext: function(context) {
            return readContext(context);
        },
        use: use,
        useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
        },
        useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            mountEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountMemo(create, deps);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountReducer(reducer, initialArg, init);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
        },
        useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountState(initialState);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
        },
        useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        },
        useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
        },
        useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
        }
    };
    HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;
    HooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {
        currentHookNameInDev = "useFormState";
        mountHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {
        currentHookNameInDev = "useActionState";
        mountHookTypesDev();
        return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        mountHookTypesDev();
        return mountOptimistic(passthrough);
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
        readContext: function(context) {
            return readContext(context);
        },
        use: use,
        useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
        },
        useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountMemo(create, deps);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountReducer(reducer, initialArg, init);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
        },
        useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountState(initialState);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value, initialValue);
        },
        useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        },
        useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
        },
        useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return mountRefresh();
        }
    };
    HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;
    HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function(action, initialState) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function(action, initialState) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return mountOptimistic(passthrough);
    };
    HooksDispatcherOnUpdateInDEV = {
        readContext: function(context) {
            return readContext(context);
        },
        use: use,
        useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateReducer(reducer, initialArg, init);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateReducer(basicStateReducer);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
        },
        useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        },
        useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        },
        useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        }
    };
    HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;
    HooksDispatcherOnUpdateInDEV.useFormState = function(action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return updateActionState(action);
    };
    HooksDispatcherOnUpdateInDEV.useActionState = function(action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return updateActionState(action);
    };
    HooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
    };
    HooksDispatcherOnRerenderInDEV = {
        readContext: function(context) {
            return readContext(context);
        },
        use: use,
        useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
                return rerenderReducer(reducer, initialArg, init);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
                return rerenderReducer(basicStateReducer);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
        },
        useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        },
        useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        },
        useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        }
    };
    HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;
    HooksDispatcherOnRerenderInDEV.useFormState = function(action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return rerenderActionState(action);
    };
    HooksDispatcherOnRerenderInDEV.useActionState = function(action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return rerenderActionState(action);
    };
    HooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
        readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
        },
        use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
        },
        useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountMemo(create, deps);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountReducer(reducer, initialArg, init);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
        },
        useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountState(initialState);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
        },
        useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        },
        useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
        },
        useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
        },
        useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
        }
    };
    InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;
    InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
    };
    InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
    };
    InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountOptimistic(passthrough);
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
        readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
        },
        use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateReducer(reducer, initialArg, init);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateReducer(basicStateReducer);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
        },
        useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        },
        useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        },
        useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        },
        useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
        }
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;
    InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function(action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function(action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
        readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
        },
        use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return rerenderReducer(reducer, initialArg, init);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return rerenderReducer(basicStateReducer);
            } finally{
                ReactSharedInternals.H = prevDispatcher;
            }
        },
        useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
        },
        useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        },
        useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        },
        useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
        },
        useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
        }
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;
    InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function(action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function(action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
    };
    var fakeInternalInstance = {};
    var didWarnAboutStateAssignmentForComponent = new Set();
    var didWarnAboutUninitializedState = new Set();
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
    var didWarnAboutDirectlyAssigningPropsToState = new Set();
    var didWarnAboutUndefinedDerivedState = new Set();
    var didWarnAboutContextTypes$1 = new Set();
    var didWarnAboutChildContextTypes = new Set();
    var didWarnAboutInvalidateContextType = new Set();
    var didWarnOnInvalidCallback = new Set();
    Object.freeze(fakeInternalInstance);
    var classComponentUpdater = {
        isMounted: function(component) {
            var owner = current;
            if (null !== owner && isRendering && 1 === owner.tag) {
                var instance = owner.stateNode;
                instance._warnedAboutRefsInRender || console.error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(owner) || "A component");
                instance._warnedAboutRefsInRender = !0;
            }
            return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : !1;
        },
        enqueueSetState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            markStateUpdateScheduled(inst, lane);
        },
        enqueueReplaceState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ReplaceState;
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            markStateUpdateScheduled(inst, lane);
        },
        enqueueForceUpdate: function(inst, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ForceUpdate;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            callback = enqueueUpdate(inst, update, lane);
            null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
        }
    }, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
                error: error
            });
            if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
        }
        console.error(error);
    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."), didReceiveUpdate = !1;
    var didWarnAboutBadClass = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutContextTypes = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = !1;
    var didWarnAboutRevealOrder = {};
    var didWarnAboutTailOptions = {};
    var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    }, hasWarnedAboutUsingNoValuePropOnContextProvider = !1, valueCursor = createCursor(null);
    var rendererCursorDEV = createCursor(null);
    var rendererSigil = {};
    var currentlyRenderingFiber = null, lastContextDependency = null, isDisallowedContextReadInDEV = !1, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1;
    var didWarnUpdateInsideUpdate = !1;
    var currentlyProcessingQueue = null;
    var didReadFromEntangledAsyncAction = !1, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
    var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, shouldFireAfterActiveInstanceBlur = !1, hostParent = null, hostParentIsContainer = !1, currentHoistableRoot = null, suspenseyCommitFlag = 8192;
    var hasBadMapPolyfill = !1;
    try {
        var nonExtensibleObject = Object.preventExtensions({});
        new Map([
            [
                nonExtensibleObject,
                null
            ]
        ]);
        new Set([
            nonExtensibleObject
        ]);
    } catch (e$7) {
        hasBadMapPolyfill = !0;
    }
    var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
            return cacheForType;
        },
        getOwner: function() {
            return current;
        }
    };
    if ("function" === typeof Symbol && Symbol.for) {
        var symbolFor = Symbol.for;
        symbolFor("selector.component");
        symbolFor("selector.has_pseudo_class");
        symbolFor("selector.role");
        symbolFor("selector.test_id");
        symbolFor("selector.text");
    }
    var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootCompleted = 5, RootDidNotComplete = 6, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, pendingPassiveEffectsRemainingLanes = 0, pendingPassiveTransitions = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = !1, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = !1;
    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();
    var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, didScheduleMicrotask_act = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0, fakeActCallbackNode = {};
    (function() {
        for(var i = 0; i < simpleEventPluginEvents.length; i++){
            var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();
            eventName = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + eventName);
        }
        registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
        registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
        registerSimpleEvent(ANIMATION_START, "onAnimationStart");
        registerSimpleEvent("dblclick", "onDoubleClick");
        registerSimpleEvent("focusin", "onFocus");
        registerSimpleEvent("focusout", "onBlur");
        registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
        registerSimpleEvent(TRANSITION_START, "onTransitionStart");
        registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
        registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    })();
    registerDirectEvent("onMouseEnter", [
        "mouseout",
        "mouseover"
    ]);
    registerDirectEvent("onMouseLeave", [
        "mouseout",
        "mouseover"
    ]);
    registerDirectEvent("onPointerEnter", [
        "pointerout",
        "pointerover"
    ]);
    registerDirectEvent("onPointerLeave", [
        "pointerout",
        "pointerover"
    ]);
    registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
    ]);
    registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = !1, didWarnUncontrolledToControlled = !1, didWarnFormActionType = !1, didWarnFormActionName = !1, didWarnFormActionTarget = !1, didWarnFormActionMethod = !1, didWarnPopoverTargetObject = !1;
    var didWarnForNewBooleanPropsWithEmptyValue = {};
    var canDiffStyleForHydrationWarning = !0;
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_FALLBACK_START_DATA = "$!", FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = {
        dialog: !0,
        webview: !0
    }, currentPopstateTransitionEvent = null, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = new Map(), preconnectsSet = new Set(), previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
        f: function() {
            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
            return previousWasRendering || wasRendering;
        },
        r: function(form) {
            var formInst = getInstanceFromNode(form);
            null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
        },
        D: function(href) {
            previousDispatcher.D(href);
            preconnectAs("dns-prefetch", href, null);
        },
        C: function(href, crossOrigin) {
            previousDispatcher.C(href, crossOrigin);
            preconnectAs("preconnect", href, crossOrigin);
        },
        L: function(href, as, options) {
            previousDispatcher.L(href, as, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href && as) {
                var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
                "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
                var key = preloadSelector;
                switch(as){
                    case "style":
                        key = getStyleKey(href);
                        break;
                    case "script":
                        key = getScriptKey(href);
                }
                preloadPropsMap.has(key) || (href = assign({
                    rel: "preload",
                    href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                    as: as
                }, options), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
            }
        },
        m: function(href, options) {
            previousDispatcher.m(href, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
                var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
                switch(as){
                    case "audioworklet":
                    case "paintworklet":
                    case "serviceworker":
                    case "sharedworker":
                    case "worker":
                    case "script":
                        key = getScriptKey(href);
                }
                if (!preloadPropsMap.has(key) && (href = assign({
                    rel: "modulepreload",
                    href: href
                }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                    switch(as){
                        case "audioworklet":
                        case "paintworklet":
                        case "serviceworker":
                        case "sharedworker":
                        case "worker":
                        case "script":
                            if (ownerDocument.querySelector(getScriptSelectorFromKey(key))) return;
                    }
                    as = ownerDocument.createElement("link");
                    setInitialProperties(as, "link", href);
                    markNodeAsHoistable(as);
                    ownerDocument.head.appendChild(as);
                }
            }
        },
        X: function(src, options) {
            previousDispatcher.X(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
                var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
                resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
                    src: src,
                    async: !0
                }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                    type: "script",
                    instance: resource,
                    count: 1,
                    state: null
                }, scripts.set(key, resource));
            }
        },
        S: function(href, precedence, options) {
            previousDispatcher.S(href, precedence, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
                var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
                precedence = precedence || "default";
                var resource = styles.get(key);
                if (!resource) {
                    var state = {
                        loading: NotLoaded,
                        preload: null
                    };
                    if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) state.loading = Loaded | Inserted;
                    else {
                        href = assign({
                            rel: "stylesheet",
                            href: href,
                            "data-precedence": precedence
                        }, options);
                        (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                        var link = resource = ownerDocument.createElement("link");
                        markNodeAsHoistable(link);
                        setInitialProperties(link, "link", href);
                        link._p = new Promise(function(resolve, reject) {
                            link.onload = resolve;
                            link.onerror = reject;
                        });
                        link.addEventListener("load", function() {
                            state.loading |= Loaded;
                        });
                        link.addEventListener("error", function() {
                            state.loading |= Errored;
                        });
                        state.loading |= Inserted;
                        insertStylesheet(resource, precedence, ownerDocument);
                    }
                    resource = {
                        type: "stylesheet",
                        instance: resource,
                        count: 1,
                        state: state
                    };
                    styles.set(key, resource);
                }
            }
        },
        M: function(src, options) {
            previousDispatcher.M(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
                var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
                resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
                    src: src,
                    async: !0,
                    type: "module"
                }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                    type: "script",
                    instance: resource,
                    count: 1,
                    state: null
                }, scripts.set(key, resource));
            }
        }
    };
    var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, suspendedState = null, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: NotPendingTransition,
        _currentValue2: NotPendingTransition,
        _threadCount: 0
    }, badgeFormat = "%c%s%c ", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind = Function.prototype.bind;
    var didWarnAboutNestedUpdates = !1;
    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;
    overrideHookState = function(fiber, id, path, value) {
        id = findHook(fiber, id);
        null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateDeletePath = function(fiber, id, path) {
        id = findHook(fiber, id);
        null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
        id = findHook(fiber, id);
        null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
    };
    overrideProps = function(fiber, path, value) {
        fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        path = enqueueConcurrentRenderForLane(fiber, 2);
        null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsDeletePath = function(fiber, path) {
        fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        path = enqueueConcurrentRenderForLane(fiber, 2);
        null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsRenamePath = function(fiber, oldPath, newPath) {
        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        oldPath = enqueueConcurrentRenderForLane(fiber, 2);
        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
    };
    scheduleUpdate = function(fiber) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    };
    setErrorHandler = function(newShouldErrorImpl) {
        shouldErrorImpl = newShouldErrorImpl;
    };
    setSuspenseHandler = function(newShouldSuspendImpl) {
        shouldSuspendImpl = newShouldSuspendImpl;
    };
    var _enabled = !0, return_targetInst = null, hasScheduledReplayAttempt = !1, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = new Map(), queuedPointerCaptures = new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "), lastScheduledReplayQueue = null;
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children, JSCompiler_OptimizeArgumentsArray_p2) {
        var root = this._internalRoot;
        if (null === root) throw Error("Cannot update an unmounted root.");
        "function" === typeof JSCompiler_OptimizeArgumentsArray_p2 ? console.error("does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : isValidContainer(JSCompiler_OptimizeArgumentsArray_p2) ? console.error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : "undefined" !== typeof JSCompiler_OptimizeArgumentsArray_p2 && console.error("You passed a second argument to root.render(...) but it only accepts one argument.");
        JSCompiler_OptimizeArgumentsArray_p2 = root.current;
        var lane = requestUpdateLane(JSCompiler_OptimizeArgumentsArray_p2);
        updateContainerImpl(JSCompiler_OptimizeArgumentsArray_p2, lane, children, root, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function(JSCompiler_OptimizeArgumentsArray_p3) {
        "function" === typeof JSCompiler_OptimizeArgumentsArray_p3 && console.error("does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
        JSCompiler_OptimizeArgumentsArray_p3 = this._internalRoot;
        if (null !== JSCompiler_OptimizeArgumentsArray_p3) {
            this._internalRoot = null;
            var container = JSCompiler_OptimizeArgumentsArray_p3.containerInfo;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
            updateContainerSync(null, JSCompiler_OptimizeArgumentsArray_p3, null, null);
            flushSyncWork$1();
            container[internalContainerInstanceKey] = null;
        }
    };
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
            var updatePriority = resolveUpdatePriority();
            target = {
                blockedOn: null,
                target: target,
                priority: updatePriority
            };
            for(var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++);
            queuedExplicitHydrationTargets.splice(i, 0, target);
            0 === i && attemptExplicitHydrationTarget(target);
        }
    };
    (function() {
        var isomorphicReactPackageVersion = React.version;
        if ("19.0.0" !== isomorphicReactPackageVersion) throw Error('Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.0.0\nLearn more: https://react.dev/warnings/version-mismatch"));
    })();
    "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills");
    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
            if ("function" === typeof componentOrElement.render) throw Error("Unable to find node on an unmounted component.");
            componentOrElement = Object.keys(componentOrElement).join(",");
            throw Error("Argument appears to not be a ReactComponent. Keys: " + componentOrElement);
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
    };
    if (!function() {
        var internals = {
            bundleType: 1,
            version: "19.0.0",
            rendererPackageName: "react-dom",
            currentDispatcherRef: ReactSharedInternals,
            findFiberByHostInstance: getClosestInstanceFromNode,
            reconcilerVersion: "19.0.0"
        };
        internals.overrideHookState = overrideHookState;
        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
        internals.overrideProps = overrideProps;
        internals.overridePropsDeletePath = overridePropsDeletePath;
        internals.overridePropsRenamePath = overridePropsRenamePath;
        internals.scheduleUpdate = scheduleUpdate;
        internals.setErrorHandler = setErrorHandler;
        internals.setSuspenseHandler = setSuspenseHandler;
        internals.scheduleRefresh = scheduleRefresh;
        internals.scheduleRoot = scheduleRoot;
        internals.setRefreshHandler = setRefreshHandler;
        internals.getCurrentFiber = getCurrentFiberForDevTools;
        internals.getLaneLabelMap = getLaneLabelMap;
        internals.injectProfilingHooks = injectProfilingHooks;
        return injectInternals(internals);
    }() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
        var protocol = window.location.protocol;
        /^(https?|file):$/.test(protocol) && console.info("%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""), "font-weight:bold");
    }
    exports.createRoot = function(container, options) {
        if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
        warnIfReactDOMContainerInDEV(container);
        var isStrictMode = !1, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
        null !== options && void 0 !== options && (options.hydrate ? console.warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"), !0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
        options = createFiberRoot(container, 1, !1, null, null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);
        container[internalContainerInstanceKey] = options.current;
        listenToAllSupportedEvents(8 === container.nodeType ? container.parentNode : container);
        return new ReactDOMRoot(options);
    };
    exports.hydrateRoot = function(container, initialChildren, options) {
        if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
        warnIfReactDOMContainerInDEV(container);
        void 0 === initialChildren && console.error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
        var isStrictMode = !1, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
        null !== options && void 0 !== options && (!0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
        initialChildren = createFiberRoot(container, 1, !0, initialChildren, null != options ? options : null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);
        initialChildren.context = getContextForSubtree(null);
        options = initialChildren.current;
        isStrictMode = requestUpdateLane(options);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options, identifierPrefix, isStrictMode);
        initialChildren.current.lanes = isStrictMode;
        markRootUpdated$1(initialChildren, isStrictMode);
        ensureRootIsScheduled(initialChildren);
        container[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMHydrationRoot(initialChildren);
    };
    exports.version = "19.0.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
})();

},{"4a48913baa1a8f0":"d5jf4","c31f9b99c1e288cf":"juvHo","c4c4bc2113e5c77f":"21dqq","772d609564cfd8f6":"j6uA9"}],"juvHo":[function(require,module,exports) {
"use strict";
module.exports = require("ef03b89c8fe2794e");

},{"ef03b89c8fe2794e":"RqdIf"}],"RqdIf":[function(require,module,exports) {
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
(function() {
    function performWorkUntilDeadline() {
        if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = !0;
            try {
                a: {
                    isHostCallbackScheduled = !1;
                    isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                    isPerformingWork = !0;
                    var previousPriorityLevel = currentPriorityLevel;
                    try {
                        b: {
                            advanceTimers(currentTime);
                            for(currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());){
                                var callback = currentTask.callback;
                                if ("function" === typeof callback) {
                                    currentTask.callback = null;
                                    currentPriorityLevel = currentTask.priorityLevel;
                                    var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                                    currentTime = exports.unstable_now();
                                    if ("function" === typeof continuationCallback) {
                                        currentTask.callback = continuationCallback;
                                        advanceTimers(currentTime);
                                        hasMoreWork = !0;
                                        break b;
                                    }
                                    currentTask === peek(taskQueue) && pop(taskQueue);
                                    advanceTimers(currentTime);
                                } else pop(taskQueue);
                                currentTask = peek(taskQueue);
                            }
                            if (null !== currentTask) hasMoreWork = !0;
                            else {
                                var firstTimer = peek(timerQueue);
                                null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                                hasMoreWork = !1;
                            }
                        }
                        break a;
                    } finally{
                        currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
                    }
                    hasMoreWork = void 0;
                }
            } finally{
                hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1;
            }
        }
    }
    function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for(; 0 < index;){
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
        }
    }
    function peek(heap) {
        return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
            heap[0] = last;
            a: for(var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;){
                var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
                if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
                else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;
                else break a;
            }
        }
        return first;
    }
    function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
        for(var timer = peek(timerQueue); null !== timer;){
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
        }
    }
    function handleTimeout(currentTime) {
        isHostTimeoutScheduled = !1;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled) {
            if (null !== peek(taskQueue)) isHostCallbackScheduled = !0, requestHostCallback();
            else {
                var firstTimer = peek(timerQueue);
                null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
        }
    }
    function shouldYieldToHost() {
        return exports.unstable_now() - startTime < frameInterval ? !1 : !0;
    }
    function requestHostCallback() {
        isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
    }
    function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
        }, ms);
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports.unstable_now = function() {
            return localPerformance.now();
        };
    } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
            return localDate.now() - initialTime;
        };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = !1, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    if ("function" === typeof localSetImmediate) var schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
    };
    else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
        };
    } else schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
    };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
        task.callback = null;
    };
    exports.unstable_continueExecution = function() {
        isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback());
    };
    exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
    };
    exports.unstable_getFirstCallbackNode = function() {
        return peek(taskQueue);
    };
    exports.unstable_next = function(eventHandler) {
        switch(currentPriorityLevel){
            case 1:
            case 2:
            case 3:
                var priorityLevel = 3;
                break;
            default:
                priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    };
    exports.unstable_pauseExecution = function() {};
    exports.unstable_requestPaint = function() {};
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch(priorityLevel){
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch(priorityLevel){
            case 1:
                var timeout = -1;
                break;
            case 2:
                timeout = 250;
                break;
            case 5:
                timeout = 1073741823;
                break;
            case 4:
                timeout = 1e4;
                break;
            default:
                timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
            id: taskIdCounter++,
            callback: callback,
            priorityLevel: priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback()));
        return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
                return callback.apply(this, arguments);
            } finally{
                currentPriorityLevel = previousPriorityLevel;
            }
        };
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
})();

},{}],"j6uA9":[function(require,module,exports) {
"use strict";
function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") return;
    var err;
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error("^_^");
}
module.exports = require("b0f0e6b9e8349dac");

},{"b0f0e6b9e8349dac":"3iA9v"}],"3iA9v":[function(require,module,exports) {
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
(function() {
    function noop() {}
    function testStringCoercion(value) {
        return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        try {
            testStringCoercion(key);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        JSCompiler_inline_result && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"), testStringCoercion(key));
        return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : "" + key,
            children: children,
            containerInfo: containerInfo,
            implementation: implementation
        };
    }
    function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input) return "use-credentials" === input ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
        return dispatcher;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = require("6f0162e9ab224cd4"), Internals = {
        d: {
            f: noop,
            r: function() {
                throw Error("Invalid form element. requestFormReset must be passed a form that was rendered by React.");
            },
            D: noop,
            C: noop,
            L: noop,
            m: noop,
            X: noop,
            S: noop,
            M: noop
        },
        p: 0,
        findDOMNode: null
    }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports.createPortal = function(children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType) throw Error("Target container is not a DOM element.");
        return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
            if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
        } finally{
            ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
        }
    };
    exports.preconnect = function(href, options) {
        "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error("ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.", getValueDescriptorExpectingEnumForWarning(options)) : null != options && "string" !== typeof options.crossOrigin && console.error("ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.", getValueDescriptorExpectingObjectForWarning(options.crossOrigin)) : console.error("ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    exports.prefetchDNS = function(href) {
        if ("string" !== typeof href || !href) console.error("ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
        else if (1 < arguments.length) {
            var options = arguments[1];
            "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options)) : console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options));
        }
        "string" === typeof href && Internals.d.D(href);
    };
    exports.preinit = function(href, options) {
        "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error("ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.", getValueDescriptorExpectingEnumForWarning(options)) : "style" !== options.as && "script" !== options.as && console.error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".', getValueDescriptorExpectingEnumForWarning(options.as)) : console.error("ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
        if ("string" === typeof href && options && "string" === typeof options.as) {
            var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
            "style" === as ? Internals.d.S(href, "string" === typeof options.precedence ? options.precedence : void 0, {
                crossOrigin: crossOrigin,
                integrity: integrity,
                fetchPriority: fetchPriority
            }) : "script" === as && Internals.d.X(href, {
                crossOrigin: crossOrigin,
                integrity: integrity,
                fetchPriority: fetchPriority,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
        }
    };
    exports.preinitModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
        if (encountered) console.error("ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s", encountered);
        else switch(encountered = options && "string" === typeof options.as ? options.as : "script", encountered){
            case "script":
                break;
            default:
                encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error('ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)', encountered, href);
        }
        if ("string" === typeof href) {
            if ("object" === typeof options && null !== options) {
                if (null == options.as || "script" === options.as) encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.M(href, {
                    crossOrigin: encountered,
                    integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                    nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
            } else null == options && Internals.d.M(href);
        }
    };
    exports.preload = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s', encountered);
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
            encountered = options.as;
            var crossOrigin = getCrossOriginStringAs(encountered, options.crossOrigin);
            Internals.d.L(href, encountered, {
                crossOrigin: crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0,
                type: "string" === typeof options.type ? options.type : void 0,
                fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
                referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
                imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
                imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
                media: "string" === typeof options.media ? options.media : void 0
            });
        }
    };
    exports.preloadModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error('ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s', encountered);
        "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin: encountered,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
        })) : Internals.d.m(href));
    };
    exports.requestFormReset = function(form) {
        Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
    };
    exports.useFormState = function(action, initialState, permalink) {
        return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function() {
        return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.0.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
})();

},{"6f0162e9ab224cd4":"21dqq"}],"2Pgyy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _appDefault.default));
var _app = require("./App");
parcelHelpers.exportAll(_app, exports);
var _appDefault = parcelHelpers.interopDefault(_app);

},{"./App":"gL2as","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gL2as":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$06f8 = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$06f8.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _game = require("../Game");
var _gameDefault = parcelHelpers.interopDefault(_game);
var _header = require("../Header");
var _headerDefault = parcelHelpers.interopDefault(_header);
function App() {
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("div", {
        className: "wrapper",
        children: [
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _headerDefault.default), {}, void 0, false, {
                fileName: "src/components/App/App.js",
                lineNumber: 7,
                columnNumber: 7
            }, this),
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("div", {
                className: "game-wrapper",
                children: /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _gameDefault.default), {}, void 0, false, {
                    fileName: "src/components/App/App.js",
                    lineNumber: 10,
                    columnNumber: 9
                }, this)
            }, void 0, false, {
                fileName: "src/components/App/App.js",
                lineNumber: 9,
                columnNumber: 7
            }, this)
        ]
    }, void 0, true, {
        fileName: "src/components/App/App.js",
        lineNumber: 6,
        columnNumber: 5
    }, this);
}
_c = App;
exports.default = App;
var _c;
$RefreshReg$(_c, "App");

  $parcel$ReactRefreshHelpers$06f8.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","../Game":"ipYvB","../Header":"cxSZo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru"}],"ipYvB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _gameDefault.default));
var _game = require("./Game");
parcelHelpers.exportAll(_game, exports);
var _gameDefault = parcelHelpers.interopDefault(_game);

},{"./Game":"aChvf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aChvf":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$161d = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$161d.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _utils = require("../../utils");
var _data = require("../../data");
var _constants = require("../../constants");
var _gameHelpers = require("../../game-helpers");
var _guessInput = require("../GuessInput");
var _guessInputDefault = parcelHelpers.interopDefault(_guessInput);
var _guessResults = require("../GuessResults");
var _guessResultsDefault = parcelHelpers.interopDefault(_guessResults);
// import GameOverBanner from '../GameOverBanner/GameOverBanner';
var _wonBanner = require("../WonBanner");
var _wonBannerDefault = parcelHelpers.interopDefault(_wonBanner);
var _lostBanner = require("../LostBanner");
var _lostBannerDefault = parcelHelpers.interopDefault(_lostBanner);
var _keyboard = require("../Keyboard");
var _keyboardDefault = parcelHelpers.interopDefault(_keyboard);
var _prettier = require("prettier");
var _s = $RefreshSig$();
// Pick a random word on every pageload.
// const answer = sample(WORDS);
// To make debugging easier, we'll log the solution in the console.
// console.log({ answer });
function Game() {
    _s();
    const [answer, setAnswer] = (0, _reactDefault.default).useState(()=>(0, _utils.sample)((0, _data.WORDS)));
    console.log({
        answer
    });
    // running, won, lost
    const [gameStatus, setGameStatus] = (0, _reactDefault.default).useState("running");
    const [guesses, setGuesses] = (0, _reactDefault.default).useState([]);
    function handleSubmitGuess(tentativeGuess) {
        // setGuesses([...guesses, tentativeGuess]);
        // console.log('Received guess ', tentativeGuess);
        const nextGuesses = [
            ...guesses,
            tentativeGuess
        ];
        setGuesses(nextGuesses);
        if (tentativeGuess.toUpperCase() === answer) setGameStatus("won");
        else if (nextGuesses.length >= (0, _constants.NUM_OF_GUESSES_ALLOWED)) setGameStatus("lost");
    }
    function handleRestart() {
        const newAnswer = (0, _utils.sample)((0, _data.WORDS));
        setAnswer(newAnswer);
        setGuesses([]);
        setGameStatus("running");
    }
    const validatedGuesses = guesses.map((guess)=>(0, _gameHelpers.checkGuess)(guess, answer));
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _jsxDevRuntime.Fragment), {
        children: [
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _guessResultsDefault.default), {
                validatedGuesses: validatedGuesses
            }, void 0, false, {
                fileName: "src/components/Game/Game.js",
                lineNumber: 63,
                columnNumber: 7
            }, this),
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _guessInputDefault.default), {
                gameStatus: gameStatus,
                handleSubmitGuess: handleSubmitGuess
            }, void 0, false, {
                fileName: "src/components/Game/Game.js",
                lineNumber: 64,
                columnNumber: 7
            }, this),
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _keyboardDefault.default), {
                validatedGuesses: validatedGuesses
            }, void 0, false, {
                fileName: "src/components/Game/Game.js",
                lineNumber: 66,
                columnNumber: 7
            }, this),
            gameStatus === "won" && // <WonBanner numOfGuesses={guesses.length} />
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _wonBannerDefault.default), {
                numOfGuesses: guesses.length,
                handleRestart: handleRestart
            }, void 0, false, {
                fileName: "src/components/Game/Game.js",
                lineNumber: 70,
                columnNumber: 9
            }, this),
            gameStatus === "lost" && // <LostBanner answer={answer} />
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _lostBannerDefault.default), {
                answer: answer,
                handleRestart: handleRestart
            }, void 0, false, {
                fileName: "src/components/Game/Game.js",
                lineNumber: 78,
                columnNumber: 9
            }, this)
        ]
    }, void 0, true);
}
_s(Game, "OlIOIBpeH/3vH6DN65mMm2UMgHI=");
_c = Game;
exports.default = Game;
var _c;
$RefreshReg$(_c, "Game");

  $parcel$ReactRefreshHelpers$161d.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","../../utils":"en4he","../../data":"9kapS","../../constants":"3huJa","../GuessInput":"7KsIF","../GuessResults":"kxxIc","../WonBanner":"isERa","../LostBanner":"5Kimf","../Keyboard":"3XTQP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru","../../game-helpers":"dWwK5","prettier":"7nQkb"}],"en4he":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sample", ()=>sample);
parcelHelpers.export(exports, "range", ()=>range);
const sample = (arr)=>{
    return arr[Math.floor(Math.random() * arr.length)];
};
const range = (start, end, step = 1)=>{
    let output = [];
    if (typeof end === "undefined") {
        end = start;
        start = 0;
    }
    for(let i = start; i < end; i += step)output.push(i);
    return output;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"9kapS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WORDS", ()=>WORDS);
const WORDS = [
    "AGENT",
    "WORLD",
    "ABOUT",
    "HEART",
    "WATER",
    "SIXTY",
    "BOARD",
    "MONTH",
    "MUSIC",
    "PARTY",
    "PIANO",
    "MOUTH",
    "WOMAN",
    "SUGAR",
    "AMBER",
    "DREAM",
    "LAUGH",
    "TIGER",
    "EARTH",
    "MONEY",
    "WORDS",
    "SMILE",
    "LEMON",
    "SOUTH",
    "AFTER",
    "STONE",
    "THING",
    "LIGHT",
    "STORY",
    "POWER",
    "TODAY",
    "RANGE",
    "PEARL",
    "VENOM",
    "PROXY",
    "ROUND",
    "HOVER",
    "CANDY",
    "ABOVE",
    "PHONE",
    "OTHER",
    "SMART",
    "BLACK",
    "MAGIC",
    "FRUIT",
    "RADIO",
    "ROYAL",
    "HONEY",
    "FLAKE",
    "SOUND"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3huJa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NUM_OF_GUESSES_ALLOWED", ()=>NUM_OF_GUESSES_ALLOWED);
const NUM_OF_GUESSES_ALLOWED = 6;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7KsIF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _guessInputDefault.default));
var _guessInput = require("./GuessInput");
parcelHelpers.exportAll(_guessInput, exports);
var _guessInputDefault = parcelHelpers.interopDefault(_guessInput);

},{"./GuessInput":"bL9cA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bL9cA":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$b46b = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$b46b.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _s = $RefreshSig$();
function GuestInput({ gameStatus, handleSubmitGuess }) {
    _s();
    const [tentativeGuess, setTentativeGuess] = (0, _reactDefault.default).useState("");
    function handleSubmit(event) {
        event.preventDefault();
        if (tentativeGuess.length !== 5) {
            alert("Please enter excatly 5 characters \uD83D\uDC96");
            return;
        }
        // console.log({ tentativeGuess });
        handleSubmitGuess(tentativeGuess);
        setTentativeGuess("");
    }
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("form", {
        onSubmit: handleSubmit,
        className: "guess-input-wrapper",
        children: [
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("label", {
                htmlFor: "guess-input",
                children: "Enter guess:"
            }, void 0, false, {
                fileName: "src/components/GuessInput/GuessInput.js",
                lineNumber: 22,
                columnNumber: 7
            }, this),
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("input", {
                required: true,
                disabled: gameStatus !== "running",
                minLength: 5,
                maxLength: 5,
                value: tentativeGuess,
                onChange: (event)=>{
                    const nextGuess = event.target.value.toUpperCase();
                    setTentativeGuess(nextGuess);
                },
                id: "guess-input",
                type: "text"
            }, void 0, false, {
                fileName: "src/components/GuessInput/GuessInput.js",
                lineNumber: 23,
                columnNumber: 7
            }, this)
        ]
    }, void 0, true, {
        fileName: "src/components/GuessInput/GuessInput.js",
        lineNumber: 21,
        columnNumber: 5
    }, this);
}
_s(GuestInput, "Nmxxg7kOIoxtnp63oWkjltQbDS8=");
_c = GuestInput;
exports.default = GuestInput;
var _c;
$RefreshReg$(_c, "GuestInput");

  $parcel$ReactRefreshHelpers$b46b.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru"}],"km3Ru":[function(require,module,exports) {
"use strict";
var Refresh = require("7422ead32dcc1e6b");
function debounce(func, delay) {
    {
        let timeout = undefined;
        let lastTime = 0;
        return function(args) {
            // Call immediately if last call was more than the delay ago.
            // Otherwise, set a timeout. This means the first call is fast
            // (for the common case of a single update), and subsequent updates
            // are batched.
            let now = Date.now();
            if (now - lastTime > delay) {
                lastTime = now;
                func.call(null, args);
            } else {
                clearTimeout(timeout);
                timeout = setTimeout(function() {
                    timeout = undefined;
                    lastTime = Date.now();
                    func.call(null, args);
                }, delay);
            }
        };
    }
}
var enqueueUpdate = debounce(function() {
    Refresh.performReactRefresh();
}, 30);
// Everthing below is either adapted or copied from
// https://github.com/facebook/metro/blob/61de16bd1edd7e738dd0311c89555a644023ab2d/packages/metro/src/lib/polyfills/require.js
// MIT License - Copyright (c) Facebook, Inc. and its affiliates.
module.exports.prelude = function(module1) {
    window.$RefreshReg$ = function(type, id) {
        Refresh.register(type, module1.id + " " + id);
    };
    window.$RefreshSig$ = Refresh.createSignatureFunctionForTransform;
};
module.exports.postlude = function(module1) {
    if (isReactRefreshBoundary(module1.exports)) {
        registerExportsForReactRefresh(module1);
        if (module1.hot) {
            module1.hot.dispose(function(data) {
                if (Refresh.hasUnrecoverableErrors()) window.location.reload();
                data.prevExports = module1.exports;
            });
            module1.hot.accept(function(getParents) {
                var prevExports = module1.hot.data.prevExports;
                var nextExports = module1.exports;
                // Since we just executed the code for it, it's possible
                // that the new exports make it ineligible for being a boundary.
                var isNoLongerABoundary = !isReactRefreshBoundary(nextExports);
                // It can also become ineligible if its exports are incompatible
                // with the previous exports.
                // For example, if you add/remove/change exports, we'll want
                // to re-execute the importing modules, and force those components
                // to re-render. Similarly, if you convert a class component
                // to a function, we want to invalidate the boundary.
                var didInvalidate = shouldInvalidateReactRefreshBoundary(prevExports, nextExports);
                if (isNoLongerABoundary || didInvalidate) {
                    // We'll be conservative. The only case in which we won't do a full
                    // reload is if all parent modules are also refresh boundaries.
                    // In that case we'll add them to the current queue.
                    var parents = getParents();
                    if (parents.length === 0) {
                        // Looks like we bubbled to the root. Can't recover from that.
                        window.location.reload();
                        return;
                    }
                    return parents;
                }
                enqueueUpdate();
            });
        }
    }
};
function isReactRefreshBoundary(exports) {
    if (Refresh.isLikelyComponentType(exports)) return true;
    if (exports == null || typeof exports !== "object") // Exit if we can't iterate over exports.
    return false;
    var hasExports = false;
    var areAllExportsComponents = true;
    let isESM = "__esModule" in exports;
    for(var key in exports){
        hasExports = true;
        if (key === "__esModule") continue;
        var desc = Object.getOwnPropertyDescriptor(exports, key);
        if (desc && desc.get && !isESM) // Don't invoke getters for CJS as they may have side effects.
        return false;
        var exportValue = exports[key];
        if (!Refresh.isLikelyComponentType(exportValue)) areAllExportsComponents = false;
    }
    return hasExports && areAllExportsComponents;
}
function shouldInvalidateReactRefreshBoundary(prevExports, nextExports) {
    var prevSignature = getRefreshBoundarySignature(prevExports);
    var nextSignature = getRefreshBoundarySignature(nextExports);
    if (prevSignature.length !== nextSignature.length) return true;
    for(var i = 0; i < nextSignature.length; i++){
        if (prevSignature[i] !== nextSignature[i]) return true;
    }
    return false;
}
// When this signature changes, it's unsafe to stop at this refresh boundary.
function getRefreshBoundarySignature(exports) {
    var signature = [];
    signature.push(Refresh.getFamilyByType(exports));
    if (exports == null || typeof exports !== "object") // Exit if we can't iterate over exports.
    // (This is important for legacy environments.)
    return signature;
    let isESM = "__esModule" in exports;
    for(var key in exports){
        if (key === "__esModule") continue;
        var desc = Object.getOwnPropertyDescriptor(exports, key);
        if (desc && desc.get && !isESM) continue;
        var exportValue = exports[key];
        signature.push(key);
        signature.push(Refresh.getFamilyByType(exportValue));
    }
    return signature;
}
function registerExportsForReactRefresh(module1) {
    var exports = module1.exports, id = module1.id;
    Refresh.register(exports, id + " %exports%");
    if (exports == null || typeof exports !== "object") // Exit if we can't iterate over exports.
    // (This is important for legacy environments.)
    return;
    let isESM = "__esModule" in exports;
    for(var key in exports){
        var desc = Object.getOwnPropertyDescriptor(exports, key);
        if (desc && desc.get && !isESM) continue;
        var exportValue = exports[key];
        var typeID = id + " %exports% " + key;
        Refresh.register(exportValue, typeID);
    }
}

},{"7422ead32dcc1e6b":"786KC"}],"kxxIc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _guessResultsDefault.default));
var _guessResults = require("./GuessResults");
parcelHelpers.exportAll(_guessResults, exports);
var _guessResultsDefault = parcelHelpers.interopDefault(_guessResults);

},{"./GuessResults":"12vl0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"12vl0":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$e9e2 = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$e9e2.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _constants = require("../../constants");
var _utils = require("../../utils");
var _guess = require("../Guess");
var _guessDefault = parcelHelpers.interopDefault(_guess);
function GuessResults({ validatedGuesses }) {
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("div", {
        className: "guess-results",
        children: (0, _utils.range)((0, _constants.NUM_OF_GUESSES_ALLOWED)).map((num)=>// <Guess key={num} value={guesses[num]} answer={answer} />
            /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _guessDefault.default), {
                value: validatedGuesses[num]
            }, num, false, {
                fileName: "src/components/GuessResults/GuessResults.js",
                lineNumber: 13,
                columnNumber: 9
            }, this))
    }, void 0, false, {
        fileName: "src/components/GuessResults/GuessResults.js",
        lineNumber: 10,
        columnNumber: 5
    }, this);
}
_c = GuessResults;
exports.default = GuessResults;
var _c;
$RefreshReg$(_c, "GuessResults");

  $parcel$ReactRefreshHelpers$e9e2.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","../../constants":"3huJa","../../utils":"en4he","../Guess":"lokSL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru"}],"lokSL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _guessDefault.default));
var _guess = require("./Guess");
parcelHelpers.exportAll(_guess, exports);
var _guessDefault = parcelHelpers.interopDefault(_guess);

},{"./Guess":"u6UxK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"u6UxK":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$424d = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$424d.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _utils = require("../../utils");
// import { checkGuess } from '../../game-helpers';
function Cell({ letter, status }) {
    const className = status ? `cell ${status}` : "cell";
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("span", {
        className: className,
        children: letter
    }, void 0, false, {
        fileName: "src/components/Guess/Guess.js",
        lineNumber: 9,
        columnNumber: 5
    }, this);
}
_c = Cell;
// function Guess({ value, answer }) {
//   const result = checkGuess(value, answer);
// console.log({ result });
function Guess({ value }) {
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("p", {
        className: "guess",
        children: (0, _utils.range)(5).map((num)=>/*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)(Cell, {
                // letter={result ? result[num].letter : undefined}
                // status={result ? result[num].status : undefined}
                letter: value ? value[num].letter : undefined,
                status: value ? value[num].status : undefined
            }, num, false, {
                fileName: "src/components/Guess/Guess.js",
                lineNumber: 23,
                columnNumber: 9
            }, this))
    }, void 0, false, {
        fileName: "src/components/Guess/Guess.js",
        lineNumber: 21,
        columnNumber: 5
    }, this);
}
_c1 = Guess;
exports.default = Guess;
var _c, _c1;
$RefreshReg$(_c, "Cell");
$RefreshReg$(_c1, "Guess");

  $parcel$ReactRefreshHelpers$424d.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","../../utils":"en4he","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru"}],"isERa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _wonBannerDefault.default));
var _wonBanner = require("./WonBanner");
parcelHelpers.exportAll(_wonBanner, exports);
var _wonBannerDefault = parcelHelpers.interopDefault(_wonBanner);

},{"./WonBanner":"lPfvi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lPfvi":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$1b8c = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$1b8c.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _banner = require("../Banner");
var _bannerDefault = parcelHelpers.interopDefault(_banner);
function WonBanner({ numOfGuesses, handleRestart }) {
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _bannerDefault.default), {
        status: "happy",
        action: handleRestart,
        actionText: "Restart game",
        children: /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("p", {
            children: [
                /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("strong", {
                    children: "Congratulations!"
                }, void 0, false, {
                    fileName: "src/components/WonBanner/WonBanner.js",
                    lineNumber: 13,
                    columnNumber: 9
                }, this),
                " Got it in",
                " ",
                /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("strong", {
                    children: numOfGuesses === 1 ? "1 guess" : `${numOfGuesses} guesses`
                }, void 0, false, {
                    fileName: "src/components/WonBanner/WonBanner.js",
                    lineNumber: 15,
                    columnNumber: 9
                }, this),
                "."
            ]
        }, void 0, true, {
            fileName: "src/components/WonBanner/WonBanner.js",
            lineNumber: 12,
            columnNumber: 7
        }, this)
    }, void 0, false, {
        fileName: "src/components/WonBanner/WonBanner.js",
        lineNumber: 7,
        columnNumber: 5
    }, this);
}
_c = WonBanner;
exports.default = WonBanner;
var _c;
$RefreshReg$(_c, "WonBanner");

  $parcel$ReactRefreshHelpers$1b8c.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","../Banner":"hcH4r","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru"}],"hcH4r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _bannerDefault.default));
var _banner = require("./Banner");
parcelHelpers.exportAll(_banner, exports);
var _bannerDefault = parcelHelpers.interopDefault(_banner);

},{"./Banner":"dRLMg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dRLMg":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$9f4a = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$9f4a.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
function Banner({ status, action, actionText, children }) {
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("div", {
        className: `${status} banner`,
        children: [
            children,
            action && /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("button", {
                className: "banner-button",
                onClick: action,
                children: actionText
            }, void 0, false, {
                fileName: "src/components/Banner/Banner.js",
                lineNumber: 10,
                columnNumber: 18
            }, this)
        ]
    }, void 0, true, {
        fileName: "src/components/Banner/Banner.js",
        lineNumber: 5,
        columnNumber: 5
    }, this);
}
_c = Banner;
exports.default = Banner;
var _c;
$RefreshReg$(_c, "Banner");

  $parcel$ReactRefreshHelpers$9f4a.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru"}],"5Kimf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _lostBannerDefault.default));
var _lostBanner = require("./LostBanner");
parcelHelpers.exportAll(_lostBanner, exports);
var _lostBannerDefault = parcelHelpers.interopDefault(_lostBanner);

},{"./LostBanner":"hljrH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hljrH":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$5049 = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$5049.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _banner = require("../Banner");
var _bannerDefault = parcelHelpers.interopDefault(_banner);
function LostBanner({ answer, handleRestart }) {
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)((0, _bannerDefault.default), {
        status: "sad",
        action: handleRestart,
        actionText: "Try again!",
        children: /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("div", {
            className: "sad banner",
            children: /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("p", {
                children: [
                    "Sorry, the correct answer is ",
                    /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("strong", {
                        children: answer
                    }, void 0, false, {
                        fileName: "src/components/LostBanner/LostBanner.js",
                        lineNumber: 13,
                        columnNumber: 41
                    }, this),
                    "."
                ]
            }, void 0, true, {
                fileName: "src/components/LostBanner/LostBanner.js",
                lineNumber: 13,
                columnNumber: 9
            }, this)
        }, void 0, false, {
            fileName: "src/components/LostBanner/LostBanner.js",
            lineNumber: 12,
            columnNumber: 7
        }, this)
    }, void 0, false, {
        fileName: "src/components/LostBanner/LostBanner.js",
        lineNumber: 7,
        columnNumber: 5
    }, this);
}
_c = LostBanner;
exports.default = LostBanner;
var _c;
$RefreshReg$(_c, "LostBanner");

  $parcel$ReactRefreshHelpers$5049.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","../Banner":"hcH4r","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru"}],"3XTQP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _keyboardDefault.default));
var _keyboard = require("./Keyboard");
parcelHelpers.exportAll(_keyboard, exports);
var _keyboardDefault = parcelHelpers.interopDefault(_keyboard);

},{"./Keyboard":"cbXLQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cbXLQ":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$5e71 = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$5e71.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
const ROWS = [
    [
        "Q",
        "W",
        "E",
        "R",
        "T",
        "Y",
        "U",
        "I",
        "O",
        "P"
    ],
    [
        "A",
        "S",
        "D",
        "F",
        "G",
        "H",
        "J",
        "K",
        "L"
    ],
    [
        "Z",
        "X",
        "C",
        "V",
        "B",
        "N",
        "M"
    ]
];
function getStatusByLetter(validatedGuesses) {
    const statusObj = {};
    // `.flat()` is a method that flattens nested arrays.
    // Here it produces an array containing all of the letter/status
    // objects for each guess.
    const allLetters = validatedGuesses.flat();
    allLetters.forEach(({ letter, status })=>{
        const currentStatus = statusObj[letter];
        if (currentStatus === undefined) {
            statusObj[letter] = status;
            return;
        }
        // The same letter might have multiple matched statuses.
        // For example, if the answer is "APPLE" and the user guesses
        // "PAPER", then the letter "P" is misplaced (for the first P)
        // and correct (for the second P).
        //
        // We want to prioritize the statuses in this order:
        const STATUS_RANKS = {
            correct: 1,
            misplaced: 2,
            incorrect: 3
        };
        const currentStatusRank = STATUS_RANKS[currentStatus];
        const newStatusRank = STATUS_RANKS[status];
        if (newStatusRank < currentStatusRank) statusObj[letter] = status;
    });
    return statusObj;
}
const Keyboard = ({ validatedGuesses })=>{
    const statusByLetter = getStatusByLetter(validatedGuesses);
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("div", {
        className: "keyboard",
        children: ROWS.map((row, index)=>/*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("div", {
                className: "keyboard-row",
                children: row.map((letter)=>/*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("div", {
                        className: `letter ${statusByLetter[letter] || ""}`,
                        children: letter
                    }, letter, false, {
                        fileName: "src/components/Keyboard/Keyboard.js",
                        lineNumber: 56,
                        columnNumber: 13
                    }, undefined))
            }, index, false, {
                fileName: "src/components/Keyboard/Keyboard.js",
                lineNumber: 54,
                columnNumber: 9
            }, undefined))
    }, void 0, false, {
        fileName: "src/components/Keyboard/Keyboard.js",
        lineNumber: 52,
        columnNumber: 5
    }, undefined);
};
_c = Keyboard;
exports.default = Keyboard;
var _c;
$RefreshReg$(_c, "Keyboard");

  $parcel$ReactRefreshHelpers$5e71.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru"}],"dWwK5":[function(require,module,exports) {
/**
 * Thanks to Github user dylano for supplying a more-accurate
 * solving algorithm!
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checkGuess", ()=>checkGuess);
function checkGuess(guess, answer) {
    // This constant is a placeholder that indicates we've successfully
    // dealt with this character (it's correct, or misplaced).
    const SOLVED_CHAR = "\u2713";
    if (!guess) return null;
    const guessChars = guess.toUpperCase().split("");
    const answerChars = answer.split("");
    const result = [];
    // Step 1: Look for correct letters.
    for(let i = 0; i < guessChars.length; i++)if (guessChars[i] === answerChars[i]) {
        result[i] = {
            letter: guessChars[i],
            status: "correct"
        };
        answerChars[i] = SOLVED_CHAR;
        guessChars[i] = SOLVED_CHAR;
    }
    // Step 2: look for misplaced letters. If it's not misplaced,
    // it must be incorrect.
    for(let i = 0; i < guessChars.length; i++){
        if (guessChars[i] === SOLVED_CHAR) continue;
        let status = "incorrect";
        const misplacedIndex = answerChars.findIndex((char)=>char === guessChars[i]);
        if (misplacedIndex >= 0) {
            status = "misplaced";
            answerChars[misplacedIndex] = SOLVED_CHAR;
        }
        result[i] = {
            letter: guessChars[i],
            status
        };
    }
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7nQkb":[function(require,module,exports) {
var global = arguments[3];
(function(e) {
    var f;
    module.exports = e();
})(function() {
    "use strict";
    var be = (e, n)=>()=>(n || e((n = {
                exports: {}
            }).exports, n), n.exports);
    var Ye = be((yg, ru)=>{
        var er = function(e) {
            return e && e.Math == Math && e;
        };
        ru.exports = er(typeof globalThis == "object" && globalThis) || er(typeof window == "object" && window) || er(typeof self == "object" && self) || er(typeof global == "object" && global) || function() {
            return this;
        }() || Function("return this")();
    });
    var ft = be((hg, nu)=>{
        nu.exports = function(e) {
            try {
                return !!e();
            } catch  {
                return !0;
            }
        };
    });
    var ht = be((Cg, uu)=>{
        var vo = ft();
        uu.exports = !vo(function() {
            return Object.defineProperty({}, 1, {
                get: function() {
                    return 7;
                }
            })[1] != 7;
        });
    });
    var tr = be((Eg, su)=>{
        var Fo = ft();
        su.exports = !Fo(function() {
            var e = (function() {}).bind();
            return typeof e != "function" || e.hasOwnProperty("prototype");
        });
    });
    var Ct = be((vg, au)=>{
        var Ao = tr(), rr = Function.prototype.call;
        au.exports = Ao ? rr.bind(rr) : function() {
            return rr.apply(rr, arguments);
        };
    });
    var lu = be((cu)=>{
        "use strict";
        var iu = {}.propertyIsEnumerable, ou = Object.getOwnPropertyDescriptor, So = ou && !iu.call({
            1: 2
        }, 1);
        cu.f = So ? function(n) {
            var t = ou(this, n);
            return !!t && t.enumerable;
        } : iu;
    });
    var nr = be((Ag, pu)=>{
        pu.exports = function(e, n) {
            return {
                enumerable: !(e & 1),
                configurable: !(e & 2),
                writable: !(e & 4),
                value: n
            };
        };
    });
    var at = be((Sg, mu)=>{
        var fu = tr(), Du = Function.prototype, xo = Du.bind, Lr = Du.call, bo = fu && xo.bind(Lr, Lr);
        mu.exports = fu ? function(e) {
            return e && bo(e);
        } : function(e) {
            return e && function() {
                return Lr.apply(e, arguments);
            };
        };
    });
    var ur = be((xg, gu)=>{
        var du = at(), To = du({}.toString), Bo = du("".slice);
        gu.exports = function(e) {
            return Bo(To(e), 8, -1);
        };
    });
    var hu = be((bg, yu)=>{
        var No = Ye(), wo = at(), _o = ft(), Po = ur(), Or = No.Object, Io = wo("".split);
        yu.exports = _o(function() {
            return !Or("z").propertyIsEnumerable(0);
        }) ? function(e) {
            return Po(e) == "String" ? Io(e, "") : Or(e);
        } : Or;
    });
    var jr = be((Tg, Cu)=>{
        var ko = Ye(), Lo = ko.TypeError;
        Cu.exports = function(e) {
            if (e == null) throw Lo("Can't call method on " + e);
            return e;
        };
    });
    var sr = be((Bg, Eu)=>{
        var Oo = hu(), jo = jr();
        Eu.exports = function(e) {
            return Oo(jo(e));
        };
    });
    var it = be((Ng, vu)=>{
        vu.exports = function(e) {
            return typeof e == "function";
        };
    });
    var Et = be((wg, Fu)=>{
        var qo = it();
        Fu.exports = function(e) {
            return typeof e == "object" ? e !== null : qo(e);
        };
    });
    var Mt = be((_g, Au)=>{
        var qr = Ye(), Mo = it(), Ro = function(e) {
            return Mo(e) ? e : void 0;
        };
        Au.exports = function(e, n) {
            return arguments.length < 2 ? Ro(qr[e]) : qr[e] && qr[e][n];
        };
    });
    var Mr = be((Pg, Su)=>{
        var Vo = at();
        Su.exports = Vo({}.isPrototypeOf);
    });
    var bu = be((Ig, xu)=>{
        var Wo = Mt();
        xu.exports = Wo("navigator", "userAgent") || "";
    });
    var Iu = be((kg, Pu)=>{
        var _u = Ye(), Rr = bu(), Tu = _u.process, Bu = _u.Deno, Nu = Tu && Tu.versions || Bu && Bu.version, wu = Nu && Nu.v8, lt, ar;
        wu && (lt = wu.split("."), ar = lt[0] > 0 && lt[0] < 4 ? 1 : +(lt[0] + lt[1]));
        !ar && Rr && (lt = Rr.match(/Edge\/(\d+)/), (!lt || lt[1] >= 74) && (lt = Rr.match(/Chrome\/(\d+)/), lt && (ar = +lt[1])));
        Pu.exports = ar;
    });
    var Vr = be((Lg, Lu)=>{
        var ku = Iu(), $o = ft();
        Lu.exports = !!Object.getOwnPropertySymbols && !$o(function() {
            var e = Symbol();
            return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && ku && ku < 41;
        });
    });
    var Wr = be((Og, Ou)=>{
        var Ho = Vr();
        Ou.exports = Ho && !Symbol.sham && typeof Symbol.iterator == "symbol";
    });
    var $r = be((jg, ju)=>{
        var Go = Ye(), Jo = Mt(), Uo = it(), zo = Mr(), Xo = Wr(), Ko = Go.Object;
        ju.exports = Xo ? function(e) {
            return typeof e == "symbol";
        } : function(e) {
            var n = Jo("Symbol");
            return Uo(n) && zo(n.prototype, Ko(e));
        };
    });
    var ir = be((qg, qu)=>{
        var Yo = Ye(), Qo = Yo.String;
        qu.exports = function(e) {
            try {
                return Qo(e);
            } catch  {
                return "Object";
            }
        };
    });
    var Rt = be((Mg, Mu)=>{
        var Zo = Ye(), ec = it(), tc = ir(), rc = Zo.TypeError;
        Mu.exports = function(e) {
            if (ec(e)) return e;
            throw rc(tc(e) + " is not a function");
        };
    });
    var or = be((Rg, Ru)=>{
        var nc = Rt();
        Ru.exports = function(e, n) {
            var t = e[n];
            return t == null ? void 0 : nc(t);
        };
    });
    var Wu = be((Vg, Vu)=>{
        var uc = Ye(), Hr = Ct(), Gr = it(), Jr = Et(), sc = uc.TypeError;
        Vu.exports = function(e, n) {
            var t, s;
            if (n === "string" && Gr(t = e.toString) && !Jr(s = Hr(t, e)) || Gr(t = e.valueOf) && !Jr(s = Hr(t, e)) || n !== "string" && Gr(t = e.toString) && !Jr(s = Hr(t, e))) return s;
            throw sc("Can't convert object to primitive value");
        };
    });
    var Hu = be((Wg, $u)=>{
        $u.exports = !1;
    });
    var cr = be(($g, Ju)=>{
        var Gu = Ye(), ac = Object.defineProperty;
        Ju.exports = function(e, n) {
            try {
                ac(Gu, e, {
                    value: n,
                    configurable: !0,
                    writable: !0
                });
            } catch  {
                Gu[e] = n;
            }
            return n;
        };
    });
    var lr = be((Hg, zu)=>{
        var ic = Ye(), oc = cr(), Uu = "__core-js_shared__", cc = ic[Uu] || oc(Uu, {});
        zu.exports = cc;
    });
    var Ur = be((Gg, Ku)=>{
        var lc = Hu(), Xu = lr();
        (Ku.exports = function(e, n) {
            return Xu[e] || (Xu[e] = n !== void 0 ? n : {});
        })("versions", []).push({
            version: "3.21.1",
            mode: lc ? "pure" : "global",
            copyright: "\xa9 2014-2022 Denis Pushkarev (zloirock.ru)",
            license: "https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE",
            source: "https://github.com/zloirock/core-js"
        });
    });
    var pr = be((Jg, Yu)=>{
        var pc = Ye(), fc = jr(), Dc = pc.Object;
        Yu.exports = function(e) {
            return Dc(fc(e));
        };
    });
    var mt = be((Ug, Qu)=>{
        var mc = at(), dc = pr(), gc = mc({}.hasOwnProperty);
        Qu.exports = Object.hasOwn || function(n, t) {
            return gc(dc(n), t);
        };
    });
    var zr = be((zg, Zu)=>{
        var yc = at(), hc = 0, Cc = Math.random(), Ec = yc(1..toString);
        Zu.exports = function(e) {
            return "Symbol(" + (e === void 0 ? "" : e) + ")_" + Ec(++hc + Cc, 36);
        };
    });
    var Ft = be((Xg, us)=>{
        var vc = Ye(), Fc = Ur(), es = mt(), Ac = zr(), ts = Vr(), ns = Wr(), Tt = Fc("wks"), vt = vc.Symbol, rs = vt && vt.for, Sc = ns ? vt : vt && vt.withoutSetter || Ac;
        us.exports = function(e) {
            if (!es(Tt, e) || !(ts || typeof Tt[e] == "string")) {
                var n = "Symbol." + e;
                ts && es(vt, e) ? Tt[e] = vt[e] : ns && rs ? Tt[e] = rs(n) : Tt[e] = Sc(n);
            }
            return Tt[e];
        };
    });
    var os = be((Kg, is)=>{
        var xc = Ye(), bc = Ct(), ss = Et(), as = $r(), Tc = or(), Bc = Wu(), Nc = Ft(), wc = xc.TypeError, _c = Nc("toPrimitive");
        is.exports = function(e, n) {
            if (!ss(e) || as(e)) return e;
            var t = Tc(e, _c), s;
            if (t) {
                if (n === void 0 && (n = "default"), s = bc(t, e, n), !ss(s) || as(s)) return s;
                throw wc("Can't convert object to primitive value");
            }
            return n === void 0 && (n = "number"), Bc(e, n);
        };
    });
    var fr = be((Yg, cs)=>{
        var Pc = os(), Ic = $r();
        cs.exports = function(e) {
            var n = Pc(e, "string");
            return Ic(n) ? n : n + "";
        };
    });
    var fs = be((Qg, ps)=>{
        var kc = Ye(), ls = Et(), Xr = kc.document, Lc = ls(Xr) && ls(Xr.createElement);
        ps.exports = function(e) {
            return Lc ? Xr.createElement(e) : {};
        };
    });
    var Kr = be((Zg, Ds)=>{
        var Oc = ht(), jc = ft(), qc = fs();
        Ds.exports = !Oc && !jc(function() {
            return Object.defineProperty(qc("div"), "a", {
                get: function() {
                    return 7;
                }
            }).a != 7;
        });
    });
    var Yr = be((ds)=>{
        var Mc = ht(), Rc = Ct(), Vc = lu(), Wc = nr(), $c = sr(), Hc = fr(), Gc = mt(), Jc = Kr(), ms = Object.getOwnPropertyDescriptor;
        ds.f = Mc ? ms : function(n, t) {
            if (n = $c(n), t = Hc(t), Jc) try {
                return ms(n, t);
            } catch  {}
            if (Gc(n, t)) return Wc(!Rc(Vc.f, n, t), n[t]);
        };
    });
    var ys = be((t0, gs)=>{
        var Uc = ht(), zc = ft();
        gs.exports = Uc && zc(function() {
            return Object.defineProperty(function() {}, "prototype", {
                value: 42,
                writable: !1
            }).prototype != 42;
        });
    });
    var Bt = be((r0, Cs)=>{
        var hs = Ye(), Xc = Et(), Kc = hs.String, Yc = hs.TypeError;
        Cs.exports = function(e) {
            if (Xc(e)) return e;
            throw Yc(Kc(e) + " is not an object");
        };
    });
    var mr = be((vs)=>{
        var Qc = Ye(), Zc = ht(), el = Kr(), tl = ys(), Dr = Bt(), Es = fr(), rl = Qc.TypeError, Qr = Object.defineProperty, nl = Object.getOwnPropertyDescriptor, Zr = "enumerable", en = "configurable", tn = "writable";
        vs.f = Zc ? tl ? function(n, t, s) {
            if (Dr(n), t = Es(t), Dr(s), typeof n == "function" && t === "prototype" && "value" in s && tn in s && !s[tn]) {
                var i = nl(n, t);
                i && i[tn] && (n[t] = s.value, s = {
                    configurable: en in s ? s[en] : i[en],
                    enumerable: Zr in s ? s[Zr] : i[Zr],
                    writable: !1
                });
            }
            return Qr(n, t, s);
        } : Qr : function(n, t, s) {
            if (Dr(n), t = Es(t), Dr(s), el) try {
                return Qr(n, t, s);
            } catch  {}
            if ("get" in s || "set" in s) throw rl("Accessors not supported");
            return "value" in s && (n[t] = s.value), n;
        };
    });
    var dr = be((u0, Fs)=>{
        var ul = ht(), sl = mr(), al = nr();
        Fs.exports = ul ? function(e, n, t) {
            return sl.f(e, n, al(1, t));
        } : function(e, n, t) {
            return e[n] = t, e;
        };
    });
    var gr = be((s0, As)=>{
        var il = at(), ol = it(), rn = lr(), cl = il(Function.toString);
        ol(rn.inspectSource) || (rn.inspectSource = function(e) {
            return cl(e);
        });
        As.exports = rn.inspectSource;
    });
    var bs = be((a0, xs)=>{
        var ll = Ye(), pl = it(), fl = gr(), Ss = ll.WeakMap;
        xs.exports = pl(Ss) && /native code/.test(fl(Ss));
    });
    var Ns = be((i0, Bs)=>{
        var Dl = Ur(), ml = zr(), Ts = Dl("keys");
        Bs.exports = function(e) {
            return Ts[e] || (Ts[e] = ml(e));
        };
    });
    var nn = be((o0, ws)=>{
        ws.exports = {};
    });
    var Os = be((c0, Ls)=>{
        var dl = bs(), ks = Ye(), un = at(), gl = Et(), yl = dr(), sn = mt(), an = lr(), hl = Ns(), Cl = nn(), _s = "Object already initialized", cn = ks.TypeError, El = ks.WeakMap, yr, Vt, hr, vl = function(e) {
            return hr(e) ? Vt(e) : yr(e, {});
        }, Fl = function(e) {
            return function(n) {
                var t;
                if (!gl(n) || (t = Vt(n)).type !== e) throw cn("Incompatible receiver, " + e + " required");
                return t;
            };
        };
        dl || an.state ? (dt = an.state || (an.state = new El), Ps = un(dt.get), on = un(dt.has), Is = un(dt.set), yr = function(e, n) {
            if (on(dt, e)) throw new cn(_s);
            return n.facade = e, Is(dt, e, n), n;
        }, Vt = function(e) {
            return Ps(dt, e) || {};
        }, hr = function(e) {
            return on(dt, e);
        }) : (At = hl("state"), Cl[At] = !0, yr = function(e, n) {
            if (sn(e, At)) throw new cn(_s);
            return n.facade = e, yl(e, At, n), n;
        }, Vt = function(e) {
            return sn(e, At) ? e[At] : {};
        }, hr = function(e) {
            return sn(e, At);
        });
        var dt, Ps, on, Is, At;
        Ls.exports = {
            set: yr,
            get: Vt,
            has: hr,
            enforce: vl,
            getterFor: Fl
        };
    });
    var Ms = be((l0, qs)=>{
        var ln = ht(), Al = mt(), js = Function.prototype, Sl = ln && Object.getOwnPropertyDescriptor, pn = Al(js, "name"), xl = pn && (function() {}).name === "something", bl = pn && (!ln || ln && Sl(js, "name").configurable);
        qs.exports = {
            EXISTS: pn,
            PROPER: xl,
            CONFIGURABLE: bl
        };
    });
    var Hs = be((p0, $s)=>{
        var Tl = Ye(), Rs = it(), Bl = mt(), Vs = dr(), Nl = cr(), wl = gr(), Ws = Os(), _l = Ms().CONFIGURABLE, Pl = Ws.get, Il = Ws.enforce, kl = String(String).split("String");
        ($s.exports = function(e, n, t, s) {
            var i = s ? !!s.unsafe : !1, r = s ? !!s.enumerable : !1, u = s ? !!s.noTargetGet : !1, a = s && s.name !== void 0 ? s.name : n, c;
            if (Rs(t) && (String(a).slice(0, 7) === "Symbol(" && (a = "[" + String(a).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Bl(t, "name") || _l && t.name !== a) && Vs(t, "name", a), c = Il(t), c.source || (c.source = kl.join(typeof a == "string" ? a : ""))), e === Tl) {
                r ? e[n] = t : Nl(n, t);
                return;
            } else i ? !u && e[n] && (r = !0) : delete e[n];
            r ? e[n] = t : Vs(e, n, t);
        })(Function.prototype, "toString", function() {
            return Rs(this) && Pl(this).source || wl(this);
        });
    });
    var Cr = be((f0, Gs)=>{
        var Ll = Math.ceil, Ol = Math.floor;
        Gs.exports = function(e) {
            var n = +e;
            return n !== n || n === 0 ? 0 : (n > 0 ? Ol : Ll)(n);
        };
    });
    var Us = be((D0, Js)=>{
        var jl = Cr(), ql = Math.max, Ml = Math.min;
        Js.exports = function(e, n) {
            var t = jl(e);
            return t < 0 ? ql(t + n, 0) : Ml(t, n);
        };
    });
    var Xs = be((m0, zs)=>{
        var Rl = Cr(), Vl = Math.min;
        zs.exports = function(e) {
            return e > 0 ? Vl(Rl(e), 9007199254740991) : 0;
        };
    });
    var Nt = be((d0, Ks)=>{
        var Wl = Xs();
        Ks.exports = function(e) {
            return Wl(e.length);
        };
    });
    var Zs = be((g0, Qs)=>{
        var $l = sr(), Hl = Us(), Gl = Nt(), Ys = function(e) {
            return function(n, t, s) {
                var i = $l(n), r = Gl(i), u = Hl(s, r), a;
                if (e && t != t) {
                    for(; r > u;)if (a = i[u++], a != a) return !0;
                } else for(; r > u; u++)if ((e || u in i) && i[u] === t) return e || u || 0;
                return !e && -1;
            };
        };
        Qs.exports = {
            includes: Ys(!0),
            indexOf: Ys(!1)
        };
    });
    var ra = be((y0, ta)=>{
        var Jl = at(), fn = mt(), Ul = sr(), zl = Zs().indexOf, Xl = nn(), ea = Jl([].push);
        ta.exports = function(e, n) {
            var t = Ul(e), s = 0, i = [], r;
            for(r in t)!fn(Xl, r) && fn(t, r) && ea(i, r);
            for(; n.length > s;)fn(t, r = n[s++]) && (~zl(i, r) || ea(i, r));
            return i;
        };
    });
    var ua = be((h0, na)=>{
        na.exports = [
            "constructor",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "toLocaleString",
            "toString",
            "valueOf"
        ];
    });
    var aa = be((sa)=>{
        var Kl = ra(), Yl = ua(), Ql = Yl.concat("length", "prototype");
        sa.f = Object.getOwnPropertyNames || function(n) {
            return Kl(n, Ql);
        };
    });
    var oa = be((ia)=>{
        ia.f = Object.getOwnPropertySymbols;
    });
    var la = be((v0, ca)=>{
        var Zl = Mt(), ep = at(), tp = aa(), rp = oa(), np = Bt(), up = ep([].concat);
        ca.exports = Zl("Reflect", "ownKeys") || function(n) {
            var t = tp.f(np(n)), s = rp.f;
            return s ? up(t, s(n)) : t;
        };
    });
    var Da = be((F0, fa)=>{
        var pa = mt(), sp = la(), ap = Yr(), ip = mr();
        fa.exports = function(e, n, t) {
            for(var s = sp(n), i = ip.f, r = ap.f, u = 0; u < s.length; u++){
                var a = s[u];
                !pa(e, a) && !(t && pa(t, a)) && i(e, a, r(n, a));
            }
        };
    });
    var da = be((A0, ma)=>{
        var op = ft(), cp = it(), lp = /#|\.prototype\./, Wt = function(e, n) {
            var t = fp[pp(e)];
            return t == mp ? !0 : t == Dp ? !1 : cp(n) ? op(n) : !!n;
        }, pp = Wt.normalize = function(e) {
            return String(e).replace(lp, ".").toLowerCase();
        }, fp = Wt.data = {}, Dp = Wt.NATIVE = "N", mp = Wt.POLYFILL = "P";
        ma.exports = Wt;
    });
    var $t = be((S0, ga)=>{
        var Dn = Ye(), dp = Yr().f, gp = dr(), yp = Hs(), hp = cr(), Cp = Da(), Ep = da();
        ga.exports = function(e, n) {
            var t = e.target, s = e.global, i = e.stat, r, u, a, c, l, C;
            if (s ? u = Dn : i ? u = Dn[t] || hp(t, {}) : u = (Dn[t] || {}).prototype, u) for(a in n){
                if (l = n[a], e.noTargetGet ? (C = dp(u, a), c = C && C.value) : c = u[a], r = Ep(s ? a : t + (i ? "." : "#") + a, e.forced), !r && c !== void 0) {
                    if (typeof l == typeof c) continue;
                    Cp(l, c);
                }
                (e.sham || c && c.sham) && gp(l, "sham", !0), yp(u, a, l, e);
            }
        };
    });
    var mn = be((x0, ya)=>{
        var vp = ur();
        ya.exports = Array.isArray || function(n) {
            return vp(n) == "Array";
        };
    });
    var dn = be((b0, Ca)=>{
        var ha = at(), Fp = Rt(), Ap = tr(), Sp = ha(ha.bind);
        Ca.exports = function(e, n) {
            return Fp(e), n === void 0 ? e : Ap ? Sp(e, n) : function() {
                return e.apply(n, arguments);
            };
        };
    });
    var gn = be((T0, va)=>{
        "use strict";
        var xp = Ye(), bp = mn(), Tp = Nt(), Bp = dn(), Np = xp.TypeError, Ea = function(e, n, t, s, i, r, u, a) {
            for(var c = i, l = 0, C = u ? Bp(u, a) : !1, m, g; l < s;){
                if (l in t) {
                    if (m = C ? C(t[l], l, n) : t[l], r > 0 && bp(m)) g = Tp(m), c = Ea(e, n, m, g, c, r - 1) - 1;
                    else {
                        if (c >= 9007199254740991) throw Np("Exceed the acceptable array length");
                        e[c] = m;
                    }
                    c++;
                }
                l++;
            }
            return c;
        };
        va.exports = Ea;
    });
    var Sa = be((B0, Aa)=>{
        var wp = Ft(), _p = wp("toStringTag"), Fa = {};
        Fa[_p] = "z";
        Aa.exports = String(Fa) === "[object z]";
    });
    var yn = be((N0, xa)=>{
        var Pp = Ye(), Ip = Sa(), kp = it(), Er = ur(), Lp = Ft(), Op = Lp("toStringTag"), jp = Pp.Object, qp = Er(function() {
            return arguments;
        }()) == "Arguments", Mp = function(e, n) {
            try {
                return e[n];
            } catch  {}
        };
        xa.exports = Ip ? Er : function(e) {
            var n, t, s;
            return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Mp(n = jp(e), Op)) == "string" ? t : qp ? Er(n) : (s = Er(n)) == "Object" && kp(n.callee) ? "Arguments" : s;
        };
    });
    var _a = be((w0, wa)=>{
        var Rp = at(), Vp = ft(), ba = it(), Wp = yn(), $p = Mt(), Hp = gr(), Ta = function() {}, Gp = [], Ba = $p("Reflect", "construct"), hn = /^\s*(?:class|function)\b/, Jp = Rp(hn.exec), Up = !hn.exec(Ta), Ht = function(n) {
            if (!ba(n)) return !1;
            try {
                return Ba(Ta, Gp, n), !0;
            } catch  {
                return !1;
            }
        }, Na = function(n) {
            if (!ba(n)) return !1;
            switch(Wp(n)){
                case "AsyncFunction":
                case "GeneratorFunction":
                case "AsyncGeneratorFunction":
                    return !1;
            }
            try {
                return Up || !!Jp(hn, Hp(n));
            } catch  {
                return !0;
            }
        };
        Na.sham = !0;
        wa.exports = !Ba || Vp(function() {
            var e;
            return Ht(Ht.call) || !Ht(Object) || !Ht(function() {
                e = !0;
            }) || e;
        }) ? Na : Ht;
    });
    var La = be((_0, ka)=>{
        var zp = Ye(), Pa = mn(), Xp = _a(), Kp = Et(), Yp = Ft(), Qp = Yp("species"), Ia = zp.Array;
        ka.exports = function(e) {
            var n;
            return Pa(e) && (n = e.constructor, Xp(n) && (n === Ia || Pa(n.prototype)) ? n = void 0 : Kp(n) && (n = n[Qp], n === null && (n = void 0))), n === void 0 ? Ia : n;
        };
    });
    var Cn = be((P0, Oa)=>{
        var Zp = La();
        Oa.exports = function(e, n) {
            return new (Zp(e))(n === 0 ? 0 : n);
        };
    });
    var ja = be(()=>{
        "use strict";
        var ef = $t(), tf = gn(), rf = Rt(), nf = pr(), uf = Nt(), sf = Cn();
        ef({
            target: "Array",
            proto: !0
        }, {
            flatMap: function(n) {
                var t = nf(this), s = uf(t), i;
                return rf(n), i = sf(t, 0), i.length = tf(i, t, t, s, 0, 1, n, arguments.length > 1 ? arguments[1] : void 0), i;
            }
        });
    });
    var En = be((L0, qa)=>{
        qa.exports = {};
    });
    var Ra = be((O0, Ma)=>{
        var af = Ft(), of = En(), cf = af("iterator"), lf = Array.prototype;
        Ma.exports = function(e) {
            return e !== void 0 && (of.Array === e || lf[cf] === e);
        };
    });
    var vn = be((j0, Wa)=>{
        var pf = yn(), Va = or(), ff = En(), Df = Ft(), mf = Df("iterator");
        Wa.exports = function(e) {
            if (e != null) return Va(e, mf) || Va(e, "@@iterator") || ff[pf(e)];
        };
    });
    var Ha = be((q0, $a)=>{
        var df = Ye(), gf = Ct(), yf = Rt(), hf = Bt(), Cf = ir(), Ef = vn(), vf = df.TypeError;
        $a.exports = function(e, n) {
            var t = arguments.length < 2 ? Ef(e) : n;
            if (yf(t)) return hf(gf(t, e));
            throw vf(Cf(e) + " is not iterable");
        };
    });
    var Ua = be((M0, Ja)=>{
        var Ff = Ct(), Ga = Bt(), Af = or();
        Ja.exports = function(e, n, t) {
            var s, i;
            Ga(e);
            try {
                if (s = Af(e, "return"), !s) {
                    if (n === "throw") throw t;
                    return t;
                }
                s = Ff(s, e);
            } catch (r) {
                i = !0, s = r;
            }
            if (n === "throw") throw t;
            if (i) throw s;
            return Ga(s), t;
        };
    });
    var Qa = be((R0, Ya)=>{
        var Sf = Ye(), xf = dn(), bf = Ct(), Tf = Bt(), Bf = ir(), Nf = Ra(), wf = Nt(), za = Mr(), _f = Ha(), Pf = vn(), Xa = Ua(), If = Sf.TypeError, vr = function(e, n) {
            this.stopped = e, this.result = n;
        }, Ka = vr.prototype;
        Ya.exports = function(e, n, t) {
            var s = t && t.that, i = !!(t && t.AS_ENTRIES), r = !!(t && t.IS_ITERATOR), u = !!(t && t.INTERRUPTED), a = xf(n, s), c, l, C, m, g, p, f, h = function(T) {
                return c && Xa(c, "normal", T), new vr(!0, T);
            }, N = function(T) {
                return i ? (Tf(T), u ? a(T[0], T[1], h) : a(T[0], T[1])) : u ? a(T, h) : a(T);
            };
            if (r) c = e;
            else {
                if (l = Pf(e), !l) throw If(Bf(e) + " is not iterable");
                if (Nf(l)) {
                    for(C = 0, m = wf(e); m > C; C++)if (g = N(e[C]), g && za(Ka, g)) return g;
                    return new vr(!1);
                }
                c = _f(e, l);
            }
            for(p = c.next; !(f = bf(p, c)).done;){
                try {
                    g = N(f.value);
                } catch (T) {
                    Xa(c, "throw", T);
                }
                if (typeof g == "object" && g && za(Ka, g)) return g;
            }
            return new vr(!1);
        };
    });
    var ei = be((V0, Za)=>{
        "use strict";
        var kf = fr(), Lf = mr(), Of = nr();
        Za.exports = function(e, n, t) {
            var s = kf(n);
            s in e ? Lf.f(e, s, Of(0, t)) : e[s] = t;
        };
    });
    var ti = be(()=>{
        var jf = $t(), qf = Qa(), Mf = ei();
        jf({
            target: "Object",
            stat: !0
        }, {
            fromEntries: function(n) {
                var t = {};
                return qf(n, function(s, i) {
                    Mf(t, s, i);
                }, {
                    AS_ENTRIES: !0
                }), t;
            }
        });
    });
    var ri = be(()=>{
        var Rf = $t(), Vf = Ye();
        Rf({
            global: !0
        }, {
            globalThis: Vf
        });
    });
    var ni = be(()=>{
        ri();
    });
    var ui = be(()=>{
        "use strict";
        var Wf = $t(), $f = gn(), Hf = pr(), Gf = Nt(), Jf = Cr(), Uf = Cn();
        Wf({
            target: "Array",
            proto: !0
        }, {
            flat: function() {
                var n = arguments.length ? arguments[0] : void 0, t = Hf(this), s = Gf(t), i = Uf(t, 0);
                return i.length = $f(i, t, t, s, 0, n === void 0 ? 1 : Jf(n)), i;
            }
        });
    });
    var dg = be((Y0, yo)=>{
        var zf = [
            "cliName",
            "cliCategory",
            "cliDescription"
        ], Xf = [
            "_"
        ], Kf = [
            "languageId"
        ], si, ai, ii, oi, ci, li;
        function _n(e, n) {
            if (e == null) return {};
            var t = Yf(e, n), s, i;
            if (Object.getOwnPropertySymbols) {
                var r = Object.getOwnPropertySymbols(e);
                for(i = 0; i < r.length; i++)s = r[i], !(n.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s) || (t[s] = e[s]));
            }
            return t;
        }
        function Yf(e, n) {
            if (e == null) return {};
            var t = {}, s = Object.keys(e), i, r;
            for(r = 0; r < s.length; r++)i = s[r], !(n.indexOf(i) >= 0) && (t[i] = e[i]);
            return t;
        }
        ja();
        ti();
        ni();
        ui();
        function wt(e, n) {
            return n || (n = e.slice(0)), Object.freeze(Object.defineProperties(e, {
                raw: {
                    value: Object.freeze(n)
                }
            }));
        }
        var Pn = Object.defineProperty, Qf = Object.getOwnPropertyDescriptor, In = Object.getOwnPropertyNames, Zf = Object.prototype.hasOwnProperty, br = (e, n)=>function() {
                return e && (n = (0, e[In(e)[0]])(e = 0)), n;
            }, Z = (e, n)=>function() {
                return n || (0, e[In(e)[0]])((n = {
                    exports: {}
                }).exports, n), n.exports;
            }, kn = (e, n)=>{
            for(var t in n)Pn(e, t, {
                get: n[t],
                enumerable: !0
            });
        }, eD = (e, n, t, s)=>{
            if (n && typeof n == "object" || typeof n == "function") for (let i of In(n))!Zf.call(e, i) && i !== t && Pn(e, i, {
                get: ()=>n[i],
                enumerable: !(s = Qf(n, i)) || s.enumerable
            });
            return e;
        }, pt = (e)=>eD(Pn({}, "__esModule", {
                value: !0
            }), e), pi, fi, xt, ae = br({
            "<define:process>" () {
                pi = {}, fi = [], xt = {
                    env: pi,
                    argv: fi
                };
            }
        }), gi = Z({
            "package.json" (e, n) {
                n.exports = {
                    version: "2.6.2"
                };
            }
        }), tD = Z({
            "node_modules/diff/lib/diff/base.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.default = n;
                function n() {}
                n.prototype = {
                    diff: function(r, u) {
                        var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, c = a.callback;
                        typeof a == "function" && (c = a, a = {}), this.options = a;
                        var l = this;
                        function C(b) {
                            return c ? (setTimeout(function() {
                                c(void 0, b);
                            }, 0), !0) : b;
                        }
                        r = this.castInput(r), u = this.castInput(u), r = this.removeEmpty(this.tokenize(r)), u = this.removeEmpty(this.tokenize(u));
                        var m = u.length, g = r.length, p = 1, f = m + g, h = [
                            {
                                newPos: -1,
                                components: []
                            }
                        ], N = this.extractCommon(h[0], u, r, 0);
                        if (h[0].newPos + 1 >= m && N + 1 >= g) return C([
                            {
                                value: this.join(u),
                                count: u.length
                            }
                        ]);
                        function T() {
                            for(var b = -1 * p; b <= p; b += 2){
                                var v = void 0, B = h[b - 1], w = h[b + 1], I = (w ? w.newPos : 0) - b;
                                B && (h[b - 1] = void 0);
                                var E = B && B.newPos + 1 < m, D = w && 0 <= I && I < g;
                                if (!E && !D) {
                                    h[b] = void 0;
                                    continue;
                                }
                                if (!E || D && B.newPos < w.newPos ? (v = s(w), l.pushComponent(v.components, void 0, !0)) : (v = B, v.newPos++, l.pushComponent(v.components, !0, void 0)), I = l.extractCommon(v, u, r, b), v.newPos + 1 >= m && I + 1 >= g) return C(t(l, v.components, u, r, l.useLongestToken));
                                h[b] = v;
                            }
                            p++;
                        }
                        if (c) (function b() {
                            setTimeout(function() {
                                if (p > f) return c();
                                T() || b();
                            }, 0);
                        })();
                        else for(; p <= f;){
                            var A = T();
                            if (A) return A;
                        }
                    },
                    pushComponent: function(r, u, a) {
                        var c = r[r.length - 1];
                        c && c.added === u && c.removed === a ? r[r.length - 1] = {
                            count: c.count + 1,
                            added: u,
                            removed: a
                        } : r.push({
                            count: 1,
                            added: u,
                            removed: a
                        });
                    },
                    extractCommon: function(r, u, a, c) {
                        for(var l = u.length, C = a.length, m = r.newPos, g = m - c, p = 0; m + 1 < l && g + 1 < C && this.equals(u[m + 1], a[g + 1]);)m++, g++, p++;
                        return p && r.components.push({
                            count: p
                        }), r.newPos = m, g;
                    },
                    equals: function(r, u) {
                        return this.options.comparator ? this.options.comparator(r, u) : r === u || this.options.ignoreCase && r.toLowerCase() === u.toLowerCase();
                    },
                    removeEmpty: function(r) {
                        for(var u = [], a = 0; a < r.length; a++)r[a] && u.push(r[a]);
                        return u;
                    },
                    castInput: function(r) {
                        return r;
                    },
                    tokenize: function(r) {
                        return r.split("");
                    },
                    join: function(r) {
                        return r.join("");
                    }
                };
                function t(i, r, u, a, c) {
                    for(var l = 0, C = r.length, m = 0, g = 0; l < C; l++){
                        var p = r[l];
                        if (p.removed) {
                            if (p.value = i.join(a.slice(g, g + p.count)), g += p.count, l && r[l - 1].added) {
                                var h = r[l - 1];
                                r[l - 1] = r[l], r[l] = h;
                            }
                        } else {
                            if (!p.added && c) {
                                var f = u.slice(m, m + p.count);
                                f = f.map(function(T, A) {
                                    var b = a[g + A];
                                    return b.length > T.length ? b : T;
                                }), p.value = i.join(f);
                            } else p.value = i.join(u.slice(m, m + p.count));
                            m += p.count, p.added || (g += p.count);
                        }
                    }
                    var N = r[C - 1];
                    return C > 1 && typeof N.value == "string" && (N.added || N.removed) && i.equals("", N.value) && (r[C - 2].value += N.value, r.pop()), r;
                }
                function s(i) {
                    return {
                        newPos: i.newPos,
                        components: i.components.slice(0)
                    };
                }
            }
        }), rD = Z({
            "node_modules/diff/lib/diff/array.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.diffArrays = i, e.arrayDiff = void 0;
                var n = t(tD());
                function t(r) {
                    return r && r.__esModule ? r : {
                        default: r
                    };
                }
                var s = new n.default;
                e.arrayDiff = s, s.tokenize = function(r) {
                    return r.slice();
                }, s.join = s.removeEmpty = function(r) {
                    return r;
                };
                function i(r, u, a) {
                    return s.diff(r, u, a);
                }
            }
        }), Ln = Z({
            "src/document/doc-builders.js" (e, n) {
                "use strict";
                ae();
                function t(y) {
                    return {
                        type: "concat",
                        parts: y
                    };
                }
                function s(y) {
                    return {
                        type: "indent",
                        contents: y
                    };
                }
                function i(y, o) {
                    return {
                        type: "align",
                        contents: o,
                        n: y
                    };
                }
                function r(y) {
                    let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    return {
                        type: "group",
                        id: o.id,
                        contents: y,
                        break: Boolean(o.shouldBreak),
                        expandedStates: o.expandedStates
                    };
                }
                function u(y) {
                    return i(Number.NEGATIVE_INFINITY, y);
                }
                function a(y) {
                    return i({
                        type: "root"
                    }, y);
                }
                function c(y) {
                    return i(-1, y);
                }
                function l(y, o) {
                    return r(y[0], Object.assign(Object.assign({}, o), {}, {
                        expandedStates: y
                    }));
                }
                function C(y) {
                    return {
                        type: "fill",
                        parts: y
                    };
                }
                function m(y, o) {
                    let x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    return {
                        type: "if-break",
                        breakContents: y,
                        flatContents: o,
                        groupId: x.groupId
                    };
                }
                function g(y, o) {
                    return {
                        type: "indent-if-break",
                        contents: y,
                        groupId: o.groupId,
                        negate: o.negate
                    };
                }
                function p(y) {
                    return {
                        type: "line-suffix",
                        contents: y
                    };
                }
                var f = {
                    type: "line-suffix-boundary"
                }, h = {
                    type: "break-parent"
                }, N = {
                    type: "trim"
                }, T = {
                    type: "line",
                    hard: !0
                }, A = {
                    type: "line",
                    hard: !0,
                    literal: !0
                }, b = {
                    type: "line"
                }, v = {
                    type: "line",
                    soft: !0
                }, B = t([
                    T,
                    h
                ]), w = t([
                    A,
                    h
                ]), I = {
                    type: "cursor",
                    placeholder: Symbol("cursor")
                };
                function E(y, o) {
                    let x = [];
                    for(let F = 0; F < o.length; F++)F !== 0 && x.push(y), x.push(o[F]);
                    return t(x);
                }
                function D(y, o, x) {
                    let F = y;
                    if (o > 0) {
                        for(let S = 0; S < Math.floor(o / x); ++S)F = s(F);
                        F = i(o % x, F), F = i(Number.NEGATIVE_INFINITY, F);
                    }
                    return F;
                }
                function d(y, o) {
                    return {
                        type: "label",
                        label: y,
                        contents: o
                    };
                }
                n.exports = {
                    concat: t,
                    join: E,
                    line: b,
                    softline: v,
                    hardline: B,
                    literalline: w,
                    group: r,
                    conditionalGroup: l,
                    fill: C,
                    lineSuffix: p,
                    lineSuffixBoundary: f,
                    cursor: I,
                    breakParent: h,
                    ifBreak: m,
                    trim: N,
                    indent: s,
                    indentIfBreak: g,
                    align: i,
                    addAlignmentToDoc: D,
                    markAsRoot: a,
                    dedentToRoot: u,
                    dedent: c,
                    hardlineWithoutBreakParent: T,
                    literallineWithoutBreakParent: A,
                    label: d
                };
            }
        }), On = Z({
            "src/common/end-of-line.js" (e, n) {
                "use strict";
                ae();
                function t(u) {
                    let a = u.indexOf("\r");
                    return a >= 0 ? u.charAt(a + 1) === `
` ? "crlf" : "cr" : "lf";
                }
                function s(u) {
                    switch(u){
                        case "cr":
                            return "\r";
                        case "crlf":
                            return `\r
`;
                        default:
                            return `
`;
                    }
                }
                function i(u, a) {
                    let c;
                    switch(a){
                        case `
`:
                            c = /\n/g;
                            break;
                        case "\r":
                            c = /\r/g;
                            break;
                        case `\r
`:
                            c = /\r\n/g;
                            break;
                        default:
                            throw new Error('Unexpected "eol" '.concat(JSON.stringify(a), "."));
                    }
                    let l = u.match(c);
                    return l ? l.length : 0;
                }
                function r(u) {
                    return u.replace(/\r\n?/g, `
`);
                }
                n.exports = {
                    guessEndOfLine: t,
                    convertEndOfLineToChars: s,
                    countEndOfLineChars: i,
                    normalizeEndOfLine: r
                };
            }
        }), st = Z({
            "src/utils/get-last.js" (e, n) {
                "use strict";
                ae();
                var t = (s)=>s[s.length - 1];
                n.exports = t;
            }
        }), nD = Z({
            "vendors/string-width.js" (e, n) {
                ae();
                var t = Object.create, s = Object.defineProperty, i = Object.getOwnPropertyDescriptor, r = Object.getOwnPropertyNames, u = Object.getPrototypeOf, a = Object.prototype.hasOwnProperty, c = (v, B)=>function() {
                        return B || (0, v[r(v)[0]])((B = {
                            exports: {}
                        }).exports, B), B.exports;
                    }, l = (v, B)=>{
                    for(var w in B)s(v, w, {
                        get: B[w],
                        enumerable: !0
                    });
                }, C = (v, B, w, I)=>{
                    if (B && typeof B == "object" || typeof B == "function") for (let E of r(B))!a.call(v, E) && E !== w && s(v, E, {
                        get: ()=>B[E],
                        enumerable: !(I = i(B, E)) || I.enumerable
                    });
                    return v;
                }, m = (v, B, w)=>(w = v != null ? t(u(v)) : {}, C(B || !v || !v.__esModule ? s(w, "default", {
                        value: v,
                        enumerable: !0
                    }) : w, v)), g = (v)=>C(s({}, "__esModule", {
                        value: !0
                    }), v), p = c({
                    "node_modules/emoji-regex/index.js" (v, B) {
                        "use strict";
                        B.exports = function() {
                            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
                        };
                    }
                }), f = {};
                l(f, {
                    default: ()=>b
                }), n.exports = g(f);
                function h() {
                    let { onlyFirst: v = !1 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, B = [
                        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
                    ].join("|");
                    return new RegExp(B, v ? void 0 : "g");
                }
                function N(v) {
                    if (typeof v != "string") throw new TypeError("Expected a `string`, got `".concat(typeof v, "`"));
                    return v.replace(h(), "");
                }
                function T(v) {
                    return Number.isInteger(v) ? v >= 4352 && (v <= 4447 || v === 9001 || v === 9002 || 11904 <= v && v <= 12871 && v !== 12351 || 12880 <= v && v <= 19903 || 19968 <= v && v <= 42182 || 43360 <= v && v <= 43388 || 44032 <= v && v <= 55203 || 63744 <= v && v <= 64255 || 65040 <= v && v <= 65049 || 65072 <= v && v <= 65131 || 65281 <= v && v <= 65376 || 65504 <= v && v <= 65510 || 110592 <= v && v <= 110593 || 127488 <= v && v <= 127569 || 131072 <= v && v <= 262141) : !1;
                }
                var A = m(p(), 1);
                function b(v) {
                    if (typeof v != "string" || v.length === 0 || (v = N(v), v.length === 0)) return 0;
                    v = v.replace((0, A.default)(), "  ");
                    let B = 0;
                    for(let w = 0; w < v.length; w++){
                        let I = v.codePointAt(w);
                        I <= 31 || I >= 127 && I <= 159 || I >= 768 && I <= 879 || (I > 65535 && w++, B += T(I) ? 2 : 1);
                    }
                    return B;
                }
            }
        }), yi = Z({
            "src/utils/get-string-width.js" (e, n) {
                "use strict";
                ae();
                var t = nD().default, s = /[^\x20-\x7F]/;
                function i(r) {
                    return r ? s.test(r) ? t(r) : r.length : 0;
                }
                n.exports = i;
            }
        }), jn = Z({
            "src/document/doc-utils.js" (e, n) {
                "use strict";
                ae();
                var t = st(), { literalline: s, join: i } = Ln(), r = (o)=>Array.isArray(o) || o && o.type === "concat", u = (o)=>{
                    if (Array.isArray(o)) return o;
                    if (o.type !== "concat" && o.type !== "fill") throw new Error("Expect doc type to be `concat` or `fill`.");
                    return o.parts;
                }, a = {};
                function c(o, x, F, S) {
                    let k = [
                        o
                    ];
                    for(; k.length > 0;){
                        let _ = k.pop();
                        if (_ === a) {
                            F(k.pop());
                            continue;
                        }
                        if (F && k.push(_, a), !x || x(_) !== !1) {
                            if (r(_) || _.type === "fill") {
                                let O = u(_);
                                for(let R = O.length, M = R - 1; M >= 0; --M)k.push(O[M]);
                            } else if (_.type === "if-break") _.flatContents && k.push(_.flatContents), _.breakContents && k.push(_.breakContents);
                            else if (_.type === "group" && _.expandedStates) {
                                if (S) for(let O = _.expandedStates.length, R = O - 1; R >= 0; --R)k.push(_.expandedStates[R]);
                                else k.push(_.contents);
                            } else _.contents && k.push(_.contents);
                        }
                    }
                }
                function l(o, x) {
                    let F = new Map;
                    return S(o);
                    function S(_) {
                        if (F.has(_)) return F.get(_);
                        let O = k(_);
                        return F.set(_, O), O;
                    }
                    function k(_) {
                        if (Array.isArray(_)) return x(_.map(S));
                        if (_.type === "concat" || _.type === "fill") {
                            let O = _.parts.map(S);
                            return x(Object.assign(Object.assign({}, _), {}, {
                                parts: O
                            }));
                        }
                        if (_.type === "if-break") {
                            let O = _.breakContents && S(_.breakContents), R = _.flatContents && S(_.flatContents);
                            return x(Object.assign(Object.assign({}, _), {}, {
                                breakContents: O,
                                flatContents: R
                            }));
                        }
                        if (_.type === "group" && _.expandedStates) {
                            let O = _.expandedStates.map(S), R = O[0];
                            return x(Object.assign(Object.assign({}, _), {}, {
                                contents: R,
                                expandedStates: O
                            }));
                        }
                        if (_.contents) {
                            let O = S(_.contents);
                            return x(Object.assign(Object.assign({}, _), {}, {
                                contents: O
                            }));
                        }
                        return x(_);
                    }
                }
                function C(o, x, F) {
                    let S = F, k = !1;
                    function _(O) {
                        let R = x(O);
                        if (R !== void 0 && (k = !0, S = R), k) return !1;
                    }
                    return c(o, _), S;
                }
                function m(o) {
                    if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent") return !0;
                }
                function g(o) {
                    return C(o, m, !1);
                }
                function p(o) {
                    if (o.length > 0) {
                        let x = t(o);
                        !x.expandedStates && !x.break && (x.break = "propagated");
                    }
                    return null;
                }
                function f(o) {
                    let x = new Set, F = [];
                    function S(_) {
                        if (_.type === "break-parent" && p(F), _.type === "group") {
                            if (F.push(_), x.has(_)) return !1;
                            x.add(_);
                        }
                    }
                    function k(_) {
                        _.type === "group" && F.pop().break && p(F);
                    }
                    c(o, S, k, !0);
                }
                function h(o) {
                    return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
                }
                function N(o) {
                    return l(o, h);
                }
                var T = (o, x)=>o && o.type === "line" && o.hard && x && x.type === "break-parent";
                function A(o) {
                    if (!o) return o;
                    if (r(o) || o.type === "fill") {
                        let x = u(o);
                        for(; x.length > 1 && T(...x.slice(-2));)x.length -= 2;
                        if (x.length > 0) {
                            let F = A(t(x));
                            x[x.length - 1] = F;
                        }
                        return Array.isArray(o) ? x : Object.assign(Object.assign({}, o), {}, {
                            parts: x
                        });
                    }
                    switch(o.type){
                        case "align":
                        case "indent":
                        case "indent-if-break":
                        case "group":
                        case "line-suffix":
                        case "label":
                            {
                                let x = A(o.contents);
                                return Object.assign(Object.assign({}, o), {}, {
                                    contents: x
                                });
                            }
                        case "if-break":
                            {
                                let x = A(o.breakContents), F = A(o.flatContents);
                                return Object.assign(Object.assign({}, o), {}, {
                                    breakContents: x,
                                    flatContents: F
                                });
                            }
                    }
                    return o;
                }
                function b(o) {
                    return A(B(o));
                }
                function v(o) {
                    switch(o.type){
                        case "fill":
                            if (o.parts.every((F)=>F === "")) return "";
                            break;
                        case "group":
                            if (!o.contents && !o.id && !o.break && !o.expandedStates) return "";
                            if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates) return o.contents;
                            break;
                        case "align":
                        case "indent":
                        case "indent-if-break":
                        case "line-suffix":
                            if (!o.contents) return "";
                            break;
                        case "if-break":
                            if (!o.flatContents && !o.breakContents) return "";
                            break;
                    }
                    if (!r(o)) return o;
                    let x = [];
                    for (let F of u(o)){
                        if (!F) continue;
                        let [S, ...k] = r(F) ? u(F) : [
                            F
                        ];
                        typeof S == "string" && typeof t(x) == "string" ? x[x.length - 1] += S : x.push(S), x.push(...k);
                    }
                    return x.length === 0 ? "" : x.length === 1 ? x[0] : Array.isArray(o) ? x : Object.assign(Object.assign({}, o), {}, {
                        parts: x
                    });
                }
                function B(o) {
                    return l(o, (x)=>v(x));
                }
                function w(o) {
                    let x = [], F = o.filter(Boolean);
                    for(; F.length > 0;){
                        let S = F.shift();
                        if (!!S) {
                            if (r(S)) {
                                F.unshift(...u(S));
                                continue;
                            }
                            if (x.length > 0 && typeof t(x) == "string" && typeof S == "string") {
                                x[x.length - 1] += S;
                                continue;
                            }
                            x.push(S);
                        }
                    }
                    return x;
                }
                function I(o) {
                    return l(o, (x)=>Array.isArray(x) ? w(x) : x.parts ? Object.assign(Object.assign({}, x), {}, {
                            parts: w(x.parts)
                        }) : x);
                }
                function E(o) {
                    return l(o, (x)=>typeof x == "string" && x.includes(`
`) ? D(x) : x);
                }
                function D(o) {
                    let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
                    return i(x, o.split(`
`)).parts;
                }
                function d(o) {
                    if (o.type === "line") return !0;
                }
                function y(o) {
                    return C(o, d, !1);
                }
                n.exports = {
                    isConcat: r,
                    getDocParts: u,
                    willBreak: g,
                    traverseDoc: c,
                    findInDoc: C,
                    mapDoc: l,
                    propagateBreaks: f,
                    removeLines: N,
                    stripTrailingHardline: b,
                    normalizeParts: w,
                    normalizeDoc: I,
                    cleanDoc: B,
                    replaceTextEndOfLine: D,
                    replaceEndOfLine: E,
                    canBreak: y
                };
            }
        }), uD = Z({
            "src/document/doc-printer.js" (e, n) {
                "use strict";
                ae();
                var { convertEndOfLineToChars: t } = On(), s = st(), i = yi(), { fill: r, cursor: u, indent: a } = Ln(), { isConcat: c, getDocParts: l } = jn(), C, m = 1, g = 2;
                function p() {
                    return {
                        value: "",
                        length: 0,
                        queue: []
                    };
                }
                function f(v, B) {
                    return N(v, {
                        type: "indent"
                    }, B);
                }
                function h(v, B, w) {
                    return B === Number.NEGATIVE_INFINITY ? v.root || p() : B < 0 ? N(v, {
                        type: "dedent"
                    }, w) : B ? B.type === "root" ? Object.assign(Object.assign({}, v), {}, {
                        root: v
                    }) : N(v, {
                        type: typeof B == "string" ? "stringAlign" : "numberAlign",
                        n: B
                    }, w) : v;
                }
                function N(v, B, w) {
                    let I = B.type === "dedent" ? v.queue.slice(0, -1) : [
                        ...v.queue,
                        B
                    ], E = "", D = 0, d = 0, y = 0;
                    for (let O of I)switch(O.type){
                        case "indent":
                            F(), w.useTabs ? o(1) : x(w.tabWidth);
                            break;
                        case "stringAlign":
                            F(), E += O.n, D += O.n.length;
                            break;
                        case "numberAlign":
                            d += 1, y += O.n;
                            break;
                        default:
                            throw new Error("Unexpected type '".concat(O.type, "'"));
                    }
                    return k(), Object.assign(Object.assign({}, v), {}, {
                        value: E,
                        length: D,
                        queue: I
                    });
                    function o(O) {
                        E += "	".repeat(O), D += w.tabWidth * O;
                    }
                    function x(O) {
                        E += " ".repeat(O), D += O;
                    }
                    function F() {
                        w.useTabs ? S() : k();
                    }
                    function S() {
                        d > 0 && o(d), _();
                    }
                    function k() {
                        y > 0 && x(y), _();
                    }
                    function _() {
                        d = 0, y = 0;
                    }
                }
                function T(v) {
                    if (v.length === 0) return 0;
                    let B = 0;
                    for(; v.length > 0 && typeof s(v) == "string" && /^[\t ]*$/.test(s(v));)B += v.pop().length;
                    if (v.length > 0 && typeof s(v) == "string") {
                        let w = s(v).replace(/[\t ]*$/, "");
                        B += s(v).length - w.length, v[v.length - 1] = w;
                    }
                    return B;
                }
                function A(v, B, w, I, E, D) {
                    let d = B.length, y = [
                        v
                    ], o = [];
                    for(; w >= 0;){
                        if (y.length === 0) {
                            if (d === 0) return !0;
                            y.push(B[d - 1]), d--;
                            continue;
                        }
                        let [x, F, S] = y.pop();
                        if (typeof S == "string") o.push(S), w -= i(S);
                        else if (c(S)) {
                            let k = l(S);
                            for(let _ = k.length - 1; _ >= 0; _--)y.push([
                                x,
                                F,
                                k[_]
                            ]);
                        } else switch(S.type){
                            case "indent":
                                y.push([
                                    f(x, I),
                                    F,
                                    S.contents
                                ]);
                                break;
                            case "align":
                                y.push([
                                    h(x, S.n, I),
                                    F,
                                    S.contents
                                ]);
                                break;
                            case "trim":
                                w += T(o);
                                break;
                            case "group":
                                {
                                    if (D && S.break) return !1;
                                    let k = S.break ? m : F;
                                    y.push([
                                        x,
                                        k,
                                        S.expandedStates && k === m ? s(S.expandedStates) : S.contents
                                    ]), S.id && (C[S.id] = k);
                                    break;
                                }
                            case "fill":
                                for(let k = S.parts.length - 1; k >= 0; k--)y.push([
                                    x,
                                    F,
                                    S.parts[k]
                                ]);
                                break;
                            case "if-break":
                            case "indent-if-break":
                                {
                                    let k = S.groupId ? C[S.groupId] : F;
                                    if (k === m) {
                                        let _ = S.type === "if-break" ? S.breakContents : S.negate ? S.contents : a(S.contents);
                                        _ && y.push([
                                            x,
                                            F,
                                            _
                                        ]);
                                    }
                                    if (k === g) {
                                        let _ = S.type === "if-break" ? S.flatContents : S.negate ? a(S.contents) : S.contents;
                                        _ && y.push([
                                            x,
                                            F,
                                            _
                                        ]);
                                    }
                                    break;
                                }
                            case "line":
                                switch(F){
                                    case g:
                                        if (!S.hard) {
                                            S.soft || (o.push(" "), w -= 1);
                                            break;
                                        }
                                        return !0;
                                    case m:
                                        return !0;
                                }
                                break;
                            case "line-suffix":
                                E = !0;
                                break;
                            case "line-suffix-boundary":
                                if (E) return !1;
                                break;
                            case "label":
                                y.push([
                                    x,
                                    F,
                                    S.contents
                                ]);
                                break;
                        }
                    }
                    return !1;
                }
                function b(v, B) {
                    C = {};
                    let w = B.printWidth, I = t(B.endOfLine), E = 0, D = [
                        [
                            p(),
                            m,
                            v
                        ]
                    ], d = [], y = !1, o = [];
                    for(; D.length > 0;){
                        let [F, S, k] = D.pop();
                        if (typeof k == "string") {
                            let _ = I !== `
` ? k.replace(/\n/g, I) : k;
                            d.push(_), E += i(_);
                        } else if (c(k)) {
                            let _ = l(k);
                            for(let O = _.length - 1; O >= 0; O--)D.push([
                                F,
                                S,
                                _[O]
                            ]);
                        } else switch(k.type){
                            case "cursor":
                                d.push(u.placeholder);
                                break;
                            case "indent":
                                D.push([
                                    f(F, B),
                                    S,
                                    k.contents
                                ]);
                                break;
                            case "align":
                                D.push([
                                    h(F, k.n, B),
                                    S,
                                    k.contents
                                ]);
                                break;
                            case "trim":
                                E -= T(d);
                                break;
                            case "group":
                                switch(S){
                                    case g:
                                        if (!y) {
                                            D.push([
                                                F,
                                                k.break ? m : g,
                                                k.contents
                                            ]);
                                            break;
                                        }
                                    case m:
                                        {
                                            y = !1;
                                            let _ = [
                                                F,
                                                g,
                                                k.contents
                                            ], O = w - E, R = o.length > 0;
                                            if (!k.break && A(_, D, O, B, R)) D.push(_);
                                            else if (k.expandedStates) {
                                                let M = s(k.expandedStates);
                                                if (k.break) {
                                                    D.push([
                                                        F,
                                                        m,
                                                        M
                                                    ]);
                                                    break;
                                                } else for(let H = 1; H < k.expandedStates.length + 1; H++)if (H >= k.expandedStates.length) {
                                                    D.push([
                                                        F,
                                                        m,
                                                        M
                                                    ]);
                                                    break;
                                                } else {
                                                    let P = k.expandedStates[H], G = [
                                                        F,
                                                        g,
                                                        P
                                                    ];
                                                    if (A(G, D, O, B, R)) {
                                                        D.push(G);
                                                        break;
                                                    }
                                                }
                                            } else D.push([
                                                F,
                                                m,
                                                k.contents
                                            ]);
                                            break;
                                        }
                                }
                                k.id && (C[k.id] = s(D)[1]);
                                break;
                            case "fill":
                                {
                                    let _ = w - E, { parts: O } = k;
                                    if (O.length === 0) break;
                                    let [R, M] = O, H = [
                                        F,
                                        g,
                                        R
                                    ], P = [
                                        F,
                                        m,
                                        R
                                    ], G = A(H, [], _, B, o.length > 0, !0);
                                    if (O.length === 1) {
                                        G ? D.push(H) : D.push(P);
                                        break;
                                    }
                                    let re = [
                                        F,
                                        g,
                                        M
                                    ], $ = [
                                        F,
                                        m,
                                        M
                                    ];
                                    if (O.length === 2) {
                                        G ? D.push(re, H) : D.push($, P);
                                        break;
                                    }
                                    O.splice(0, 2);
                                    let W = [
                                        F,
                                        S,
                                        r(O)
                                    ], ee = O[0];
                                    A([
                                        F,
                                        g,
                                        [
                                            R,
                                            M,
                                            ee
                                        ]
                                    ], [], _, B, o.length > 0, !0) ? D.push(W, re, H) : G ? D.push(W, $, H) : D.push(W, $, P);
                                    break;
                                }
                            case "if-break":
                            case "indent-if-break":
                                {
                                    let _ = k.groupId ? C[k.groupId] : S;
                                    if (_ === m) {
                                        let O = k.type === "if-break" ? k.breakContents : k.negate ? k.contents : a(k.contents);
                                        O && D.push([
                                            F,
                                            S,
                                            O
                                        ]);
                                    }
                                    if (_ === g) {
                                        let O = k.type === "if-break" ? k.flatContents : k.negate ? a(k.contents) : k.contents;
                                        O && D.push([
                                            F,
                                            S,
                                            O
                                        ]);
                                    }
                                    break;
                                }
                            case "line-suffix":
                                o.push([
                                    F,
                                    S,
                                    k.contents
                                ]);
                                break;
                            case "line-suffix-boundary":
                                o.length > 0 && D.push([
                                    F,
                                    S,
                                    {
                                        type: "line",
                                        hard: !0
                                    }
                                ]);
                                break;
                            case "line":
                                switch(S){
                                    case g:
                                        if (k.hard) y = !0;
                                        else {
                                            k.soft || (d.push(" "), E += 1);
                                            break;
                                        }
                                    case m:
                                        if (o.length > 0) {
                                            D.push([
                                                F,
                                                S,
                                                k
                                            ], ...o.reverse()), o = [];
                                            break;
                                        }
                                        k.literal ? F.root ? (d.push(I, F.root.value), E = F.root.length) : (d.push(I), E = 0) : (E -= T(d), d.push(I + F.value), E = F.length);
                                        break;
                                }
                                break;
                            case "label":
                                D.push([
                                    F,
                                    S,
                                    k.contents
                                ]);
                                break;
                            default:
                        }
                        D.length === 0 && o.length > 0 && (D.push(...o.reverse()), o = []);
                    }
                    let x = d.indexOf(u.placeholder);
                    if (x !== -1) {
                        let F = d.indexOf(u.placeholder, x + 1), S = d.slice(0, x).join(""), k = d.slice(x + 1, F).join(""), _ = d.slice(F + 1).join("");
                        return {
                            formatted: S + k + _,
                            cursorNodeStart: S.length,
                            cursorNodeText: k
                        };
                    }
                    return {
                        formatted: d.join("")
                    };
                }
                n.exports = {
                    printDocToString: b
                };
            }
        }), sD = Z({
            "src/document/doc-debug.js" (e, n) {
                "use strict";
                ae();
                var { isConcat: t, getDocParts: s } = jn();
                function i(u) {
                    if (!u) return "";
                    if (t(u)) {
                        let a = [];
                        for (let c of s(u))if (t(c)) a.push(...i(c).parts);
                        else {
                            let l = i(c);
                            l !== "" && a.push(l);
                        }
                        return {
                            type: "concat",
                            parts: a
                        };
                    }
                    return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, {
                        breakContents: i(u.breakContents),
                        flatContents: i(u.flatContents)
                    }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, {
                        contents: i(u.contents),
                        expandedStates: u.expandedStates && u.expandedStates.map(i)
                    }) : u.type === "fill" ? {
                        type: "fill",
                        parts: u.parts.map(i)
                    } : u.contents ? Object.assign(Object.assign({}, u), {}, {
                        contents: i(u.contents)
                    }) : u;
                }
                function r(u) {
                    let a = Object.create(null), c = new Set;
                    return l(i(u));
                    function l(m, g, p) {
                        if (typeof m == "string") return JSON.stringify(m);
                        if (t(m)) {
                            let f = s(m).map(l).filter(Boolean);
                            return f.length === 1 ? f[0] : "[".concat(f.join(", "), "]");
                        }
                        if (m.type === "line") {
                            let f = Array.isArray(p) && p[g + 1] && p[g + 1].type === "break-parent";
                            return m.literal ? f ? "literalline" : "literallineWithoutBreakParent" : m.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : m.soft ? "softline" : "line";
                        }
                        if (m.type === "break-parent") return Array.isArray(p) && p[g - 1] && p[g - 1].type === "line" && p[g - 1].hard ? void 0 : "breakParent";
                        if (m.type === "trim") return "trim";
                        if (m.type === "indent") return "indent(" + l(m.contents) + ")";
                        if (m.type === "align") return m.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + l(m.contents) + ")" : m.n < 0 ? "dedent(" + l(m.contents) + ")" : m.n.type === "root" ? "markAsRoot(" + l(m.contents) + ")" : "align(" + JSON.stringify(m.n) + ", " + l(m.contents) + ")";
                        if (m.type === "if-break") return "ifBreak(" + l(m.breakContents) + (m.flatContents ? ", " + l(m.flatContents) : "") + (m.groupId ? (m.flatContents ? "" : ', ""') + ", { groupId: ".concat(C(m.groupId), " }") : "") + ")";
                        if (m.type === "indent-if-break") {
                            let f = [];
                            m.negate && f.push("negate: true"), m.groupId && f.push("groupId: ".concat(C(m.groupId)));
                            let h = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                            return "indentIfBreak(".concat(l(m.contents)).concat(h, ")");
                        }
                        if (m.type === "group") {
                            let f = [];
                            m.break && m.break !== "propagated" && f.push("shouldBreak: true"), m.id && f.push("id: ".concat(C(m.id)));
                            let h = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                            return m.expandedStates ? "conditionalGroup([".concat(m.expandedStates.map((N)=>l(N)).join(","), "]").concat(h, ")") : "group(".concat(l(m.contents)).concat(h, ")");
                        }
                        if (m.type === "fill") return "fill([".concat(m.parts.map((f)=>l(f)).join(", "), "])");
                        if (m.type === "line-suffix") return "lineSuffix(" + l(m.contents) + ")";
                        if (m.type === "line-suffix-boundary") return "lineSuffixBoundary";
                        if (m.type === "label") return "label(".concat(JSON.stringify(m.label), ", ").concat(l(m.contents), ")");
                        throw new Error("Unknown doc type " + m.type);
                    }
                    function C(m) {
                        if (typeof m != "symbol") return JSON.stringify(String(m));
                        if (m in a) return a[m];
                        let g = String(m).slice(7, -1) || "symbol";
                        for(let p = 0;; p++){
                            let f = g + (p > 0 ? " #".concat(p) : "");
                            if (!c.has(f)) return c.add(f), a[m] = "Symbol.for(".concat(JSON.stringify(f), ")");
                        }
                    }
                }
                n.exports = {
                    printDocToDebug: r
                };
            }
        }), Le = Z({
            "src/document/index.js" (e, n) {
                "use strict";
                ae(), n.exports = {
                    builders: Ln(),
                    printer: uD(),
                    utils: jn(),
                    debug: sD()
                };
            }
        }), aD = Z({
            "vendors/escape-string-regexp.js" (e, n) {
                ae();
                var t = Object.defineProperty, s = Object.getOwnPropertyDescriptor, i = Object.getOwnPropertyNames, r = Object.prototype.hasOwnProperty, u = (m, g)=>{
                    for(var p in g)t(m, p, {
                        get: g[p],
                        enumerable: !0
                    });
                }, a = (m, g, p, f)=>{
                    if (g && typeof g == "object" || typeof g == "function") for (let h of i(g))!r.call(m, h) && h !== p && t(m, h, {
                        get: ()=>g[h],
                        enumerable: !(f = s(g, h)) || f.enumerable
                    });
                    return m;
                }, c = (m)=>a(t({}, "__esModule", {
                        value: !0
                    }), m), l = {};
                u(l, {
                    default: ()=>C
                }), n.exports = c(l);
                function C(m) {
                    if (typeof m != "string") throw new TypeError("Expected a string");
                    return m.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
                }
            }
        }), hi = Z({
            "node_modules/semver/internal/debug.js" (e, n) {
                ae();
                var t = typeof xt == "object" && xt.env && xt.env.NODE_DEBUG && /\bsemver\b/i.test(xt.env.NODE_DEBUG) ? function() {
                    for(var s = arguments.length, i = new Array(s), r = 0; r < s; r++)i[r] = arguments[r];
                    return console.error("SEMVER", ...i);
                } : ()=>{};
                n.exports = t;
            }
        }), Ci = Z({
            "node_modules/semver/internal/constants.js" (e, n) {
                ae();
                var t = "2.0.0", s = 256, i = Number.MAX_SAFE_INTEGER || 9007199254740991, r = 16;
                n.exports = {
                    SEMVER_SPEC_VERSION: t,
                    MAX_LENGTH: s,
                    MAX_SAFE_INTEGER: i,
                    MAX_SAFE_COMPONENT_LENGTH: r
                };
            }
        }), iD = Z({
            "node_modules/semver/internal/re.js" (e, n) {
                ae();
                var { MAX_SAFE_COMPONENT_LENGTH: t } = Ci(), s = hi();
                e = n.exports = {};
                var i = e.re = [], r = e.src = [], u = e.t = {}, a = 0, c = (l, C, m)=>{
                    let g = a++;
                    s(g, C), u[l] = g, r[g] = C, i[g] = new RegExp(C, m ? "g" : void 0);
                };
                c("NUMERICIDENTIFIER", "0|[1-9]\\d*"), c("NUMERICIDENTIFIERLOOSE", "[0-9]+"), c("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), c("MAINVERSION", "(".concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")")), c("MAINVERSIONLOOSE", "(".concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")")), c("PRERELEASEIDENTIFIER", "(?:".concat(r[u.NUMERICIDENTIFIER], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), c("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(r[u.NUMERICIDENTIFIERLOOSE], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), c("PRERELEASE", "(?:-(".concat(r[u.PRERELEASEIDENTIFIER], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIER], ")*))")), c("PRERELEASELOOSE", "(?:-?(".concat(r[u.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIERLOOSE], ")*))")), c("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), c("BUILD", "(?:\\+(".concat(r[u.BUILDIDENTIFIER], "(?:\\.").concat(r[u.BUILDIDENTIFIER], ")*))")), c("FULLPLAIN", "v?".concat(r[u.MAINVERSION]).concat(r[u.PRERELEASE], "?").concat(r[u.BUILD], "?")), c("FULL", "^".concat(r[u.FULLPLAIN], "$")), c("LOOSEPLAIN", "[v=\\s]*".concat(r[u.MAINVERSIONLOOSE]).concat(r[u.PRERELEASELOOSE], "?").concat(r[u.BUILD], "?")), c("LOOSE", "^".concat(r[u.LOOSEPLAIN], "$")), c("GTLT", "((?:<|>)?=?)"), c("XRANGEIDENTIFIERLOOSE", "".concat(r[u.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), c("XRANGEIDENTIFIER", "".concat(r[u.NUMERICIDENTIFIER], "|x|X|\\*")), c("XRANGEPLAIN", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:").concat(r[u.PRERELEASE], ")?").concat(r[u.BUILD], "?)?)?")), c("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:").concat(r[u.PRERELEASELOOSE], ")?").concat(r[u.BUILD], "?)?)?")), c("XRANGE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAIN], "$")), c("XRANGELOOSE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAINLOOSE], "$")), c("COERCE", "(^|[^\\d])(\\d{1,".concat(t, "})(?:\\.(\\d{1,").concat(t, "}))?(?:\\.(\\d{1,").concat(t, "}))?(?:$|[^\\d])")), c("COERCERTL", r[u.COERCE], !0), c("LONETILDE", "(?:~>?)"), c("TILDETRIM", "(\\s*)".concat(r[u.LONETILDE], "\\s+"), !0), e.tildeTrimReplace = "$1~", c("TILDE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAIN], "$")), c("TILDELOOSE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAINLOOSE], "$")), c("LONECARET", "(?:\\^)"), c("CARETTRIM", "(\\s*)".concat(r[u.LONECARET], "\\s+"), !0), e.caretTrimReplace = "$1^", c("CARET", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAIN], "$")), c("CARETLOOSE", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAINLOOSE], "$")), c("COMPARATORLOOSE", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], ")$|^$")), c("COMPARATOR", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.FULLPLAIN], ")$|^$")), c("COMPARATORTRIM", "(\\s*)".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], "|").concat(r[u.XRANGEPLAIN], ")"), !0), e.comparatorTrimReplace = "$1$2$3", c("HYPHENRANGE", "^\\s*(".concat(r[u.XRANGEPLAIN], ")\\s+-\\s+(").concat(r[u.XRANGEPLAIN], ")\\s*$")), c("HYPHENRANGELOOSE", "^\\s*(".concat(r[u.XRANGEPLAINLOOSE], ")\\s+-\\s+(").concat(r[u.XRANGEPLAINLOOSE], ")\\s*$")), c("STAR", "(<|>)?=?\\s*\\*"), c("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), c("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
            }
        }), oD = Z({
            "node_modules/semver/internal/parse-options.js" (e, n) {
                ae();
                var t = [
                    "includePrerelease",
                    "loose",
                    "rtl"
                ], s = (i)=>i ? typeof i != "object" ? {
                        loose: !0
                    } : t.filter((r)=>i[r]).reduce((r, u)=>(r[u] = !0, r), {}) : {};
                n.exports = s;
            }
        }), cD = Z({
            "node_modules/semver/internal/identifiers.js" (e, n) {
                ae();
                var t = /^[0-9]+$/, s = (r, u)=>{
                    let a = t.test(r), c = t.test(u);
                    return a && c && (r = +r, u = +u), r === u ? 0 : a && !c ? -1 : c && !a ? 1 : r < u ? -1 : 1;
                }, i = (r, u)=>s(u, r);
                n.exports = {
                    compareIdentifiers: s,
                    rcompareIdentifiers: i
                };
            }
        }), lD = Z({
            "node_modules/semver/classes/semver.js" (e, n) {
                ae();
                var t = hi(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: i } = Ci(), { re: r, t: u } = iD(), a = oD(), { compareIdentifiers: c } = cD(), l = class {
                    constructor(C, m){
                        if (m = a(m), C instanceof l) {
                            if (C.loose === !!m.loose && C.includePrerelease === !!m.includePrerelease) return C;
                            C = C.version;
                        } else if (typeof C != "string") throw new TypeError("Invalid Version: ".concat(C));
                        if (C.length > s) throw new TypeError("version is longer than ".concat(s, " characters"));
                        t("SemVer", C, m), this.options = m, this.loose = !!m.loose, this.includePrerelease = !!m.includePrerelease;
                        let g = C.trim().match(m.loose ? r[u.LOOSE] : r[u.FULL]);
                        if (!g) throw new TypeError("Invalid Version: ".concat(C));
                        if (this.raw = C, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > i || this.major < 0) throw new TypeError("Invalid major version");
                        if (this.minor > i || this.minor < 0) throw new TypeError("Invalid minor version");
                        if (this.patch > i || this.patch < 0) throw new TypeError("Invalid patch version");
                        g[4] ? this.prerelease = g[4].split(".").map((p)=>{
                            if (/^[0-9]+$/.test(p)) {
                                let f = +p;
                                if (f >= 0 && f < i) return f;
                            }
                            return p;
                        }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
                    }
                    format() {
                        return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
                    }
                    toString() {
                        return this.version;
                    }
                    compare(C) {
                        if (t("SemVer.compare", this.version, this.options, C), !(C instanceof l)) {
                            if (typeof C == "string" && C === this.version) return 0;
                            C = new l(C, this.options);
                        }
                        return C.version === this.version ? 0 : this.compareMain(C) || this.comparePre(C);
                    }
                    compareMain(C) {
                        return C instanceof l || (C = new l(C, this.options)), c(this.major, C.major) || c(this.minor, C.minor) || c(this.patch, C.patch);
                    }
                    comparePre(C) {
                        if (C instanceof l || (C = new l(C, this.options)), this.prerelease.length && !C.prerelease.length) return -1;
                        if (!this.prerelease.length && C.prerelease.length) return 1;
                        if (!this.prerelease.length && !C.prerelease.length) return 0;
                        let m = 0;
                        do {
                            let g = this.prerelease[m], p = C.prerelease[m];
                            if (t("prerelease compare", m, g, p), g === void 0 && p === void 0) return 0;
                            if (p === void 0) return 1;
                            if (g === void 0) return -1;
                            if (g === p) continue;
                            return c(g, p);
                        }while (++m);
                    }
                    compareBuild(C) {
                        C instanceof l || (C = new l(C, this.options));
                        let m = 0;
                        do {
                            let g = this.build[m], p = C.build[m];
                            if (t("prerelease compare", m, g, p), g === void 0 && p === void 0) return 0;
                            if (p === void 0) return 1;
                            if (g === void 0) return -1;
                            if (g === p) continue;
                            return c(g, p);
                        }while (++m);
                    }
                    inc(C, m) {
                        switch(C){
                            case "premajor":
                                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", m);
                                break;
                            case "preminor":
                                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", m);
                                break;
                            case "prepatch":
                                this.prerelease.length = 0, this.inc("patch", m), this.inc("pre", m);
                                break;
                            case "prerelease":
                                this.prerelease.length === 0 && this.inc("patch", m), this.inc("pre", m);
                                break;
                            case "major":
                                (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                                break;
                            case "minor":
                                (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                                break;
                            case "patch":
                                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                                break;
                            case "pre":
                                if (this.prerelease.length === 0) this.prerelease = [
                                    0
                                ];
                                else {
                                    let g = this.prerelease.length;
                                    for(; --g >= 0;)typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
                                    g === -1 && this.prerelease.push(0);
                                }
                                m && (this.prerelease[0] === m ? isNaN(this.prerelease[1]) && (this.prerelease = [
                                    m,
                                    0
                                ]) : this.prerelease = [
                                    m,
                                    0
                                ]);
                                break;
                            default:
                                throw new Error("invalid increment argument: ".concat(C));
                        }
                        return this.format(), this.raw = this.version, this;
                    }
                };
                n.exports = l;
            }
        }), qn = Z({
            "node_modules/semver/functions/compare.js" (e, n) {
                ae();
                var t = lD(), s = (i, r, u)=>new t(i, u).compare(new t(r, u));
                n.exports = s;
            }
        }), pD = Z({
            "node_modules/semver/functions/lt.js" (e, n) {
                ae();
                var t = qn(), s = (i, r, u)=>t(i, r, u) < 0;
                n.exports = s;
            }
        }), fD = Z({
            "node_modules/semver/functions/gte.js" (e, n) {
                ae();
                var t = qn(), s = (i, r, u)=>t(i, r, u) >= 0;
                n.exports = s;
            }
        }), DD = Z({
            "src/utils/arrayify.js" (e, n) {
                "use strict";
                ae(), n.exports = (t, s)=>Object.entries(t).map((i)=>{
                        let [r, u] = i;
                        return Object.assign({
                            [s]: r
                        }, u);
                    });
            }
        }), mD = Z({
            "node_modules/outdent/lib/index.js" (e, n) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.outdent = void 0;
                function t() {
                    for(var A = [], b = 0; b < arguments.length; b++)A[b] = arguments[b];
                }
                function s() {
                    return typeof WeakMap < "u" ? new WeakMap : i();
                }
                function i() {
                    return {
                        add: t,
                        delete: t,
                        get: t,
                        set: t,
                        has: function(A) {
                            return !1;
                        }
                    };
                }
                var r = Object.prototype.hasOwnProperty, u = function(A, b) {
                    return r.call(A, b);
                };
                function a(A, b) {
                    for(var v in b)u(b, v) && (A[v] = b[v]);
                    return A;
                }
                var c = /^[ \t]*(?:\r\n|\r|\n)/, l = /(?:\r\n|\r|\n)[ \t]*$/, C = /^(?:[\r\n]|$)/, m = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
                function p(A, b, v) {
                    var B = 0, w = A[0].match(m);
                    w && (B = w[1].length);
                    var I = "(\\r\\n|\\r|\\n).{0," + B + "}", E = new RegExp(I, "g");
                    b && (A = A.slice(1));
                    var D = v.newline, d = v.trimLeadingNewline, y = v.trimTrailingNewline, o = typeof D == "string", x = A.length, F = A.map(function(S, k) {
                        return S = S.replace(E, "$1"), k === 0 && d && (S = S.replace(c, "")), k === x - 1 && y && (S = S.replace(l, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(_) {
                            return D;
                        })), S;
                    });
                    return F;
                }
                function f(A, b) {
                    for(var v = "", B = 0, w = A.length; B < w; B++)v += A[B], B < w - 1 && (v += b[B]);
                    return v;
                }
                function h(A) {
                    return u(A, "raw") && u(A, "length");
                }
                function N(A) {
                    var b = s(), v = s();
                    function B(I) {
                        for(var E = [], D = 1; D < arguments.length; D++)E[D - 1] = arguments[D];
                        if (h(I)) {
                            var d = I, y = (E[0] === B || E[0] === T) && g.test(d[0]) && C.test(d[1]), o = y ? v : b, x = o.get(d);
                            if (x || (x = p(d, y, A), o.set(d, x)), E.length === 0) return x[0];
                            var F = f(x, y ? E.slice(1) : E);
                            return F;
                        } else return N(a(a({}, A), I || {}));
                    }
                    var w = a(B, {
                        string: function(I) {
                            return p([
                                I
                            ], !1, A)[0];
                        }
                    });
                    return w;
                }
                var T = N({
                    trimLeadingNewline: !0,
                    trimTrailingNewline: !0
                });
                if (e.outdent = T, e.default = T, typeof n < "u") try {
                    n.exports = T, Object.defineProperty(T, "__esModule", {
                        value: !0
                    }), T.default = T, T.outdent = T;
                } catch  {}
            }
        }), dD = Z({
            "src/main/core-options.js" (e, n) {
                "use strict";
                ae();
                var { outdent: t } = mD(), s = "Config", i = "Editor", r = "Format", u = "Other", a = "Output", c = "Global", l = "Special", C = {
                    cursorOffset: {
                        since: "1.4.0",
                        category: l,
                        type: "int",
                        default: -1,
                        range: {
                            start: -1,
                            end: Number.POSITIVE_INFINITY,
                            step: 1
                        },
                        description: t(si || (si = wt([
                            `
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `
                        ]))),
                        cliCategory: i
                    },
                    endOfLine: {
                        since: "1.15.0",
                        category: c,
                        type: "choice",
                        default: [
                            {
                                since: "1.15.0",
                                value: "auto"
                            },
                            {
                                since: "2.0.0",
                                value: "lf"
                            }
                        ],
                        description: "Which end of line characters to apply.",
                        choices: [
                            {
                                value: "lf",
                                description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
                            },
                            {
                                value: "crlf",
                                description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
                            },
                            {
                                value: "cr",
                                description: "Carriage Return character only (\\r), used very rarely"
                            },
                            {
                                value: "auto",
                                description: t(ai || (ai = wt([
                                    `
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `
                                ])))
                            }
                        ]
                    },
                    filepath: {
                        since: "1.4.0",
                        category: l,
                        type: "path",
                        description: "Specify the input filepath. This will be used to do parser inference.",
                        cliName: "stdin-filepath",
                        cliCategory: u,
                        cliDescription: "Path to the file to pretend that stdin comes from."
                    },
                    insertPragma: {
                        since: "1.8.0",
                        category: l,
                        type: "boolean",
                        default: !1,
                        description: "Insert @format pragma into file's first docblock comment.",
                        cliCategory: u
                    },
                    parser: {
                        since: "0.0.10",
                        category: c,
                        type: "choice",
                        default: [
                            {
                                since: "0.0.10",
                                value: "babylon"
                            },
                            {
                                since: "1.13.0",
                                value: void 0
                            }
                        ],
                        description: "Which parser to use.",
                        exception: (m)=>typeof m == "string" || typeof m == "function",
                        choices: [
                            {
                                value: "flow",
                                description: "Flow"
                            },
                            {
                                value: "babel",
                                since: "1.16.0",
                                description: "JavaScript"
                            },
                            {
                                value: "babel-flow",
                                since: "1.16.0",
                                description: "Flow"
                            },
                            {
                                value: "babel-ts",
                                since: "2.0.0",
                                description: "TypeScript"
                            },
                            {
                                value: "typescript",
                                since: "1.4.0",
                                description: "TypeScript"
                            },
                            {
                                value: "acorn",
                                since: "2.6.0",
                                description: "JavaScript"
                            },
                            {
                                value: "espree",
                                since: "2.2.0",
                                description: "JavaScript"
                            },
                            {
                                value: "meriyah",
                                since: "2.2.0",
                                description: "JavaScript"
                            },
                            {
                                value: "css",
                                since: "1.7.1",
                                description: "CSS"
                            },
                            {
                                value: "less",
                                since: "1.7.1",
                                description: "Less"
                            },
                            {
                                value: "scss",
                                since: "1.7.1",
                                description: "SCSS"
                            },
                            {
                                value: "json",
                                since: "1.5.0",
                                description: "JSON"
                            },
                            {
                                value: "json5",
                                since: "1.13.0",
                                description: "JSON5"
                            },
                            {
                                value: "json-stringify",
                                since: "1.13.0",
                                description: "JSON.stringify"
                            },
                            {
                                value: "graphql",
                                since: "1.5.0",
                                description: "GraphQL"
                            },
                            {
                                value: "markdown",
                                since: "1.8.0",
                                description: "Markdown"
                            },
                            {
                                value: "mdx",
                                since: "1.15.0",
                                description: "MDX"
                            },
                            {
                                value: "vue",
                                since: "1.10.0",
                                description: "Vue"
                            },
                            {
                                value: "yaml",
                                since: "1.14.0",
                                description: "YAML"
                            },
                            {
                                value: "glimmer",
                                since: "2.3.0",
                                description: "Ember / Handlebars"
                            },
                            {
                                value: "html",
                                since: "1.15.0",
                                description: "HTML"
                            },
                            {
                                value: "angular",
                                since: "1.15.0",
                                description: "Angular"
                            },
                            {
                                value: "lwc",
                                since: "1.17.0",
                                description: "Lightning Web Components"
                            }
                        ]
                    },
                    plugins: {
                        since: "1.10.0",
                        type: "path",
                        array: !0,
                        default: [
                            {
                                value: []
                            }
                        ],
                        category: c,
                        description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
                        exception: (m)=>typeof m == "string" || typeof m == "object",
                        cliName: "plugin",
                        cliCategory: s
                    },
                    pluginSearchDirs: {
                        since: "1.13.0",
                        type: "path",
                        array: !0,
                        default: [
                            {
                                value: []
                            }
                        ],
                        category: c,
                        description: t(ii || (ii = wt([
                            `
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `
                        ]))),
                        exception: (m)=>typeof m == "string" || typeof m == "object",
                        cliName: "plugin-search-dir",
                        cliCategory: s
                    },
                    printWidth: {
                        since: "0.0.0",
                        category: c,
                        type: "int",
                        default: 80,
                        description: "The line length where Prettier will try wrap.",
                        range: {
                            start: 0,
                            end: Number.POSITIVE_INFINITY,
                            step: 1
                        }
                    },
                    rangeEnd: {
                        since: "1.4.0",
                        category: l,
                        type: "int",
                        default: Number.POSITIVE_INFINITY,
                        range: {
                            start: 0,
                            end: Number.POSITIVE_INFINITY,
                            step: 1
                        },
                        description: t(oi || (oi = wt([
                            `
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `
                        ]))),
                        cliCategory: i
                    },
                    rangeStart: {
                        since: "1.4.0",
                        category: l,
                        type: "int",
                        default: 0,
                        range: {
                            start: 0,
                            end: Number.POSITIVE_INFINITY,
                            step: 1
                        },
                        description: t(ci || (ci = wt([
                            `
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `
                        ]))),
                        cliCategory: i
                    },
                    requirePragma: {
                        since: "1.7.0",
                        category: l,
                        type: "boolean",
                        default: !1,
                        description: t(li || (li = wt([
                            `
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `
                        ]))),
                        cliCategory: u
                    },
                    tabWidth: {
                        type: "int",
                        category: c,
                        default: 2,
                        description: "Number of spaces per indentation level.",
                        range: {
                            start: 0,
                            end: Number.POSITIVE_INFINITY,
                            step: 1
                        }
                    },
                    useTabs: {
                        since: "1.0.0",
                        category: c,
                        type: "boolean",
                        default: !1,
                        description: "Indent with tabs instead of spaces."
                    },
                    embeddedLanguageFormatting: {
                        since: "2.1.0",
                        category: c,
                        type: "choice",
                        default: [
                            {
                                since: "2.1.0",
                                value: "auto"
                            }
                        ],
                        description: "Control how Prettier formats quoted code embedded in the file.",
                        choices: [
                            {
                                value: "auto",
                                description: "Format embedded code if Prettier can automatically identify it."
                            },
                            {
                                value: "off",
                                description: "Never automatically format embedded code."
                            }
                        ]
                    }
                };
                n.exports = {
                    CATEGORY_CONFIG: s,
                    CATEGORY_EDITOR: i,
                    CATEGORY_FORMAT: r,
                    CATEGORY_OTHER: u,
                    CATEGORY_OUTPUT: a,
                    CATEGORY_GLOBAL: c,
                    CATEGORY_SPECIAL: l,
                    options: C
                };
            }
        }), Mn = Z({
            "src/main/support.js" (e, n) {
                "use strict";
                ae();
                var t = {
                    compare: qn(),
                    lt: pD(),
                    gte: fD()
                }, s = DD(), i = gi().version, r = dD().options;
                function u() {
                    let { plugins: c = [], showUnreleased: l = !1, showDeprecated: C = !1, showInternal: m = !1 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = i.split("-", 1)[0], p = c.flatMap((A)=>A.languages || []).filter(h), f = s(Object.assign({}, ...c.map((A)=>{
                        let { options: b } = A;
                        return b;
                    }), r), "name").filter((A)=>h(A) && N(A)).sort((A, b)=>A.name === b.name ? 0 : A.name < b.name ? -1 : 1).map(T).map((A)=>{
                        A = Object.assign({}, A), Array.isArray(A.default) && (A.default = A.default.length === 1 ? A.default[0].value : A.default.filter(h).sort((v, B)=>t.compare(B.since, v.since))[0].value), Array.isArray(A.choices) && (A.choices = A.choices.filter((v)=>h(v) && N(v)), A.name === "parser" && a(A, p, c));
                        let b = Object.fromEntries(c.filter((v)=>v.defaultOptions && v.defaultOptions[A.name] !== void 0).map((v)=>[
                                v.name,
                                v.defaultOptions[A.name]
                            ]));
                        return Object.assign(Object.assign({}, A), {}, {
                            pluginDefaults: b
                        });
                    });
                    return {
                        languages: p,
                        options: f
                    };
                    function h(A) {
                        return l || !("since" in A) || A.since && t.gte(g, A.since);
                    }
                    function N(A) {
                        return C || !("deprecated" in A) || A.deprecated && t.lt(g, A.deprecated);
                    }
                    function T(A) {
                        if (m) return A;
                        let { cliName: b, cliCategory: v, cliDescription: B } = A;
                        return _n(A, zf);
                    }
                }
                function a(c, l, C) {
                    let m = new Set(c.choices.map((g)=>g.value));
                    for (let g of l)if (g.parsers) {
                        for (let p of g.parsers)if (!m.has(p)) {
                            m.add(p);
                            let f = C.find((N)=>N.parsers && N.parsers[p]), h = g.name;
                            f && f.name && (h += " (plugin: ".concat(f.name, ")")), c.choices.push({
                                value: p,
                                description: h
                            });
                        }
                    }
                }
                n.exports = {
                    getSupportInfo: u
                };
            }
        }), Rn = Z({
            "src/utils/is-non-empty-array.js" (e, n) {
                "use strict";
                ae();
                function t(s) {
                    return Array.isArray(s) && s.length > 0;
                }
                n.exports = t;
            }
        }), Tr = Z({
            "src/utils/text/skip.js" (e, n) {
                "use strict";
                ae();
                function t(a) {
                    return (c, l, C)=>{
                        let m = C && C.backwards;
                        if (l === !1) return !1;
                        let { length: g } = c, p = l;
                        for(; p >= 0 && p < g;){
                            let f = c.charAt(p);
                            if (a instanceof RegExp) {
                                if (!a.test(f)) return p;
                            } else if (!a.includes(f)) return p;
                            m ? p-- : p++;
                        }
                        return p === -1 || p === g ? p : !1;
                    };
                }
                var s = t(/\s/), i = t(" 	"), r = t(",; 	"), u = t(/[^\n\r]/);
                n.exports = {
                    skipWhitespace: s,
                    skipSpaces: i,
                    skipToLineEnd: r,
                    skipEverythingButNewLine: u
                };
            }
        }), Ei = Z({
            "src/utils/text/skip-inline-comment.js" (e, n) {
                "use strict";
                ae();
                function t(s, i) {
                    if (i === !1) return !1;
                    if (s.charAt(i) === "/" && s.charAt(i + 1) === "*") {
                        for(let r = i + 2; r < s.length; ++r)if (s.charAt(r) === "*" && s.charAt(r + 1) === "/") return r + 2;
                    }
                    return i;
                }
                n.exports = t;
            }
        }), vi = Z({
            "src/utils/text/skip-trailing-comment.js" (e, n) {
                "use strict";
                ae();
                var { skipEverythingButNewLine: t } = Tr();
                function s(i, r) {
                    return r === !1 ? !1 : i.charAt(r) === "/" && i.charAt(r + 1) === "/" ? t(i, r) : r;
                }
                n.exports = s;
            }
        }), Fi = Z({
            "src/utils/text/skip-newline.js" (e, n) {
                "use strict";
                ae();
                function t(s, i, r) {
                    let u = r && r.backwards;
                    if (i === !1) return !1;
                    let a = s.charAt(i);
                    if (u) {
                        if (s.charAt(i - 1) === "\r" && a === `
`) return i - 2;
                        if (a === `
` || a === "\r" || a === "\u2028" || a === "\u2029") return i - 1;
                    } else {
                        if (a === "\r" && s.charAt(i + 1) === `
`) return i + 2;
                        if (a === `
` || a === "\r" || a === "\u2028" || a === "\u2029") return i + 1;
                    }
                    return i;
                }
                n.exports = t;
            }
        }), gD = Z({
            "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js" (e, n) {
                "use strict";
                ae();
                var t = Ei(), s = Fi(), i = vi(), { skipSpaces: r } = Tr();
                function u(a, c) {
                    let l = null, C = c;
                    for(; C !== l;)l = C, C = r(a, C), C = t(a, C), C = i(a, C), C = s(a, C);
                    return C;
                }
                n.exports = u;
            }
        }), Ge = Z({
            "src/common/util.js" (e, n) {
                "use strict";
                ae();
                var { default: t } = aD(), s = st(), { getSupportInfo: i } = Mn(), r = Rn(), u = yi(), { skipWhitespace: a, skipSpaces: c, skipToLineEnd: l, skipEverythingButNewLine: C } = Tr(), m = Ei(), g = vi(), p = Fi(), f = gD(), h = ($)=>$[$.length - 2];
                function N($) {
                    return (W, ee, U)=>{
                        let ne = U && U.backwards;
                        if (ee === !1) return !1;
                        let { length: se } = W, V = ee;
                        for(; V >= 0 && V < se;){
                            let oe = W.charAt(V);
                            if ($ instanceof RegExp) {
                                if (!$.test(oe)) return V;
                            } else if (!$.includes(oe)) return V;
                            ne ? V-- : V++;
                        }
                        return V === -1 || V === se ? V : !1;
                    };
                }
                function T($, W) {
                    let ee = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, U = c($, ee.backwards ? W - 1 : W, ee), ne = p($, U, ee);
                    return U !== ne;
                }
                function A($, W, ee) {
                    for(let U = W; U < ee; ++U)if ($.charAt(U) === `
`) return !0;
                    return !1;
                }
                function b($, W, ee) {
                    let U = ee(W) - 1;
                    U = c($, U, {
                        backwards: !0
                    }), U = p($, U, {
                        backwards: !0
                    }), U = c($, U, {
                        backwards: !0
                    });
                    let ne = p($, U, {
                        backwards: !0
                    });
                    return U !== ne;
                }
                function v($, W) {
                    let ee = null, U = W;
                    for(; U !== ee;)ee = U, U = l($, U), U = m($, U), U = c($, U);
                    return U = g($, U), U = p($, U), U !== !1 && T($, U);
                }
                function B($, W, ee) {
                    return v($, ee(W));
                }
                function w($, W, ee) {
                    return f($, ee(W));
                }
                function I($, W, ee) {
                    return $.charAt(w($, W, ee));
                }
                function E($, W) {
                    let ee = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    return c($, ee.backwards ? W - 1 : W, ee) !== W;
                }
                function D($, W) {
                    let ee = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, U = 0;
                    for(let ne = ee; ne < $.length; ++ne)$[ne] === "	" ? U = U + W - U % W : U++;
                    return U;
                }
                function d($, W) {
                    let ee = $.lastIndexOf(`
`);
                    return ee === -1 ? 0 : D($.slice(ee + 1).match(/^[\t ]*/)[0], W);
                }
                function y($, W) {
                    let ee = {
                        quote: '"',
                        regex: /"/g,
                        escaped: "&quot;"
                    }, U = {
                        quote: "'",
                        regex: /'/g,
                        escaped: "&apos;"
                    }, ne = W === "'" ? U : ee, se = ne === U ? ee : U, V = ne;
                    if ($.includes(ne.quote) || $.includes(se.quote)) {
                        let oe = ($.match(ne.regex) || []).length, K = ($.match(se.regex) || []).length;
                        V = oe > K ? se : ne;
                    }
                    return V;
                }
                function o($, W) {
                    let ee = $.slice(1, -1), U = W.parser === "json" || W.parser === "json5" && W.quoteProps === "preserve" && !W.singleQuote ? '"' : W.__isInHtmlAttribute ? "'" : y(ee, W.singleQuote ? "'" : '"').quote;
                    return x(ee, U, !(W.parser === "css" || W.parser === "less" || W.parser === "scss" || W.__embeddedInHtml));
                }
                function x($, W, ee) {
                    let U = W === '"' ? "'" : '"', ne = /\\(.)|(["'])/gs, se = $.replace(ne, (V, oe, K)=>oe === U ? oe : K === W ? "\\" + K : K || (ee && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(oe) ? oe : "\\" + oe));
                    return W + se + W;
                }
                function F($) {
                    return $.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
                }
                function S($, W) {
                    let ee = $.match(new RegExp("(".concat(t(W), ")+"), "g"));
                    return ee === null ? 0 : ee.reduce((U, ne)=>Math.max(U, ne.length / W.length), 0);
                }
                function k($, W) {
                    let ee = $.match(new RegExp("(".concat(t(W), ")+"), "g"));
                    if (ee === null) return 0;
                    let U = new Map, ne = 0;
                    for (let se of ee){
                        let V = se.length / W.length;
                        U.set(V, !0), V > ne && (ne = V);
                    }
                    for(let se = 1; se < ne; se++)if (!U.get(se)) return se;
                    return ne + 1;
                }
                function _($, W) {
                    ($.comments || ($.comments = [])).push(W), W.printed = !1, W.nodeDescription = re($);
                }
                function O($, W) {
                    W.leading = !0, W.trailing = !1, _($, W);
                }
                function R($, W, ee) {
                    W.leading = !1, W.trailing = !1, ee && (W.marker = ee), _($, W);
                }
                function M($, W) {
                    W.leading = !1, W.trailing = !0, _($, W);
                }
                function H($, W) {
                    let { languages: ee } = i({
                        plugins: W.plugins
                    }), U = ee.find((ne)=>{
                        let { name: se } = ne;
                        return se.toLowerCase() === $;
                    }) || ee.find((ne)=>{
                        let { aliases: se } = ne;
                        return Array.isArray(se) && se.includes($);
                    }) || ee.find((ne)=>{
                        let { extensions: se } = ne;
                        return Array.isArray(se) && se.includes(".".concat($));
                    });
                    return U && U.parsers[0];
                }
                function P($) {
                    return $ && $.type === "front-matter";
                }
                function G($) {
                    let W = new WeakMap;
                    return function(ee) {
                        return W.has(ee) || W.set(ee, Symbol($)), W.get(ee);
                    };
                }
                function re($) {
                    let W = $.type || $.kind || "(unknown type)", ee = String($.name || $.id && (typeof $.id == "object" ? $.id.name : $.id) || $.key && (typeof $.key == "object" ? $.key.name : $.key) || $.value && (typeof $.value == "object" ? "" : String($.value)) || $.operator || "");
                    return ee.length > 20 && (ee = ee.slice(0, 19) + "\u2026"), W + (ee ? " " + ee : "");
                }
                n.exports = {
                    inferParserByLanguage: H,
                    getStringWidth: u,
                    getMaxContinuousCount: S,
                    getMinNotPresentContinuousCount: k,
                    getPenultimate: h,
                    getLast: s,
                    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f,
                    getNextNonSpaceNonCommentCharacterIndex: w,
                    getNextNonSpaceNonCommentCharacter: I,
                    skip: N,
                    skipWhitespace: a,
                    skipSpaces: c,
                    skipToLineEnd: l,
                    skipEverythingButNewLine: C,
                    skipInlineComment: m,
                    skipTrailingComment: g,
                    skipNewline: p,
                    isNextLineEmptyAfterIndex: v,
                    isNextLineEmpty: B,
                    isPreviousLineEmpty: b,
                    hasNewline: T,
                    hasNewlineInRange: A,
                    hasSpaces: E,
                    getAlignmentSize: D,
                    getIndentSize: d,
                    getPreferredQuote: y,
                    printString: o,
                    printNumber: F,
                    makeString: x,
                    addLeadingComment: O,
                    addDanglingComment: R,
                    addTrailingComment: M,
                    isFrontMatterNode: P,
                    isNonEmptyArray: r,
                    createGroupIdMapper: G
                };
            }
        }), Ai = {};
        kn(Ai, {
            basename: ()=>Bi,
            default: ()=>wi,
            delimiter: ()=>bn,
            dirname: ()=>Ti,
            extname: ()=>Ni,
            isAbsolute: ()=>Wn,
            join: ()=>xi,
            normalize: ()=>Vn,
            relative: ()=>bi,
            resolve: ()=>xr,
            sep: ()=>xn
        });
        function Si(e, n) {
            for(var t = 0, s = e.length - 1; s >= 0; s--){
                var i = e[s];
                i === "." ? e.splice(s, 1) : i === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
            }
            if (n) for(; t--; t)e.unshift("..");
            return e;
        }
        function xr() {
            for(var e = "", n = !1, t = arguments.length - 1; t >= -1 && !n; t--){
                var s = t >= 0 ? arguments[t] : "/";
                if (typeof s != "string") throw new TypeError("Arguments to path.resolve must be strings");
                if (!s) continue;
                e = s + "/" + e, n = s.charAt(0) === "/";
            }
            return e = Si($n(e.split("/"), function(i) {
                return !!i;
            }), !n).join("/"), (n ? "/" : "") + e || ".";
        }
        function Vn(e) {
            var n = Wn(e), t = _i(e, -1) === "/";
            return e = Si($n(e.split("/"), function(s) {
                return !!s;
            }), !n).join("/"), !e && !n && (e = "."), e && t && (e += "/"), (n ? "/" : "") + e;
        }
        function Wn(e) {
            return e.charAt(0) === "/";
        }
        function xi() {
            var e = Array.prototype.slice.call(arguments, 0);
            return Vn($n(e, function(n, t) {
                if (typeof n != "string") throw new TypeError("Arguments to path.join must be strings");
                return n;
            }).join("/"));
        }
        function bi(e, n) {
            e = xr(e).substr(1), n = xr(n).substr(1);
            function t(l) {
                for(var C = 0; C < l.length && l[C] === ""; C++);
                for(var m = l.length - 1; m >= 0 && l[m] === ""; m--);
                return C > m ? [] : l.slice(C, m - C + 1);
            }
            for(var s = t(e.split("/")), i = t(n.split("/")), r = Math.min(s.length, i.length), u = r, a = 0; a < r; a++)if (s[a] !== i[a]) {
                u = a;
                break;
            }
            for(var c = [], a = u; a < s.length; a++)c.push("..");
            return c = c.concat(i.slice(u)), c.join("/");
        }
        function Ti(e) {
            var n = Br(e), t = n[0], s = n[1];
            return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
        }
        function Bi(e, n) {
            var t = Br(e)[2];
            return n && t.substr(-1 * n.length) === n && (t = t.substr(0, t.length - n.length)), t;
        }
        function Ni(e) {
            return Br(e)[3];
        }
        function $n(e, n) {
            if (e.filter) return e.filter(n);
            for(var t = [], s = 0; s < e.length; s++)n(e[s], s, e) && t.push(e[s]);
            return t;
        }
        var Di, Br, xn, bn, wi, _i, yD = br({
            "node-modules-polyfills:path" () {
                ae(), Di = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Br = function(e) {
                    return Di.exec(e).slice(1);
                }, xn = "/", bn = ":", wi = {
                    extname: Ni,
                    basename: Bi,
                    dirname: Ti,
                    sep: xn,
                    delimiter: bn,
                    relative: bi,
                    join: xi,
                    isAbsolute: Wn,
                    normalize: Vn,
                    resolve: xr
                }, _i = "ab".substr(-1) === "b" ? function(e, n, t) {
                    return e.substr(n, t);
                } : function(e, n, t) {
                    return n < 0 && (n = e.length + n), e.substr(n, t);
                };
            }
        }), Pi = Z({
            "node-modules-polyfills-commonjs:path" (e, n) {
                ae();
                var t = (yD(), pt(Ai));
                if (t && t.default) {
                    n.exports = t.default;
                    for(let s in t)n.exports[s] = t[s];
                } else t && (n.exports = t);
            }
        }), Jt = Z({
            "src/common/errors.js" (e, n) {
                "use strict";
                ae();
                var t = class extends Error {
                }, s = class extends Error {
                }, i = class extends Error {
                }, r = class extends Error {
                };
                n.exports = {
                    ConfigError: t,
                    DebugError: s,
                    UndefinedParserError: i,
                    ArgExpansionBailout: r
                };
            }
        }), Dt = {};
        kn(Dt, {
            __assign: ()=>Sr,
            __asyncDelegator: ()=>wD,
            __asyncGenerator: ()=>ND,
            __asyncValues: ()=>_D,
            __await: ()=>Gt,
            __awaiter: ()=>AD,
            __classPrivateFieldGet: ()=>LD,
            __classPrivateFieldSet: ()=>OD,
            __createBinding: ()=>xD,
            __decorate: ()=>ED,
            __exportStar: ()=>bD,
            __extends: ()=>hD,
            __generator: ()=>SD,
            __importDefault: ()=>kD,
            __importStar: ()=>ID,
            __makeTemplateObject: ()=>PD,
            __metadata: ()=>FD,
            __param: ()=>vD,
            __read: ()=>Ii,
            __rest: ()=>CD,
            __spread: ()=>TD,
            __spreadArrays: ()=>BD,
            __values: ()=>Tn
        });
        function hD(e, n) {
            Ar(e, n);
            function t() {
                this.constructor = e;
            }
            e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t);
        }
        function CD(e, n) {
            var t = {};
            for(var s in e)Object.prototype.hasOwnProperty.call(e, s) && n.indexOf(s) < 0 && (t[s] = e[s]);
            if (e != null && typeof Object.getOwnPropertySymbols == "function") for(var i = 0, s = Object.getOwnPropertySymbols(e); i < s.length; i++)n.indexOf(s[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[i]) && (t[s[i]] = e[s[i]]);
            return t;
        }
        function ED(e, n, t, s) {
            var i = arguments.length, r = i < 3 ? n : s === null ? s = Object.getOwnPropertyDescriptor(n, t) : s, u;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function") r = Reflect.decorate(e, n, t, s);
            else for(var a = e.length - 1; a >= 0; a--)(u = e[a]) && (r = (i < 3 ? u(r) : i > 3 ? u(n, t, r) : u(n, t)) || r);
            return i > 3 && r && Object.defineProperty(n, t, r), r;
        }
        function vD(e, n) {
            return function(t, s) {
                n(t, s, e);
            };
        }
        function FD(e, n) {
            if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(e, n);
        }
        function AD(e, n, t, s) {
            function i(r) {
                return r instanceof t ? r : new t(function(u) {
                    u(r);
                });
            }
            return new (t || (t = Promise))(function(r, u) {
                function a(C) {
                    try {
                        l(s.next(C));
                    } catch (m) {
                        u(m);
                    }
                }
                function c(C) {
                    try {
                        l(s.throw(C));
                    } catch (m) {
                        u(m);
                    }
                }
                function l(C) {
                    C.done ? r(C.value) : i(C.value).then(a, c);
                }
                l((s = s.apply(e, n || [])).next());
            });
        }
        function SD(e, n) {
            var t = {
                label: 0,
                sent: function() {
                    if (r[0] & 1) throw r[1];
                    return r[1];
                },
                trys: [],
                ops: []
            }, s, i, r, u;
            return u = {
                next: a(0),
                throw: a(1),
                return: a(2)
            }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
                return this;
            }), u;
            function a(l) {
                return function(C) {
                    return c([
                        l,
                        C
                    ]);
                };
            }
            function c(l) {
                if (s) throw new TypeError("Generator is already executing.");
                for(; t;)try {
                    if (s = 1, i && (r = l[0] & 2 ? i.return : l[0] ? i.throw || ((r = i.return) && r.call(i), 0) : i.next) && !(r = r.call(i, l[1])).done) return r;
                    switch(i = 0, r && (l = [
                        l[0] & 2,
                        r.value
                    ]), l[0]){
                        case 0:
                        case 1:
                            r = l;
                            break;
                        case 4:
                            return t.label++, {
                                value: l[1],
                                done: !1
                            };
                        case 5:
                            t.label++, i = l[1], l = [
                                0
                            ];
                            continue;
                        case 7:
                            l = t.ops.pop(), t.trys.pop();
                            continue;
                        default:
                            if (r = t.trys, !(r = r.length > 0 && r[r.length - 1]) && (l[0] === 6 || l[0] === 2)) {
                                t = 0;
                                continue;
                            }
                            if (l[0] === 3 && (!r || l[1] > r[0] && l[1] < r[3])) {
                                t.label = l[1];
                                break;
                            }
                            if (l[0] === 6 && t.label < r[1]) {
                                t.label = r[1], r = l;
                                break;
                            }
                            if (r && t.label < r[2]) {
                                t.label = r[2], t.ops.push(l);
                                break;
                            }
                            r[2] && t.ops.pop(), t.trys.pop();
                            continue;
                    }
                    l = n.call(e, t);
                } catch (C) {
                    l = [
                        6,
                        C
                    ], i = 0;
                } finally{
                    s = r = 0;
                }
                if (l[0] & 5) throw l[1];
                return {
                    value: l[0] ? l[1] : void 0,
                    done: !0
                };
            }
        }
        function xD(e, n, t, s) {
            s === void 0 && (s = t), e[s] = n[t];
        }
        function bD(e, n) {
            for(var t in e)t !== "default" && !n.hasOwnProperty(t) && (n[t] = e[t]);
        }
        function Tn(e) {
            var n = typeof Symbol == "function" && Symbol.iterator, t = n && e[n], s = 0;
            if (t) return t.call(e);
            if (e && typeof e.length == "number") return {
                next: function() {
                    return e && s >= e.length && (e = void 0), {
                        value: e && e[s++],
                        done: !e
                    };
                }
            };
            throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function Ii(e, n) {
            var t = typeof Symbol == "function" && e[Symbol.iterator];
            if (!t) return e;
            var s = t.call(e), i, r = [], u;
            try {
                for(; (n === void 0 || n-- > 0) && !(i = s.next()).done;)r.push(i.value);
            } catch (a) {
                u = {
                    error: a
                };
            } finally{
                try {
                    i && !i.done && (t = s.return) && t.call(s);
                } finally{
                    if (u) throw u.error;
                }
            }
            return r;
        }
        function TD() {
            for(var e = [], n = 0; n < arguments.length; n++)e = e.concat(Ii(arguments[n]));
            return e;
        }
        function BD() {
            for(var e = 0, n = 0, t = arguments.length; n < t; n++)e += arguments[n].length;
            for(var s = Array(e), i = 0, n = 0; n < t; n++)for(var r = arguments[n], u = 0, a = r.length; u < a; u++, i++)s[i] = r[u];
            return s;
        }
        function Gt(e) {
            return this instanceof Gt ? (this.v = e, this) : new Gt(e);
        }
        function ND(e, n, t) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var s = t.apply(e, n || []), i, r = [];
            return i = {}, u("next"), u("throw"), u("return"), i[Symbol.asyncIterator] = function() {
                return this;
            }, i;
            function u(g) {
                s[g] && (i[g] = function(p) {
                    return new Promise(function(f, h) {
                        r.push([
                            g,
                            p,
                            f,
                            h
                        ]) > 1 || a(g, p);
                    });
                });
            }
            function a(g, p) {
                try {
                    c(s[g](p));
                } catch (f) {
                    m(r[0][3], f);
                }
            }
            function c(g) {
                g.value instanceof Gt ? Promise.resolve(g.value.v).then(l, C) : m(r[0][2], g);
            }
            function l(g) {
                a("next", g);
            }
            function C(g) {
                a("throw", g);
            }
            function m(g, p) {
                g(p), r.shift(), r.length && a(r[0][0], r[0][1]);
            }
        }
        function wD(e) {
            var n, t;
            return n = {}, s("next"), s("throw", function(i) {
                throw i;
            }), s("return"), n[Symbol.iterator] = function() {
                return this;
            }, n;
            function s(i, r) {
                n[i] = e[i] ? function(u) {
                    return (t = !t) ? {
                        value: Gt(e[i](u)),
                        done: i === "return"
                    } : r ? r(u) : u;
                } : r;
            }
        }
        function _D(e) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var n = e[Symbol.asyncIterator], t;
            return n ? n.call(e) : (e = typeof Tn == "function" ? Tn(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
                return this;
            }, t);
            function s(r) {
                t[r] = e[r] && function(u) {
                    return new Promise(function(a, c) {
                        u = e[r](u), i(a, c, u.done, u.value);
                    });
                };
            }
            function i(r, u, a, c) {
                Promise.resolve(c).then(function(l) {
                    r({
                        value: l,
                        done: a
                    });
                }, u);
            }
        }
        function PD(e, n) {
            return Object.defineProperty ? Object.defineProperty(e, "raw", {
                value: n
            }) : e.raw = n, e;
        }
        function ID(e) {
            if (e && e.__esModule) return e;
            var n = {};
            if (e != null) for(var t in e)Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);
            return n.default = e, n;
        }
        function kD(e) {
            return e && e.__esModule ? e : {
                default: e
            };
        }
        function LD(e, n) {
            if (!n.has(e)) throw new TypeError("attempted to get private field on non-instance");
            return n.get(e);
        }
        function OD(e, n, t) {
            if (!n.has(e)) throw new TypeError("attempted to set private field on non-instance");
            return n.set(e, t), t;
        }
        var Ar, Sr, gt = br({
            "node_modules/tslib/tslib.es6.js" () {
                ae(), Ar = function(e, n) {
                    return Ar = Object.setPrototypeOf || ({
                        __proto__: []
                    }) instanceof Array && function(t, s) {
                        t.__proto__ = s;
                    } || function(t, s) {
                        for(var i in s)s.hasOwnProperty(i) && (t[i] = s[i]);
                    }, Ar(e, n);
                }, Sr = function() {
                    return Sr = Object.assign || function(n) {
                        for(var t, s = 1, i = arguments.length; s < i; s++){
                            t = arguments[s];
                            for(var r in t)Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
                        }
                        return n;
                    }, Sr.apply(this, arguments);
                };
            }
        }), ki = Z({
            "node_modules/vnopts/lib/descriptors/api.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.apiDescriptor = {
                    key: (n)=>/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n) ? n : JSON.stringify(n),
                    value (n) {
                        if (n === null || typeof n != "object") return JSON.stringify(n);
                        if (Array.isArray(n)) return "[".concat(n.map((s)=>e.apiDescriptor.value(s)).join(", "), "]");
                        let t = Object.keys(n);
                        return t.length === 0 ? "{}" : "{ ".concat(t.map((s)=>"".concat(e.apiDescriptor.key(s), ": ").concat(e.apiDescriptor.value(n[s]))).join(", "), " }");
                    },
                    pair: (n)=>{
                        let { key: t, value: s } = n;
                        return e.apiDescriptor.value({
                            [t]: s
                        });
                    }
                };
            }
        }), jD = Z({
            "node_modules/vnopts/lib/descriptors/index.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = (gt(), pt(Dt));
                n.__exportStar(ki(), e);
            }
        }), Nr = Z({
            "scripts/build/shims/chalk.cjs" (e, n) {
                "use strict";
                ae();
                var t = (s)=>s;
                t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, n.exports = t;
            }
        }), Li = Z({
            "node_modules/vnopts/lib/handlers/deprecated/common.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = Nr();
                e.commonDeprecatedHandler = (t, s, i)=>{
                    let { descriptor: r } = i, u = [
                        "".concat(n.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t)), " is deprecated")
                    ];
                    return s && u.push("we now treat it as ".concat(n.default.blue(typeof s == "string" ? r.key(s) : r.pair(s)))), u.join("; ") + ".";
                };
            }
        }), qD = Z({
            "node_modules/vnopts/lib/handlers/deprecated/index.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = (gt(), pt(Dt));
                n.__exportStar(Li(), e);
            }
        }), MD = Z({
            "node_modules/vnopts/lib/handlers/invalid/common.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = Nr();
                e.commonInvalidHandler = (t, s, i)=>[
                        "Invalid ".concat(n.default.red(i.descriptor.key(t)), " value."),
                        "Expected ".concat(n.default.blue(i.schemas[t].expected(i)), ","),
                        "but received ".concat(n.default.red(i.descriptor.value(s)), ".")
                    ].join(" ");
            }
        }), Oi = Z({
            "node_modules/vnopts/lib/handlers/invalid/index.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = (gt(), pt(Dt));
                n.__exportStar(MD(), e);
            }
        }), RD = Z({
            "node_modules/vnopts/node_modules/leven/index.js" (e, n) {
                "use strict";
                ae();
                var t = [], s = [];
                n.exports = function(i, r) {
                    if (i === r) return 0;
                    var u = i;
                    i.length > r.length && (i = r, r = u);
                    var a = i.length, c = r.length;
                    if (a === 0) return c;
                    if (c === 0) return a;
                    for(; a > 0 && i.charCodeAt(~-a) === r.charCodeAt(~-c);)a--, c--;
                    if (a === 0) return c;
                    for(var l = 0; l < a && i.charCodeAt(l) === r.charCodeAt(l);)l++;
                    if (a -= l, c -= l, a === 0) return c;
                    for(var C, m, g, p, f = 0, h = 0; f < a;)s[l + f] = i.charCodeAt(l + f), t[f] = ++f;
                    for(; h < c;)for(C = r.charCodeAt(l + h), g = h++, m = h, f = 0; f < a; f++)p = C === s[l + f] ? g : g + 1, g = t[f], m = t[f] = g > m ? p > m ? m + 1 : p : p > g ? g + 1 : p;
                    return m;
                };
            }
        }), ji = Z({
            "node_modules/vnopts/lib/handlers/unknown/leven.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = Nr(), t = RD();
                e.levenUnknownHandler = (s, i, r)=>{
                    let { descriptor: u, logger: a, schemas: c } = r, l = [
                        "Ignored unknown option ".concat(n.default.yellow(u.pair({
                            key: s,
                            value: i
                        })), ".")
                    ], C = Object.keys(c).sort().find((m)=>t(s, m) < 3);
                    C && l.push("Did you mean ".concat(n.default.blue(u.key(C)), "?")), a.warn(l.join(" "));
                };
            }
        }), VD = Z({
            "node_modules/vnopts/lib/handlers/unknown/index.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = (gt(), pt(Dt));
                n.__exportStar(ji(), e);
            }
        }), WD = Z({
            "node_modules/vnopts/lib/handlers/index.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = (gt(), pt(Dt));
                n.__exportStar(qD(), e), n.__exportStar(Oi(), e), n.__exportStar(VD(), e);
            }
        }), yt = Z({
            "node_modules/vnopts/lib/schema.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = [
                    "default",
                    "expected",
                    "validate",
                    "deprecated",
                    "forward",
                    "redirect",
                    "overlap",
                    "preprocess",
                    "postprocess"
                ];
                function t(r, u) {
                    let a = new r(u), c = Object.create(a);
                    for (let l of n)l in u && (c[l] = i(u[l], a, s.prototype[l].length));
                    return c;
                }
                e.createSchema = t;
                var s = class {
                    constructor(r){
                        this.name = r.name;
                    }
                    static create(r) {
                        return t(this, r);
                    }
                    default(r) {}
                    expected(r) {
                        return "nothing";
                    }
                    validate(r, u) {
                        return !1;
                    }
                    deprecated(r, u) {
                        return !1;
                    }
                    forward(r, u) {}
                    redirect(r, u) {}
                    overlap(r, u, a) {
                        return r;
                    }
                    preprocess(r, u) {
                        return r;
                    }
                    postprocess(r, u) {
                        return r;
                    }
                };
                e.Schema = s;
                function i(r, u, a) {
                    return typeof r == "function" ? function() {
                        for(var c = arguments.length, l = new Array(c), C = 0; C < c; C++)l[C] = arguments[C];
                        return r(...l.slice(0, a - 1), u, ...l.slice(a - 1));
                    } : ()=>r;
                }
            }
        }), $D = Z({
            "node_modules/vnopts/lib/schemas/alias.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = yt(), t = class extends n.Schema {
                    constructor(s){
                        super(s);
                        this._sourceName = s.sourceName;
                    }
                    expected(s) {
                        return s.schemas[this._sourceName].expected(s);
                    }
                    validate(s, i) {
                        return i.schemas[this._sourceName].validate(s, i);
                    }
                    redirect(s, i) {
                        return this._sourceName;
                    }
                };
                e.AliasSchema = t;
            }
        }), HD = Z({
            "node_modules/vnopts/lib/schemas/any.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = yt(), t = class extends n.Schema {
                    expected() {
                        return "anything";
                    }
                    validate() {
                        return !0;
                    }
                };
                e.AnySchema = t;
            }
        }), GD = Z({
            "node_modules/vnopts/lib/schemas/array.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = (gt(), pt(Dt)), t = yt(), s = class extends t.Schema {
                    constructor(r){
                        var { valueSchema: u, name: a = u.name } = r, c = n.__rest(r, [
                            "valueSchema",
                            "name"
                        ]);
                        super(Object.assign({}, c, {
                            name: a
                        }));
                        this._valueSchema = u;
                    }
                    expected(r) {
                        return "an array of ".concat(this._valueSchema.expected(r));
                    }
                    validate(r, u) {
                        if (!Array.isArray(r)) return !1;
                        let a = [];
                        for (let c of r){
                            let l = u.normalizeValidateResult(this._valueSchema.validate(c, u), c);
                            l !== !0 && a.push(l.value);
                        }
                        return a.length === 0 ? !0 : {
                            value: a
                        };
                    }
                    deprecated(r, u) {
                        let a = [];
                        for (let c of r){
                            let l = u.normalizeDeprecatedResult(this._valueSchema.deprecated(c, u), c);
                            l !== !1 && a.push(...l.map((C)=>{
                                let { value: m } = C;
                                return {
                                    value: [
                                        m
                                    ]
                                };
                            }));
                        }
                        return a;
                    }
                    forward(r, u) {
                        let a = [];
                        for (let c of r){
                            let l = u.normalizeForwardResult(this._valueSchema.forward(c, u), c);
                            a.push(...l.map(i));
                        }
                        return a;
                    }
                    redirect(r, u) {
                        let a = [], c = [];
                        for (let l of r){
                            let C = u.normalizeRedirectResult(this._valueSchema.redirect(l, u), l);
                            "remain" in C && a.push(C.remain), c.push(...C.redirect.map(i));
                        }
                        return a.length === 0 ? {
                            redirect: c
                        } : {
                            redirect: c,
                            remain: a
                        };
                    }
                    overlap(r, u) {
                        return r.concat(u);
                    }
                };
                e.ArraySchema = s;
                function i(r) {
                    let { from: u, to: a } = r;
                    return {
                        from: [
                            u
                        ],
                        to: a
                    };
                }
            }
        }), JD = Z({
            "node_modules/vnopts/lib/schemas/boolean.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = yt(), t = class extends n.Schema {
                    expected() {
                        return "true or false";
                    }
                    validate(s) {
                        return typeof s == "boolean";
                    }
                };
                e.BooleanSchema = t;
            }
        }), Hn = Z({
            "node_modules/vnopts/lib/utils.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                function n(p, f) {
                    let h = Object.create(null);
                    for (let N of p){
                        let T = N[f];
                        if (h[T]) throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T)));
                        h[T] = N;
                    }
                    return h;
                }
                e.recordFromArray = n;
                function t(p, f) {
                    let h = new Map;
                    for (let N of p){
                        let T = N[f];
                        if (h.has(T)) throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T)));
                        h.set(T, N);
                    }
                    return h;
                }
                e.mapFromArray = t;
                function s() {
                    let p = Object.create(null);
                    return (f)=>{
                        let h = JSON.stringify(f);
                        return p[h] ? !0 : (p[h] = !0, !1);
                    };
                }
                e.createAutoChecklist = s;
                function i(p, f) {
                    let h = [], N = [];
                    for (let T of p)f(T) ? h.push(T) : N.push(T);
                    return [
                        h,
                        N
                    ];
                }
                e.partition = i;
                function r(p) {
                    return p === Math.floor(p);
                }
                e.isInt = r;
                function u(p, f) {
                    if (p === f) return 0;
                    let h = typeof p, N = typeof f, T = [
                        "undefined",
                        "object",
                        "boolean",
                        "number",
                        "string"
                    ];
                    return h !== N ? T.indexOf(h) - T.indexOf(N) : h !== "string" ? Number(p) - Number(f) : p.localeCompare(f);
                }
                e.comparePrimitive = u;
                function a(p) {
                    return p === void 0 ? {} : p;
                }
                e.normalizeDefaultResult = a;
                function c(p, f) {
                    return p === !0 ? !0 : p === !1 ? {
                        value: f
                    } : p;
                }
                e.normalizeValidateResult = c;
                function l(p, f) {
                    let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
                    return p === !1 ? !1 : p === !0 ? h ? !0 : [
                        {
                            value: f
                        }
                    ] : "value" in p ? [
                        p
                    ] : p.length === 0 ? !1 : p;
                }
                e.normalizeDeprecatedResult = l;
                function C(p, f) {
                    return typeof p == "string" || "key" in p ? {
                        from: f,
                        to: p
                    } : "from" in p ? {
                        from: p.from,
                        to: p.to
                    } : {
                        from: f,
                        to: p.to
                    };
                }
                e.normalizeTransferResult = C;
                function m(p, f) {
                    return p === void 0 ? [] : Array.isArray(p) ? p.map((h)=>C(h, f)) : [
                        C(p, f)
                    ];
                }
                e.normalizeForwardResult = m;
                function g(p, f) {
                    let h = m(typeof p == "object" && "redirect" in p ? p.redirect : p, f);
                    return h.length === 0 ? {
                        remain: f,
                        redirect: h
                    } : typeof p == "object" && "remain" in p ? {
                        remain: p.remain,
                        redirect: h
                    } : {
                        redirect: h
                    };
                }
                e.normalizeRedirectResult = g;
            }
        }), UD = Z({
            "node_modules/vnopts/lib/schemas/choice.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = yt(), t = Hn(), s = class extends n.Schema {
                    constructor(i){
                        super(i);
                        this._choices = t.mapFromArray(i.choices.map((r)=>r && typeof r == "object" ? r : {
                                value: r
                            }), "value");
                    }
                    expected(i) {
                        let { descriptor: r } = i, u = Array.from(this._choices.keys()).map((l)=>this._choices.get(l)).filter((l)=>!l.deprecated).map((l)=>l.value).sort(t.comparePrimitive).map(r.value), a = u.slice(0, -2), c = u.slice(-2);
                        return a.concat(c.join(" or ")).join(", ");
                    }
                    validate(i) {
                        return this._choices.has(i);
                    }
                    deprecated(i) {
                        let r = this._choices.get(i);
                        return r && r.deprecated ? {
                            value: i
                        } : !1;
                    }
                    forward(i) {
                        let r = this._choices.get(i);
                        return r ? r.forward : void 0;
                    }
                    redirect(i) {
                        let r = this._choices.get(i);
                        return r ? r.redirect : void 0;
                    }
                };
                e.ChoiceSchema = s;
            }
        }), qi = Z({
            "node_modules/vnopts/lib/schemas/number.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = yt(), t = class extends n.Schema {
                    expected() {
                        return "a number";
                    }
                    validate(s, i) {
                        return typeof s == "number";
                    }
                };
                e.NumberSchema = t;
            }
        }), zD = Z({
            "node_modules/vnopts/lib/schemas/integer.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = Hn(), t = qi(), s = class extends t.NumberSchema {
                    expected() {
                        return "an integer";
                    }
                    validate(i, r) {
                        return r.normalizeValidateResult(super.validate(i, r), i) === !0 && n.isInt(i);
                    }
                };
                e.IntegerSchema = s;
            }
        }), XD = Z({
            "node_modules/vnopts/lib/schemas/string.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = yt(), t = class extends n.Schema {
                    expected() {
                        return "a string";
                    }
                    validate(s) {
                        return typeof s == "string";
                    }
                };
                e.StringSchema = t;
            }
        }), KD = Z({
            "node_modules/vnopts/lib/schemas/index.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = (gt(), pt(Dt));
                n.__exportStar($D(), e), n.__exportStar(HD(), e), n.__exportStar(GD(), e), n.__exportStar(JD(), e), n.__exportStar(UD(), e), n.__exportStar(zD(), e), n.__exportStar(qi(), e), n.__exportStar(XD(), e);
            }
        }), YD = Z({
            "node_modules/vnopts/lib/defaults.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = ki(), t = Li(), s = Oi(), i = ji();
                e.defaultDescriptor = n.apiDescriptor, e.defaultUnknownHandler = i.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
            }
        }), QD = Z({
            "node_modules/vnopts/lib/normalize.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = YD(), t = Hn();
                e.normalize = (i, r, u)=>new s(r, u).normalize(i);
                var s = class {
                    constructor(i, r){
                        let { logger: u = console, descriptor: a = n.defaultDescriptor, unknown: c = n.defaultUnknownHandler, invalid: l = n.defaultInvalidHandler, deprecated: C = n.defaultDeprecatedHandler } = r || {};
                        this._utils = {
                            descriptor: a,
                            logger: u || {
                                warn: ()=>{}
                            },
                            schemas: t.recordFromArray(i, "name"),
                            normalizeDefaultResult: t.normalizeDefaultResult,
                            normalizeDeprecatedResult: t.normalizeDeprecatedResult,
                            normalizeForwardResult: t.normalizeForwardResult,
                            normalizeRedirectResult: t.normalizeRedirectResult,
                            normalizeValidateResult: t.normalizeValidateResult
                        }, this._unknownHandler = c, this._invalidHandler = l, this._deprecatedHandler = C, this.cleanHistory();
                    }
                    cleanHistory() {
                        this._hasDeprecationWarned = t.createAutoChecklist();
                    }
                    normalize(i) {
                        let r = {}, u = [
                            i
                        ], a = ()=>{
                            for(; u.length !== 0;){
                                let c = u.shift(), l = this._applyNormalization(c, r);
                                u.push(...l);
                            }
                        };
                        a();
                        for (let c of Object.keys(this._utils.schemas)){
                            let l = this._utils.schemas[c];
                            if (!(c in r)) {
                                let C = t.normalizeDefaultResult(l.default(this._utils));
                                "value" in C && u.push({
                                    [c]: C.value
                                });
                            }
                        }
                        a();
                        for (let c of Object.keys(this._utils.schemas)){
                            let l = this._utils.schemas[c];
                            c in r && (r[c] = l.postprocess(r[c], this._utils));
                        }
                        return r;
                    }
                    _applyNormalization(i, r) {
                        let u = [], [a, c] = t.partition(Object.keys(i), (l)=>l in this._utils.schemas);
                        for (let l of a){
                            let C = this._utils.schemas[l], m = C.preprocess(i[l], this._utils), g = t.normalizeValidateResult(C.validate(m, this._utils), m);
                            if (g !== !0) {
                                let { value: T } = g, A = this._invalidHandler(l, T, this._utils);
                                throw typeof A == "string" ? new Error(A) : A;
                            }
                            let p = (T)=>{
                                let { from: A, to: b } = T;
                                u.push(typeof b == "string" ? {
                                    [b]: A
                                } : {
                                    [b.key]: b.value
                                });
                            }, f = (T)=>{
                                let { value: A, redirectTo: b } = T, v = t.normalizeDeprecatedResult(C.deprecated(A, this._utils), m, !0);
                                if (v !== !1) {
                                    if (v === !0) this._hasDeprecationWarned(l) || this._utils.logger.warn(this._deprecatedHandler(l, b, this._utils));
                                    else for (let { value: B } of v){
                                        let w = {
                                            key: l,
                                            value: B
                                        };
                                        if (!this._hasDeprecationWarned(w)) {
                                            let I = typeof b == "string" ? {
                                                key: b,
                                                value: B
                                            } : b;
                                            this._utils.logger.warn(this._deprecatedHandler(w, I, this._utils));
                                        }
                                    }
                                }
                            };
                            t.normalizeForwardResult(C.forward(m, this._utils), m).forEach(p);
                            let N = t.normalizeRedirectResult(C.redirect(m, this._utils), m);
                            if (N.redirect.forEach(p), "remain" in N) {
                                let T = N.remain;
                                r[l] = l in r ? C.overlap(r[l], T, this._utils) : T, f({
                                    value: T
                                });
                            }
                            for (let { from: T, to: A } of N.redirect)f({
                                value: T,
                                redirectTo: A
                            });
                        }
                        for (let l of c){
                            let C = i[l], m = this._unknownHandler(l, C, this._utils);
                            if (m) for (let g of Object.keys(m)){
                                let p = {
                                    [g]: m[g]
                                };
                                g in this._utils.schemas ? u.push(p) : Object.assign(r, p);
                            }
                        }
                        return u;
                    }
                };
                e.Normalizer = s;
            }
        }), ZD = Z({
            "node_modules/vnopts/lib/index.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = (gt(), pt(Dt));
                n.__exportStar(jD(), e), n.__exportStar(WD(), e), n.__exportStar(KD(), e), n.__exportStar(QD(), e), n.__exportStar(yt(), e);
            }
        }), em = Z({
            "src/main/options-normalizer.js" (e, n) {
                "use strict";
                ae();
                var t = ZD(), s = st(), i = {
                    key: (g)=>g.length === 1 ? "-".concat(g) : "--".concat(g),
                    value: (g)=>t.apiDescriptor.value(g),
                    pair: (g)=>{
                        let { key: p, value: f } = g;
                        return f === !1 ? "--no-".concat(p) : f === !0 ? i.key(p) : f === "" ? "".concat(i.key(p), " without an argument") : "".concat(i.key(p), "=").concat(f);
                    }
                }, r = (g)=>{
                    let { colorsModule: p, levenshteinDistance: f } = g;
                    return class extends t.ChoiceSchema {
                        constructor(N){
                            let { name: T, flags: A } = N;
                            super({
                                name: T,
                                choices: A
                            });
                            this._flags = [
                                ...A
                            ].sort();
                        }
                        preprocess(N, T) {
                            if (typeof N == "string" && N.length > 0 && !this._flags.includes(N)) {
                                let A = this._flags.find((b)=>f(b, N) < 3);
                                if (A) return T.logger.warn([
                                    "Unknown flag ".concat(p.yellow(T.descriptor.value(N)), ","),
                                    "did you mean ".concat(p.blue(T.descriptor.value(A)), "?")
                                ].join(" ")), A;
                            }
                            return N;
                        }
                        expected() {
                            return "a flag";
                        }
                    };
                }, u;
                function a(g, p) {
                    let { logger: f, isCLI: h = !1, passThrough: N = !1, colorsModule: T, levenshteinDistance: A } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, b = N ? Array.isArray(N) ? (D, d)=>N.includes(D) ? {
                            [D]: d
                        } : void 0 : (D, d)=>({
                            [D]: d
                        }) : (D, d, y)=>{
                        let o = y.schemas, { _: x } = o, F = _n(o, Xf);
                        return t.levenUnknownHandler(D, d, Object.assign(Object.assign({}, y), {}, {
                            schemas: F
                        }));
                    }, v = h ? i : t.apiDescriptor, B = c(p, {
                        isCLI: h,
                        colorsModule: T,
                        levenshteinDistance: A
                    }), w = new t.Normalizer(B, {
                        logger: f,
                        unknown: b,
                        descriptor: v
                    }), I = f !== !1;
                    I && u && (w._hasDeprecationWarned = u);
                    let E = w.normalize(g);
                    return I && (u = w._hasDeprecationWarned), h && E["plugin-search"] === !1 && (E["plugin-search-dir"] = !1), E;
                }
                function c(g, p) {
                    let { isCLI: f, colorsModule: h, levenshteinDistance: N } = p, T = [];
                    f && T.push(t.AnySchema.create({
                        name: "_"
                    }));
                    for (let A of g)T.push(l(A, {
                        isCLI: f,
                        optionInfos: g,
                        colorsModule: h,
                        levenshteinDistance: N
                    })), A.alias && f && T.push(t.AliasSchema.create({
                        name: A.alias,
                        sourceName: A.name
                    }));
                    return T;
                }
                function l(g, p) {
                    let { isCLI: f, optionInfos: h, colorsModule: N, levenshteinDistance: T } = p, { name: A } = g;
                    if (A === "plugin-search-dir" || A === "pluginSearchDirs") return t.AnySchema.create({
                        name: A,
                        preprocess (w) {
                            return w === !1 || (w = Array.isArray(w) ? w : [
                                w
                            ]), w;
                        },
                        validate (w) {
                            return w === !1 ? !0 : w.every((I)=>typeof I == "string");
                        },
                        expected () {
                            return "false or paths to plugin search dir";
                        }
                    });
                    let b = {
                        name: A
                    }, v, B = {};
                    switch(g.type){
                        case "int":
                            v = t.IntegerSchema, f && (b.preprocess = (w)=>Number(w));
                            break;
                        case "string":
                            v = t.StringSchema;
                            break;
                        case "choice":
                            v = t.ChoiceSchema, b.choices = g.choices.map((w)=>typeof w == "object" && w.redirect ? Object.assign(Object.assign({}, w), {}, {
                                    redirect: {
                                        to: {
                                            key: g.name,
                                            value: w.redirect
                                        }
                                    }
                                }) : w);
                            break;
                        case "boolean":
                            v = t.BooleanSchema;
                            break;
                        case "flag":
                            v = r({
                                colorsModule: N,
                                levenshteinDistance: T
                            }), b.flags = h.flatMap((w)=>[
                                    w.alias,
                                    w.description && w.name,
                                    w.oppositeDescription && "no-".concat(w.name)
                                ].filter(Boolean));
                            break;
                        case "path":
                            v = t.StringSchema;
                            break;
                        default:
                            throw new Error("Unexpected type ".concat(g.type));
                    }
                    if (g.exception ? b.validate = (w, I, E)=>g.exception(w) || I.validate(w, E) : b.validate = (w, I, E)=>w === void 0 || I.validate(w, E), g.redirect && (B.redirect = (w)=>w ? {
                            to: {
                                key: g.redirect.option,
                                value: g.redirect.value
                            }
                        } : void 0), g.deprecated && (B.deprecated = !0), f && !g.array) {
                        let w = b.preprocess || ((I)=>I);
                        b.preprocess = (I, E, D)=>E.preprocess(w(Array.isArray(I) ? s(I) : I), D);
                    }
                    return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? {
                        preprocess: (w)=>Array.isArray(w) ? w : [
                                w
                            ]
                    } : {}), B), {}, {
                        valueSchema: v.create(b)
                    })) : v.create(Object.assign(Object.assign({}, b), B));
                }
                function C(g, p, f) {
                    return a(g, p, f);
                }
                function m(g, p, f) {
                    return a(g, p, Object.assign({
                        isCLI: !0
                    }, f));
                }
                n.exports = {
                    normalizeApiOptions: C,
                    normalizeCliOptions: m
                };
            }
        }), nt = Z({
            "src/language-js/loc.js" (e, n) {
                "use strict";
                ae();
                var t = Rn();
                function s(c, l) {
                    let { ignoreDecorators: C } = l || {};
                    if (!C) {
                        let m = c.declaration && c.declaration.decorators || c.decorators;
                        if (t(m)) return s(m[0]);
                    }
                    return c.range ? c.range[0] : c.start;
                }
                function i(c) {
                    return c.range ? c.range[1] : c.end;
                }
                function r(c, l) {
                    let C = s(c);
                    return Number.isInteger(C) && C === s(l);
                }
                function u(c, l) {
                    let C = i(c);
                    return Number.isInteger(C) && C === i(l);
                }
                function a(c, l) {
                    return r(c, l) && u(c, l);
                }
                n.exports = {
                    locStart: s,
                    locEnd: i,
                    hasSameLocStart: r,
                    hasSameLoc: a
                };
            }
        }), tm = Z({
            "scripts/build/shims/babel-highlight.cjs" (e, n) {
                "use strict";
                ae();
                var t = Nr(), s = {
                    shouldHighlight: ()=>!1,
                    getChalk: ()=>t
                };
                n.exports = s;
            }
        }), rm = Z({
            "node_modules/@babel/code-frame/lib/index.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.codeFrameColumns = u, e.default = a;
                var n = tm(), t = !1;
                function s(c) {
                    return {
                        gutter: c.grey,
                        marker: c.red.bold,
                        message: c.red.bold
                    };
                }
                var i = /\r\n|[\n\r\u2028\u2029]/;
                function r(c, l, C) {
                    let m = Object.assign({
                        column: 0,
                        line: -1
                    }, c.start), g = Object.assign({}, m, c.end), { linesAbove: p = 2, linesBelow: f = 3 } = C || {}, h = m.line, N = m.column, T = g.line, A = g.column, b = Math.max(h - (p + 1), 0), v = Math.min(l.length, T + f);
                    h === -1 && (b = 0), T === -1 && (v = l.length);
                    let B = T - h, w = {};
                    if (B) for(let I = 0; I <= B; I++){
                        let E = I + h;
                        if (!N) w[E] = !0;
                        else if (I === 0) {
                            let D = l[E - 1].length;
                            w[E] = [
                                N,
                                D - N + 1
                            ];
                        } else if (I === B) w[E] = [
                            0,
                            A
                        ];
                        else {
                            let D = l[E - I].length;
                            w[E] = [
                                0,
                                D
                            ];
                        }
                    }
                    else N === A ? N ? w[h] = [
                        N,
                        0
                    ] : w[h] = !0 : w[h] = [
                        N,
                        A - N
                    ];
                    return {
                        start: b,
                        end: v,
                        markerLines: w
                    };
                }
                function u(c, l) {
                    let C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, m = (C.highlightCode || C.forceColor) && (0, n.shouldHighlight)(C), g = (0, n.getChalk)(C), p = s(g), f = (I, E)=>m ? I(E) : E, h = c.split(i), { start: N, end: T, markerLines: A } = r(l, h, C), b = l.start && typeof l.start.column == "number", v = String(T).length, w = (m ? (0, n.default)(c, C) : c).split(i, T).slice(N, T).map((I, E)=>{
                        let D = N + 1 + E, d = " ".concat(D).slice(-v), y = " ".concat(d, " |"), o = A[D], x = !A[D + 1];
                        if (o) {
                            let F = "";
                            if (Array.isArray(o)) {
                                let S = I.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), k = o[1] || 1;
                                F = [
                                    `
 `,
                                    f(p.gutter, y.replace(/\d/g, " ")),
                                    " ",
                                    S,
                                    f(p.marker, "^").repeat(k)
                                ].join(""), x && C.message && (F += " " + f(p.message, C.message));
                            }
                            return [
                                f(p.marker, ">"),
                                f(p.gutter, y),
                                I.length > 0 ? " ".concat(I) : "",
                                F
                            ].join("");
                        } else return " ".concat(f(p.gutter, y)).concat(I.length > 0 ? " ".concat(I) : "");
                    }).join(`
`);
                    return C.message && !b && (w = "".concat(" ".repeat(v + 1)).concat(C.message, `
`).concat(w)), m ? g.reset(w) : w;
                }
                function a(c, l, C) {
                    let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                    if (!t) {
                        t = !0;
                        let p = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                        if (xt.emitWarning) xt.emitWarning(p, "DeprecationWarning");
                        else {
                            let f = new Error(p);
                            f.name = "DeprecationWarning", console.warn(new Error(p));
                        }
                    }
                    return C = Math.max(C, 0), u(c, {
                        start: {
                            column: C,
                            line: l
                        }
                    }, m);
                }
            }
        }), Gn = Z({
            "src/main/parser.js" (e, n) {
                "use strict";
                ae();
                var t = Pi(), { ConfigError: s } = Jt(), i = nt(), { locStart: r, locEnd: u } = i, a = Object.getOwnPropertyNames, c = Object.getOwnPropertyDescriptor;
                function l(g) {
                    let p = {};
                    for (let f of g.plugins)if (!!f.parsers) for (let h of a(f.parsers))Object.defineProperty(p, h, c(f.parsers, h));
                    return p;
                }
                function C(g) {
                    let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : l(g);
                    if (typeof g.parser == "function") return {
                        parse: g.parser,
                        astFormat: "estree",
                        locStart: r,
                        locEnd: u
                    };
                    if (typeof g.parser == "string") {
                        if (Object.prototype.hasOwnProperty.call(p, g.parser)) return p[g.parser];
                        throw new s(`Couldn't resolve parser "`.concat(g.parser, '". Parsers must be explicitly added to the standalone bundle.'));
                    }
                }
                function m(g, p) {
                    let f = l(p), h = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((T)=>[
                            T,
                            {
                                enumerable: !0,
                                get () {
                                    return f[T].parse;
                                }
                            }
                        ]))), N = C(p, f);
                    try {
                        return N.preprocess && (g = N.preprocess(g, p)), {
                            text: g,
                            ast: N.parse(g, h, p)
                        };
                    } catch (T) {
                        let { loc: A } = T;
                        if (A) {
                            let { codeFrameColumns: b } = rm();
                            throw T.codeFrame = b(g, A, {
                                highlightCode: !0
                            }), T.message += `
` + T.codeFrame, T;
                        }
                        throw T.stack;
                    }
                }
                n.exports = {
                    parse: m,
                    resolveParser: C
                };
            }
        }), Mi = Z({
            "src/main/options.js" (e, n) {
                "use strict";
                ae();
                var t = Pi(), { UndefinedParserError: s } = Jt(), { getSupportInfo: i } = Mn(), r = em(), { resolveParser: u } = Gn(), a = {
                    astFormat: "estree",
                    printer: {},
                    originalText: void 0,
                    locStart: null,
                    locEnd: null
                };
                function c(m) {
                    let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = Object.assign({}, m), f = i({
                        plugins: m.plugins,
                        showUnreleased: !0,
                        showDeprecated: !0
                    }).options, h = Object.assign(Object.assign({}, a), Object.fromEntries(f.filter((v)=>v.default !== void 0).map((v)=>[
                            v.name,
                            v.default
                        ])));
                    if (!p.parser) {
                        if (!p.filepath) (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), p.parser = "babel";
                        else if (p.parser = C(p.filepath, p.plugins), !p.parser) throw new s("No parser could be inferred for file: ".concat(p.filepath));
                    }
                    let N = u(r.normalizeApiOptions(p, [
                        f.find((v)=>v.name === "parser")
                    ], {
                        passThrough: !0,
                        logger: !1
                    }));
                    p.astFormat = N.astFormat, p.locEnd = N.locEnd, p.locStart = N.locStart;
                    let T = l(p);
                    p.printer = T.printers[p.astFormat];
                    let A = Object.fromEntries(f.filter((v)=>v.pluginDefaults && v.pluginDefaults[T.name] !== void 0).map((v)=>[
                            v.name,
                            v.pluginDefaults[T.name]
                        ])), b = Object.assign(Object.assign({}, h), A);
                    for (let [v, B] of Object.entries(b))(p[v] === null || p[v] === void 0) && (p[v] = B);
                    return p.parser === "json" && (p.trailingComma = "none"), r.normalizeApiOptions(p, f, Object.assign({
                        passThrough: Object.keys(a)
                    }, g));
                }
                function l(m) {
                    let { astFormat: g } = m;
                    if (!g) throw new Error("getPlugin() requires astFormat to be set");
                    let p = m.plugins.find((f)=>f.printers && f.printers[g]);
                    if (!p) throw new Error(`Couldn't find plugin for AST format "`.concat(g, '"'));
                    return p;
                }
                function C(m, g) {
                    let p = t.basename(m).toLowerCase(), h = i({
                        plugins: g
                    }).languages.filter((N)=>N.since !== null).find((N)=>N.extensions && N.extensions.some((T)=>p.endsWith(T)) || N.filenames && N.filenames.some((T)=>T.toLowerCase() === p));
                    return h && h.parsers[0];
                }
                n.exports = {
                    normalize: c,
                    hiddenDefaults: a,
                    inferParser: C
                };
            }
        }), nm = Z({
            "src/main/massage-ast.js" (e, n) {
                "use strict";
                ae();
                function t(s, i, r) {
                    if (Array.isArray(s)) return s.map((l)=>t(l, i, r)).filter(Boolean);
                    if (!s || typeof s != "object") return s;
                    let u = i.printer.massageAstNode, a;
                    u && u.ignoredProperties ? a = u.ignoredProperties : a = new Set;
                    let c = {};
                    for (let [l, C] of Object.entries(s))!a.has(l) && typeof C != "function" && (c[l] = t(C, i, s));
                    if (u) {
                        let l = u(s, c, r);
                        if (l === null) return;
                        if (l) return l;
                    }
                    return c;
                }
                n.exports = t;
            }
        }), Ut = Z({
            "scripts/build/shims/assert.cjs" (e, n) {
                "use strict";
                ae();
                var t = ()=>{};
                t.ok = t, t.strictEqual = t, n.exports = t;
            }
        }), Qe = Z({
            "src/main/comments.js" (e, n) {
                "use strict";
                ae();
                var t = Ut(), { builders: { line: s, hardline: i, breakParent: r, indent: u, lineSuffix: a, join: c, cursor: l } } = Le(), { hasNewline: C, skipNewline: m, skipSpaces: g, isPreviousLineEmpty: p, addLeadingComment: f, addDanglingComment: h, addTrailingComment: N } = Ge(), T = new WeakMap;
                function A(O, R, M) {
                    if (!O) return;
                    let { printer: H, locStart: P, locEnd: G } = R;
                    if (M) {
                        if (H.canAttachComment && H.canAttachComment(O)) {
                            let $;
                            for($ = M.length - 1; $ >= 0 && !(P(M[$]) <= P(O) && G(M[$]) <= G(O)); --$);
                            M.splice($ + 1, 0, O);
                            return;
                        }
                    } else if (T.has(O)) return T.get(O);
                    let re = H.getCommentChildNodes && H.getCommentChildNodes(O, R) || typeof O == "object" && Object.entries(O).filter(($)=>{
                        let [W] = $;
                        return W !== "enclosingNode" && W !== "precedingNode" && W !== "followingNode" && W !== "tokens" && W !== "comments" && W !== "parent";
                    }).map(($)=>{
                        let [, W] = $;
                        return W;
                    });
                    if (!!re) {
                        M || (M = [], T.set(O, M));
                        for (let $ of re)A($, R, M);
                        return M;
                    }
                }
                function b(O, R, M, H) {
                    let { locStart: P, locEnd: G } = M, re = P(R), $ = G(R), W = A(O, M), ee, U, ne = 0, se = W.length;
                    for(; ne < se;){
                        let V = ne + se >> 1, oe = W[V], K = P(oe), Ee = G(oe);
                        if (K <= re && $ <= Ee) return b(oe, R, M, oe);
                        if (Ee <= re) {
                            ee = oe, ne = V + 1;
                            continue;
                        }
                        if ($ <= K) {
                            U = oe, se = V;
                            continue;
                        }
                        throw new Error("Comment location overlaps with node location");
                    }
                    if (H && H.type === "TemplateLiteral") {
                        let { quasis: V } = H, oe = y(V, R, M);
                        ee && y(V, ee, M) !== oe && (ee = null), U && y(V, U, M) !== oe && (U = null);
                    }
                    return {
                        enclosingNode: H,
                        precedingNode: ee,
                        followingNode: U
                    };
                }
                var v = ()=>!1;
                function B(O, R, M, H) {
                    if (!Array.isArray(O)) return;
                    let P = [], { locStart: G, locEnd: re, printer: { handleComments: $ = {} } } = H, { avoidAstMutation: W, ownLine: ee = v, endOfLine: U = v, remaining: ne = v } = $, se = O.map((V, oe)=>Object.assign(Object.assign({}, b(R, V, H)), {}, {
                            comment: V,
                            text: M,
                            options: H,
                            ast: R,
                            isLastComment: O.length - 1 === oe
                        }));
                    for (let [V, oe] of se.entries()){
                        let { comment: K, precedingNode: Ee, enclosingNode: q, followingNode: le, text: ue, options: Q, ast: de, isLastComment: ge } = oe;
                        if (Q.parser === "json" || Q.parser === "json5" || Q.parser === "__js_expression" || Q.parser === "__vue_expression") {
                            if (G(K) - G(de) <= 0) {
                                f(de, K);
                                continue;
                            }
                            if (re(K) - re(de) >= 0) {
                                N(de, K);
                                continue;
                            }
                        }
                        let ve;
                        if (W ? ve = [
                            oe
                        ] : (K.enclosingNode = q, K.precedingNode = Ee, K.followingNode = le, ve = [
                            K,
                            ue,
                            Q,
                            de,
                            ge
                        ]), I(ue, Q, se, V)) K.placement = "ownLine", ee(...ve) || (le ? f(le, K) : Ee ? N(Ee, K) : h(q || de, K));
                        else if (E(ue, Q, se, V)) K.placement = "endOfLine", U(...ve) || (Ee ? N(Ee, K) : le ? f(le, K) : h(q || de, K));
                        else if (K.placement = "remaining", !ne(...ve)) {
                            if (Ee && le) {
                                let xe = P.length;
                                xe > 0 && P[xe - 1].followingNode !== le && D(P, ue, Q), P.push(oe);
                            } else Ee ? N(Ee, K) : le ? f(le, K) : h(q || de, K);
                        }
                    }
                    if (D(P, M, H), !W) for (let V of O)delete V.precedingNode, delete V.enclosingNode, delete V.followingNode;
                }
                var w = (O)=>!/[\S\n\u2028\u2029]/.test(O);
                function I(O, R, M, H) {
                    let { comment: P, precedingNode: G } = M[H], { locStart: re, locEnd: $ } = R, W = re(P);
                    if (G) for(let ee = H - 1; ee >= 0; ee--){
                        let { comment: U, precedingNode: ne } = M[ee];
                        if (ne !== G || !w(O.slice($(U), W))) break;
                        W = re(U);
                    }
                    return C(O, W, {
                        backwards: !0
                    });
                }
                function E(O, R, M, H) {
                    let { comment: P, followingNode: G } = M[H], { locStart: re, locEnd: $ } = R, W = $(P);
                    if (G) for(let ee = H + 1; ee < M.length; ee++){
                        let { comment: U, followingNode: ne } = M[ee];
                        if (ne !== G || !w(O.slice(W, re(U)))) break;
                        W = $(U);
                    }
                    return C(O, W);
                }
                function D(O, R, M) {
                    let H = O.length;
                    if (H === 0) return;
                    let { precedingNode: P, followingNode: G, enclosingNode: re } = O[0], $ = M.printer.getGapRegex && M.printer.getGapRegex(re) || /^[\s(]*$/, W = M.locStart(G), ee;
                    for(ee = H; ee > 0; --ee){
                        let { comment: U, precedingNode: ne, followingNode: se } = O[ee - 1];
                        t.strictEqual(ne, P), t.strictEqual(se, G);
                        let V = R.slice(M.locEnd(U), W);
                        if ($.test(V)) W = M.locStart(U);
                        else break;
                    }
                    for (let [U, { comment: ne }] of O.entries())U < ee ? N(P, ne) : f(G, ne);
                    for (let U of [
                        P,
                        G
                    ])U.comments && U.comments.length > 1 && U.comments.sort((ne, se)=>M.locStart(ne) - M.locStart(se));
                    O.length = 0;
                }
                function d(O, R) {
                    let M = O.getValue();
                    return M.printed = !0, R.printer.printComment(O, R);
                }
                function y(O, R, M) {
                    let H = M.locStart(R) - 1;
                    for(let P = 1; P < O.length; ++P)if (H < M.locStart(O[P])) return P - 1;
                    return 0;
                }
                function o(O, R) {
                    let M = O.getValue(), H = [
                        d(O, R)
                    ], { printer: P, originalText: G, locStart: re, locEnd: $ } = R;
                    if (P.isBlockComment && P.isBlockComment(M)) {
                        let U = C(G, $(M)) ? C(G, re(M), {
                            backwards: !0
                        }) ? i : s : " ";
                        H.push(U);
                    } else H.push(i);
                    let ee = m(G, g(G, $(M)));
                    return ee !== !1 && C(G, ee) && H.push(i), H;
                }
                function x(O, R) {
                    let M = O.getValue(), H = d(O, R), { printer: P, originalText: G, locStart: re } = R, $ = P.isBlockComment && P.isBlockComment(M);
                    if (C(G, re(M), {
                        backwards: !0
                    })) {
                        let ee = p(G, M, re);
                        return a([
                            i,
                            ee ? i : "",
                            H
                        ]);
                    }
                    let W = [
                        " ",
                        H
                    ];
                    return $ || (W = [
                        a(W),
                        r
                    ]), W;
                }
                function F(O, R, M, H) {
                    let P = [], G = O.getValue();
                    return !G || !G.comments || (O.each(()=>{
                        let re = O.getValue();
                        !re.leading && !re.trailing && (!H || H(re)) && P.push(d(O, R));
                    }, "comments"), P.length === 0) ? "" : M ? c(i, P) : u([
                        i,
                        c(i, P)
                    ]);
                }
                function S(O, R, M) {
                    let H = O.getValue();
                    if (!H) return {};
                    let P = H.comments || [];
                    M && (P = P.filter((W)=>!M.has(W)));
                    let G = H === R.cursorNode;
                    if (P.length === 0) {
                        let W = G ? l : "";
                        return {
                            leading: W,
                            trailing: W
                        };
                    }
                    let re = [], $ = [];
                    return O.each(()=>{
                        let W = O.getValue();
                        if (M && M.has(W)) return;
                        let { leading: ee, trailing: U } = W;
                        ee ? re.push(o(O, R)) : U && $.push(x(O, R));
                    }, "comments"), G && (re.unshift(l), $.push(l)), {
                        leading: re,
                        trailing: $
                    };
                }
                function k(O, R, M, H) {
                    let { leading: P, trailing: G } = S(O, M, H);
                    return !P && !G ? R : [
                        P,
                        R,
                        G
                    ];
                }
                function _(O) {
                    if (!!O) for (let R of O){
                        if (!R.printed) throw new Error('Comment "' + R.value.trim() + '" was not printed. Please report this error!');
                        delete R.printed;
                    }
                }
                n.exports = {
                    attach: B,
                    printComments: k,
                    printCommentsSeparately: S,
                    printDanglingComments: F,
                    getSortedChildNodes: A,
                    ensureAllCommentsPrinted: _
                };
            }
        }), um = Z({
            "src/common/ast-path.js" (e, n) {
                "use strict";
                ae();
                var t = st();
                function s(u, a) {
                    let c = i(u.stack, a);
                    return c === -1 ? null : u.stack[c];
                }
                function i(u, a) {
                    for(let c = u.length - 1; c >= 0; c -= 2){
                        let l = u[c];
                        if (l && !Array.isArray(l) && --a < 0) return c;
                    }
                    return -1;
                }
                var r = class {
                    constructor(u){
                        this.stack = [
                            u
                        ];
                    }
                    getName() {
                        let { stack: u } = this, { length: a } = u;
                        return a > 1 ? u[a - 2] : null;
                    }
                    getValue() {
                        return t(this.stack);
                    }
                    getNode() {
                        let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                        return s(this, u);
                    }
                    getParentNode() {
                        let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                        return s(this, u + 1);
                    }
                    call(u) {
                        let { stack: a } = this, { length: c } = a, l = t(a);
                        for(var C = arguments.length, m = new Array(C > 1 ? C - 1 : 0), g = 1; g < C; g++)m[g - 1] = arguments[g];
                        for (let f of m)l = l[f], a.push(f, l);
                        let p = u(this);
                        return a.length = c, p;
                    }
                    callParent(u) {
                        let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, c = i(this.stack, a + 1), l = this.stack.splice(c + 1), C = u(this);
                        return this.stack.push(...l), C;
                    }
                    each(u) {
                        let { stack: a } = this, { length: c } = a, l = t(a);
                        for(var C = arguments.length, m = new Array(C > 1 ? C - 1 : 0), g = 1; g < C; g++)m[g - 1] = arguments[g];
                        for (let p of m)l = l[p], a.push(p, l);
                        for(let p = 0; p < l.length; ++p)a.push(p, l[p]), u(this, p, l), a.length -= 2;
                        a.length = c;
                    }
                    map(u) {
                        let a = [];
                        for(var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), C = 1; C < c; C++)l[C - 1] = arguments[C];
                        return this.each((m, g, p)=>{
                            a[g] = u(m, g, p);
                        }, ...l), a;
                    }
                    try(u) {
                        let { stack: a } = this, c = [
                            ...a
                        ];
                        try {
                            return u();
                        } finally{
                            a.length = 0, a.push(...c);
                        }
                    }
                    match() {
                        let u = this.stack.length - 1, a = null, c = this.stack[u--];
                        for(var l = arguments.length, C = new Array(l), m = 0; m < l; m++)C[m] = arguments[m];
                        for (let g of C){
                            if (c === void 0) return !1;
                            let p = null;
                            if (typeof a == "number" && (p = a, a = this.stack[u--], c = this.stack[u--]), g && !g(c, a, p)) return !1;
                            a = this.stack[u--], c = this.stack[u--];
                        }
                        return !0;
                    }
                    findAncestor(u) {
                        let a = this.stack.length - 1, c = null, l = this.stack[a--];
                        for(; l;){
                            let C = null;
                            if (typeof c == "number" && (C = c, c = this.stack[a--], l = this.stack[a--]), c !== null && u(l, c, C)) return l;
                            c = this.stack[a--], l = this.stack[a--];
                        }
                    }
                };
                n.exports = r;
            }
        }), sm = Z({
            "src/main/multiparser.js" (e, n) {
                "use strict";
                ae();
                var { utils: { stripTrailingHardline: t } } = Le(), { normalize: s } = Mi(), i = Qe();
                function r(a, c, l, C) {
                    if (l.printer.embed && l.embeddedLanguageFormatting === "auto") return l.printer.embed(a, c, (m, g, p)=>u(m, g, l, C, p), l);
                }
                function u(a, c, l, C) {
                    let { stripTrailingHardline: m = !1 } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s(Object.assign(Object.assign(Object.assign({}, l), c), {}, {
                        parentParser: l.parser,
                        originalText: a
                    }), {
                        passThrough: !0
                    }), p = Gn().parse(a, g), { ast: f } = p;
                    a = p.text;
                    let h = f.comments;
                    delete f.comments, i.attach(h, f, a, g), g[Symbol.for("comments")] = h || [], g[Symbol.for("tokens")] = f.tokens || [];
                    let N = C(f, g);
                    return i.ensureAllCommentsPrinted(h), m ? typeof N == "string" ? N.replace(/(?:\r?\n)*$/, "") : t(N) : N;
                }
                n.exports = {
                    printSubtree: r
                };
            }
        }), am = Z({
            "src/main/ast-to-doc.js" (e, n) {
                "use strict";
                ae();
                var t = um(), { builders: { hardline: s, addAlignmentToDoc: i }, utils: { propagateBreaks: r } } = Le(), { printComments: u } = Qe(), a = sm();
                function c(m, g) {
                    let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = g;
                    f.preprocess && (m = f.preprocess(m, g));
                    let h = new Map, N = new t(m), T = A();
                    return p > 0 && (T = i([
                        s,
                        T
                    ], p, g.tabWidth)), r(T), T;
                    function A(v, B) {
                        return v === void 0 || v === N ? b(B) : Array.isArray(v) ? N.call(()=>b(B), ...v) : N.call(()=>b(B), v);
                    }
                    function b(v) {
                        let B = N.getValue(), w = B && typeof B == "object" && v === void 0;
                        if (w && h.has(B)) return h.get(B);
                        let I = C(N, g, A, v);
                        return w && h.set(B, I), I;
                    }
                }
                function l(m, g) {
                    let { originalText: p, [Symbol.for("comments")]: f, locStart: h, locEnd: N } = g, T = h(m), A = N(m), b = new Set;
                    for (let v of f)h(v) >= T && N(v) <= A && (v.printed = !0, b.add(v));
                    return {
                        doc: p.slice(T, A),
                        printedComments: b
                    };
                }
                function C(m, g, p, f) {
                    let h = m.getValue(), { printer: N } = g, T, A;
                    if (N.hasPrettierIgnore && N.hasPrettierIgnore(m)) ({ doc: T, printedComments: A } = l(h, g));
                    else {
                        if (h) try {
                            T = a.printSubtree(m, p, g, c);
                        } catch (b) {
                            if (globalThis.PRETTIER_DEBUG) throw b;
                        }
                        T || (T = N.print(m, g, p, f));
                    }
                    return (!N.willPrintOwnComments || !N.willPrintOwnComments(m, g)) && (T = u(m, T, g, A)), T;
                }
                n.exports = c;
            }
        }), im = Z({
            "src/main/range-util.js" (e, n) {
                "use strict";
                ae();
                var t = Ut(), s = Qe(), i = (f)=>{
                    let { parser: h } = f;
                    return h === "json" || h === "json5" || h === "json-stringify";
                };
                function r(f, h) {
                    let N = [
                        f.node,
                        ...f.parentNodes
                    ], T = new Set([
                        h.node,
                        ...h.parentNodes
                    ]);
                    return N.find((A)=>C.has(A.type) && T.has(A));
                }
                function u(f) {
                    let h = f.length - 1;
                    for(;;){
                        let N = f[h];
                        if (N && (N.type === "Program" || N.type === "File")) h--;
                        else break;
                    }
                    return f.slice(0, h + 1);
                }
                function a(f, h, N) {
                    let { locStart: T, locEnd: A } = N, b = f.node, v = h.node;
                    if (b === v) return {
                        startNode: b,
                        endNode: v
                    };
                    let B = T(f.node);
                    for (let I of u(h.parentNodes))if (T(I) >= B) v = I;
                    else break;
                    let w = A(h.node);
                    for (let I of u(f.parentNodes))if (A(I) <= w) b = I;
                    else break;
                    return {
                        startNode: b,
                        endNode: v
                    };
                }
                function c(f, h, N, T) {
                    let A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], b = arguments.length > 5 ? arguments[5] : void 0, { locStart: v, locEnd: B } = N, w = v(f), I = B(f);
                    if (!(h > I || h < w || b === "rangeEnd" && h === w || b === "rangeStart" && h === I)) {
                        for (let E of s.getSortedChildNodes(f, N)){
                            let D = c(E, h, N, T, [
                                f,
                                ...A
                            ], b);
                            if (D) return D;
                        }
                        if (!T || T(f, A[0])) return {
                            node: f,
                            parentNodes: A
                        };
                    }
                }
                function l(f, h) {
                    return h !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
                }
                var C = new Set([
                    "ObjectExpression",
                    "ArrayExpression",
                    "StringLiteral",
                    "NumericLiteral",
                    "BooleanLiteral",
                    "NullLiteral",
                    "UnaryExpression",
                    "TemplateLiteral"
                ]), m = new Set([
                    "OperationDefinition",
                    "FragmentDefinition",
                    "VariableDefinition",
                    "TypeExtensionDefinition",
                    "ObjectTypeDefinition",
                    "FieldDefinition",
                    "DirectiveDefinition",
                    "EnumTypeDefinition",
                    "EnumValueDefinition",
                    "InputValueDefinition",
                    "InputObjectTypeDefinition",
                    "SchemaDefinition",
                    "OperationTypeDefinition",
                    "InterfaceTypeDefinition",
                    "UnionTypeDefinition",
                    "ScalarTypeDefinition"
                ]);
                function g(f, h, N) {
                    if (!h) return !1;
                    switch(f.parser){
                        case "flow":
                        case "babel":
                        case "babel-flow":
                        case "babel-ts":
                        case "typescript":
                        case "acorn":
                        case "espree":
                        case "meriyah":
                        case "__babel_estree":
                            return l(h.type, N && N.type);
                        case "json":
                        case "json5":
                        case "json-stringify":
                            return C.has(h.type);
                        case "graphql":
                            return m.has(h.kind);
                        case "vue":
                            return h.tag !== "root";
                    }
                    return !1;
                }
                function p(f, h, N) {
                    let { rangeStart: T, rangeEnd: A, locStart: b, locEnd: v } = h;
                    t.ok(A > T);
                    let B = f.slice(T, A).search(/\S/), w = B === -1;
                    if (!w) for(T += B; A > T && !/\S/.test(f[A - 1]); --A);
                    let I = c(N, T, h, (y, o)=>g(h, y, o), [], "rangeStart"), E = w ? I : c(N, A, h, (y)=>g(h, y), [], "rangeEnd");
                    if (!I || !E) return {
                        rangeStart: 0,
                        rangeEnd: 0
                    };
                    let D, d;
                    if (i(h)) {
                        let y = r(I, E);
                        D = y, d = y;
                    } else ({ startNode: D, endNode: d } = a(I, E, h));
                    return {
                        rangeStart: Math.min(b(D), b(d)),
                        rangeEnd: Math.max(v(D), v(d))
                    };
                }
                n.exports = {
                    calculateRange: p,
                    findNodeAtOffset: c
                };
            }
        }), om = Z({
            "src/main/core.js" (e, n) {
                "use strict";
                ae();
                var { diffArrays: t } = rD(), { printer: { printDocToString: s }, debug: { printDocToDebug: i } } = Le(), { getAlignmentSize: r } = Ge(), { guessEndOfLine: u, convertEndOfLineToChars: a, countEndOfLineChars: c, normalizeEndOfLine: l } = On(), C = Mi().normalize, m = nm(), g = Qe(), p = Gn(), f = am(), h = im(), N = "\uFEFF", T = Symbol("cursor");
                function A(d, y, o) {
                    let x = y.comments;
                    return x && (delete y.comments, g.attach(x, y, d, o)), o[Symbol.for("comments")] = x || [], o[Symbol.for("tokens")] = y.tokens || [], o.originalText = d, x;
                }
                function b(d, y) {
                    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                    if (!d || d.trim().length === 0) return {
                        formatted: "",
                        cursorOffset: -1,
                        comments: []
                    };
                    let { ast: x, text: F } = p.parse(d, y);
                    if (y.cursorOffset >= 0) {
                        let O = h.findNodeAtOffset(x, y.cursorOffset, y);
                        O && O.node && (y.cursorNode = O.node);
                    }
                    let S = A(F, x, y), k = f(x, y, o), _ = s(k, y);
                    if (g.ensureAllCommentsPrinted(S), o > 0) {
                        let O = _.formatted.trim();
                        _.cursorNodeStart !== void 0 && (_.cursorNodeStart -= _.formatted.indexOf(O)), _.formatted = O + a(y.endOfLine);
                    }
                    if (y.cursorOffset >= 0) {
                        let O, R, M, H, P;
                        if (y.cursorNode && _.cursorNodeText ? (O = y.locStart(y.cursorNode), R = F.slice(O, y.locEnd(y.cursorNode)), M = y.cursorOffset - O, H = _.cursorNodeStart, P = _.cursorNodeText) : (O = 0, R = F, M = y.cursorOffset, H = 0, P = _.formatted), R === P) return {
                            formatted: _.formatted,
                            cursorOffset: H + M,
                            comments: S
                        };
                        let G = [
                            ...R
                        ];
                        G.splice(M, 0, T);
                        let re = [
                            ...P
                        ], $ = t(G, re), W = H;
                        for (let ee of $)if (ee.removed) {
                            if (ee.value.includes(T)) break;
                        } else W += ee.count;
                        return {
                            formatted: _.formatted,
                            cursorOffset: W,
                            comments: S
                        };
                    }
                    return {
                        formatted: _.formatted,
                        cursorOffset: -1,
                        comments: S
                    };
                }
                function v(d, y) {
                    let { ast: o, text: x } = p.parse(d, y), { rangeStart: F, rangeEnd: S } = h.calculateRange(x, y, o), k = x.slice(F, S), _ = Math.min(F, x.lastIndexOf(`
`, F) + 1), O = x.slice(_, F).match(/^\s*/)[0], R = r(O, y.tabWidth), M = b(k, Object.assign(Object.assign({}, y), {}, {
                        rangeStart: 0,
                        rangeEnd: Number.POSITIVE_INFINITY,
                        cursorOffset: y.cursorOffset > F && y.cursorOffset <= S ? y.cursorOffset - F : -1,
                        endOfLine: "lf"
                    }), R), H = M.formatted.trimEnd(), { cursorOffset: P } = y;
                    P > S ? P += H.length - k.length : M.cursorOffset >= 0 && (P = M.cursorOffset + F);
                    let G = x.slice(0, F) + H + x.slice(S);
                    if (y.endOfLine !== "lf") {
                        let re = a(y.endOfLine);
                        P >= 0 && re === `\r
` && (P += c(G.slice(0, P), `
`)), G = G.replace(/\n/g, re);
                    }
                    return {
                        formatted: G,
                        cursorOffset: P,
                        comments: M.comments
                    };
                }
                function B(d, y, o) {
                    return typeof y != "number" || Number.isNaN(y) || y < 0 || y > d.length ? o : y;
                }
                function w(d, y) {
                    let { cursorOffset: o, rangeStart: x, rangeEnd: F } = y;
                    return o = B(d, o, -1), x = B(d, x, 0), F = B(d, F, d.length), Object.assign(Object.assign({}, y), {}, {
                        cursorOffset: o,
                        rangeStart: x,
                        rangeEnd: F
                    });
                }
                function I(d, y) {
                    let { cursorOffset: o, rangeStart: x, rangeEnd: F, endOfLine: S } = w(d, y), k = d.charAt(0) === N;
                    if (k && (d = d.slice(1), o--, x--, F--), S === "auto" && (S = u(d)), d.includes("\r")) {
                        let _ = (O)=>c(d.slice(0, Math.max(O, 0)), `\r
`);
                        o -= _(o), x -= _(x), F -= _(F), d = l(d);
                    }
                    return {
                        hasBOM: k,
                        text: d,
                        options: w(d, Object.assign(Object.assign({}, y), {}, {
                            cursorOffset: o,
                            rangeStart: x,
                            rangeEnd: F,
                            endOfLine: S
                        }))
                    };
                }
                function E(d, y) {
                    let o = p.resolveParser(y);
                    return !o.hasPragma || o.hasPragma(d);
                }
                function D(d, y) {
                    let { hasBOM: o, text: x, options: F } = I(d, C(y));
                    if (F.rangeStart >= F.rangeEnd && x !== "" || F.requirePragma && !E(x, F)) return {
                        formatted: d,
                        cursorOffset: y.cursorOffset,
                        comments: []
                    };
                    let S;
                    return F.rangeStart > 0 || F.rangeEnd < x.length ? S = v(x, F) : (!F.requirePragma && F.insertPragma && F.printer.insertPragma && !E(x, F) && (x = F.printer.insertPragma(x)), S = b(x, F)), o && (S.formatted = N + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
                }
                n.exports = {
                    formatWithCursor: D,
                    parse (d, y, o) {
                        let { text: x, options: F } = I(d, C(y)), S = p.parse(x, F);
                        return o && (S.ast = m(S.ast, F)), S;
                    },
                    formatAST (d, y) {
                        y = C(y);
                        let o = f(d, y);
                        return s(o, y);
                    },
                    formatDoc (d, y) {
                        return D(i(d), Object.assign(Object.assign({}, y), {}, {
                            parser: "__js_expression"
                        })).formatted;
                    },
                    printToDoc (d, y) {
                        y = C(y);
                        let { ast: o, text: x } = p.parse(d, y);
                        return A(x, o, y), f(o, y);
                    },
                    printDocToString (d, y) {
                        return s(d, C(y));
                    }
                };
            }
        }), cm = Z({
            "src/common/util-shared.js" (e, n) {
                "use strict";
                ae();
                var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: i, getIndentSize: r, skip: u, skipWhitespace: a, skipSpaces: c, skipNewline: l, skipToLineEnd: C, skipEverythingButNewLine: m, skipInlineComment: g, skipTrailingComment: p, hasNewline: f, hasNewlineInRange: h, hasSpaces: N, isNextLineEmpty: T, isNextLineEmptyAfterIndex: A, isPreviousLineEmpty: b, getNextNonSpaceNonCommentCharacterIndex: v, makeString: B, addLeadingComment: w, addDanglingComment: I, addTrailingComment: E } = Ge();
                n.exports = {
                    getMaxContinuousCount: t,
                    getStringWidth: s,
                    getAlignmentSize: i,
                    getIndentSize: r,
                    skip: u,
                    skipWhitespace: a,
                    skipSpaces: c,
                    skipNewline: l,
                    skipToLineEnd: C,
                    skipEverythingButNewLine: m,
                    skipInlineComment: g,
                    skipTrailingComment: p,
                    hasNewline: f,
                    hasNewlineInRange: h,
                    hasSpaces: N,
                    isNextLineEmpty: T,
                    isNextLineEmptyAfterIndex: A,
                    isPreviousLineEmpty: b,
                    getNextNonSpaceNonCommentCharacterIndex: v,
                    makeString: B,
                    addLeadingComment: w,
                    addDanglingComment: I,
                    addTrailingComment: E
                };
            }
        }), bt = Z({
            "src/utils/create-language.js" (e, n) {
                "use strict";
                ae(), n.exports = function(t, s) {
                    let { languageId: i } = t, r = _n(t, Kf);
                    return Object.assign(Object.assign({
                        linguistLanguageId: i
                    }, r), s(t));
                };
            }
        }), lm = Z({
            "node_modules/esutils/lib/ast.js" (e, n) {
                ae(), function() {
                    "use strict";
                    function t(c) {
                        if (c == null) return !1;
                        switch(c.type){
                            case "ArrayExpression":
                            case "AssignmentExpression":
                            case "BinaryExpression":
                            case "CallExpression":
                            case "ConditionalExpression":
                            case "FunctionExpression":
                            case "Identifier":
                            case "Literal":
                            case "LogicalExpression":
                            case "MemberExpression":
                            case "NewExpression":
                            case "ObjectExpression":
                            case "SequenceExpression":
                            case "ThisExpression":
                            case "UnaryExpression":
                            case "UpdateExpression":
                                return !0;
                        }
                        return !1;
                    }
                    function s(c) {
                        if (c == null) return !1;
                        switch(c.type){
                            case "DoWhileStatement":
                            case "ForInStatement":
                            case "ForStatement":
                            case "WhileStatement":
                                return !0;
                        }
                        return !1;
                    }
                    function i(c) {
                        if (c == null) return !1;
                        switch(c.type){
                            case "BlockStatement":
                            case "BreakStatement":
                            case "ContinueStatement":
                            case "DebuggerStatement":
                            case "DoWhileStatement":
                            case "EmptyStatement":
                            case "ExpressionStatement":
                            case "ForInStatement":
                            case "ForStatement":
                            case "IfStatement":
                            case "LabeledStatement":
                            case "ReturnStatement":
                            case "SwitchStatement":
                            case "ThrowStatement":
                            case "TryStatement":
                            case "VariableDeclaration":
                            case "WhileStatement":
                            case "WithStatement":
                                return !0;
                        }
                        return !1;
                    }
                    function r(c) {
                        return i(c) || c != null && c.type === "FunctionDeclaration";
                    }
                    function u(c) {
                        switch(c.type){
                            case "IfStatement":
                                return c.alternate != null ? c.alternate : c.consequent;
                            case "LabeledStatement":
                            case "ForStatement":
                            case "ForInStatement":
                            case "WhileStatement":
                            case "WithStatement":
                                return c.body;
                        }
                        return null;
                    }
                    function a(c) {
                        var l;
                        if (c.type !== "IfStatement" || c.alternate == null) return !1;
                        l = c.consequent;
                        do {
                            if (l.type === "IfStatement" && l.alternate == null) return !0;
                            l = u(l);
                        }while (l);
                        return !1;
                    }
                    n.exports = {
                        isExpression: t,
                        isStatement: i,
                        isIterationStatement: s,
                        isSourceElement: r,
                        isProblematicIfStatement: a,
                        trailingStatement: u
                    };
                }();
            }
        }), Ri = Z({
            "node_modules/esutils/lib/code.js" (e, n) {
                ae(), function() {
                    "use strict";
                    var t, s, i, r, u, a;
                    s = {
                        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
                        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
                    }, t = {
                        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
                        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
                    };
                    function c(A) {
                        return 48 <= A && A <= 57;
                    }
                    function l(A) {
                        return 48 <= A && A <= 57 || 97 <= A && A <= 102 || 65 <= A && A <= 70;
                    }
                    function C(A) {
                        return A >= 48 && A <= 55;
                    }
                    i = [
                        5760,
                        8192,
                        8193,
                        8194,
                        8195,
                        8196,
                        8197,
                        8198,
                        8199,
                        8200,
                        8201,
                        8202,
                        8239,
                        8287,
                        12288,
                        65279
                    ];
                    function m(A) {
                        return A === 32 || A === 9 || A === 11 || A === 12 || A === 160 || A >= 5760 && i.indexOf(A) >= 0;
                    }
                    function g(A) {
                        return A === 10 || A === 13 || A === 8232 || A === 8233;
                    }
                    function p(A) {
                        if (A <= 65535) return String.fromCharCode(A);
                        var b = String.fromCharCode(Math.floor((A - 65536) / 1024) + 55296), v = String.fromCharCode((A - 65536) % 1024 + 56320);
                        return b + v;
                    }
                    for(r = new Array(128), a = 0; a < 128; ++a)r[a] = a >= 97 && a <= 122 || a >= 65 && a <= 90 || a === 36 || a === 95;
                    for(u = new Array(128), a = 0; a < 128; ++a)u[a] = a >= 97 && a <= 122 || a >= 65 && a <= 90 || a >= 48 && a <= 57 || a === 36 || a === 95;
                    function f(A) {
                        return A < 128 ? r[A] : s.NonAsciiIdentifierStart.test(p(A));
                    }
                    function h(A) {
                        return A < 128 ? u[A] : s.NonAsciiIdentifierPart.test(p(A));
                    }
                    function N(A) {
                        return A < 128 ? r[A] : t.NonAsciiIdentifierStart.test(p(A));
                    }
                    function T(A) {
                        return A < 128 ? u[A] : t.NonAsciiIdentifierPart.test(p(A));
                    }
                    n.exports = {
                        isDecimalDigit: c,
                        isHexDigit: l,
                        isOctalDigit: C,
                        isWhiteSpace: m,
                        isLineTerminator: g,
                        isIdentifierStartES5: f,
                        isIdentifierPartES5: h,
                        isIdentifierStartES6: N,
                        isIdentifierPartES6: T
                    };
                }();
            }
        }), pm = Z({
            "node_modules/esutils/lib/keyword.js" (e, n) {
                ae(), function() {
                    "use strict";
                    var t = Ri();
                    function s(f) {
                        switch(f){
                            case "implements":
                            case "interface":
                            case "package":
                            case "private":
                            case "protected":
                            case "public":
                            case "static":
                            case "let":
                                return !0;
                            default:
                                return !1;
                        }
                    }
                    function i(f, h) {
                        return !h && f === "yield" ? !1 : r(f, h);
                    }
                    function r(f, h) {
                        if (h && s(f)) return !0;
                        switch(f.length){
                            case 2:
                                return f === "if" || f === "in" || f === "do";
                            case 3:
                                return f === "var" || f === "for" || f === "new" || f === "try";
                            case 4:
                                return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                            case 5:
                                return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                            case 6:
                                return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                            case 7:
                                return f === "default" || f === "finally" || f === "extends";
                            case 8:
                                return f === "function" || f === "continue" || f === "debugger";
                            case 10:
                                return f === "instanceof";
                            default:
                                return !1;
                        }
                    }
                    function u(f, h) {
                        return f === "null" || f === "true" || f === "false" || i(f, h);
                    }
                    function a(f, h) {
                        return f === "null" || f === "true" || f === "false" || r(f, h);
                    }
                    function c(f) {
                        return f === "eval" || f === "arguments";
                    }
                    function l(f) {
                        var h, N, T;
                        if (f.length === 0 || (T = f.charCodeAt(0), !t.isIdentifierStartES5(T))) return !1;
                        for(h = 1, N = f.length; h < N; ++h)if (T = f.charCodeAt(h), !t.isIdentifierPartES5(T)) return !1;
                        return !0;
                    }
                    function C(f, h) {
                        return (f - 55296) * 1024 + (h - 56320) + 65536;
                    }
                    function m(f) {
                        var h, N, T, A, b;
                        if (f.length === 0) return !1;
                        for(b = t.isIdentifierStartES6, h = 0, N = f.length; h < N; ++h){
                            if (T = f.charCodeAt(h), 55296 <= T && T <= 56319) {
                                if (++h, h >= N || (A = f.charCodeAt(h), !(56320 <= A && A <= 57343))) return !1;
                                T = C(T, A);
                            }
                            if (!b(T)) return !1;
                            b = t.isIdentifierPartES6;
                        }
                        return !0;
                    }
                    function g(f, h) {
                        return l(f) && !u(f, h);
                    }
                    function p(f, h) {
                        return m(f) && !a(f, h);
                    }
                    n.exports = {
                        isKeywordES5: i,
                        isKeywordES6: r,
                        isReservedWordES5: u,
                        isReservedWordES6: a,
                        isRestrictedWord: c,
                        isIdentifierNameES5: l,
                        isIdentifierNameES6: m,
                        isIdentifierES5: g,
                        isIdentifierES6: p
                    };
                }();
            }
        }), fm = Z({
            "node_modules/esutils/lib/utils.js" (e) {
                ae(), function() {
                    "use strict";
                    e.ast = lm(), e.code = Ri(), e.keyword = pm();
                }();
            }
        }), Pt = Z({
            "src/language-js/utils/is-block-comment.js" (e, n) {
                "use strict";
                ae();
                function t(s) {
                    return s.type === "Block" || s.type === "CommentBlock" || s.type === "MultiLine";
                }
                n.exports = t;
            }
        }), Xe = Z({
            "src/language-js/utils/index.js" (e, n) {
                "use strict";
                ae();
                var t = fm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: i, skipWhitespace: r, isNonEmptyArray: u, isNextLineEmptyAfterIndex: a, getStringWidth: c } = Ge(), { locStart: l, locEnd: C, hasSameLocStart: m } = nt(), g = Pt(), p = "(?:(?=.)\\s)", f = new RegExp("^".concat(p, "*:")), h = new RegExp("^".concat(p, "*::"));
                function N(L) {
                    return L.extra && L.extra.parenthesized && u(L.trailingComments) && g(L.trailingComments[0]) && f.test(L.trailingComments[0].value);
                }
                function T(L) {
                    return u(L) && g(L[0]) && h.test(L[0].value);
                }
                function A(L, De) {
                    if (!L || typeof L != "object") return !1;
                    if (Array.isArray(L)) return L.some((We)=>A(We, De));
                    let ke = De(L);
                    return typeof ke == "boolean" ? ke : Object.values(L).some((We)=>A(We, De));
                }
                function b(L) {
                    return L.type === "AssignmentExpression" || L.type === "BinaryExpression" || L.type === "LogicalExpression" || L.type === "NGPipeExpression" || L.type === "ConditionalExpression" || Ee(L) || q(L) || L.type === "SequenceExpression" || L.type === "TaggedTemplateExpression" || L.type === "BindExpression" || L.type === "UpdateExpression" && !L.prefix || L.type === "TSAsExpression" || L.type === "TSNonNullExpression";
                }
                function v(L) {
                    return L.expressions ? L.expressions[0] : L.left || L.test || L.callee || L.object || L.tag || L.argument || L.expression;
                }
                function B(L, De) {
                    if (De.expressions) return [
                        "expressions",
                        0
                    ];
                    if (De.left) return [
                        "left"
                    ];
                    if (De.test) return [
                        "test"
                    ];
                    if (De.object) return [
                        "object"
                    ];
                    if (De.callee) return [
                        "callee"
                    ];
                    if (De.tag) return [
                        "tag"
                    ];
                    if (De.argument) return [
                        "argument"
                    ];
                    if (De.expression) return [
                        "expression"
                    ];
                    throw new Error("Unexpected node has no left side.");
                }
                function w(L) {
                    return L.type === "Line" || L.type === "CommentLine" || L.type === "SingleLine" || L.type === "HashbangComment" || L.type === "HTMLOpen" || L.type === "HTMLClose";
                }
                var I = new Set([
                    "ExportDefaultDeclaration",
                    "ExportDefaultSpecifier",
                    "DeclareExportDeclaration",
                    "ExportNamedDeclaration",
                    "ExportAllDeclaration"
                ]);
                function E(L) {
                    return L && I.has(L.type);
                }
                function D(L) {
                    let De = L.getParentNode();
                    return L.getName() === "declaration" && E(De) ? De : null;
                }
                function d(L) {
                    return L.type === "BooleanLiteral" || L.type === "DirectiveLiteral" || L.type === "Literal" || L.type === "NullLiteral" || L.type === "NumericLiteral" || L.type === "BigIntLiteral" || L.type === "DecimalLiteral" || L.type === "RegExpLiteral" || L.type === "StringLiteral" || L.type === "TemplateLiteral" || L.type === "TSTypeLiteral" || L.type === "JSXText";
                }
                function y(L) {
                    return L.type === "NumericLiteral" || L.type === "Literal" && typeof L.value == "number";
                }
                function o(L) {
                    return L.type === "UnaryExpression" && (L.operator === "+" || L.operator === "-") && y(L.argument);
                }
                function x(L) {
                    return L.type === "StringLiteral" || L.type === "Literal" && typeof L.value == "string";
                }
                function F(L) {
                    return L.type === "ObjectTypeAnnotation" || L.type === "TSTypeLiteral" || L.type === "TSMappedType";
                }
                function S(L) {
                    return L.type === "FunctionExpression" || L.type === "ArrowFunctionExpression";
                }
                function k(L) {
                    return L.type === "FunctionExpression" || L.type === "ArrowFunctionExpression" && L.body.type === "BlockStatement";
                }
                function _(L) {
                    return L.type === "TemplateLiteral";
                }
                function O(L) {
                    return Ee(L) && L.callee.type === "Identifier" && [
                        "async",
                        "inject",
                        "fakeAsync",
                        "waitForAsync"
                    ].includes(L.callee.name);
                }
                function R(L) {
                    return L.type === "JSXElement" || L.type === "JSXFragment";
                }
                function M(L, De) {
                    if (L.parentParser !== "markdown" && L.parentParser !== "mdx") return !1;
                    let ke = De.getNode();
                    if (!ke.expression || !R(ke.expression)) return !1;
                    let We = De.getParentNode();
                    return We.type === "Program" && We.body.length === 1;
                }
                function H(L) {
                    return L.kind === "get" || L.kind === "set";
                }
                function P(L) {
                    return H(L) || m(L, L.value);
                }
                function G(L) {
                    return (L.type === "ObjectTypeProperty" || L.type === "ObjectTypeInternalSlot") && L.value.type === "FunctionTypeAnnotation" && !L.static && !P(L);
                }
                function re(L) {
                    return (L.type === "TypeAnnotation" || L.type === "TSTypeAnnotation") && L.typeAnnotation.type === "FunctionTypeAnnotation" && !L.static && !m(L, L.typeAnnotation);
                }
                var $ = new Set([
                    "BinaryExpression",
                    "LogicalExpression",
                    "NGPipeExpression"
                ]);
                function W(L) {
                    return $.has(L.type);
                }
                function ee(L) {
                    return q(L) || L.type === "BindExpression" && Boolean(L.object);
                }
                var U = new Set([
                    "AnyTypeAnnotation",
                    "TSAnyKeyword",
                    "NullLiteralTypeAnnotation",
                    "TSNullKeyword",
                    "ThisTypeAnnotation",
                    "TSThisType",
                    "NumberTypeAnnotation",
                    "TSNumberKeyword",
                    "VoidTypeAnnotation",
                    "TSVoidKeyword",
                    "BooleanTypeAnnotation",
                    "TSBooleanKeyword",
                    "BigIntTypeAnnotation",
                    "TSBigIntKeyword",
                    "SymbolTypeAnnotation",
                    "TSSymbolKeyword",
                    "StringTypeAnnotation",
                    "TSStringKeyword",
                    "BooleanLiteralTypeAnnotation",
                    "StringLiteralTypeAnnotation",
                    "BigIntLiteralTypeAnnotation",
                    "NumberLiteralTypeAnnotation",
                    "TSLiteralType",
                    "TSTemplateLiteralType",
                    "EmptyTypeAnnotation",
                    "MixedTypeAnnotation",
                    "TSNeverKeyword",
                    "TSObjectKeyword",
                    "TSUndefinedKeyword",
                    "TSUnknownKeyword"
                ]);
                function ne(L) {
                    return L ? !!((L.type === "GenericTypeAnnotation" || L.type === "TSTypeReference") && !L.typeParameters || U.has(L.type)) : !1;
                }
                var se = /^(?:skip|[fx]?(?:it|describe|test))$/;
                function V(L) {
                    return q(L.callee) && L.callee.object.type === "Identifier" && L.callee.property.type === "Identifier" && se.test(L.callee.object.name) && (L.callee.property.name === "only" || L.callee.property.name === "skip");
                }
                function oe(L) {
                    let De = /^(?:before|after)(?:Each|All)$/;
                    return L.callee.type === "Identifier" && De.test(L.callee.name) && L.arguments.length === 1;
                }
                function K(L, De) {
                    if (L.type !== "CallExpression") return !1;
                    if (L.arguments.length === 1) {
                        if (O(L) && De && K(De)) return S(L.arguments[0]);
                        if (oe(L)) return O(L.arguments[0]);
                    } else if ((L.arguments.length === 2 || L.arguments.length === 3) && (L.callee.type === "Identifier" && se.test(L.callee.name) || V(L)) && (_(L.arguments[0]) || x(L.arguments[0]))) return L.arguments[2] && !y(L.arguments[2]) ? !1 : (L.arguments.length === 2 ? S(L.arguments[1]) : k(L.arguments[1]) && Ke(L.arguments[1]).length <= 1) || O(L.arguments[1]);
                    return !1;
                }
                function Ee(L) {
                    return L && (L.type === "CallExpression" || L.type === "OptionalCallExpression");
                }
                function q(L) {
                    return L && (L.type === "MemberExpression" || L.type === "OptionalMemberExpression");
                }
                function le(L) {
                    let De = "expressions";
                    L.type === "TSTemplateLiteralType" && (De = "types");
                    let ke = L[De];
                    return ke.length === 0 ? !1 : ke.every((We)=>{
                        if (Me(We)) return !1;
                        if (We.type === "Identifier" || We.type === "ThisExpression") return !0;
                        if (q(We)) {
                            let $e = We;
                            for(; q($e);)if ($e.property.type !== "Identifier" && $e.property.type !== "Literal" && $e.property.type !== "StringLiteral" && $e.property.type !== "NumericLiteral" || ($e = $e.object, Me($e))) return !1;
                            return $e.type === "Identifier" || $e.type === "ThisExpression";
                        }
                        return !1;
                    });
                }
                function ue(L, De) {
                    return L === "+" ? "+" + De : L === "-" ? "-" + De : De;
                }
                function Q(L, De) {
                    let ke = l(De), We = r(L, C(De));
                    return We !== !1 && L.slice(ke, ke + 2) === "/*" && L.slice(We, We + 2) === "*/";
                }
                function de(L, De) {
                    return R(De) ? Ae(De) : Me(De, Pe.Leading, (ke)=>i(L, C(ke)));
                }
                function ge(L, De) {
                    return De.parser !== "json" && x(L.key) && J(L.key).slice(1, -1) === L.key.value && (t(L.key.value) && !(De.parser === "babel-ts" && L.type === "ClassProperty" || De.parser === "typescript" && L.type === "PropertyDefinition") || ve(L.key.value) && String(Number(L.key.value)) === L.key.value && (De.parser === "babel" || De.parser === "acorn" || De.parser === "espree" || De.parser === "meriyah" || De.parser === "__babel_estree"));
                }
                function ve(L) {
                    return /^(?:\d+|\d+\.\d+)$/.test(L);
                }
                function xe(L, De) {
                    let ke = /^[fx]?(?:describe|it|test)$/;
                    return De.type === "TaggedTemplateExpression" && De.quasi === L && De.tag.type === "MemberExpression" && De.tag.property.type === "Identifier" && De.tag.property.name === "each" && (De.tag.object.type === "Identifier" && ke.test(De.tag.object.name) || De.tag.object.type === "MemberExpression" && De.tag.object.property.type === "Identifier" && (De.tag.object.property.name === "only" || De.tag.object.property.name === "skip") && De.tag.object.object.type === "Identifier" && ke.test(De.tag.object.object.name));
                }
                function we(L) {
                    return L.quasis.some((De)=>De.value.raw.includes(`
`));
                }
                function fe(L, De) {
                    return (L.type === "TemplateLiteral" && we(L) || L.type === "TaggedTemplateExpression" && we(L.quasi)) && !i(De, l(L), {
                        backwards: !0
                    });
                }
                function pe(L) {
                    if (!Me(L)) return !1;
                    let De = s(qe(L, Pe.Dangling));
                    return De && !g(De);
                }
                function me(L) {
                    if (L.length <= 1) return !1;
                    let De = 0;
                    for (let ke of L)if (S(ke)) {
                        if (De += 1, De > 1) return !0;
                    } else if (Ee(ke)) {
                        for (let We of ke.arguments)if (S(We)) return !0;
                    }
                    return !1;
                }
                function ce(L) {
                    let De = L.getValue(), ke = L.getParentNode();
                    return Ee(De) && Ee(ke) && ke.callee === De && De.arguments.length > ke.arguments.length && ke.arguments.length > 0;
                }
                function he(L, De) {
                    if (De >= 2) return !1;
                    let ke = ($e)=>he($e, De + 1), We = L.type === "Literal" && "regex" in L && L.regex.pattern || L.type === "RegExpLiteral" && L.pattern;
                    return We && c(We) > 5 ? !1 : L.type === "Literal" || L.type === "BigIntLiteral" || L.type === "DecimalLiteral" || L.type === "BooleanLiteral" || L.type === "NullLiteral" || L.type === "NumericLiteral" || L.type === "RegExpLiteral" || L.type === "StringLiteral" || L.type === "Identifier" || L.type === "ThisExpression" || L.type === "Super" || L.type === "PrivateName" || L.type === "PrivateIdentifier" || L.type === "ArgumentPlaceholder" || L.type === "Import" ? !0 : L.type === "TemplateLiteral" ? L.quasis.every(($e)=>!$e.value.raw.includes(`
`)) && L.expressions.every(ke) : L.type === "ObjectExpression" ? L.properties.every(($e)=>!$e.computed && ($e.shorthand || $e.value && ke($e.value))) : L.type === "ArrayExpression" ? L.elements.every(($e)=>$e === null || ke($e)) : rt(L) ? (L.type === "ImportExpression" || he(L.callee, De)) && Be(L).every(ke) : q(L) ? he(L.object, De) && he(L.property, De) : L.type === "UnaryExpression" && (L.operator === "!" || L.operator === "-") ? he(L.argument, De) : L.type === "TSNonNullExpression" ? he(L.expression, De) : !1;
                }
                function J(L) {
                    return L.extra ? L.extra.raw : L.raw;
                }
                function ye(L) {
                    return L;
                }
                function X(L) {
                    return L.filepath && /\.tsx$/i.test(L.filepath);
                }
                function Y(L) {
                    let De = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
                    return L.trailingComma === "es5" && De === "es5" || L.trailingComma === "all" && (De === "all" || De === "es5");
                }
                function te(L, De) {
                    switch(L = tt(L), L.type){
                        case "FunctionExpression":
                        case "ClassExpression":
                        case "DoExpression":
                            return De;
                        case "ObjectExpression":
                            return !0;
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                            return te(L.object, De);
                        case "TaggedTemplateExpression":
                            return L.tag.type === "FunctionExpression" ? !1 : te(L.tag, De);
                        case "CallExpression":
                        case "OptionalCallExpression":
                            return L.callee.type === "FunctionExpression" ? !1 : te(L.callee, De);
                        case "ConditionalExpression":
                            return te(L.test, De);
                        case "UpdateExpression":
                            return !L.prefix && te(L.argument, De);
                        case "BindExpression":
                            return L.object && te(L.object, De);
                        case "SequenceExpression":
                            return te(L.expressions[0], De);
                        case "TSAsExpression":
                        case "TSNonNullExpression":
                            return te(L.expression, De);
                        default:
                            return !1;
                    }
                }
                var z = {
                    "==": !0,
                    "!=": !0,
                    "===": !0,
                    "!==": !0
                }, j = {
                    "*": !0,
                    "/": !0,
                    "%": !0
                }, Ce = {
                    ">>": !0,
                    ">>>": !0,
                    "<<": !0
                };
                function Ne(L, De) {
                    return !(Ue(De) !== Ue(L) || L === "**" || z[L] && z[De] || De === "%" && j[L] || L === "%" && j[De] || De !== L && j[De] && j[L] || Ce[L] && Ce[De]);
                }
                var je = {};
                for (let [L, De] of [
                    [
                        "|>"
                    ],
                    [
                        "??"
                    ],
                    [
                        "||"
                    ],
                    [
                        "&&"
                    ],
                    [
                        "|"
                    ],
                    [
                        "^"
                    ],
                    [
                        "&"
                    ],
                    [
                        "==",
                        "===",
                        "!=",
                        "!=="
                    ],
                    [
                        "<",
                        ">",
                        "<=",
                        ">=",
                        "in",
                        "instanceof"
                    ],
                    [
                        ">>",
                        "<<",
                        ">>>"
                    ],
                    [
                        "+",
                        "-"
                    ],
                    [
                        "*",
                        "/",
                        "%"
                    ],
                    [
                        "**"
                    ]
                ].entries())for (let ke of De)je[ke] = L;
                function Ue(L) {
                    return je[L];
                }
                function tt(L) {
                    for(; L.left;)L = L.left;
                    return L;
                }
                function Te(L) {
                    return Boolean(Ce[L]) || L === "|" || L === "^" || L === "&";
                }
                function _e(L) {
                    if (L.rest) return !0;
                    let De = Ke(L);
                    return De.length > 0 && s(De).type === "RestElement";
                }
                var Fe = new WeakMap;
                function Ke(L) {
                    if (Fe.has(L)) return Fe.get(L);
                    let De = [];
                    return L.this && De.push(L.this), Array.isArray(L.parameters) ? De.push(...L.parameters) : Array.isArray(L.params) && De.push(...L.params), L.rest && De.push(L.rest), Fe.set(L, De), De;
                }
                function Se(L, De) {
                    let ke = L.getValue(), We = 0, $e = (ut)=>De(ut, We++);
                    ke.this && L.call($e, "this"), Array.isArray(ke.parameters) ? L.each($e, "parameters") : Array.isArray(ke.params) && L.each($e, "params"), ke.rest && L.call($e, "rest");
                }
                var ze = new WeakMap;
                function Be(L) {
                    if (ze.has(L)) return ze.get(L);
                    let De = L.arguments;
                    return L.type === "ImportExpression" && (De = [
                        L.source
                    ], L.attributes && De.push(L.attributes)), ze.set(L, De), De;
                }
                function Ie(L, De) {
                    let ke = L.getValue();
                    ke.type === "ImportExpression" ? (L.call((We)=>De(We, 0), "source"), ke.attributes && L.call((We)=>De(We, 1), "attributes")) : L.each(De, "arguments");
                }
                function Ve(L) {
                    return L.value.trim() === "prettier-ignore" && !L.unignore;
                }
                function Ae(L) {
                    return L && (L.prettierIgnore || Me(L, Pe.PrettierIgnore));
                }
                function Oe(L) {
                    let De = L.getValue();
                    return Ae(De);
                }
                var Pe = {
                    Leading: 2,
                    Trailing: 4,
                    Dangling: 8,
                    Block: 16,
                    Line: 32,
                    PrettierIgnore: 64,
                    First: 128,
                    Last: 256
                }, ie = (L, De)=>{
                    if (typeof L == "function" && (De = L, L = 0), L || De) return (ke, We, $e)=>!(L & Pe.Leading && !ke.leading || L & Pe.Trailing && !ke.trailing || L & Pe.Dangling && (ke.leading || ke.trailing) || L & Pe.Block && !g(ke) || L & Pe.Line && !w(ke) || L & Pe.First && We !== 0 || L & Pe.Last && We !== $e.length - 1 || L & Pe.PrettierIgnore && !Ve(ke) || De && !De(ke));
                };
                function Me(L, De, ke) {
                    if (!L || !u(L.comments)) return !1;
                    let We = ie(De, ke);
                    return We ? L.comments.some(We) : !0;
                }
                function qe(L, De, ke) {
                    if (!L || !Array.isArray(L.comments)) return [];
                    let We = ie(De, ke);
                    return We ? L.comments.filter(We) : L.comments;
                }
                var Je = (L, De)=>{
                    let { originalText: ke } = De;
                    return a(ke, C(L));
                };
                function rt(L) {
                    return Ee(L) || L.type === "NewExpression" || L.type === "ImportExpression";
                }
                function Ze(L) {
                    return L && (L.type === "ObjectProperty" || L.type === "Property" && !L.method && L.kind === "init");
                }
                function ct(L) {
                    return Boolean(L.__isUsingHackPipeline);
                }
                var qt = Symbol("ifWithoutBlockAndSameLineComment");
                n.exports = {
                    getFunctionParameters: Ke,
                    iterateFunctionParametersPath: Se,
                    getCallArguments: Be,
                    iterateCallArgumentsPath: Ie,
                    hasRestParameter: _e,
                    getLeftSide: v,
                    getLeftSidePathName: B,
                    getParentExportDeclaration: D,
                    getTypeScriptMappedTypeModifier: ue,
                    hasFlowAnnotationComment: T,
                    hasFlowShorthandAnnotationComment: N,
                    hasLeadingOwnLineComment: de,
                    hasNakedLeftSide: b,
                    hasNode: A,
                    hasIgnoreComment: Oe,
                    hasNodeIgnoreComment: Ae,
                    identity: ye,
                    isBinaryish: W,
                    isCallLikeExpression: rt,
                    isEnabledHackPipeline: ct,
                    isLineComment: w,
                    isPrettierIgnoreComment: Ve,
                    isCallExpression: Ee,
                    isMemberExpression: q,
                    isExportDeclaration: E,
                    isFlowAnnotationComment: Q,
                    isFunctionCompositionArgs: me,
                    isFunctionNotation: P,
                    isFunctionOrArrowExpression: S,
                    isGetterOrSetter: H,
                    isJestEachTemplateLiteral: xe,
                    isJsxNode: R,
                    isLiteral: d,
                    isLongCurriedCallExpression: ce,
                    isSimpleCallArgument: he,
                    isMemberish: ee,
                    isNumericLiteral: y,
                    isSignedNumericLiteral: o,
                    isObjectProperty: Ze,
                    isObjectType: F,
                    isObjectTypePropertyAFunction: G,
                    isSimpleType: ne,
                    isSimpleNumber: ve,
                    isSimpleTemplateLiteral: le,
                    isStringLiteral: x,
                    isStringPropSafeToUnquote: ge,
                    isTemplateOnItsOwnLine: fe,
                    isTestCall: K,
                    isTheOnlyJsxElementInMarkdown: M,
                    isTSXFile: X,
                    isTypeAnnotationAFunction: re,
                    isNextLineEmpty: Je,
                    needsHardlineAfterDanglingComment: pe,
                    rawText: J,
                    shouldPrintComma: Y,
                    isBitwiseOperator: Te,
                    shouldFlatten: Ne,
                    startsWithNoLookaheadToken: te,
                    getPrecedence: Ue,
                    hasComment: Me,
                    getComments: qe,
                    CommentCheckFlags: Pe,
                    markerForIfWithoutBlockAndSameLineComment: qt
                };
            }
        }), It = Z({
            "src/language-js/print/template-literal.js" (e, n) {
                "use strict";
                ae();
                var t = st(), { getStringWidth: s, getIndentSize: i } = Ge(), { builders: { join: r, hardline: u, softline: a, group: c, indent: l, align: C, lineSuffixBoundary: m, addAlignmentToDoc: g }, printer: { printDocToString: p }, utils: { mapDoc: f } } = Le(), { isBinaryish: h, isJestEachTemplateLiteral: N, isSimpleTemplateLiteral: T, hasComment: A, isMemberExpression: b } = Xe();
                function v(d, y, o) {
                    let x = d.getValue();
                    if (x.type === "TemplateLiteral" && N(x, d.getParentNode())) {
                        let R = B(d, o, y);
                        if (R) return R;
                    }
                    let S = "expressions";
                    x.type === "TSTemplateLiteralType" && (S = "types");
                    let k = [], _ = d.map(y, S), O = T(x);
                    return O && (_ = _.map((R)=>p(R, Object.assign(Object.assign({}, o), {}, {
                            printWidth: Number.POSITIVE_INFINITY
                        })).formatted)), k.push(m, "`"), d.each((R)=>{
                        let M = R.getName();
                        if (k.push(y()), M < _.length) {
                            let { tabWidth: H } = o, P = R.getValue(), G = i(P.value.raw, H), re = _[M];
                            if (!O) {
                                let W = x[S][M];
                                (A(W) || b(W) || W.type === "ConditionalExpression" || W.type === "SequenceExpression" || W.type === "TSAsExpression" || h(W)) && (re = [
                                    l([
                                        a,
                                        re
                                    ]),
                                    a
                                ]);
                            }
                            let $ = G === 0 && P.value.raw.endsWith(`
`) ? C(Number.NEGATIVE_INFINITY, re) : g(re, G, H);
                            k.push(c([
                                "${",
                                $,
                                m,
                                "}"
                            ]));
                        }
                    }, "quasis"), k.push("`"), k;
                }
                function B(d, y, o) {
                    let x = d.getNode(), F = x.quasis[0].value.raw.trim().split(/\s*\|\s*/);
                    if (F.length > 1 || F.some((S)=>S.length > 0)) {
                        y.__inJestEach = !0;
                        let S = d.map(o, "expressions");
                        y.__inJestEach = !1;
                        let k = [], _ = S.map((P)=>"${" + p(P, Object.assign(Object.assign({}, y), {}, {
                                printWidth: Number.POSITIVE_INFINITY,
                                endOfLine: "lf"
                            })).formatted + "}"), O = [
                            {
                                hasLineBreak: !1,
                                cells: []
                            }
                        ];
                        for(let P = 1; P < x.quasis.length; P++){
                            let G = t(O), re = _[P - 1];
                            G.cells.push(re), re.includes(`
`) && (G.hasLineBreak = !0), x.quasis[P].value.raw.includes(`
`) && O.push({
                                hasLineBreak: !1,
                                cells: []
                            });
                        }
                        let R = Math.max(F.length, ...O.map((P)=>P.cells.length)), M = Array.from({
                            length: R
                        }).fill(0), H = [
                            {
                                cells: F
                            },
                            ...O.filter((P)=>P.cells.length > 0)
                        ];
                        for (let { cells: P } of H.filter((G)=>!G.hasLineBreak))for (let [G, re] of P.entries())M[G] = Math.max(M[G], s(re));
                        return k.push(m, "`", l([
                            u,
                            r(u, H.map((P)=>r(" | ", P.cells.map((G, re)=>P.hasLineBreak ? G : G + " ".repeat(M[re] - s(G))))))
                        ]), u, "`"), k;
                    }
                }
                function w(d, y) {
                    let o = d.getValue(), x = y();
                    return A(o) && (x = c([
                        l([
                            a,
                            x
                        ]),
                        a
                    ])), [
                        "${",
                        x,
                        m,
                        "}"
                    ];
                }
                function I(d, y) {
                    return d.map((o)=>w(o, y), "expressions");
                }
                function E(d, y) {
                    return f(d, (o)=>typeof o == "string" ? y ? o.replace(/(\\*)`/g, "$1$1\\`") : D(o) : o);
                }
                function D(d) {
                    return d.replace(/([\\`]|\${)/g, "\\$1");
                }
                n.exports = {
                    printTemplateLiteral: v,
                    printTemplateExpressions: I,
                    escapeTemplateCharacters: E,
                    uncookTemplateElementValue: D
                };
            }
        }), Dm = Z({
            "src/language-js/embed/markdown.js" (e, n) {
                "use strict";
                ae();
                var { builders: { indent: t, softline: s, literalline: i, dedentToRoot: r } } = Le(), { escapeTemplateCharacters: u } = It();
                function a(l, C, m) {
                    let p = l.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (T, A)=>"\\".repeat(A.length / 2) + "`"), f = c(p), h = f !== "";
                    h && (p = p.replace(new RegExp("^".concat(f), "gm"), ""));
                    let N = u(m(p, {
                        parser: "markdown",
                        __inJsTemplate: !0
                    }, {
                        stripTrailingHardline: !0
                    }), !0);
                    return [
                        "`",
                        h ? t([
                            s,
                            N
                        ]) : [
                            i,
                            r(N)
                        ],
                        s,
                        "`"
                    ];
                }
                function c(l) {
                    let C = l.match(/^([^\S\n]*)\S/m);
                    return C === null ? "" : C[1];
                }
                n.exports = a;
            }
        }), mm = Z({
            "src/language-js/embed/css.js" (e, n) {
                "use strict";
                ae();
                var { isNonEmptyArray: t } = Ge(), { builders: { indent: s, hardline: i, softline: r }, utils: { mapDoc: u, replaceEndOfLine: a, cleanDoc: c } } = Le(), { printTemplateExpressions: l } = It();
                function C(p, f, h) {
                    let N = p.getValue(), T = N.quasis.map((w)=>w.value.raw), A = 0, b = T.reduce((w, I, E)=>E === 0 ? I : w + "@prettier-placeholder-" + A++ + "-id" + I, ""), v = h(b, {
                        parser: "scss"
                    }, {
                        stripTrailingHardline: !0
                    }), B = l(p, f);
                    return m(v, N, B);
                }
                function m(p, f, h) {
                    if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim()) return "``";
                    let T = g(p, h);
                    if (!T) throw new Error("Couldn't insert all the expressions");
                    return [
                        "`",
                        s([
                            i,
                            T
                        ]),
                        r,
                        "`"
                    ];
                }
                function g(p, f) {
                    if (!t(f)) return p;
                    let h = 0, N = u(c(p), (T)=>typeof T != "string" || !T.includes("@prettier-placeholder") ? T : T.split(/@prettier-placeholder-(\d+)-id/).map((A, b)=>b % 2 === 0 ? a(A) : (h++, f[A])));
                    return f.length === h ? N : null;
                }
                n.exports = C;
            }
        }), dm = Z({
            "src/language-js/embed/graphql.js" (e, n) {
                "use strict";
                ae();
                var { builders: { indent: t, join: s, hardline: i } } = Le(), { escapeTemplateCharacters: r, printTemplateExpressions: u } = It();
                function a(l, C, m) {
                    let g = l.getValue(), p = g.quasis.length;
                    if (p === 1 && g.quasis[0].value.raw.trim() === "") return "``";
                    let f = u(l, C), h = [];
                    for(let N = 0; N < p; N++){
                        let T = g.quasis[N], A = N === 0, b = N === p - 1, v = T.value.cooked, B = v.split(`
`), w = B.length, I = f[N], E = w > 2 && B[0].trim() === "" && B[1].trim() === "", D = w > 2 && B[w - 1].trim() === "" && B[w - 2].trim() === "", d = B.every((o)=>/^\s*(?:#[^\n\r]*)?$/.test(o));
                        if (!b && /#[^\n\r]*$/.test(B[w - 1])) return null;
                        let y = null;
                        d ? y = c(B) : y = m(v, {
                            parser: "graphql"
                        }, {
                            stripTrailingHardline: !0
                        }), y ? (y = r(y, !1), !A && E && h.push(""), h.push(y), !b && D && h.push("")) : !A && !b && E && h.push(""), I && h.push(I);
                    }
                    return [
                        "`",
                        t([
                            i,
                            s(i, h)
                        ]),
                        i,
                        "`"
                    ];
                }
                function c(l) {
                    let C = [], m = !1, g = l.map((p)=>p.trim());
                    for (let [p, f] of g.entries())f !== "" && (g[p - 1] === "" && m ? C.push([
                        i,
                        f
                    ]) : C.push(f), m = !0);
                    return C.length === 0 ? null : s(i, C);
                }
                n.exports = a;
            }
        }), gm = Z({
            "src/language-js/embed/html.js" (e, n) {
                "use strict";
                ae();
                var { builders: { indent: t, line: s, hardline: i, group: r }, utils: { mapDoc: u } } = Le(), { printTemplateExpressions: a, uncookTemplateElementValue: c } = It(), l = 0;
                function C(m, g, p, f, h) {
                    let { parser: N } = h, T = m.getValue(), A = l;
                    l = l + 1 >>> 0;
                    let b = (x)=>"PRETTIER_HTML_PLACEHOLDER_".concat(x, "_").concat(A, "_IN_JS"), v = T.quasis.map((x, F, S)=>F === S.length - 1 ? x.value.cooked : x.value.cooked + b(F)).join(""), B = a(m, g);
                    if (B.length === 0 && v.trim().length === 0) return "``";
                    let w = new RegExp(b("(\\d+)"), "g"), I = 0, E = p(v, {
                        parser: N,
                        __onHtmlRoot (x) {
                            I = x.children.length;
                        }
                    }, {
                        stripTrailingHardline: !0
                    }), D = u(E, (x)=>{
                        if (typeof x != "string") return x;
                        let F = [], S = x.split(w);
                        for(let k = 0; k < S.length; k++){
                            let _ = S[k];
                            if (k % 2 === 0) {
                                _ && (_ = c(_), f.__embeddedInHtml && (_ = _.replace(/<\/(script)\b/gi, "<\\/$1")), F.push(_));
                                continue;
                            }
                            let O = Number(_);
                            F.push(B[O]);
                        }
                        return F;
                    }), d = /^\s/.test(v) ? " " : "", y = /\s$/.test(v) ? " " : "", o = f.htmlWhitespaceSensitivity === "ignore" ? i : d && y ? s : null;
                    return r(o ? [
                        "`",
                        t([
                            o,
                            r(D)
                        ]),
                        o,
                        "`"
                    ] : [
                        "`",
                        d,
                        I > 1 ? t(r(D)) : r(D),
                        y,
                        "`"
                    ]);
                }
                n.exports = C;
            }
        }), ym = Z({
            "src/language-js/embed.js" (e, n) {
                "use strict";
                ae();
                var { hasComment: t, CommentCheckFlags: s, isObjectProperty: i } = Xe(), r = Dm(), u = mm(), a = dm(), c = gm();
                function l(E) {
                    if (g(E) || N(E) || T(E) || p(E)) return "css";
                    if (v(E)) return "graphql";
                    if (w(E)) return "html";
                    if (f(E)) return "angular";
                    if (m(E)) return "markdown";
                }
                function C(E, D, d, y) {
                    let o = E.getValue();
                    if (o.type !== "TemplateLiteral" || I(o)) return;
                    let x = l(E);
                    if (!!x) {
                        if (x === "markdown") return r(E, D, d);
                        if (x === "css") return u(E, D, d);
                        if (x === "graphql") return a(E, D, d);
                        if (x === "html" || x === "angular") return c(E, D, d, y, {
                            parser: x
                        });
                    }
                }
                function m(E) {
                    let D = E.getValue(), d = E.getParentNode();
                    return d && d.type === "TaggedTemplateExpression" && D.quasis.length === 1 && d.tag.type === "Identifier" && (d.tag.name === "md" || d.tag.name === "markdown");
                }
                function g(E) {
                    let D = E.getValue(), d = E.getParentNode(), y = E.getParentNode(1);
                    return y && D.quasis && d.type === "JSXExpressionContainer" && y.type === "JSXElement" && y.openingElement.name.name === "style" && y.openingElement.attributes.some((o)=>o.name.name === "jsx") || d && d.type === "TaggedTemplateExpression" && d.tag.type === "Identifier" && d.tag.name === "css" || d && d.type === "TaggedTemplateExpression" && d.tag.type === "MemberExpression" && d.tag.object.name === "css" && (d.tag.property.name === "global" || d.tag.property.name === "resolve");
                }
                function p(E) {
                    return E.match((D)=>D.type === "TemplateLiteral", (D, d)=>D.type === "ArrayExpression" && d === "elements", (D, d)=>i(D) && D.key.type === "Identifier" && D.key.name === "styles" && d === "value", ...h);
                }
                function f(E) {
                    return E.match((D)=>D.type === "TemplateLiteral", (D, d)=>i(D) && D.key.type === "Identifier" && D.key.name === "template" && d === "value", ...h);
                }
                var h = [
                    (E, D)=>E.type === "ObjectExpression" && D === "properties",
                    (E, D)=>E.type === "CallExpression" && E.callee.type === "Identifier" && E.callee.name === "Component" && D === "arguments",
                    (E, D)=>E.type === "Decorator" && D === "expression"
                ];
                function N(E) {
                    let D = E.getParentNode();
                    if (!D || D.type !== "TaggedTemplateExpression") return !1;
                    let d = D.tag.type === "ParenthesizedExpression" ? D.tag.expression : D.tag;
                    switch(d.type){
                        case "MemberExpression":
                            return A(d.object) || b(d);
                        case "CallExpression":
                            return A(d.callee) || d.callee.type === "MemberExpression" && (d.callee.object.type === "MemberExpression" && (A(d.callee.object.object) || b(d.callee.object)) || d.callee.object.type === "CallExpression" && A(d.callee.object.callee));
                        case "Identifier":
                            return d.name === "css";
                        default:
                            return !1;
                    }
                }
                function T(E) {
                    let D = E.getParentNode(), d = E.getParentNode(1);
                    return d && D.type === "JSXExpressionContainer" && d.type === "JSXAttribute" && d.name.type === "JSXIdentifier" && d.name.name === "css";
                }
                function A(E) {
                    return E.type === "Identifier" && E.name === "styled";
                }
                function b(E) {
                    return /^[A-Z]/.test(E.object.name) && E.property.name === "extend";
                }
                function v(E) {
                    let D = E.getValue(), d = E.getParentNode();
                    return B(D, "GraphQL") || d && (d.type === "TaggedTemplateExpression" && (d.tag.type === "MemberExpression" && d.tag.object.name === "graphql" && d.tag.property.name === "experimental" || d.tag.type === "Identifier" && (d.tag.name === "gql" || d.tag.name === "graphql")) || d.type === "CallExpression" && d.callee.type === "Identifier" && d.callee.name === "graphql");
                }
                function B(E, D) {
                    return t(E, s.Block | s.Leading, (d)=>{
                        let { value: y } = d;
                        return y === " ".concat(D, " ");
                    });
                }
                function w(E) {
                    return B(E.getValue(), "HTML") || E.match((D)=>D.type === "TemplateLiteral", (D, d)=>D.type === "TaggedTemplateExpression" && D.tag.type === "Identifier" && D.tag.name === "html" && d === "quasi");
                }
                function I(E) {
                    let { quasis: D } = E;
                    return D.some((d)=>{
                        let { value: { cooked: y } } = d;
                        return y === null;
                    });
                }
                n.exports = C;
            }
        }), hm = Z({
            "src/language-js/clean.js" (e, n) {
                "use strict";
                ae();
                var t = Pt(), s = new Set([
                    "range",
                    "raw",
                    "comments",
                    "leadingComments",
                    "trailingComments",
                    "innerComments",
                    "extra",
                    "start",
                    "end",
                    "loc",
                    "flags",
                    "errors",
                    "tokens"
                ]), i = (u)=>{
                    for (let a of u.quasis)delete a.value;
                };
                function r(u, a, c) {
                    if (u.type === "Program" && delete a.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && a.value && (a.value = a.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && a.bigint && (a.bigint = a.bigint.toLowerCase()), u.type === "DecimalLiteral" && (a.value = Number(a.value)), u.type === "Literal" && a.decimal && (a.decimal = Number(a.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ") return null;
                    if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete a.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((C)=>C.name.name === "jsx")) for (let { type: C, expression: m } of a.children)C === "JSXExpressionContainer" && m.type === "TemplateLiteral" && i(m);
                    u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && i(a.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (a.value.value = a.value.value.replace(/["']|&quot;|&apos;/g, '"'));
                    let l = u.expression || u.callee;
                    if (u.type === "Decorator" && l.type === "CallExpression" && l.callee.name === "Component" && l.arguments.length === 1) {
                        let C = u.expression.arguments[0].properties;
                        for (let [m, g] of a.expression.arguments[0].properties.entries())switch(C[m].key.name){
                            case "styles":
                                g.value.type === "ArrayExpression" && i(g.value.elements[0]);
                                break;
                            case "template":
                                g.value.type === "TemplateLiteral" && i(g.value);
                                break;
                        }
                    }
                    if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && i(a.quasi), u.type === "TemplateLiteral" && (u.leadingComments && u.leadingComments.some((m)=>t(m) && [
                            "GraphQL",
                            "HTML"
                        ].some((g)=>m.value === " ".concat(g, " "))) || c.type === "CallExpression" && c.callee.name === "graphql" || !u.leadingComments) && i(a), u.type === "InterpreterDirective" && (a.value = a.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1) return a.types[0];
                }
                r.ignoredProperties = s, n.exports = r;
            }
        }), Vi = {};
        kn(Vi, {
            EOL: ()=>wn,
            arch: ()=>Cm,
            cpus: ()=>zi,
            default: ()=>Zi,
            endianness: ()=>Wi,
            freemem: ()=>Ji,
            getNetworkInterfaces: ()=>Qi,
            hostname: ()=>$i,
            loadavg: ()=>Hi,
            networkInterfaces: ()=>Yi,
            platform: ()=>Em,
            release: ()=>Ki,
            tmpDir: ()=>Bn,
            tmpdir: ()=>Nn,
            totalmem: ()=>Ui,
            type: ()=>Xi,
            uptime: ()=>Gi
        });
        function Wi() {
            if (typeof Fr > "u") {
                var e = new ArrayBuffer(2), n = new Uint8Array(e), t = new Uint16Array(e);
                if (n[0] = 1, n[1] = 2, t[0] === 258) Fr = "BE";
                else if (t[0] === 513) Fr = "LE";
                else throw new Error("unable to figure out endianess");
            }
            return Fr;
        }
        function $i() {
            return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function Hi() {
            return [];
        }
        function Gi() {
            return 0;
        }
        function Ji() {
            return Number.MAX_VALUE;
        }
        function Ui() {
            return Number.MAX_VALUE;
        }
        function zi() {
            return [];
        }
        function Xi() {
            return "Browser";
        }
        function Ki() {
            return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function Yi() {}
        function Qi() {}
        function Cm() {
            return "javascript";
        }
        function Em() {
            return "browser";
        }
        function Bn() {
            return "/tmp";
        }
        var Fr, Nn, wn, Zi, vm = br({
            "node-modules-polyfills:os" () {
                ae(), Nn = Bn, wn = `
`, Zi = {
                    EOL: wn,
                    tmpdir: Nn,
                    tmpDir: Bn,
                    networkInterfaces: Yi,
                    getNetworkInterfaces: Qi,
                    release: Ki,
                    type: Xi,
                    cpus: zi,
                    totalmem: Ui,
                    freemem: Ji,
                    uptime: Gi,
                    loadavg: Hi,
                    hostname: $i,
                    endianness: Wi
                };
            }
        }), Fm = Z({
            "node-modules-polyfills-commonjs:os" (e, n) {
                ae();
                var t = (vm(), pt(Vi));
                if (t && t.default) {
                    n.exports = t.default;
                    for(let s in t)n.exports[s] = t[s];
                } else t && (n.exports = t);
            }
        }), Am = Z({
            "node_modules/detect-newline/index.js" (e, n) {
                "use strict";
                ae();
                var t = (s)=>{
                    if (typeof s != "string") throw new TypeError("Expected a string");
                    let i = s.match(/(?:\r?\n)/g) || [];
                    if (i.length === 0) return;
                    let r = i.filter((a)=>a === `\r
`).length, u = i.length - r;
                    return r > u ? `\r
` : `
`;
                };
                n.exports = t, n.exports.graceful = (s)=>typeof s == "string" && t(s) || `
`;
            }
        }), Sm = Z({
            "node_modules/jest-docblock/build/index.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.extract = p, e.parse = h, e.parseWithComments = N, e.print = T, e.strip = f;
                function n() {
                    let b = Fm();
                    return n = function() {
                        return b;
                    }, b;
                }
                function t() {
                    let b = s(Am());
                    return t = function() {
                        return b;
                    }, b;
                }
                function s(b) {
                    return b && b.__esModule ? b : {
                        default: b
                    };
                }
                var i = /\*\/$/, r = /^\/\*\*/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, a = /(^|\s+)\/\/([^\r\n]*)/g, c = /^(\r?\n)+/, l = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, C = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, m = /(\r?\n|^) *\* ?/g, g = [];
                function p(b) {
                    let v = b.match(u);
                    return v ? v[0].trimLeft() : "";
                }
                function f(b) {
                    let v = b.match(u);
                    return v && v[0] ? b.substring(v[0].length) : b;
                }
                function h(b) {
                    return N(b).pragmas;
                }
                function N(b) {
                    let v = (0, t().default)(b) || n().EOL;
                    b = b.replace(r, "").replace(i, "").replace(m, "$1");
                    let B = "";
                    for(; B !== b;)B = b, b = b.replace(l, "".concat(v, "$1 $2").concat(v));
                    b = b.replace(c, "").trimRight();
                    let w = Object.create(null), I = b.replace(C, "").replace(c, "").trimRight(), E;
                    for(; E = C.exec(b);){
                        let D = E[2].replace(a, "");
                        typeof w[E[1]] == "string" || Array.isArray(w[E[1]]) ? w[E[1]] = g.concat(w[E[1]], D) : w[E[1]] = D;
                    }
                    return {
                        comments: I,
                        pragmas: w
                    };
                }
                function T(b) {
                    let { comments: v = "", pragmas: B = {} } = b, w = (0, t().default)(v) || n().EOL, I = "/**", E = " *", D = " */", d = Object.keys(B), y = d.map((x)=>A(x, B[x])).reduce((x, F)=>x.concat(F), []).map((x)=>E + " " + x + w).join("");
                    if (!v) {
                        if (d.length === 0) return "";
                        if (d.length === 1 && !Array.isArray(B[d[0]])) {
                            let x = B[d[0]];
                            return "".concat(I, " ").concat(A(d[0], x)[0]).concat(D);
                        }
                    }
                    let o = v.split(w).map((x)=>"".concat(E, " ").concat(x)).join(w) + w;
                    return I + w + (v ? o : "") + (v && d.length ? E + w : "") + y + D;
                }
                function A(b, v) {
                    return g.concat(v).map((B)=>"@".concat(b, " ").concat(B).trim());
                }
            }
        }), xm = Z({
            "src/language-js/utils/get-shebang.js" (e, n) {
                "use strict";
                ae();
                function t(s) {
                    if (!s.startsWith("#!")) return "";
                    let i = s.indexOf(`
`);
                    return i === -1 ? s : s.slice(0, i);
                }
                n.exports = t;
            }
        }), eo = Z({
            "src/language-js/pragma.js" (e, n) {
                "use strict";
                ae();
                var { parseWithComments: t, strip: s, extract: i, print: r } = Sm(), { normalizeEndOfLine: u } = On(), a = xm();
                function c(m) {
                    let g = a(m);
                    g && (m = m.slice(g.length + 1));
                    let p = i(m), { pragmas: f, comments: h } = t(p);
                    return {
                        shebang: g,
                        text: m,
                        pragmas: f,
                        comments: h
                    };
                }
                function l(m) {
                    let g = Object.keys(c(m).pragmas);
                    return g.includes("prettier") || g.includes("format");
                }
                function C(m) {
                    let { shebang: g, text: p, pragmas: f, comments: h } = c(m), N = s(p), T = r({
                        pragmas: Object.assign({
                            format: ""
                        }, f),
                        comments: h.trimStart()
                    });
                    return (g ? "".concat(g, `
`) : "") + u(T) + (N.startsWith(`
`) ? `
` : `

`) + N;
                }
                n.exports = {
                    hasPragma: l,
                    insertPragma: C
                };
            }
        }), to = Z({
            "src/language-js/comments.js" (e, n) {
                "use strict";
                ae();
                var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: i, getNextNonSpaceNonCommentCharacter: r, hasNewlineInRange: u, addLeadingComment: a, addTrailingComment: c, addDanglingComment: l, getNextNonSpaceNonCommentCharacterIndex: C, isNonEmptyArray: m } = Ge(), { getFunctionParameters: g, isPrettierIgnoreComment: p, isJsxNode: f, hasFlowShorthandAnnotationComment: h, hasFlowAnnotationComment: N, hasIgnoreComment: T, isCallLikeExpression: A, getCallArguments: b, isCallExpression: v, isMemberExpression: B, isObjectProperty: w, isLineComment: I, getComments: E, CommentCheckFlags: D, markerForIfWithoutBlockAndSameLineComment: d } = Xe(), { locStart: y, locEnd: o } = nt(), x = Pt();
                function F(X) {
                    return [
                        fe,
                        V,
                        G,
                        M,
                        H,
                        P,
                        W,
                        oe,
                        de,
                        le,
                        Q,
                        ge,
                        ve,
                        ee,
                        K,
                        Ee
                    ].some((Y)=>Y(X));
                }
                function S(X) {
                    return [
                        R,
                        V,
                        re,
                        oe,
                        M,
                        H,
                        P,
                        W,
                        K,
                        q,
                        ue,
                        Q,
                        xe,
                        Ee,
                        me
                    ].some((Y)=>Y(X));
                }
                function k(X) {
                    return [
                        fe,
                        M,
                        H,
                        $,
                        se,
                        ee,
                        Q,
                        ne,
                        U,
                        pe,
                        Ee,
                        we
                    ].some((Y)=>Y(X));
                }
                function _(X, Y) {
                    let te = (X.body || X.properties).find((z)=>{
                        let { type: j } = z;
                        return j !== "EmptyStatement";
                    });
                    te ? a(te, Y) : l(X, Y);
                }
                function O(X, Y) {
                    X.type === "BlockStatement" ? _(X, Y) : a(X, Y);
                }
                function R(X) {
                    let { comment: Y, followingNode: te } = X;
                    return te && J(Y) ? (a(te, Y), !0) : !1;
                }
                function M(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j, text: Ce } = X;
                    if (!z || z.type !== "IfStatement" || !j) return !1;
                    if (r(Ce, Y, o) === ")") return c(te, Y), !0;
                    if (te === z.consequent && j === z.alternate) {
                        if (te.type === "BlockStatement") c(te, Y);
                        else {
                            let je = Y.type === "SingleLine" || Y.loc.start.line === Y.loc.end.line, Ue = Y.loc.start.line === te.loc.start.line;
                            je && Ue ? l(te, Y, d) : l(z, Y);
                        }
                        return !0;
                    }
                    return j.type === "BlockStatement" ? (_(j, Y), !0) : j.type === "IfStatement" ? (O(j.consequent, Y), !0) : z.consequent === j ? (a(j, Y), !0) : !1;
                }
                function H(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j, text: Ce } = X;
                    return !z || z.type !== "WhileStatement" || !j ? !1 : r(Ce, Y, o) === ")" ? (c(te, Y), !0) : j.type === "BlockStatement" ? (_(j, Y), !0) : z.body === j ? (a(j, Y), !0) : !1;
                }
                function P(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j } = X;
                    return !z || z.type !== "TryStatement" && z.type !== "CatchClause" || !j ? !1 : z.type === "CatchClause" && te ? (c(te, Y), !0) : j.type === "BlockStatement" ? (_(j, Y), !0) : j.type === "TryStatement" ? (O(j.finalizer, Y), !0) : j.type === "CatchClause" ? (O(j.body, Y), !0) : !1;
                }
                function G(X) {
                    let { comment: Y, enclosingNode: te, followingNode: z } = X;
                    return B(te) && z && z.type === "Identifier" ? (a(te, Y), !0) : !1;
                }
                function re(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j, text: Ce } = X, Ne = te && !u(Ce, o(te), y(Y));
                    return (!te || !Ne) && z && (z.type === "ConditionalExpression" || z.type === "TSConditionalType") && j ? (a(j, Y), !0) : !1;
                }
                function $(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z } = X;
                    return w(z) && z.shorthand && z.key === te && z.value.type === "AssignmentPattern" ? (c(z.value.left, Y), !0) : !1;
                }
                function W(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j } = X;
                    if (z && (z.type === "ClassDeclaration" || z.type === "ClassExpression" || z.type === "DeclareClass" || z.type === "DeclareInterface" || z.type === "InterfaceDeclaration" || z.type === "TSInterfaceDeclaration")) {
                        if (m(z.decorators) && !(j && j.type === "Decorator")) return c(t(z.decorators), Y), !0;
                        if (z.body && j === z.body) return _(z.body, Y), !0;
                        if (j) {
                            if (z.superClass && j === z.superClass && te && (te === z.id || te === z.typeParameters)) return c(te, Y), !0;
                            for (let Ce of [
                                "implements",
                                "extends",
                                "mixins"
                            ])if (z[Ce] && j === z[Ce][0]) return te && (te === z.id || te === z.typeParameters || te === z.superClass) ? c(te, Y) : l(z, Y, Ce), !0;
                        }
                    }
                    return !1;
                }
                function ee(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z, text: j } = X;
                    return z && te && r(j, Y, o) === "(" && (z.type === "Property" || z.type === "TSDeclareMethod" || z.type === "TSAbstractMethodDefinition") && te.type === "Identifier" && z.key === te && r(j, te, o) !== ":" || te && z && te.type === "Decorator" && (z.type === "ClassMethod" || z.type === "ClassProperty" || z.type === "PropertyDefinition" || z.type === "TSAbstractPropertyDefinition" || z.type === "TSAbstractMethodDefinition" || z.type === "TSDeclareMethod" || z.type === "MethodDefinition") ? (c(te, Y), !0) : !1;
                }
                function U(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z, text: j } = X;
                    return r(j, Y, o) !== "(" ? !1 : te && z && (z.type === "FunctionDeclaration" || z.type === "FunctionExpression" || z.type === "ClassMethod" || z.type === "MethodDefinition" || z.type === "ObjectMethod") ? (c(te, Y), !0) : !1;
                }
                function ne(X) {
                    let { comment: Y, enclosingNode: te, text: z } = X;
                    if (!(te && te.type === "ArrowFunctionExpression")) return !1;
                    let j = C(z, Y, o);
                    return j !== !1 && z.slice(j, j + 2) === "=>" ? (l(te, Y), !0) : !1;
                }
                function se(X) {
                    let { comment: Y, enclosingNode: te, text: z } = X;
                    return r(z, Y, o) !== ")" ? !1 : te && (ce(te) && g(te).length === 0 || A(te) && b(te).length === 0) ? (l(te, Y), !0) : te && (te.type === "MethodDefinition" || te.type === "TSAbstractMethodDefinition") && g(te.value).length === 0 ? (l(te.value, Y), !0) : !1;
                }
                function V(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j, text: Ce } = X;
                    if (te && te.type === "FunctionTypeParam" && z && z.type === "FunctionTypeAnnotation" && j && j.type !== "FunctionTypeParam" || te && (te.type === "Identifier" || te.type === "AssignmentPattern") && z && ce(z) && r(Ce, Y, o) === ")") return c(te, Y), !0;
                    if (z && z.type === "FunctionDeclaration" && j && j.type === "BlockStatement") {
                        let Ne = (()=>{
                            let je = g(z);
                            if (je.length > 0) return i(Ce, o(t(je)));
                            let Ue = i(Ce, o(z.id));
                            return Ue !== !1 && i(Ce, Ue + 1);
                        })();
                        if (y(Y) > Ne) return _(j, Y), !0;
                    }
                    return !1;
                }
                function oe(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return te && te.type === "ImportSpecifier" ? (a(te, Y), !0) : !1;
                }
                function K(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return te && te.type === "LabeledStatement" ? (a(te, Y), !0) : !1;
                }
                function Ee(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return te && (te.type === "ContinueStatement" || te.type === "BreakStatement") && !te.label ? (c(te, Y), !0) : !1;
                }
                function q(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z } = X;
                    return v(z) && te && z.callee === te && z.arguments.length > 0 ? (a(z.arguments[0], Y), !0) : !1;
                }
                function le(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j } = X;
                    return z && (z.type === "UnionTypeAnnotation" || z.type === "TSUnionType") ? (p(Y) && (j.prettierIgnore = !0, Y.unignore = !0), te ? (c(te, Y), !0) : !1) : (j && (j.type === "UnionTypeAnnotation" || j.type === "TSUnionType") && p(Y) && (j.types[0].prettierIgnore = !0, Y.unignore = !0), !1);
                }
                function ue(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return w(te) ? (a(te, Y), !0) : !1;
                }
                function Q(X) {
                    let { comment: Y, enclosingNode: te, followingNode: z, ast: j, isLastComment: Ce } = X;
                    return j && j.body && j.body.length === 0 ? (Ce ? l(j, Y) : a(j, Y), !0) : te && te.type === "Program" && te.body.length === 0 && !m(te.directives) ? (Ce ? l(te, Y) : a(te, Y), !0) : z && z.type === "Program" && z.body.length === 0 && te && te.type === "ModuleExpression" ? (l(z, Y), !0) : !1;
                }
                function de(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return te && (te.type === "ForInStatement" || te.type === "ForOfStatement") ? (a(te, Y), !0) : !1;
                }
                function ge(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z, text: j } = X;
                    return te && te.type === "ImportSpecifier" && z && z.type === "ImportDeclaration" && s(j, o(Y)) ? (c(te, Y), !0) : !1;
                }
                function ve(X) {
                    let { comment: Y, enclosingNode: te } = X;
                    return te && te.type === "AssignmentPattern" ? (a(te, Y), !0) : !1;
                }
                function xe(X) {
                    let { comment: Y, enclosingNode: te, followingNode: z } = X;
                    return te && (te.type === "VariableDeclarator" || te.type === "AssignmentExpression" || te.type === "TypeAlias" || te.type === "TSTypeAliasDeclaration") && z && (z.type === "ObjectExpression" || z.type === "ArrayExpression" || z.type === "TemplateLiteral" || z.type === "TaggedTemplateExpression" || z.type === "ObjectTypeAnnotation" || z.type === "TSTypeLiteral" || x(Y)) ? (a(z, Y), !0) : !1;
                }
                function we(X) {
                    let { comment: Y, enclosingNode: te, followingNode: z, text: j } = X;
                    return !z && te && (te.type === "TSMethodSignature" || te.type === "TSDeclareFunction" || te.type === "TSAbstractMethodDefinition") && r(j, Y, o) === ";" ? (c(te, Y), !0) : !1;
                }
                function fe(X) {
                    let { comment: Y, enclosingNode: te, followingNode: z } = X;
                    if (p(Y) && te && te.type === "TSMappedType" && z && z.type === "TSTypeParameter" && z.constraint) return te.prettierIgnore = !0, Y.unignore = !0, !0;
                }
                function pe(X) {
                    let { comment: Y, precedingNode: te, enclosingNode: z, followingNode: j } = X;
                    return !z || z.type !== "TSMappedType" ? !1 : j && j.type === "TSTypeParameter" && j.name ? (a(j.name, Y), !0) : te && te.type === "TSTypeParameter" && te.constraint ? (c(te.constraint, Y), !0) : !1;
                }
                function me(X) {
                    let { comment: Y, enclosingNode: te, followingNode: z } = X;
                    return !te || te.type !== "SwitchCase" || te.test ? !1 : (z.type === "BlockStatement" && I(Y) ? _(z, Y) : l(te, Y), !0);
                }
                function ce(X) {
                    return X.type === "ArrowFunctionExpression" || X.type === "FunctionExpression" || X.type === "FunctionDeclaration" || X.type === "ObjectMethod" || X.type === "ClassMethod" || X.type === "TSDeclareFunction" || X.type === "TSCallSignatureDeclaration" || X.type === "TSConstructSignatureDeclaration" || X.type === "TSMethodSignature" || X.type === "TSConstructorType" || X.type === "TSFunctionType" || X.type === "TSDeclareMethod";
                }
                function he(X, Y) {
                    if ((Y.parser === "typescript" || Y.parser === "flow" || Y.parser === "acorn" || Y.parser === "espree" || Y.parser === "meriyah" || Y.parser === "__babel_estree") && X.type === "MethodDefinition" && X.value && X.value.type === "FunctionExpression" && g(X.value).length === 0 && !X.value.returnType && !m(X.value.typeParameters) && X.value.body) return [
                        ...X.decorators || [],
                        X.key,
                        X.value.body
                    ];
                }
                function J(X) {
                    return x(X) && X.value[0] === "*" && /@type\b/.test(X.value);
                }
                function ye(X) {
                    let Y = X.getValue(), te = X.getParentNode(), z = (j)=>N(E(j, D.Leading)) || N(E(j, D.Trailing));
                    return (Y && (f(Y) || h(Y) || v(te) && z(Y)) || te && (te.type === "JSXSpreadAttribute" || te.type === "JSXSpreadChild" || te.type === "UnionTypeAnnotation" || te.type === "TSUnionType" || (te.type === "ClassDeclaration" || te.type === "ClassExpression") && te.superClass === Y)) && (!T(X) || te.type === "UnionTypeAnnotation" || te.type === "TSUnionType");
                }
                n.exports = {
                    handleOwnLineComment: F,
                    handleEndOfLineComment: S,
                    handleRemainingComment: k,
                    isTypeCastComment: J,
                    getCommentChildNodes: he,
                    willPrintOwnComments: ye
                };
            }
        }), kt = Z({
            "src/language-js/needs-parens.js" (e, n) {
                "use strict";
                ae();
                var t = st(), s = Rn(), { getFunctionParameters: i, getLeftSidePathName: r, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: a, hasNode: c, isBitwiseOperator: l, startsWithNoLookaheadToken: C, shouldFlatten: m, getPrecedence: g, isCallExpression: p, isMemberExpression: f, isObjectProperty: h } = Xe();
                function N(I, E) {
                    let D = I.getParentNode();
                    if (!D) return !1;
                    let d = I.getName(), y = I.getNode();
                    if (E.__isInHtmlInterpolation && !E.bracketSpacing && v(y) && B(I)) return !0;
                    if (T(y)) return !1;
                    if (E.parser !== "flow" && u(I.getValue())) return !0;
                    if (y.type === "Identifier") return !!(y.extra && y.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(y.name) || d === "left" && y.name === "async" && D.type === "ForOfStatement" && !D.await);
                    switch(D.type){
                        case "ParenthesizedExpression":
                            return !1;
                        case "ClassDeclaration":
                        case "ClassExpression":
                            if (d === "superClass" && (y.type === "ArrowFunctionExpression" || y.type === "AssignmentExpression" || y.type === "AwaitExpression" || y.type === "BinaryExpression" || y.type === "ConditionalExpression" || y.type === "LogicalExpression" || y.type === "NewExpression" || y.type === "ObjectExpression" || y.type === "SequenceExpression" || y.type === "TaggedTemplateExpression" || y.type === "UnaryExpression" || y.type === "UpdateExpression" || y.type === "YieldExpression" || y.type === "TSNonNullExpression")) return !0;
                            break;
                        case "ExportDefaultDeclaration":
                            return w(I, E) || y.type === "SequenceExpression";
                        case "Decorator":
                            if (d === "expression") {
                                let o = !1, x = !1, F = y;
                                for(; F;)switch(F.type){
                                    case "MemberExpression":
                                        x = !0, F = F.object;
                                        break;
                                    case "CallExpression":
                                        if (x || o) return E.parser !== "typescript";
                                        o = !0, F = F.callee;
                                        break;
                                    case "Identifier":
                                        return !1;
                                    case "TaggedTemplateExpression":
                                        return E.parser !== "typescript";
                                    default:
                                        return !0;
                                }
                                return !0;
                            }
                            break;
                        case "ExpressionStatement":
                            if (C(y, !0)) return !0;
                            break;
                        case "ArrowFunctionExpression":
                            if (d === "body" && y.type !== "SequenceExpression" && C(y, !1)) return !0;
                            break;
                    }
                    switch(y.type){
                        case "UpdateExpression":
                            if (D.type === "UnaryExpression") return y.prefix && (y.operator === "++" && D.operator === "+" || y.operator === "--" && D.operator === "-");
                        case "UnaryExpression":
                            switch(D.type){
                                case "UnaryExpression":
                                    return y.operator === D.operator && (y.operator === "+" || y.operator === "-");
                                case "BindExpression":
                                    return !0;
                                case "MemberExpression":
                                case "OptionalMemberExpression":
                                    return d === "object";
                                case "TaggedTemplateExpression":
                                    return !0;
                                case "NewExpression":
                                case "CallExpression":
                                case "OptionalCallExpression":
                                    return d === "callee";
                                case "BinaryExpression":
                                    return d === "left" && D.operator === "**";
                                case "TSNonNullExpression":
                                    return !0;
                                default:
                                    return !1;
                            }
                        case "BinaryExpression":
                            if (D.type === "UpdateExpression" || y.operator === "in" && A(I)) return !0;
                            if (y.operator === "|>" && y.extra && y.extra.parenthesized) {
                                let o = I.getParentNode(1);
                                if (o.type === "BinaryExpression" && o.operator === "|>") return !0;
                            }
                        case "TSTypeAssertion":
                        case "TSAsExpression":
                        case "LogicalExpression":
                            switch(D.type){
                                case "TSAsExpression":
                                    return y.type !== "TSAsExpression";
                                case "ConditionalExpression":
                                    return y.type === "TSAsExpression";
                                case "CallExpression":
                                case "NewExpression":
                                case "OptionalCallExpression":
                                    return d === "callee";
                                case "ClassExpression":
                                case "ClassDeclaration":
                                    return d === "superClass";
                                case "TSTypeAssertion":
                                case "TaggedTemplateExpression":
                                case "UnaryExpression":
                                case "JSXSpreadAttribute":
                                case "SpreadElement":
                                case "SpreadProperty":
                                case "BindExpression":
                                case "AwaitExpression":
                                case "TSNonNullExpression":
                                case "UpdateExpression":
                                    return !0;
                                case "MemberExpression":
                                case "OptionalMemberExpression":
                                    return d === "object";
                                case "AssignmentExpression":
                                case "AssignmentPattern":
                                    return d === "left" && (y.type === "TSTypeAssertion" || y.type === "TSAsExpression");
                                case "LogicalExpression":
                                    if (y.type === "LogicalExpression") return D.operator !== y.operator;
                                case "BinaryExpression":
                                    {
                                        let { operator: o, type: x } = y;
                                        if (!o && x !== "TSTypeAssertion") return !0;
                                        let F = g(o), S = D.operator, k = g(S);
                                        return k > F || d === "right" && k === F || k === F && !m(S, o) ? !0 : k < F && o === "%" ? S === "+" || S === "-" : !!l(S);
                                    }
                                default:
                                    return !1;
                            }
                        case "SequenceExpression":
                            switch(D.type){
                                case "ReturnStatement":
                                    return !1;
                                case "ForStatement":
                                    return !1;
                                case "ExpressionStatement":
                                    return d !== "expression";
                                case "ArrowFunctionExpression":
                                    return d !== "body";
                                default:
                                    return !0;
                            }
                        case "YieldExpression":
                            if (D.type === "UnaryExpression" || D.type === "AwaitExpression" || D.type === "TSAsExpression" || D.type === "TSNonNullExpression") return !0;
                        case "AwaitExpression":
                            switch(D.type){
                                case "TaggedTemplateExpression":
                                case "UnaryExpression":
                                case "LogicalExpression":
                                case "SpreadElement":
                                case "SpreadProperty":
                                case "TSAsExpression":
                                case "TSNonNullExpression":
                                case "BindExpression":
                                    return !0;
                                case "MemberExpression":
                                case "OptionalMemberExpression":
                                    return d === "object";
                                case "NewExpression":
                                case "CallExpression":
                                case "OptionalCallExpression":
                                    return d === "callee";
                                case "ConditionalExpression":
                                    return d === "test";
                                case "BinaryExpression":
                                    return !(!y.argument && D.operator === "|>");
                                default:
                                    return !1;
                            }
                        case "TSConditionalType":
                            if (d === "extendsType" && D.type === "TSConditionalType") return !0;
                        case "TSFunctionType":
                        case "TSConstructorType":
                            if (d === "checkType" && D.type === "TSConditionalType") return !0;
                        case "TSUnionType":
                        case "TSIntersectionType":
                            if ((D.type === "TSUnionType" || D.type === "TSIntersectionType") && D.types.length > 1 && (!y.types || y.types.length > 1)) return !0;
                        case "TSInferType":
                            if (y.type === "TSInferType" && D.type === "TSRestType") return !1;
                        case "TSTypeOperator":
                            return D.type === "TSArrayType" || D.type === "TSOptionalType" || D.type === "TSRestType" || d === "objectType" && D.type === "TSIndexedAccessType" || D.type === "TSTypeOperator" || D.type === "TSTypeAnnotation" && I.getParentNode(1).type.startsWith("TSJSDoc");
                        case "ArrayTypeAnnotation":
                            return D.type === "NullableTypeAnnotation";
                        case "IntersectionTypeAnnotation":
                        case "UnionTypeAnnotation":
                            return D.type === "ArrayTypeAnnotation" || D.type === "NullableTypeAnnotation" || D.type === "IntersectionTypeAnnotation" || D.type === "UnionTypeAnnotation" || d === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
                        case "NullableTypeAnnotation":
                            return D.type === "ArrayTypeAnnotation" || d === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
                        case "FunctionTypeAnnotation":
                            {
                                let o = D.type === "NullableTypeAnnotation" ? I.getParentNode(1) : D;
                                return o.type === "UnionTypeAnnotation" || o.type === "IntersectionTypeAnnotation" || o.type === "ArrayTypeAnnotation" || d === "objectType" && (o.type === "IndexedAccessType" || o.type === "OptionalIndexedAccessType") || o.type === "NullableTypeAnnotation" || D.type === "FunctionTypeParam" && D.name === null && i(y).some((x)=>x.typeAnnotation && x.typeAnnotation.type === "NullableTypeAnnotation");
                            }
                        case "OptionalIndexedAccessType":
                            return d === "objectType" && D.type === "IndexedAccessType";
                        case "TypeofTypeAnnotation":
                            return d === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
                        case "StringLiteral":
                        case "NumericLiteral":
                        case "Literal":
                            if (typeof y.value == "string" && D.type === "ExpressionStatement" && !D.directive) {
                                let o = I.getParentNode(1);
                                return o.type === "Program" || o.type === "BlockStatement";
                            }
                            return d === "object" && D.type === "MemberExpression" && typeof y.value == "number";
                        case "AssignmentExpression":
                            {
                                let o = I.getParentNode(1);
                                return d === "body" && D.type === "ArrowFunctionExpression" ? !0 : d === "key" && (D.type === "ClassProperty" || D.type === "PropertyDefinition") && D.computed || (d === "init" || d === "update") && D.type === "ForStatement" ? !1 : D.type === "ExpressionStatement" ? y.left.type === "ObjectPattern" : !(d === "key" && D.type === "TSPropertySignature" || D.type === "AssignmentExpression" || D.type === "SequenceExpression" && o && o.type === "ForStatement" && (o.init === D || o.update === D) || d === "value" && D.type === "Property" && o && o.type === "ObjectPattern" && o.properties.includes(D) || D.type === "NGChainedExpression");
                            }
                        case "ConditionalExpression":
                            switch(D.type){
                                case "TaggedTemplateExpression":
                                case "UnaryExpression":
                                case "SpreadElement":
                                case "SpreadProperty":
                                case "BinaryExpression":
                                case "LogicalExpression":
                                case "NGPipeExpression":
                                case "ExportDefaultDeclaration":
                                case "AwaitExpression":
                                case "JSXSpreadAttribute":
                                case "TSTypeAssertion":
                                case "TypeCastExpression":
                                case "TSAsExpression":
                                case "TSNonNullExpression":
                                    return !0;
                                case "NewExpression":
                                case "CallExpression":
                                case "OptionalCallExpression":
                                    return d === "callee";
                                case "ConditionalExpression":
                                    return d === "test";
                                case "MemberExpression":
                                case "OptionalMemberExpression":
                                    return d === "object";
                                default:
                                    return !1;
                            }
                        case "FunctionExpression":
                            switch(D.type){
                                case "NewExpression":
                                case "CallExpression":
                                case "OptionalCallExpression":
                                    return d === "callee";
                                case "TaggedTemplateExpression":
                                    return !0;
                                default:
                                    return !1;
                            }
                        case "ArrowFunctionExpression":
                            switch(D.type){
                                case "BinaryExpression":
                                    return D.operator !== "|>" || y.extra && y.extra.parenthesized;
                                case "NewExpression":
                                case "CallExpression":
                                case "OptionalCallExpression":
                                    return d === "callee";
                                case "MemberExpression":
                                case "OptionalMemberExpression":
                                    return d === "object";
                                case "TSAsExpression":
                                case "TSNonNullExpression":
                                case "BindExpression":
                                case "TaggedTemplateExpression":
                                case "UnaryExpression":
                                case "LogicalExpression":
                                case "AwaitExpression":
                                case "TSTypeAssertion":
                                    return !0;
                                case "ConditionalExpression":
                                    return d === "test";
                                default:
                                    return !1;
                            }
                        case "ClassExpression":
                            if (s(y.decorators)) return !0;
                            switch(D.type){
                                case "NewExpression":
                                    return d === "callee";
                                default:
                                    return !1;
                            }
                        case "OptionalMemberExpression":
                        case "OptionalCallExpression":
                            {
                                let o = I.getParentNode(1);
                                if (d === "object" && D.type === "MemberExpression" || d === "callee" && (D.type === "CallExpression" || D.type === "NewExpression") || D.type === "TSNonNullExpression" && o.type === "MemberExpression" && o.object === D) return !0;
                            }
                        case "CallExpression":
                        case "MemberExpression":
                        case "TaggedTemplateExpression":
                        case "TSNonNullExpression":
                            if (d === "callee" && (D.type === "BindExpression" || D.type === "NewExpression")) {
                                let o = y;
                                for(; o;)switch(o.type){
                                    case "CallExpression":
                                    case "OptionalCallExpression":
                                        return !0;
                                    case "MemberExpression":
                                    case "OptionalMemberExpression":
                                    case "BindExpression":
                                        o = o.object;
                                        break;
                                    case "TaggedTemplateExpression":
                                        o = o.tag;
                                        break;
                                    case "TSNonNullExpression":
                                        o = o.expression;
                                        break;
                                    default:
                                        return !1;
                                }
                            }
                            return !1;
                        case "BindExpression":
                            return d === "callee" && (D.type === "BindExpression" || D.type === "NewExpression") || d === "object" && f(D);
                        case "NGPipeExpression":
                            return !(D.type === "NGRoot" || D.type === "NGMicrosyntaxExpression" || D.type === "ObjectProperty" && !(y.extra && y.extra.parenthesized) || D.type === "ArrayExpression" || p(D) && D.arguments[d] === y || d === "right" && D.type === "NGPipeExpression" || d === "property" && D.type === "MemberExpression" || D.type === "AssignmentExpression");
                        case "JSXFragment":
                        case "JSXElement":
                            return d === "callee" || d === "left" && D.type === "BinaryExpression" && D.operator === "<" || D.type !== "ArrayExpression" && D.type !== "ArrowFunctionExpression" && D.type !== "AssignmentExpression" && D.type !== "AssignmentPattern" && D.type !== "BinaryExpression" && D.type !== "NewExpression" && D.type !== "ConditionalExpression" && D.type !== "ExpressionStatement" && D.type !== "JsExpressionRoot" && D.type !== "JSXAttribute" && D.type !== "JSXElement" && D.type !== "JSXExpressionContainer" && D.type !== "JSXFragment" && D.type !== "LogicalExpression" && !p(D) && !h(D) && D.type !== "ReturnStatement" && D.type !== "ThrowStatement" && D.type !== "TypeCastExpression" && D.type !== "VariableDeclarator" && D.type !== "YieldExpression";
                        case "TypeAnnotation":
                            return d === "returnType" && D.type === "ArrowFunctionExpression" && b(y);
                    }
                    return !1;
                }
                function T(I) {
                    return I.type === "BlockStatement" || I.type === "BreakStatement" || I.type === "ClassBody" || I.type === "ClassDeclaration" || I.type === "ClassMethod" || I.type === "ClassProperty" || I.type === "PropertyDefinition" || I.type === "ClassPrivateProperty" || I.type === "ContinueStatement" || I.type === "DebuggerStatement" || I.type === "DeclareClass" || I.type === "DeclareExportAllDeclaration" || I.type === "DeclareExportDeclaration" || I.type === "DeclareFunction" || I.type === "DeclareInterface" || I.type === "DeclareModule" || I.type === "DeclareModuleExports" || I.type === "DeclareVariable" || I.type === "DoWhileStatement" || I.type === "EnumDeclaration" || I.type === "ExportAllDeclaration" || I.type === "ExportDefaultDeclaration" || I.type === "ExportNamedDeclaration" || I.type === "ExpressionStatement" || I.type === "ForInStatement" || I.type === "ForOfStatement" || I.type === "ForStatement" || I.type === "FunctionDeclaration" || I.type === "IfStatement" || I.type === "ImportDeclaration" || I.type === "InterfaceDeclaration" || I.type === "LabeledStatement" || I.type === "MethodDefinition" || I.type === "ReturnStatement" || I.type === "SwitchStatement" || I.type === "ThrowStatement" || I.type === "TryStatement" || I.type === "TSDeclareFunction" || I.type === "TSEnumDeclaration" || I.type === "TSImportEqualsDeclaration" || I.type === "TSInterfaceDeclaration" || I.type === "TSModuleDeclaration" || I.type === "TSNamespaceExportDeclaration" || I.type === "TypeAlias" || I.type === "VariableDeclaration" || I.type === "WhileStatement" || I.type === "WithStatement";
                }
                function A(I) {
                    let E = 0, D = I.getValue();
                    for(; D;){
                        let d = I.getParentNode(E++);
                        if (d && d.type === "ForStatement" && d.init === D) return !0;
                        D = d;
                    }
                    return !1;
                }
                function b(I) {
                    return c(I, (E)=>E.type === "ObjectTypeAnnotation" && c(E, (D)=>D.type === "FunctionTypeAnnotation" || void 0) || void 0);
                }
                function v(I) {
                    switch(I.type){
                        case "ObjectExpression":
                            return !0;
                        default:
                            return !1;
                    }
                }
                function B(I) {
                    let E = I.getValue(), D = I.getParentNode(), d = I.getName();
                    switch(D.type){
                        case "NGPipeExpression":
                            if (typeof d == "number" && D.arguments[d] === E && D.arguments.length - 1 === d) return I.callParent(B);
                            break;
                        case "ObjectProperty":
                            if (d === "value") {
                                let y = I.getParentNode(1);
                                return t(y.properties) === D;
                            }
                            break;
                        case "BinaryExpression":
                        case "LogicalExpression":
                            if (d === "right") return I.callParent(B);
                            break;
                        case "ConditionalExpression":
                            if (d === "alternate") return I.callParent(B);
                            break;
                        case "UnaryExpression":
                            if (D.prefix) return I.callParent(B);
                            break;
                    }
                    return !1;
                }
                function w(I, E) {
                    let D = I.getValue(), d = I.getParentNode();
                    return D.type === "FunctionExpression" || D.type === "ClassExpression" ? d.type === "ExportDefaultDeclaration" || !N(I, E) : !a(D) || d.type !== "ExportDefaultDeclaration" && N(I, E) ? !1 : I.call((y)=>w(y, E), ...r(I, D));
                }
                n.exports = N;
            }
        }), ro = Z({
            "src/language-js/print-preprocess.js" (e, n) {
                "use strict";
                ae();
                function t(s, i) {
                    switch(i.parser){
                        case "json":
                        case "json5":
                        case "json-stringify":
                        case "__js_expression":
                        case "__vue_expression":
                            return Object.assign(Object.assign({}, s), {}, {
                                type: i.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot",
                                node: s,
                                comments: [],
                                rootMarker: i.rootMarker
                            });
                        default:
                            return s;
                    }
                }
                n.exports = t;
            }
        }), bm = Z({
            "src/language-js/print/html-binding.js" (e, n) {
                "use strict";
                ae();
                var { builders: { join: t, line: s, group: i, softline: r, indent: u } } = Le();
                function a(l, C, m) {
                    let g = l.getValue();
                    if (C.__onHtmlBindingRoot && l.getName() === null && C.__onHtmlBindingRoot(g, C), g.type === "File") {
                        if (C.__isVueForBindingLeft) return l.call((p)=>{
                            let f = t([
                                ",",
                                s
                            ], p.map(m, "params")), { params: h } = p.getValue();
                            return h.length === 1 ? f : [
                                "(",
                                u([
                                    r,
                                    i(f)
                                ]),
                                r,
                                ")"
                            ];
                        }, "program", "body", 0);
                        if (C.__isVueBindings) return l.call((p)=>t([
                                ",",
                                s
                            ], p.map(m, "params")), "program", "body", 0);
                    }
                }
                function c(l) {
                    switch(l.type){
                        case "MemberExpression":
                            switch(l.property.type){
                                case "Identifier":
                                case "NumericLiteral":
                                case "StringLiteral":
                                    return c(l.object);
                            }
                            return !1;
                        case "Identifier":
                            return !0;
                        default:
                            return !1;
                    }
                }
                n.exports = {
                    isVueEventBindingExpression: c,
                    printHtmlBinding: a
                };
            }
        }), Jn = Z({
            "src/language-js/print/binaryish.js" (e, n) {
                "use strict";
                ae();
                var { printComments: t } = Qe(), { getLast: s } = Ge(), { builders: { join: i, line: r, softline: u, group: a, indent: c, align: l, ifBreak: C, indentIfBreak: m }, utils: { cleanDoc: g, getDocParts: p, isConcat: f } } = Le(), { hasLeadingOwnLineComment: h, isBinaryish: N, isJsxNode: T, shouldFlatten: A, hasComment: b, CommentCheckFlags: v, isCallExpression: B, isMemberExpression: w, isObjectProperty: I, isEnabledHackPipeline: E } = Xe(), D = 0;
                function d(x, F, S) {
                    let k = x.getValue(), _ = x.getParentNode(), O = x.getParentNode(1), R = k !== _.body && (_.type === "IfStatement" || _.type === "WhileStatement" || _.type === "SwitchStatement" || _.type === "DoWhileStatement"), M = E(F) && k.operator === "|>", H = y(x, S, F, !1, R);
                    if (R) return H;
                    if (M) return a(H);
                    if (B(_) && _.callee === k || _.type === "UnaryExpression" || w(_) && !_.computed) return a([
                        c([
                            u,
                            ...H
                        ]),
                        u
                    ]);
                    let P = _.type === "ReturnStatement" || _.type === "ThrowStatement" || _.type === "JSXExpressionContainer" && O.type === "JSXAttribute" || k.operator !== "|" && _.type === "JsExpressionRoot" || k.type !== "NGPipeExpression" && (_.type === "NGRoot" && F.parser === "__ng_binding" || _.type === "NGMicrosyntaxExpression" && O.type === "NGMicrosyntax" && O.body.length === 1) || k === _.body && _.type === "ArrowFunctionExpression" || k !== _.body && _.type === "ForStatement" || _.type === "ConditionalExpression" && O.type !== "ReturnStatement" && O.type !== "ThrowStatement" && !B(O) || _.type === "TemplateLiteral", G = _.type === "AssignmentExpression" || _.type === "VariableDeclarator" || _.type === "ClassProperty" || _.type === "PropertyDefinition" || _.type === "TSAbstractPropertyDefinition" || _.type === "ClassPrivateProperty" || I(_), re = N(k.left) && A(k.operator, k.left.operator);
                    if (P || o(k) && !re || !o(k) && G) return a(H);
                    if (H.length === 0) return "";
                    let $ = T(k.right), W = H.findIndex((oe)=>typeof oe != "string" && !Array.isArray(oe) && oe.type === "group"), ee = H.slice(0, W === -1 ? 1 : W + 1), U = H.slice(ee.length, $ ? -1 : void 0), ne = Symbol("logicalChain-" + ++D), se = a([
                        ...ee,
                        c(U)
                    ], {
                        id: ne
                    });
                    if (!$) return se;
                    let V = s(H);
                    return a([
                        se,
                        m(V, {
                            groupId: ne
                        })
                    ]);
                }
                function y(x, F, S, k, _) {
                    let O = x.getValue();
                    if (!N(O)) return [
                        a(F())
                    ];
                    let R = [];
                    A(O.operator, O.left.operator) ? R = x.call((U)=>y(U, F, S, !0, _), "left") : R.push(a(F("left")));
                    let M = o(O), H = (O.operator === "|>" || O.type === "NGPipeExpression" || O.operator === "|" && S.parser === "__vue_expression") && !h(S.originalText, O.right), P = O.type === "NGPipeExpression" ? "|" : O.operator, G = O.type === "NGPipeExpression" && O.arguments.length > 0 ? a(c([
                        u,
                        ": ",
                        i([
                            u,
                            ":",
                            C(" ")
                        ], x.map(F, "arguments").map((U)=>l(2, a(U))))
                    ])) : "", re;
                    if (M) re = [
                        P,
                        " ",
                        F("right"),
                        G
                    ];
                    else {
                        let ne = E(S) && P === "|>" ? x.call((se)=>y(se, F, S, !0, _), "right") : F("right");
                        re = [
                            H ? r : "",
                            P,
                            H ? " " : r,
                            ne,
                            G
                        ];
                    }
                    let $ = x.getParentNode(), W = b(O.left, v.Trailing | v.Line), ee = W || !(_ && O.type === "LogicalExpression") && $.type !== O.type && O.left.type !== O.type && O.right.type !== O.type;
                    if (R.push(H ? "" : " ", ee ? a(re, {
                        shouldBreak: W
                    }) : re), k && b(O)) {
                        let U = g(t(x, R, S));
                        return f(U) || U.type === "fill" ? p(U) : [
                            U
                        ];
                    }
                    return R;
                }
                function o(x) {
                    return x.type !== "LogicalExpression" ? !1 : !!(x.right.type === "ObjectExpression" && x.right.properties.length > 0 || x.right.type === "ArrayExpression" && x.right.elements.length > 0 || T(x.right));
                }
                n.exports = {
                    printBinaryishExpression: d,
                    shouldInlineLogicalExpression: o
                };
            }
        }), Tm = Z({
            "src/language-js/print/angular.js" (e, n) {
                "use strict";
                ae();
                var { builders: { join: t, line: s, group: i } } = Le(), { hasNode: r, hasComment: u, getComments: a } = Xe(), { printBinaryishExpression: c } = Jn();
                function l(g, p, f) {
                    let h = g.getValue();
                    if (!!h.type.startsWith("NG")) switch(h.type){
                        case "NGRoot":
                            return [
                                f("node"),
                                u(h.node) ? " //" + a(h.node)[0].value.trimEnd() : ""
                            ];
                        case "NGPipeExpression":
                            return c(g, p, f);
                        case "NGChainedExpression":
                            return i(t([
                                ";",
                                s
                            ], g.map((N)=>m(N) ? f() : [
                                    "(",
                                    f(),
                                    ")"
                                ], "expressions")));
                        case "NGEmptyExpression":
                            return "";
                        case "NGQuotedExpression":
                            return [
                                h.prefix,
                                ": ",
                                h.value.trim()
                            ];
                        case "NGMicrosyntax":
                            return g.map((N, T)=>[
                                    T === 0 ? "" : C(N.getValue(), T, h) ? " " : [
                                        ";",
                                        s
                                    ],
                                    f()
                                ], "body");
                        case "NGMicrosyntaxKey":
                            return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(h.name) ? h.name : JSON.stringify(h.name);
                        case "NGMicrosyntaxExpression":
                            return [
                                f("expression"),
                                h.alias === null ? "" : [
                                    " as ",
                                    f("alias")
                                ]
                            ];
                        case "NGMicrosyntaxKeyedExpression":
                            {
                                let N = g.getName(), T = g.getParentNode(), A = C(h, N, T) || (N === 1 && (h.key.name === "then" || h.key.name === "else") || N === 2 && h.key.name === "else" && T.body[N - 1].type === "NGMicrosyntaxKeyedExpression" && T.body[N - 1].key.name === "then") && T.body[0].type === "NGMicrosyntaxExpression";
                                return [
                                    f("key"),
                                    A ? " " : ": ",
                                    f("expression")
                                ];
                            }
                        case "NGMicrosyntaxLet":
                            return [
                                "let ",
                                f("key"),
                                h.value === null ? "" : [
                                    " = ",
                                    f("value")
                                ]
                            ];
                        case "NGMicrosyntaxAs":
                            return [
                                f("key"),
                                " as ",
                                f("alias")
                            ];
                        default:
                            throw new Error("Unknown Angular node type: ".concat(JSON.stringify(h.type), "."));
                    }
                }
                function C(g, p, f) {
                    return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && p === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
                }
                function m(g) {
                    return r(g.getValue(), (p)=>{
                        switch(p.type){
                            case void 0:
                                return !1;
                            case "CallExpression":
                            case "OptionalCallExpression":
                            case "AssignmentExpression":
                                return !0;
                        }
                    });
                }
                n.exports = {
                    printAngular: l
                };
            }
        }), Bm = Z({
            "src/language-js/print/jsx.js" (e, n) {
                "use strict";
                ae();
                var { printComments: t, printDanglingComments: s } = Qe(), { builders: { line: i, hardline: r, softline: u, group: a, indent: c, conditionalGroup: l, fill: C, ifBreak: m, lineSuffixBoundary: g, join: p }, utils: { willBreak: f } } = Le(), { getLast: h, getPreferredQuote: N } = Ge(), { isJsxNode: T, rawText: A, isLiteral: b, isCallExpression: v, isStringLiteral: B, isBinaryish: w, hasComment: I, CommentCheckFlags: E, hasNodeIgnoreComment: D } = Xe(), d = kt(), { willPrintOwnComments: y } = to(), o = (q)=>q === "" || q === i || q === r || q === u;
                function x(q, le, ue) {
                    let Q = q.getValue();
                    if (Q.type === "JSXElement" && V(Q)) return [
                        ue("openingElement"),
                        ue("closingElement")
                    ];
                    let de = Q.type === "JSXElement" ? ue("openingElement") : ue("openingFragment"), ge = Q.type === "JSXElement" ? ue("closingElement") : ue("closingFragment");
                    if (Q.children.length === 1 && Q.children[0].type === "JSXExpressionContainer" && (Q.children[0].expression.type === "TemplateLiteral" || Q.children[0].expression.type === "TaggedTemplateExpression")) return [
                        de,
                        ...q.map(ue, "children"),
                        ge
                    ];
                    Q.children = Q.children.map((z)=>K(z) ? {
                            type: "JSXText",
                            value: " ",
                            raw: " "
                        } : z);
                    let ve = Q.children.some(T), xe = Q.children.filter((z)=>z.type === "JSXExpressionContainer").length > 1, we = Q.type === "JSXElement" && Q.openingElement.attributes.length > 1, fe = f(de) || ve || we || xe, pe = q.getParentNode().rootMarker === "mdx", me = le.singleQuote ? "{' '}" : '{" "}', ce = pe ? " " : m([
                        me,
                        u
                    ], " "), he = Q.openingElement && Q.openingElement.name && Q.openingElement.name.name === "fbt", J = F(q, le, ue, ce, he), ye = Q.children.some((z)=>oe(z));
                    for(let z = J.length - 2; z >= 0; z--){
                        let j = J[z] === "" && J[z + 1] === "", Ce = J[z] === r && J[z + 1] === "" && J[z + 2] === r, Ne = (J[z] === u || J[z] === r) && J[z + 1] === "" && J[z + 2] === ce, je = J[z] === ce && J[z + 1] === "" && (J[z + 2] === u || J[z + 2] === r), Ue = J[z] === ce && J[z + 1] === "" && J[z + 2] === ce, tt = J[z] === u && J[z + 1] === "" && J[z + 2] === r || J[z] === r && J[z + 1] === "" && J[z + 2] === u;
                        Ce && ye || j || Ne || Ue || tt ? J.splice(z, 2) : je && J.splice(z + 1, 2);
                    }
                    for(; J.length > 0 && o(h(J));)J.pop();
                    for(; J.length > 1 && o(J[0]) && o(J[1]);)J.shift(), J.shift();
                    let X = [];
                    for (let [z, j] of J.entries()){
                        if (j === ce) {
                            if (z === 1 && J[z - 1] === "") {
                                if (J.length === 2) {
                                    X.push(me);
                                    continue;
                                }
                                X.push([
                                    me,
                                    r
                                ]);
                                continue;
                            } else if (z === J.length - 1) {
                                X.push(me);
                                continue;
                            } else if (J[z - 1] === "" && J[z - 2] === r) {
                                X.push(me);
                                continue;
                            }
                        }
                        X.push(j), f(j) && (fe = !0);
                    }
                    let Y = ye ? C(X) : a(X, {
                        shouldBreak: !0
                    });
                    if (pe) return Y;
                    let te = a([
                        de,
                        c([
                            r,
                            Y
                        ]),
                        r,
                        ge
                    ]);
                    return fe ? te : l([
                        a([
                            de,
                            ...J,
                            ge
                        ]),
                        te
                    ]);
                }
                function F(q, le, ue, Q, de) {
                    let ge = [];
                    return q.each((ve, xe, we)=>{
                        let fe = ve.getValue();
                        if (b(fe)) {
                            let pe = A(fe);
                            if (oe(fe)) {
                                let me = pe.split(U);
                                if (me[0] === "") {
                                    if (ge.push(""), me.shift(), /\n/.test(me[0])) {
                                        let he = we[xe + 1];
                                        ge.push(k(de, me[1], fe, he));
                                    } else ge.push(Q);
                                    me.shift();
                                }
                                let ce;
                                if (h(me) === "" && (me.pop(), ce = me.pop()), me.length === 0) return;
                                for (let [he, J] of me.entries())he % 2 === 1 ? ge.push(i) : ge.push(J);
                                if (ce !== void 0) {
                                    if (/\n/.test(ce)) {
                                        let he = we[xe + 1];
                                        ge.push(k(de, h(ge), fe, he));
                                    } else ge.push(Q);
                                } else {
                                    let he = we[xe + 1];
                                    ge.push(S(de, h(ge), fe, he));
                                }
                            } else /\n/.test(pe) ? pe.match(/\n/g).length > 1 && ge.push("", r) : ge.push("", Q);
                        } else {
                            let pe = ue();
                            ge.push(pe);
                            let me = we[xe + 1];
                            if (me && oe(me)) {
                                let he = se(A(me)).split(U)[0];
                                ge.push(S(de, he, fe, me));
                            } else ge.push(r);
                        }
                    }, "children"), ge;
                }
                function S(q, le, ue, Q) {
                    return q ? "" : ue.type === "JSXElement" && !ue.closingElement || Q && Q.type === "JSXElement" && !Q.closingElement ? le.length === 1 ? u : r : u;
                }
                function k(q, le, ue, Q) {
                    return q ? r : le.length === 1 ? ue.type === "JSXElement" && !ue.closingElement || Q && Q.type === "JSXElement" && !Q.closingElement ? r : u : r;
                }
                function _(q, le, ue) {
                    let Q = q.getParentNode();
                    if (!Q || ({
                        ArrayExpression: !0,
                        JSXAttribute: !0,
                        JSXElement: !0,
                        JSXExpressionContainer: !0,
                        JSXFragment: !0,
                        ExpressionStatement: !0,
                        CallExpression: !0,
                        OptionalCallExpression: !0,
                        ConditionalExpression: !0,
                        JsExpressionRoot: !0
                    })[Q.type]) return le;
                    let ge = q.match(void 0, (xe)=>xe.type === "ArrowFunctionExpression", v, (xe)=>xe.type === "JSXExpressionContainer"), ve = d(q, ue);
                    return a([
                        ve ? "" : m("("),
                        c([
                            u,
                            le
                        ]),
                        u,
                        ve ? "" : m(")")
                    ], {
                        shouldBreak: ge
                    });
                }
                function O(q, le, ue) {
                    let Q = q.getValue(), de = [];
                    if (de.push(ue("name")), Q.value) {
                        let ge;
                        if (B(Q.value)) {
                            let xe = A(Q.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: we, quote: fe, regex: pe } = N(xe, le.jsxSingleQuote ? "'" : '"');
                            xe = xe.replace(pe, we), ge = [
                                fe,
                                xe,
                                fe
                            ];
                        } else ge = ue("value");
                        de.push("=", ge);
                    }
                    return de;
                }
                function R(q, le, ue) {
                    let Q = q.getValue(), de = (ge, ve)=>ge.type === "JSXEmptyExpression" || !I(ge) && (ge.type === "ArrayExpression" || ge.type === "ObjectExpression" || ge.type === "ArrowFunctionExpression" || ge.type === "AwaitExpression" && (de(ge.argument, ge) || ge.argument.type === "JSXElement") || v(ge) || ge.type === "FunctionExpression" || ge.type === "TemplateLiteral" || ge.type === "TaggedTemplateExpression" || ge.type === "DoExpression" || T(ve) && (ge.type === "ConditionalExpression" || w(ge)));
                    return de(Q.expression, q.getParentNode(0)) ? a([
                        "{",
                        ue("expression"),
                        g,
                        "}"
                    ]) : a([
                        "{",
                        c([
                            u,
                            ue("expression")
                        ]),
                        u,
                        g,
                        "}"
                    ]);
                }
                function M(q, le, ue) {
                    let Q = q.getValue(), de = Q.name && I(Q.name) || Q.typeParameters && I(Q.typeParameters);
                    if (Q.selfClosing && Q.attributes.length === 0 && !de) return [
                        "<",
                        ue("name"),
                        ue("typeParameters"),
                        " />"
                    ];
                    if (Q.attributes && Q.attributes.length === 1 && Q.attributes[0].value && B(Q.attributes[0].value) && !Q.attributes[0].value.value.includes(`
`) && !de && !I(Q.attributes[0])) return a([
                        "<",
                        ue("name"),
                        ue("typeParameters"),
                        " ",
                        ...q.map(ue, "attributes"),
                        Q.selfClosing ? " />" : ">"
                    ]);
                    let ge = Q.attributes.length > 0 && I(h(Q.attributes), E.Trailing), ve = Q.attributes.length === 0 && !de || (le.bracketSameLine || le.jsxBracketSameLine) && (!de || Q.attributes.length > 0) && !ge, xe = Q.attributes && Q.attributes.some((fe)=>fe.value && B(fe.value) && fe.value.value.includes(`
`)), we = le.singleAttributePerLine && Q.attributes.length > 1 ? r : i;
                    return a([
                        "<",
                        ue("name"),
                        ue("typeParameters"),
                        c(q.map(()=>[
                                we,
                                ue()
                            ], "attributes")),
                        Q.selfClosing ? i : ve ? ">" : u,
                        Q.selfClosing ? "/>" : ve ? "" : ">"
                    ], {
                        shouldBreak: xe
                    });
                }
                function H(q, le, ue) {
                    let Q = q.getValue(), de = [];
                    de.push("</");
                    let ge = ue("name");
                    return I(Q.name, E.Leading | E.Line) ? de.push(c([
                        r,
                        ge
                    ]), r) : I(Q.name, E.Leading | E.Block) ? de.push(" ", ge) : de.push(ge), de.push(">"), de;
                }
                function P(q, le) {
                    let ue = q.getValue(), Q = I(ue), de = I(ue, E.Line), ge = ue.type === "JSXOpeningFragment";
                    return [
                        ge ? "<" : "</",
                        c([
                            de ? r : Q && !ge ? " " : "",
                            s(q, le, !0)
                        ]),
                        de ? r : "",
                        ">"
                    ];
                }
                function G(q, le, ue) {
                    let Q = t(q, x(q, le, ue), le);
                    return _(q, Q, le);
                }
                function re(q, le) {
                    let ue = q.getValue(), Q = I(ue, E.Line);
                    return [
                        s(q, le, !Q),
                        Q ? r : ""
                    ];
                }
                function $(q, le, ue) {
                    let Q = q.getValue();
                    return [
                        "{",
                        q.call((de)=>{
                            let ge = [
                                "...",
                                ue()
                            ], ve = de.getValue();
                            return !I(ve) || !y(de) ? ge : [
                                c([
                                    u,
                                    t(de, ge, le)
                                ]),
                                u
                            ];
                        }, Q.type === "JSXSpreadAttribute" ? "argument" : "expression"),
                        "}"
                    ];
                }
                function W(q, le, ue) {
                    let Q = q.getValue();
                    if (!!Q.type.startsWith("JSX")) switch(Q.type){
                        case "JSXAttribute":
                            return O(q, le, ue);
                        case "JSXIdentifier":
                            return String(Q.name);
                        case "JSXNamespacedName":
                            return p(":", [
                                ue("namespace"),
                                ue("name")
                            ]);
                        case "JSXMemberExpression":
                            return p(".", [
                                ue("object"),
                                ue("property")
                            ]);
                        case "JSXSpreadAttribute":
                            return $(q, le, ue);
                        case "JSXSpreadChild":
                            return $(q, le, ue);
                        case "JSXExpressionContainer":
                            return R(q, le, ue);
                        case "JSXFragment":
                        case "JSXElement":
                            return G(q, le, ue);
                        case "JSXOpeningElement":
                            return M(q, le, ue);
                        case "JSXClosingElement":
                            return H(q, le, ue);
                        case "JSXOpeningFragment":
                        case "JSXClosingFragment":
                            return P(q, le);
                        case "JSXEmptyExpression":
                            return re(q, le);
                        case "JSXText":
                            throw new Error("JSXTest should be handled by JSXElement");
                        default:
                            throw new Error("Unknown JSX node type: ".concat(JSON.stringify(Q.type), "."));
                    }
                }
                var ee = ` 
\r	`, U = new RegExp("([" + ee + "]+)"), ne = new RegExp("[^" + ee + "]"), se = (q)=>q.replace(new RegExp("(?:^" + U.source + "|" + U.source + "$)"), "");
                function V(q) {
                    if (q.children.length === 0) return !0;
                    if (q.children.length > 1) return !1;
                    let le = q.children[0];
                    return b(le) && !oe(le);
                }
                function oe(q) {
                    return b(q) && (ne.test(A(q)) || !/\n/.test(A(q)));
                }
                function K(q) {
                    return q.type === "JSXExpressionContainer" && b(q.expression) && q.expression.value === " " && !I(q.expression);
                }
                function Ee(q) {
                    let le = q.getValue(), ue = q.getParentNode();
                    if (!ue || !le || !T(le) || !T(ue)) return !1;
                    let Q = ue.children.indexOf(le), de = null;
                    for(let ge = Q; ge > 0; ge--){
                        let ve = ue.children[ge - 1];
                        if (!(ve.type === "JSXText" && !oe(ve))) {
                            de = ve;
                            break;
                        }
                    }
                    return de && de.type === "JSXExpressionContainer" && de.expression.type === "JSXEmptyExpression" && D(de.expression);
                }
                n.exports = {
                    hasJsxIgnoreComment: Ee,
                    printJsx: W
                };
            }
        }), ot = Z({
            "src/language-js/print/misc.js" (e, n) {
                "use strict";
                ae();
                var { isNonEmptyArray: t } = Ge(), { builders: { indent: s, join: i, line: r } } = Le(), { isFlowAnnotationComment: u } = Xe();
                function a(h) {
                    let N = h.getValue();
                    return !N.optional || N.type === "Identifier" && N === h.getParentNode().key ? "" : N.type === "OptionalCallExpression" || N.type === "OptionalMemberExpression" && N.computed ? "?." : "?";
                }
                function c(h) {
                    return h.getValue().definite || h.match(void 0, (N, T)=>T === "id" && N.type === "VariableDeclarator" && N.definite) ? "!" : "";
                }
                function l(h, N, T) {
                    let A = h.getValue();
                    return A.typeArguments ? T("typeArguments") : A.typeParameters ? T("typeParameters") : "";
                }
                function C(h, N, T) {
                    let A = h.getValue();
                    if (!A.typeAnnotation) return "";
                    let b = h.getParentNode(), v = b.type === "DeclareFunction" && b.id === A;
                    return u(N.originalText, A.typeAnnotation) ? [
                        " /*: ",
                        T("typeAnnotation"),
                        " */"
                    ] : [
                        v ? "" : ": ",
                        T("typeAnnotation")
                    ];
                }
                function m(h, N, T) {
                    return [
                        "::",
                        T("callee")
                    ];
                }
                function g(h, N, T) {
                    let A = h.getValue();
                    return t(A.modifiers) ? [
                        i(" ", h.map(T, "modifiers")),
                        " "
                    ] : "";
                }
                function p(h, N, T) {
                    return h.type === "EmptyStatement" ? ";" : h.type === "BlockStatement" || T ? [
                        " ",
                        N
                    ] : s([
                        r,
                        N
                    ]);
                }
                function f(h, N, T) {
                    return [
                        "...",
                        T("argument"),
                        C(h, N, T)
                    ];
                }
                n.exports = {
                    printOptionalToken: a,
                    printDefiniteToken: c,
                    printFunctionTypeParameters: l,
                    printBindExpressionCallee: m,
                    printTypeScriptModifiers: g,
                    printTypeAnnotation: C,
                    printRestSpread: f,
                    adjustClause: p
                };
            }
        }), zt = Z({
            "src/language-js/print/array.js" (e, n) {
                "use strict";
                ae();
                var { printDanglingComments: t } = Qe(), { builders: { line: s, softline: i, hardline: r, group: u, indent: a, ifBreak: c, fill: l } } = Le(), { getLast: C, hasNewline: m } = Ge(), { shouldPrintComma: g, hasComment: p, CommentCheckFlags: f, isNextLineEmpty: h, isNumericLiteral: N, isSignedNumericLiteral: T } = Xe(), { locStart: A } = nt(), { printOptionalToken: b, printTypeAnnotation: v } = ot();
                function B(D, d, y) {
                    let o = D.getValue(), x = [], F = o.type === "TupleExpression" ? "#[" : "[", S = "]";
                    if (o.elements.length === 0) p(o, f.Dangling) ? x.push(u([
                        F,
                        t(D, d),
                        i,
                        S
                    ])) : x.push(F, S);
                    else {
                        let k = C(o.elements), _ = !(k && k.type === "RestElement"), O = k === null, R = Symbol("array"), M = !d.__inJestEach && o.elements.length > 1 && o.elements.every((G, re, $)=>{
                            let W = G && G.type;
                            if (W !== "ArrayExpression" && W !== "ObjectExpression") return !1;
                            let ee = $[re + 1];
                            if (ee && W !== ee.type) return !1;
                            let U = W === "ArrayExpression" ? "elements" : "properties";
                            return G[U] && G[U].length > 1;
                        }), H = w(o, d), P = _ ? O ? "," : g(d) ? H ? c(",", "", {
                            groupId: R
                        }) : c(",") : "" : "";
                        x.push(u([
                            F,
                            a([
                                i,
                                H ? E(D, d, y, P) : [
                                    I(D, d, "elements", y),
                                    P
                                ],
                                t(D, d, !0)
                            ]),
                            i,
                            S
                        ], {
                            shouldBreak: M,
                            id: R
                        }));
                    }
                    return x.push(b(D), v(D, d, y)), x;
                }
                function w(D, d) {
                    return D.elements.length > 1 && D.elements.every((y)=>y && (N(y) || T(y) && !p(y.argument)) && !p(y, f.Trailing | f.Line, (o)=>!m(d.originalText, A(o), {
                                backwards: !0
                            })));
                }
                function I(D, d, y, o) {
                    let x = [], F = [];
                    return D.each((S)=>{
                        x.push(F, u(o())), F = [
                            ",",
                            s
                        ], S.getValue() && h(S.getValue(), d) && F.push(i);
                    }, y), x;
                }
                function E(D, d, y, o) {
                    let x = [];
                    return D.each((F, S, k)=>{
                        let _ = S === k.length - 1;
                        x.push([
                            y(),
                            _ ? o : ","
                        ]), _ || x.push(h(F.getValue(), d) ? [
                            r,
                            r
                        ] : p(k[S + 1], f.Leading | f.Line) ? r : s);
                    }, "elements"), l(x);
                }
                n.exports = {
                    printArray: B,
                    printArrayItems: I,
                    isConciselyPrintedArray: w
                };
            }
        }), no = Z({
            "src/language-js/print/call-arguments.js" (e, n) {
                "use strict";
                ae();
                var { printDanglingComments: t } = Qe(), { getLast: s, getPenultimate: i } = Ge(), { getFunctionParameters: r, hasComment: u, CommentCheckFlags: a, isFunctionCompositionArgs: c, isJsxNode: l, isLongCurriedCallExpression: C, shouldPrintComma: m, getCallArguments: g, iterateCallArgumentsPath: p, isNextLineEmpty: f, isCallExpression: h, isStringLiteral: N, isObjectProperty: T } = Xe(), { builders: { line: A, hardline: b, softline: v, group: B, indent: w, conditionalGroup: I, ifBreak: E, breakParent: D }, utils: { willBreak: d } } = Le(), { ArgExpansionBailout: y } = Jt(), { isConciselyPrintedArray: o } = zt();
                function x(M, H, P) {
                    let G = M.getValue(), re = G.type === "ImportExpression", $ = g(G);
                    if ($.length === 0) return [
                        "(",
                        t(M, H, !0),
                        ")"
                    ];
                    if (_($)) return [
                        "(",
                        P([
                            "arguments",
                            0
                        ]),
                        ", ",
                        P([
                            "arguments",
                            1
                        ]),
                        ")"
                    ];
                    let W = !1, ee = !1, U = $.length - 1, ne = [];
                    p(M, (q, le)=>{
                        let ue = q.getNode(), Q = [
                            P()
                        ];
                        le === U || (f(ue, H) ? (le === 0 && (ee = !0), W = !0, Q.push(",", b, b)) : Q.push(",", A)), ne.push(Q);
                    });
                    let se = !(re || G.callee && G.callee.type === "Import") && m(H, "all") ? "," : "";
                    function V() {
                        return B([
                            "(",
                            w([
                                A,
                                ...ne
                            ]),
                            se,
                            A,
                            ")"
                        ], {
                            shouldBreak: !0
                        });
                    }
                    if (W || M.getParentNode().type !== "Decorator" && c($)) return V();
                    let oe = k($), K = S($, H);
                    if (oe || K) {
                        if (oe ? ne.slice(1).some(d) : ne.slice(0, -1).some(d)) return V();
                        let q = [];
                        try {
                            M.try(()=>{
                                p(M, (le, ue)=>{
                                    oe && ue === 0 && (q = [
                                        [
                                            P([], {
                                                expandFirstArg: !0
                                            }),
                                            ne.length > 1 ? "," : "",
                                            ee ? b : A,
                                            ee ? b : ""
                                        ],
                                        ...ne.slice(1)
                                    ]), K && ue === U && (q = [
                                        ...ne.slice(0, -1),
                                        P([], {
                                            expandLastArg: !0
                                        })
                                    ]);
                                });
                            });
                        } catch (le) {
                            if (le instanceof y) return V();
                            throw le;
                        }
                        return [
                            ne.some(d) ? D : "",
                            I([
                                [
                                    "(",
                                    ...q,
                                    ")"
                                ],
                                oe ? [
                                    "(",
                                    B(q[0], {
                                        shouldBreak: !0
                                    }),
                                    ...q.slice(1),
                                    ")"
                                ] : [
                                    "(",
                                    ...ne.slice(0, -1),
                                    B(s(q), {
                                        shouldBreak: !0
                                    }),
                                    ")"
                                ],
                                V()
                            ])
                        ];
                    }
                    let Ee = [
                        "(",
                        w([
                            v,
                            ...ne
                        ]),
                        E(se),
                        v,
                        ")"
                    ];
                    return C(M) ? Ee : B(Ee, {
                        shouldBreak: ne.some(d) || W
                    });
                }
                function F(M) {
                    let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
                    return M.type === "ObjectExpression" && (M.properties.length > 0 || u(M)) || M.type === "ArrayExpression" && (M.elements.length > 0 || u(M)) || M.type === "TSTypeAssertion" && F(M.expression) || M.type === "TSAsExpression" && F(M.expression) || M.type === "FunctionExpression" || M.type === "ArrowFunctionExpression" && (!M.returnType || !M.returnType.typeAnnotation || M.returnType.typeAnnotation.type !== "TSTypeReference" || O(M.body)) && (M.body.type === "BlockStatement" || M.body.type === "ArrowFunctionExpression" && F(M.body, !0) || M.body.type === "ObjectExpression" || M.body.type === "ArrayExpression" || !H && (h(M.body) || M.body.type === "ConditionalExpression") || l(M.body)) || M.type === "DoExpression" || M.type === "ModuleExpression";
                }
                function S(M, H) {
                    let P = s(M), G = i(M);
                    return !u(P, a.Leading) && !u(P, a.Trailing) && F(P) && (!G || G.type !== P.type) && (M.length !== 2 || G.type !== "ArrowFunctionExpression" || P.type !== "ArrayExpression") && !(M.length > 1 && P.type === "ArrayExpression" && o(P, H));
                }
                function k(M) {
                    if (M.length !== 2) return !1;
                    let [H, P] = M;
                    return H.type === "ModuleExpression" && R(P) ? !0 : !u(H) && (H.type === "FunctionExpression" || H.type === "ArrowFunctionExpression" && H.body.type === "BlockStatement") && P.type !== "FunctionExpression" && P.type !== "ArrowFunctionExpression" && P.type !== "ConditionalExpression" && !F(P);
                }
                function _(M) {
                    return M.length === 2 && M[0].type === "ArrowFunctionExpression" && r(M[0]).length === 0 && M[0].body.type === "BlockStatement" && M[1].type === "ArrayExpression" && !M.some((H)=>u(H));
                }
                function O(M) {
                    return M.type === "BlockStatement" && (M.body.some((H)=>H.type !== "EmptyStatement") || u(M, a.Dangling));
                }
                function R(M) {
                    return M.type === "ObjectExpression" && M.properties.length === 1 && T(M.properties[0]) && M.properties[0].key.type === "Identifier" && M.properties[0].key.name === "type" && N(M.properties[0].value) && M.properties[0].value.value === "module";
                }
                n.exports = x;
            }
        }), uo = Z({
            "src/language-js/print/member.js" (e, n) {
                "use strict";
                ae();
                var { builders: { softline: t, group: s, indent: i, label: r } } = Le(), { isNumericLiteral: u, isMemberExpression: a, isCallExpression: c } = Xe(), { printOptionalToken: l } = ot();
                function C(g, p, f) {
                    let h = g.getValue(), N = g.getParentNode(), T, A = 0;
                    do T = g.getParentNode(A), A++;
                    while (T && (a(T) || T.type === "TSNonNullExpression"));
                    let b = f("object"), v = m(g, p, f), B = T && (T.type === "NewExpression" || T.type === "BindExpression" || T.type === "AssignmentExpression" && T.left.type !== "Identifier") || h.computed || h.object.type === "Identifier" && h.property.type === "Identifier" && !a(N) || (N.type === "AssignmentExpression" || N.type === "VariableDeclarator") && (c(h.object) && h.object.arguments.length > 0 || h.object.type === "TSNonNullExpression" && c(h.object.expression) && h.object.expression.arguments.length > 0 || b.label === "member-chain");
                    return r(b.label === "member-chain" ? "member-chain" : "member", [
                        b,
                        B ? v : s(i([
                            t,
                            v
                        ]))
                    ]);
                }
                function m(g, p, f) {
                    let h = f("property"), N = g.getValue(), T = l(g);
                    return N.computed ? !N.property || u(N.property) ? [
                        T,
                        "[",
                        h,
                        "]"
                    ] : s([
                        T,
                        "[",
                        i([
                            t,
                            h
                        ]),
                        t,
                        "]"
                    ]) : [
                        T,
                        ".",
                        h
                    ];
                }
                n.exports = {
                    printMemberExpression: C,
                    printMemberLookup: m
                };
            }
        }), Nm = Z({
            "src/language-js/print/member-chain.js" (e, n) {
                "use strict";
                ae();
                var { printComments: t } = Qe(), { getLast: s, isNextLineEmptyAfterIndex: i, getNextNonSpaceNonCommentCharacterIndex: r } = Ge(), u = kt(), { isCallExpression: a, isMemberExpression: c, isFunctionOrArrowExpression: l, isLongCurriedCallExpression: C, isMemberish: m, isNumericLiteral: g, isSimpleCallArgument: p, hasComment: f, CommentCheckFlags: h, isNextLineEmpty: N } = Xe(), { locEnd: T } = nt(), { builders: { join: A, hardline: b, group: v, indent: B, conditionalGroup: w, breakParent: I, label: E }, utils: { willBreak: D } } = Le(), d = no(), { printMemberLookup: y } = uo(), { printOptionalToken: o, printFunctionTypeParameters: x, printBindExpressionCallee: F } = ot();
                function S(k, _, O) {
                    let R = k.getParentNode(), M = !R || R.type === "ExpressionStatement", H = [];
                    function P(me) {
                        let { originalText: ce } = _, he = r(ce, me, T);
                        return ce.charAt(he) === ")" ? he !== !1 && i(ce, he + 1) : N(me, _);
                    }
                    function G(me) {
                        let ce = me.getValue();
                        a(ce) && (m(ce.callee) || a(ce.callee)) ? (H.unshift({
                            node: ce,
                            printed: [
                                t(me, [
                                    o(me),
                                    x(me, _, O),
                                    d(me, _, O)
                                ], _),
                                P(ce) ? b : ""
                            ]
                        }), me.call((he)=>G(he), "callee")) : m(ce) ? (H.unshift({
                            node: ce,
                            needsParens: u(me, _),
                            printed: t(me, c(ce) ? y(me, _, O) : F(me, _, O), _)
                        }), me.call((he)=>G(he), "object")) : ce.type === "TSNonNullExpression" ? (H.unshift({
                            node: ce,
                            printed: t(me, "!", _)
                        }), me.call((he)=>G(he), "expression")) : H.unshift({
                            node: ce,
                            printed: O()
                        });
                    }
                    let re = k.getValue();
                    H.unshift({
                        node: re,
                        printed: [
                            o(k),
                            x(k, _, O),
                            d(k, _, O)
                        ]
                    }), re.callee && k.call((me)=>G(me), "callee");
                    let $ = [], W = [
                        H[0]
                    ], ee = 1;
                    for(; ee < H.length && (H[ee].node.type === "TSNonNullExpression" || a(H[ee].node) || c(H[ee].node) && H[ee].node.computed && g(H[ee].node.property)); ++ee)W.push(H[ee]);
                    if (!a(H[0].node)) for(; ee + 1 < H.length && m(H[ee].node) && m(H[ee + 1].node); ++ee)W.push(H[ee]);
                    $.push(W), W = [];
                    let U = !1;
                    for(; ee < H.length; ++ee){
                        if (U && m(H[ee].node)) {
                            if (H[ee].node.computed && g(H[ee].node.property)) {
                                W.push(H[ee]);
                                continue;
                            }
                            $.push(W), W = [], U = !1;
                        }
                        (a(H[ee].node) || H[ee].node.type === "ImportExpression") && (U = !0), W.push(H[ee]), f(H[ee].node, h.Trailing) && ($.push(W), W = [], U = !1);
                    }
                    W.length > 0 && $.push(W);
                    function ne(me) {
                        return /^[A-Z]|^[$_]+$/.test(me);
                    }
                    function se(me) {
                        return me.length <= _.tabWidth;
                    }
                    function V(me) {
                        let ce = me[1].length > 0 && me[1][0].node.computed;
                        if (me[0].length === 1) {
                            let J = me[0][0].node;
                            return J.type === "ThisExpression" || J.type === "Identifier" && (ne(J.name) || M && se(J.name) || ce);
                        }
                        let he = s(me[0]).node;
                        return c(he) && he.property.type === "Identifier" && (ne(he.property.name) || ce);
                    }
                    let oe = $.length >= 2 && !f($[1][0].node) && V($);
                    function K(me) {
                        let ce = me.map((he)=>he.printed);
                        return me.length > 0 && s(me).needsParens ? [
                            "(",
                            ...ce,
                            ")"
                        ] : ce;
                    }
                    function Ee(me) {
                        return me.length === 0 ? "" : B(v([
                            b,
                            A(b, me.map(K))
                        ]));
                    }
                    let q = $.map(K), le = q, ue = oe ? 3 : 2, Q = $.flat(), de = Q.slice(1, -1).some((me)=>f(me.node, h.Leading)) || Q.slice(0, -1).some((me)=>f(me.node, h.Trailing)) || $[ue] && f($[ue][0].node, h.Leading);
                    if ($.length <= ue && !de) return C(k) ? le : v(le);
                    let ge = s($[oe ? 1 : 0]).node, ve = !a(ge) && P(ge), xe = [
                        K($[0]),
                        oe ? $.slice(1, 2).map(K) : "",
                        ve ? b : "",
                        Ee($.slice(oe ? 2 : 1))
                    ], we = H.map((me)=>{
                        let { node: ce } = me;
                        return ce;
                    }).filter(a);
                    function fe() {
                        let me = s(s($)).node, ce = s(q);
                        return a(me) && D(ce) && we.slice(0, -1).some((he)=>he.arguments.some(l));
                    }
                    let pe;
                    return de || we.length > 2 && we.some((me)=>!me.arguments.every((ce)=>p(ce, 0))) || q.slice(0, -1).some(D) || fe() ? pe = v(xe) : pe = [
                        D(le) || ve ? I : "",
                        w([
                            le,
                            xe
                        ])
                    ], E("member-chain", pe);
                }
                n.exports = S;
            }
        }), so = Z({
            "src/language-js/print/call-expression.js" (e, n) {
                "use strict";
                ae();
                var { builders: { join: t, group: s } } = Le(), i = kt(), { getCallArguments: r, hasFlowAnnotationComment: u, isCallExpression: a, isMemberish: c, isStringLiteral: l, isTemplateOnItsOwnLine: C, isTestCall: m, iterateCallArgumentsPath: g } = Xe(), p = Nm(), f = no(), { printOptionalToken: h, printFunctionTypeParameters: N } = ot();
                function T(b, v, B) {
                    let w = b.getValue(), I = b.getParentNode(), E = w.type === "NewExpression", D = w.type === "ImportExpression", d = h(b), y = r(w);
                    if (y.length > 0 && (!D && !E && A(w, I) || y.length === 1 && C(y[0], v.originalText) || !E && m(w, I))) {
                        let F = [];
                        return g(b, ()=>{
                            F.push(B());
                        }), [
                            E ? "new " : "",
                            B("callee"),
                            d,
                            N(b, v, B),
                            "(",
                            t(", ", F),
                            ")"
                        ];
                    }
                    let o = (v.parser === "babel" || v.parser === "babel-flow") && w.callee && w.callee.type === "Identifier" && u(w.callee.trailingComments);
                    if (o && (w.callee.trailingComments[0].printed = !0), !D && !E && c(w.callee) && !b.call((F)=>i(F, v), "callee")) return p(b, v, B);
                    let x = [
                        E ? "new " : "",
                        D ? "import" : B("callee"),
                        d,
                        o ? "/*:: ".concat(w.callee.trailingComments[0].value.slice(2).trim(), " */") : "",
                        N(b, v, B),
                        f(b, v, B)
                    ];
                    return D || a(w.callee) ? s(x) : x;
                }
                function A(b, v) {
                    if (b.callee.type !== "Identifier") return !1;
                    if (b.callee.name === "require") return !0;
                    if (b.callee.name === "define") {
                        let B = r(b);
                        return v.type === "ExpressionStatement" && (B.length === 1 || B.length === 2 && B[0].type === "ArrayExpression" || B.length === 3 && l(B[0]) && B[1].type === "ArrayExpression");
                    }
                    return !1;
                }
                n.exports = {
                    printCallExpression: T
                };
            }
        }), Xt = Z({
            "src/language-js/print/assignment.js" (e, n) {
                "use strict";
                ae();
                var { isNonEmptyArray: t, getStringWidth: s } = Ge(), { builders: { line: i, group: r, indent: u, indentIfBreak: a, lineSuffixBoundary: c }, utils: { cleanDoc: l, willBreak: C, canBreak: m } } = Le(), { hasLeadingOwnLineComment: g, isBinaryish: p, isStringLiteral: f, isLiteral: h, isNumericLiteral: N, isCallExpression: T, isMemberExpression: A, getCallArguments: b, rawText: v, hasComment: B, isSignedNumericLiteral: w, isObjectProperty: I } = Xe(), { shouldInlineLogicalExpression: E } = Jn(), { printCallExpression: D } = so();
                function d(V, oe, K, Ee, q, le) {
                    let ue = x(V, oe, K, Ee, le), Q = K(le, {
                        assignmentLayout: ue
                    });
                    switch(ue){
                        case "break-after-operator":
                            return r([
                                r(Ee),
                                q,
                                r(u([
                                    i,
                                    Q
                                ]))
                            ]);
                        case "never-break-after-operator":
                            return r([
                                r(Ee),
                                q,
                                " ",
                                Q
                            ]);
                        case "fluid":
                            {
                                let de = Symbol("assignment");
                                return r([
                                    r(Ee),
                                    q,
                                    r(u(i), {
                                        id: de
                                    }),
                                    c,
                                    a(Q, {
                                        groupId: de
                                    })
                                ]);
                            }
                        case "break-lhs":
                            return r([
                                Ee,
                                q,
                                " ",
                                r(Q)
                            ]);
                        case "chain":
                            return [
                                r(Ee),
                                q,
                                i,
                                Q
                            ];
                        case "chain-tail":
                            return [
                                r(Ee),
                                q,
                                u([
                                    i,
                                    Q
                                ])
                            ];
                        case "chain-tail-arrow-chain":
                            return [
                                r(Ee),
                                q,
                                Q
                            ];
                        case "only-left":
                            return Ee;
                    }
                }
                function y(V, oe, K) {
                    let Ee = V.getValue();
                    return d(V, oe, K, K("left"), [
                        " ",
                        Ee.operator
                    ], "right");
                }
                function o(V, oe, K) {
                    return d(V, oe, K, K("id"), " =", "init");
                }
                function x(V, oe, K, Ee, q) {
                    let le = V.getValue(), ue = le[q];
                    if (!ue) return "only-left";
                    let Q = !k(ue);
                    if (V.match(k, _, (xe)=>!Q || xe.type !== "ExpressionStatement" && xe.type !== "VariableDeclaration")) return Q ? ue.type === "ArrowFunctionExpression" && ue.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
                    if (!Q && k(ue.right) || g(oe.originalText, ue)) return "break-after-operator";
                    if (ue.type === "CallExpression" && ue.callee.name === "require" || oe.parser === "json5" || oe.parser === "json") return "never-break-after-operator";
                    if (S(le) || O(le) || H(le) || P(le) && m(Ee)) return "break-lhs";
                    let ve = U(le, Ee, oe);
                    return V.call(()=>F(V, oe, K, ve), q) ? "break-after-operator" : ve || ue.type === "TemplateLiteral" || ue.type === "TaggedTemplateExpression" || ue.type === "BooleanLiteral" || N(ue) || ue.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
                }
                function F(V, oe, K, Ee) {
                    let q = V.getValue();
                    if (p(q) && !E(q)) return !0;
                    switch(q.type){
                        case "StringLiteralTypeAnnotation":
                        case "SequenceExpression":
                            return !0;
                        case "ConditionalExpression":
                            {
                                let { test: Q } = q;
                                return p(Q) && !E(Q);
                            }
                        case "ClassExpression":
                            return t(q.decorators);
                    }
                    if (Ee) return !1;
                    let le = q, ue = [];
                    for(;;)if (le.type === "UnaryExpression") le = le.argument, ue.push("argument");
                    else if (le.type === "TSNonNullExpression") le = le.expression, ue.push("expression");
                    else break;
                    return !!(f(le) || V.call(()=>$(V, oe, K), ...ue));
                }
                function S(V) {
                    if (_(V)) {
                        let oe = V.left || V.id;
                        return oe.type === "ObjectPattern" && oe.properties.length > 2 && oe.properties.some((K)=>I(K) && (!K.shorthand || K.value && K.value.type === "AssignmentPattern"));
                    }
                    return !1;
                }
                function k(V) {
                    return V.type === "AssignmentExpression";
                }
                function _(V) {
                    return k(V) || V.type === "VariableDeclarator";
                }
                function O(V) {
                    let oe = R(V);
                    if (t(oe)) {
                        let K = V.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
                        if (oe.length > 1 && oe.some((Ee)=>Ee[K] || Ee.default)) return !0;
                    }
                    return !1;
                }
                function R(V) {
                    return M(V) && V.typeParameters && V.typeParameters.params ? V.typeParameters.params : null;
                }
                function M(V) {
                    return V.type === "TSTypeAliasDeclaration" || V.type === "TypeAlias";
                }
                function H(V) {
                    if (V.type !== "VariableDeclarator") return !1;
                    let { typeAnnotation: oe } = V.id;
                    if (!oe || !oe.typeAnnotation) return !1;
                    let K = G(oe.typeAnnotation);
                    return t(K) && K.length > 1 && K.some((Ee)=>t(G(Ee)) || Ee.type === "TSConditionalType");
                }
                function P(V) {
                    return V.type === "VariableDeclarator" && V.init && V.init.type === "ArrowFunctionExpression";
                }
                function G(V) {
                    return re(V) && V.typeParameters && V.typeParameters.params ? V.typeParameters.params : null;
                }
                function re(V) {
                    return V.type === "TSTypeReference" || V.type === "GenericTypeAnnotation";
                }
                function $(V, oe, K) {
                    let Ee = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, q = V.getValue(), le = ()=>$(V, oe, K, !0);
                    if (q.type === "TSNonNullExpression") return V.call(le, "expression");
                    if (T(q)) {
                        if (D(V, oe, K).label === "member-chain") return !1;
                        let Q = b(q);
                        return !(Q.length === 0 || Q.length === 1 && ee(Q[0], oe)) || ne(q, K) ? !1 : V.call(le, "callee");
                    }
                    return A(q) ? V.call(le, "object") : Ee && (q.type === "Identifier" || q.type === "ThisExpression");
                }
                var W = .25;
                function ee(V, oe) {
                    let { printWidth: K } = oe;
                    if (B(V)) return !1;
                    let Ee = K * W;
                    if (V.type === "ThisExpression" || V.type === "Identifier" && V.name.length <= Ee || w(V) && !B(V.argument)) return !0;
                    let q = V.type === "Literal" && "regex" in V && V.regex.pattern || V.type === "RegExpLiteral" && V.pattern;
                    return q ? q.length <= Ee : f(V) ? v(V).length <= Ee : V.type === "TemplateLiteral" ? V.expressions.length === 0 && V.quasis[0].value.raw.length <= Ee && !V.quasis[0].value.raw.includes(`
`) : h(V);
                }
                function U(V, oe, K) {
                    if (!I(V)) return !1;
                    oe = l(oe);
                    let Ee = 3;
                    return typeof oe == "string" && s(oe) < K.tabWidth + Ee;
                }
                function ne(V, oe) {
                    let K = se(V);
                    if (t(K)) {
                        if (K.length > 1) return !0;
                        if (K.length === 1) {
                            let q = K[0];
                            if (q.type === "TSUnionType" || q.type === "UnionTypeAnnotation" || q.type === "TSIntersectionType" || q.type === "IntersectionTypeAnnotation" || q.type === "TSTypeLiteral" || q.type === "ObjectTypeAnnotation") return !0;
                        }
                        let Ee = V.typeParameters ? "typeParameters" : "typeArguments";
                        if (C(oe(Ee))) return !0;
                    }
                    return !1;
                }
                function se(V) {
                    return V.typeParameters && V.typeParameters.params || V.typeArguments && V.typeArguments.params;
                }
                n.exports = {
                    printVariableDeclarator: o,
                    printAssignmentExpression: y,
                    printAssignment: d,
                    isArrowFunctionVariableDeclarator: P
                };
            }
        }), wr = Z({
            "src/language-js/print/function-parameters.js" (e, n) {
                "use strict";
                ae();
                var { getNextNonSpaceNonCommentCharacter: t } = Ge(), { printDanglingComments: s } = Qe(), { builders: { line: i, hardline: r, softline: u, group: a, indent: c, ifBreak: l }, utils: { removeLines: C, willBreak: m } } = Le(), { getFunctionParameters: g, iterateFunctionParametersPath: p, isSimpleType: f, isTestCall: h, isTypeAnnotationAFunction: N, isObjectType: T, isObjectTypePropertyAFunction: A, hasRestParameter: b, shouldPrintComma: v, hasComment: B, isNextLineEmpty: w } = Xe(), { locEnd: I } = nt(), { ArgExpansionBailout: E } = Jt(), { printFunctionTypeParameters: D } = ot();
                function d(F, S, k, _, O) {
                    let R = F.getValue(), M = g(R), H = O ? D(F, k, S) : "";
                    if (M.length === 0) return [
                        H,
                        "(",
                        s(F, k, !0, (U)=>t(k.originalText, U, I) === ")"),
                        ")"
                    ];
                    let P = F.getParentNode(), G = h(P), re = y(R), $ = [];
                    if (p(F, (U, ne)=>{
                        let se = ne === M.length - 1;
                        se && R.rest && $.push("..."), $.push(S()), !se && ($.push(","), G || re ? $.push(" ") : w(M[ne], k) ? $.push(r, r) : $.push(i));
                    }), _) {
                        if (m(H) || m($)) throw new E;
                        return a([
                            C(H),
                            "(",
                            C($),
                            ")"
                        ]);
                    }
                    let W = M.every((U)=>!U.decorators);
                    return re && W ? [
                        H,
                        "(",
                        ...$,
                        ")"
                    ] : G ? [
                        H,
                        "(",
                        ...$,
                        ")"
                    ] : (A(P) || N(P) || P.type === "TypeAlias" || P.type === "UnionTypeAnnotation" || P.type === "TSUnionType" || P.type === "IntersectionTypeAnnotation" || P.type === "FunctionTypeAnnotation" && P.returnType === R) && M.length === 1 && M[0].name === null && R.this !== M[0] && M[0].typeAnnotation && R.typeParameters === null && f(M[0].typeAnnotation) && !R.rest ? k.arrowParens === "always" ? [
                        "(",
                        ...$,
                        ")"
                    ] : $ : [
                        H,
                        "(",
                        c([
                            u,
                            ...$
                        ]),
                        l(!b(R) && v(k, "all") ? "," : ""),
                        u,
                        ")"
                    ];
                }
                function y(F) {
                    if (!F) return !1;
                    let S = g(F);
                    if (S.length !== 1) return !1;
                    let [k] = S;
                    return !B(k) && (k.type === "ObjectPattern" || k.type === "ArrayPattern" || k.type === "Identifier" && k.typeAnnotation && (k.typeAnnotation.type === "TypeAnnotation" || k.typeAnnotation.type === "TSTypeAnnotation") && T(k.typeAnnotation.typeAnnotation) || k.type === "FunctionTypeParam" && T(k.typeAnnotation) || k.type === "AssignmentPattern" && (k.left.type === "ObjectPattern" || k.left.type === "ArrayPattern") && (k.right.type === "Identifier" || k.right.type === "ObjectExpression" && k.right.properties.length === 0 || k.right.type === "ArrayExpression" && k.right.elements.length === 0));
                }
                function o(F) {
                    let S;
                    return F.returnType ? (S = F.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : F.typeAnnotation && (S = F.typeAnnotation), S;
                }
                function x(F, S) {
                    let k = o(F);
                    if (!k) return !1;
                    let _ = F.typeParameters && F.typeParameters.params;
                    if (_) {
                        if (_.length > 1) return !1;
                        if (_.length === 1) {
                            let O = _[0];
                            if (O.constraint || O.default) return !1;
                        }
                    }
                    return g(F).length === 1 && (T(k) || m(S));
                }
                n.exports = {
                    printFunctionParameters: d,
                    shouldHugFunctionParameters: y,
                    shouldGroupFunctionParameters: x
                };
            }
        }), _r = Z({
            "src/language-js/print/type-annotation.js" (e, n) {
                "use strict";
                ae();
                var { printComments: t, printDanglingComments: s } = Qe(), { isNonEmptyArray: i } = Ge(), { builders: { group: r, join: u, line: a, softline: c, indent: l, align: C, ifBreak: m } } = Le(), g = kt(), { locStart: p } = nt(), { isSimpleType: f, isObjectType: h, hasLeadingOwnLineComment: N, isObjectTypePropertyAFunction: T, shouldPrintComma: A } = Xe(), { printAssignment: b } = Xt(), { printFunctionParameters: v, shouldGroupFunctionParameters: B } = wr(), { printArrayItems: w } = zt();
                function I(S) {
                    if (f(S) || h(S)) return !0;
                    if (S.type === "UnionTypeAnnotation" || S.type === "TSUnionType") {
                        let k = S.types.filter((O)=>O.type === "VoidTypeAnnotation" || O.type === "TSVoidKeyword" || O.type === "NullLiteralTypeAnnotation" || O.type === "TSNullKeyword").length, _ = S.types.some((O)=>O.type === "ObjectTypeAnnotation" || O.type === "TSTypeLiteral" || O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference");
                        if (S.types.length - 1 === k && _) return !0;
                    }
                    return !1;
                }
                function E(S, k, _) {
                    let O = k.semi ? ";" : "", R = S.getValue(), M = [];
                    return M.push("opaque type ", _("id"), _("typeParameters")), R.supertype && M.push(": ", _("supertype")), R.impltype && M.push(" = ", _("impltype")), M.push(O), M;
                }
                function D(S, k, _) {
                    let O = k.semi ? ";" : "", R = S.getValue(), M = [];
                    R.declare && M.push("declare "), M.push("type ", _("id"), _("typeParameters"));
                    let H = R.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
                    return [
                        b(S, k, _, M, " =", H),
                        O
                    ];
                }
                function d(S, k, _) {
                    let O = S.getValue(), R = S.map(_, "types"), M = [], H = !1;
                    for(let P = 0; P < R.length; ++P)P === 0 ? M.push(R[P]) : h(O.types[P - 1]) && h(O.types[P]) ? M.push([
                        " & ",
                        H ? l(R[P]) : R[P]
                    ]) : !h(O.types[P - 1]) && !h(O.types[P]) ? M.push(l([
                        " &",
                        a,
                        R[P]
                    ])) : (P > 1 && (H = !0), M.push(" & ", P > 1 ? l(R[P]) : R[P]));
                    return r(M);
                }
                function y(S, k, _) {
                    let O = S.getValue(), R = S.getParentNode(), M = R.type !== "TypeParameterInstantiation" && R.type !== "TSTypeParameterInstantiation" && R.type !== "GenericTypeAnnotation" && R.type !== "TSTypeReference" && R.type !== "TSTypeAssertion" && R.type !== "TupleTypeAnnotation" && R.type !== "TSTupleType" && !(R.type === "FunctionTypeParam" && !R.name && S.getParentNode(1).this !== R) && !((R.type === "TypeAlias" || R.type === "VariableDeclarator" || R.type === "TSTypeAliasDeclaration") && N(k.originalText, O)), H = I(O), P = S.map(($)=>{
                        let W = _();
                        return H || (W = C(2, W)), t($, W, k);
                    }, "types");
                    if (H) return u(" | ", P);
                    let G = M && !N(k.originalText, O), re = [
                        m([
                            G ? a : "",
                            "| "
                        ]),
                        u([
                            a,
                            "| "
                        ], P)
                    ];
                    return g(S, k) ? r([
                        l(re),
                        c
                    ]) : R.type === "TupleTypeAnnotation" && R.types.length > 1 || R.type === "TSTupleType" && R.elementTypes.length > 1 ? r([
                        l([
                            m([
                                "(",
                                c
                            ]),
                            re
                        ]),
                        c,
                        m(")")
                    ]) : r(M ? l(re) : re);
                }
                function o(S, k, _) {
                    let O = S.getValue(), R = [], M = S.getParentNode(0), H = S.getParentNode(1), P = S.getParentNode(2), G = O.type === "TSFunctionType" || !((M.type === "ObjectTypeProperty" || M.type === "ObjectTypeInternalSlot") && !M.variance && !M.optional && p(M) === p(O) || M.type === "ObjectTypeCallProperty" || P && P.type === "DeclareFunction"), re = G && (M.type === "TypeAnnotation" || M.type === "TSTypeAnnotation"), $ = re && G && (M.type === "TypeAnnotation" || M.type === "TSTypeAnnotation") && H.type === "ArrowFunctionExpression";
                    T(M) && (G = !0, re = !0), $ && R.push("(");
                    let W = v(S, _, k, !1, !0), ee = O.returnType || O.predicate || O.typeAnnotation ? [
                        G ? " => " : ": ",
                        _("returnType"),
                        _("predicate"),
                        _("typeAnnotation")
                    ] : "", U = B(O, ee);
                    return R.push(U ? r(W) : W), ee && R.push(ee), $ && R.push(")"), r(R);
                }
                function x(S, k, _) {
                    let O = S.getValue(), R = O.type === "TSTupleType" ? "elementTypes" : "types", M = O[R], H = i(M), P = H ? c : "";
                    return r([
                        "[",
                        l([
                            P,
                            w(S, k, R, _)
                        ]),
                        m(H && A(k, "all") ? "," : ""),
                        s(S, k, !0),
                        P,
                        "]"
                    ]);
                }
                function F(S, k, _) {
                    let O = S.getValue(), R = O.type === "OptionalIndexedAccessType" && O.optional ? "?.[" : "[";
                    return [
                        _("objectType"),
                        R,
                        _("indexType"),
                        "]"
                    ];
                }
                n.exports = {
                    printOpaqueType: E,
                    printTypeAlias: D,
                    printIntersectionType: d,
                    printUnionType: y,
                    printFunctionType: o,
                    printTupleType: x,
                    printIndexedAccessType: F,
                    shouldHugType: I
                };
            }
        }), Pr = Z({
            "src/language-js/print/type-parameters.js" (e, n) {
                "use strict";
                ae();
                var { printDanglingComments: t } = Qe(), { builders: { join: s, line: i, hardline: r, softline: u, group: a, indent: c, ifBreak: l } } = Le(), { isTestCall: C, hasComment: m, CommentCheckFlags: g, isTSXFile: p, shouldPrintComma: f, getFunctionParameters: h, isObjectType: N } = Xe(), { createGroupIdMapper: T } = Ge(), { shouldHugType: A } = _r(), { isArrowFunctionVariableDeclarator: b } = Xt(), v = T("typeParameters");
                function B(E, D, d, y) {
                    let o = E.getValue();
                    if (!o[y]) return "";
                    if (!Array.isArray(o[y])) return d(y);
                    let x = E.getNode(2), F = x && C(x);
                    if (!E.match((O)=>!(O[y].length === 1 && N(O[y][0])), void 0, (O, R)=>R === "typeAnnotation", (O)=>O.type === "Identifier", b) && (F || o[y].length === 0 || o[y].length === 1 && (o[y][0].type === "NullableTypeAnnotation" || A(o[y][0])))) return [
                        "<",
                        s(", ", E.map(d, y)),
                        w(E, D),
                        ">"
                    ];
                    let _ = o.type === "TSTypeParameterInstantiation" ? "" : h(o).length === 1 && p(D) && !o[y][0].constraint && E.getParentNode().type === "ArrowFunctionExpression" ? "," : f(D, "all") ? l(",") : "";
                    return a([
                        "<",
                        c([
                            u,
                            s([
                                ",",
                                i
                            ], E.map(d, y))
                        ]),
                        _,
                        u,
                        ">"
                    ], {
                        id: v(o)
                    });
                }
                function w(E, D) {
                    let d = E.getValue();
                    if (!m(d, g.Dangling)) return "";
                    let y = !m(d, g.Line), o = t(E, D, y);
                    return y ? o : [
                        o,
                        r
                    ];
                }
                function I(E, D, d) {
                    let y = E.getValue(), o = [], x = E.getParentNode();
                    return x.type === "TSMappedType" ? (o.push("[", d("name")), y.constraint && o.push(" in ", d("constraint")), x.nameType && o.push(" as ", E.callParent(()=>d("nameType"))), o.push("]"), o) : (y.variance && o.push(d("variance")), o.push(d("name")), y.bound && o.push(": ", d("bound")), y.constraint && o.push(" extends ", d("constraint")), y.default && o.push(" = ", d("default")), o);
                }
                n.exports = {
                    printTypeParameter: I,
                    printTypeParameters: B,
                    getTypeParametersGroupId: v
                };
            }
        }), Kt = Z({
            "src/language-js/print/property.js" (e, n) {
                "use strict";
                ae();
                var { printComments: t } = Qe(), { printString: s, printNumber: i } = Ge(), { isNumericLiteral: r, isSimpleNumber: u, isStringLiteral: a, isStringPropSafeToUnquote: c, rawText: l } = Xe(), { printAssignment: C } = Xt(), m = new WeakMap;
                function g(f, h, N) {
                    let T = f.getNode();
                    if (T.computed) return [
                        "[",
                        N("key"),
                        "]"
                    ];
                    let A = f.getParentNode(), { key: b } = T;
                    if (T.type === "ClassPrivateProperty" && b.type === "Identifier") return [
                        "#",
                        N("key")
                    ];
                    if (h.quoteProps === "consistent" && !m.has(A)) {
                        let v = (A.properties || A.body || A.members).some((B)=>!B.computed && B.key && a(B.key) && !c(B, h));
                        m.set(A, v);
                    }
                    if ((b.type === "Identifier" || r(b) && u(i(l(b))) && String(b.value) === i(l(b)) && !(h.parser === "typescript" || h.parser === "babel-ts")) && (h.parser === "json" || h.quoteProps === "consistent" && m.get(A))) {
                        let v = s(JSON.stringify(b.type === "Identifier" ? b.name : b.value.toString()), h);
                        return f.call((B)=>t(B, v, h), "key");
                    }
                    return c(T, h) && (h.quoteProps === "as-needed" || h.quoteProps === "consistent" && !m.get(A)) ? f.call((v)=>t(v, /^\d/.test(b.value) ? i(b.value) : b.value, h), "key") : N("key");
                }
                function p(f, h, N) {
                    return f.getValue().shorthand ? N("value") : C(f, h, N, g(f, h, N), ":", "value");
                }
                n.exports = {
                    printProperty: p,
                    printPropertyKey: g
                };
            }
        }), Ir = Z({
            "src/language-js/print/function.js" (e, n) {
                "use strict";
                ae();
                var t = Ut(), { printDanglingComments: s, printCommentsSeparately: i } = Qe(), r = st(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ge(), { builders: { line: a, softline: c, group: l, indent: C, ifBreak: m, hardline: g, join: p, indentIfBreak: f }, utils: { removeLines: h, willBreak: N } } = Le(), { ArgExpansionBailout: T } = Jt(), { getFunctionParameters: A, hasLeadingOwnLineComment: b, isFlowAnnotationComment: v, isJsxNode: B, isTemplateOnItsOwnLine: w, shouldPrintComma: I, startsWithNoLookaheadToken: E, isBinaryish: D, isLineComment: d, hasComment: y, getComments: o, CommentCheckFlags: x, isCallLikeExpression: F, isCallExpression: S, getCallArguments: k, hasNakedLeftSide: _, getLeftSide: O } = Xe(), { locEnd: R } = nt(), { printFunctionParameters: M, shouldGroupFunctionParameters: H } = wr(), { printPropertyKey: P } = Kt(), { printFunctionTypeParameters: G } = ot();
                function re(ue, Q, de, ge) {
                    let ve = ue.getValue(), xe = !1;
                    if ((ve.type === "FunctionDeclaration" || ve.type === "FunctionExpression") && ge && ge.expandLastArg) {
                        let ce = ue.getParentNode();
                        S(ce) && k(ce).length > 1 && (xe = !0);
                    }
                    let we = [];
                    ve.type === "TSDeclareFunction" && ve.declare && we.push("declare "), ve.async && we.push("async "), ve.generator ? we.push("function* ") : we.push("function "), ve.id && we.push(Q("id"));
                    let fe = M(ue, Q, de, xe), pe = oe(ue, Q, de), me = H(ve, pe);
                    return we.push(G(ue, de, Q), l([
                        me ? l(fe) : fe,
                        pe
                    ]), ve.body ? " " : "", Q("body")), de.semi && (ve.declare || !ve.body) && we.push(";"), we;
                }
                function $(ue, Q, de) {
                    let ge = ue.getNode(), { kind: ve } = ge, xe = ge.value || ge, we = [];
                    return !ve || ve === "init" || ve === "method" || ve === "constructor" ? xe.async && we.push("async ") : (t.ok(ve === "get" || ve === "set"), we.push(ve, " ")), xe.generator && we.push("*"), we.push(P(ue, Q, de), ge.optional || ge.key.optional ? "?" : ""), ge === xe ? we.push(W(ue, Q, de)) : xe.type === "FunctionExpression" ? we.push(ue.call((fe)=>W(fe, Q, de), "value")) : we.push(de("value")), we;
                }
                function W(ue, Q, de) {
                    let ge = ue.getNode(), ve = M(ue, de, Q), xe = oe(ue, de, Q), we = H(ge, xe), fe = [
                        G(ue, Q, de),
                        l([
                            we ? l(ve) : ve,
                            xe
                        ])
                    ];
                    return ge.body ? fe.push(" ", de("body")) : fe.push(Q.semi ? ";" : ""), fe;
                }
                function ee(ue, Q, de, ge) {
                    let ve = ue.getValue(), xe = [];
                    if (ve.async && xe.push("async "), V(ue, Q)) xe.push(de([
                        "params",
                        0
                    ]));
                    else {
                        let fe = ge && (ge.expandLastArg || ge.expandFirstArg), pe = oe(ue, de, Q);
                        if (fe) {
                            if (N(pe)) throw new T;
                            pe = l(h(pe));
                        }
                        xe.push(l([
                            M(ue, de, Q, fe, !0),
                            pe
                        ]));
                    }
                    let we = s(ue, Q, !0, (fe)=>{
                        let pe = u(Q.originalText, fe, R);
                        return pe !== !1 && Q.originalText.slice(pe, pe + 2) === "=>";
                    });
                    return we && xe.push(" ", we), xe;
                }
                function U(ue, Q, de, ge, ve, xe) {
                    let we = ue.getName(), fe = ue.getParentNode(), pe = F(fe) && we === "callee", me = Boolean(Q && Q.assignmentLayout), ce = xe.body.type !== "BlockStatement" && xe.body.type !== "ObjectExpression" && xe.body.type !== "SequenceExpression", he = pe && ce || Q && Q.assignmentLayout === "chain-tail-arrow-chain", J = Symbol("arrow-chain");
                    return xe.body.type === "SequenceExpression" && (ve = l([
                        "(",
                        C([
                            c,
                            ve
                        ]),
                        c,
                        ")"
                    ])), l([
                        l(C([
                            pe || me ? c : "",
                            l(p([
                                " =>",
                                a
                            ], de), {
                                shouldBreak: ge
                            })
                        ]), {
                            id: J,
                            shouldBreak: he
                        }),
                        " =>",
                        f(ce ? C([
                            a,
                            ve
                        ]) : [
                            " ",
                            ve
                        ], {
                            groupId: J
                        }),
                        pe ? m(c, "", {
                            groupId: J
                        }) : ""
                    ]);
                }
                function ne(ue, Q, de, ge) {
                    let ve = ue.getValue(), xe = [], we = [], fe = !1;
                    if (function J() {
                        let ye = ee(ue, Q, de, ge);
                        if (xe.length === 0) xe.push(ye);
                        else {
                            let { leading: X, trailing: Y } = i(ue, Q);
                            xe.push([
                                X,
                                ye
                            ]), we.unshift(Y);
                        }
                        fe = fe || ve.returnType && A(ve).length > 0 || ve.typeParameters || A(ve).some((X)=>X.type !== "Identifier"), ve.body.type !== "ArrowFunctionExpression" || ge && ge.expandLastArg ? we.unshift(de("body", ge)) : (ve = ve.body, ue.call(J, "body"));
                    }(), xe.length > 1) return U(ue, ge, xe, fe, we, ve);
                    let pe = xe;
                    if (pe.push(" =>"), !b(Q.originalText, ve.body) && (ve.body.type === "ArrayExpression" || ve.body.type === "ObjectExpression" || ve.body.type === "BlockStatement" || B(ve.body) || w(ve.body, Q.originalText) || ve.body.type === "ArrowFunctionExpression" || ve.body.type === "DoExpression")) return l([
                        ...pe,
                        " ",
                        we
                    ]);
                    if (ve.body.type === "SequenceExpression") return l([
                        ...pe,
                        l([
                            " (",
                            C([
                                c,
                                we
                            ]),
                            c,
                            ")"
                        ])
                    ]);
                    let me = (ge && ge.expandLastArg || ue.getParentNode().type === "JSXExpressionContainer") && !y(ve), ce = ge && ge.expandLastArg && I(Q, "all"), he = ve.body.type === "ConditionalExpression" && !E(ve.body, !1);
                    return l([
                        ...pe,
                        l([
                            C([
                                a,
                                he ? m("", "(") : "",
                                we,
                                he ? m("", ")") : ""
                            ]),
                            me ? [
                                m(ce ? "," : ""),
                                c
                            ] : ""
                        ])
                    ]);
                }
                function se(ue) {
                    let Q = A(ue);
                    return Q.length === 1 && !ue.typeParameters && !y(ue, x.Dangling) && Q[0].type === "Identifier" && !Q[0].typeAnnotation && !y(Q[0]) && !Q[0].optional && !ue.predicate && !ue.returnType;
                }
                function V(ue, Q) {
                    if (Q.arrowParens === "always") return !1;
                    if (Q.arrowParens === "avoid") {
                        let de = ue.getValue();
                        return se(de);
                    }
                    return !1;
                }
                function oe(ue, Q, de) {
                    let ge = ue.getValue(), ve = Q("returnType");
                    if (ge.returnType && v(de.originalText, ge.returnType)) return [
                        " /*: ",
                        ve,
                        " */"
                    ];
                    let xe = [
                        ve
                    ];
                    return ge.returnType && ge.returnType.typeAnnotation && xe.unshift(": "), ge.predicate && xe.push(ge.returnType ? " " : ": ", Q("predicate")), xe;
                }
                function K(ue, Q, de) {
                    let ge = ue.getValue(), ve = Q.semi ? ";" : "", xe = [];
                    ge.argument && (le(Q, ge.argument) ? xe.push([
                        " (",
                        C([
                            g,
                            de("argument")
                        ]),
                        g,
                        ")"
                    ]) : D(ge.argument) || ge.argument.type === "SequenceExpression" ? xe.push(l([
                        m(" (", " "),
                        C([
                            c,
                            de("argument")
                        ]),
                        c,
                        m(")")
                    ])) : xe.push(" ", de("argument")));
                    let we = o(ge), fe = r(we), pe = fe && d(fe);
                    return pe && xe.push(ve), y(ge, x.Dangling) && xe.push(" ", s(ue, Q, !0)), pe || xe.push(ve), xe;
                }
                function Ee(ue, Q, de) {
                    return [
                        "return",
                        K(ue, Q, de)
                    ];
                }
                function q(ue, Q, de) {
                    return [
                        "throw",
                        K(ue, Q, de)
                    ];
                }
                function le(ue, Q) {
                    if (b(ue.originalText, Q)) return !0;
                    if (_(Q)) {
                        let de = Q, ge;
                        for(; ge = O(de);)if (de = ge, b(ue.originalText, de)) return !0;
                    }
                    return !1;
                }
                n.exports = {
                    printFunction: re,
                    printArrowFunction: ne,
                    printMethod: $,
                    printReturnStatement: Ee,
                    printThrowStatement: q,
                    printMethodInternal: W,
                    shouldPrintParamsWithoutParens: V
                };
            }
        }), Un = Z({
            "src/language-js/print/decorators.js" (e, n) {
                "use strict";
                ae();
                var { isNonEmptyArray: t, hasNewline: s } = Ge(), { builders: { line: i, hardline: r, join: u, breakParent: a, group: c } } = Le(), { locStart: l, locEnd: C } = nt(), { getParentExportDeclaration: m } = Xe();
                function g(T, A, b) {
                    let v = T.getValue();
                    return c([
                        u(i, T.map(b, "decorators")),
                        h(v, A) ? r : i
                    ]);
                }
                function p(T, A, b) {
                    return [
                        u(r, T.map(b, "declaration", "decorators")),
                        r
                    ];
                }
                function f(T, A, b) {
                    let v = T.getValue(), { decorators: B } = v;
                    if (!t(B) || N(T.getParentNode())) return;
                    let w = v.type === "ClassExpression" || v.type === "ClassDeclaration" || h(v, A);
                    return [
                        m(T) ? r : w ? a : "",
                        u(i, T.map(b, "decorators")),
                        i
                    ];
                }
                function h(T, A) {
                    return T.decorators.some((b)=>s(A.originalText, C(b)));
                }
                function N(T) {
                    if (T.type !== "ExportDefaultDeclaration" && T.type !== "ExportNamedDeclaration" && T.type !== "DeclareExportDeclaration") return !1;
                    let A = T.declaration && T.declaration.decorators;
                    return t(A) && l(T, {
                        ignoreDecorators: !0
                    }) > l(A[0]);
                }
                n.exports = {
                    printDecorators: f,
                    printClassMemberDecorators: g,
                    printDecoratorsBeforeExport: p,
                    hasDecoratorsBeforeExport: N
                };
            }
        }), Yt = Z({
            "src/language-js/print/class.js" (e, n) {
                "use strict";
                ae();
                var { isNonEmptyArray: t, createGroupIdMapper: s } = Ge(), { printComments: i, printDanglingComments: r } = Qe(), { builders: { join: u, line: a, hardline: c, softline: l, group: C, indent: m, ifBreak: g } } = Le(), { hasComment: p, CommentCheckFlags: f } = Xe(), { getTypeParametersGroupId: h } = Pr(), { printMethod: N } = Ir(), { printOptionalToken: T, printTypeAnnotation: A, printDefiniteToken: b } = ot(), { printPropertyKey: v } = Kt(), { printAssignment: B } = Xt(), { printClassMemberDecorators: w } = Un();
                function I(k, _, O) {
                    let R = k.getValue(), M = [];
                    R.declare && M.push("declare "), R.abstract && M.push("abstract "), M.push("class");
                    let H = R.id && p(R.id, f.Trailing) || R.typeParameters && p(R.typeParameters, f.Trailing) || R.superClass && p(R.superClass) || t(R.extends) || t(R.mixins) || t(R.implements), P = [], G = [];
                    if (R.id && P.push(" ", O("id")), P.push(O("typeParameters")), R.superClass) {
                        let re = [
                            x(k, _, O),
                            O("superTypeParameters")
                        ], $ = k.call((W)=>[
                                "extends ",
                                i(W, re, _)
                            ], "superClass");
                        H ? G.push(a, C($)) : G.push(" ", $);
                    } else G.push(o(k, _, O, "extends"));
                    if (G.push(o(k, _, O, "mixins"), o(k, _, O, "implements")), H) {
                        let re;
                        y(R) ? re = [
                            ...P,
                            m(G)
                        ] : re = m([
                            ...P,
                            G
                        ]), M.push(C(re, {
                            id: E(R)
                        }));
                    } else M.push(...P, ...G);
                    return M.push(" ", O("body")), M;
                }
                var E = s("heritageGroup");
                function D(k) {
                    return g(c, "", {
                        groupId: E(k)
                    });
                }
                function d(k) {
                    return [
                        "superClass",
                        "extends",
                        "mixins",
                        "implements"
                    ].filter((_)=>Boolean(k[_])).length > 1;
                }
                function y(k) {
                    return k.typeParameters && !p(k.typeParameters, f.Trailing | f.Line) && !d(k);
                }
                function o(k, _, O, R) {
                    let M = k.getValue();
                    if (!t(M[R])) return "";
                    let H = r(k, _, !0, (P)=>{
                        let { marker: G } = P;
                        return G === R;
                    });
                    return [
                        y(M) ? g(" ", a, {
                            groupId: h(M.typeParameters)
                        }) : a,
                        H,
                        H && c,
                        R,
                        C(m([
                            a,
                            u([
                                ",",
                                a
                            ], k.map(O, R))
                        ]))
                    ];
                }
                function x(k, _, O) {
                    let R = O("superClass");
                    return k.getParentNode().type === "AssignmentExpression" ? C(g([
                        "(",
                        m([
                            l,
                            R
                        ]),
                        l,
                        ")"
                    ], R)) : R;
                }
                function F(k, _, O) {
                    let R = k.getValue(), M = [];
                    return t(R.decorators) && M.push(w(k, _, O)), R.accessibility && M.push(R.accessibility + " "), R.readonly && M.push("readonly "), R.declare && M.push("declare "), R.static && M.push("static "), (R.type === "TSAbstractMethodDefinition" || R.abstract) && M.push("abstract "), R.override && M.push("override "), M.push(N(k, _, O)), M;
                }
                function S(k, _, O) {
                    let R = k.getValue(), M = [], H = _.semi ? ";" : "";
                    return t(R.decorators) && M.push(w(k, _, O)), R.accessibility && M.push(R.accessibility + " "), R.declare && M.push("declare "), R.static && M.push("static "), (R.type === "TSAbstractPropertyDefinition" || R.abstract) && M.push("abstract "), R.override && M.push("override "), R.readonly && M.push("readonly "), R.variance && M.push(O("variance")), R.type === "ClassAccessorProperty" && M.push("accessor "), M.push(v(k, _, O), T(k), b(k), A(k, _, O)), [
                        B(k, _, O, M, " =", "value"),
                        H
                    ];
                }
                n.exports = {
                    printClass: I,
                    printClassMethod: F,
                    printClassProperty: S,
                    printHardlineAfterHeritage: D
                };
            }
        }), ao = Z({
            "src/language-js/print/interface.js" (e, n) {
                "use strict";
                ae();
                var { isNonEmptyArray: t } = Ge(), { builders: { join: s, line: i, group: r, indent: u, ifBreak: a } } = Le(), { hasComment: c, identity: l, CommentCheckFlags: C } = Xe(), { getTypeParametersGroupId: m } = Pr(), { printTypeScriptModifiers: g } = ot();
                function p(f, h, N) {
                    let T = f.getValue(), A = [];
                    T.declare && A.push("declare "), T.type === "TSInterfaceDeclaration" && A.push(T.abstract ? "abstract " : "", g(f, h, N)), A.push("interface");
                    let b = [], v = [];
                    T.type !== "InterfaceTypeAnnotation" && b.push(" ", N("id"), N("typeParameters"));
                    let B = T.typeParameters && !c(T.typeParameters, C.Trailing | C.Line);
                    return t(T.extends) && v.push(B ? a(" ", i, {
                        groupId: m(T.typeParameters)
                    }) : i, "extends ", (T.extends.length === 1 ? l : u)(s([
                        ",",
                        i
                    ], f.map(N, "extends")))), T.id && c(T.id, C.Trailing) || t(T.extends) ? B ? A.push(r([
                        ...b,
                        u(v)
                    ])) : A.push(r(u([
                        ...b,
                        ...v
                    ]))) : A.push(...b, ...v), A.push(" ", N("body")), r(A);
                }
                n.exports = {
                    printInterface: p
                };
            }
        }), io = Z({
            "src/language-js/print/module.js" (e, n) {
                "use strict";
                ae();
                var { isNonEmptyArray: t } = Ge(), { builders: { softline: s, group: i, indent: r, join: u, line: a, ifBreak: c, hardline: l } } = Le(), { printDanglingComments: C } = Qe(), { hasComment: m, CommentCheckFlags: g, shouldPrintComma: p, needsHardlineAfterDanglingComment: f, isStringLiteral: h, rawText: N } = Xe(), { locStart: T, hasSameLoc: A } = nt(), { hasDecoratorsBeforeExport: b, printDecoratorsBeforeExport: v } = Un();
                function B(S, k, _) {
                    let O = S.getValue(), R = k.semi ? ";" : "", M = [], { importKind: H } = O;
                    return M.push("import"), H && H !== "value" && M.push(" ", H), M.push(d(S, k, _), D(S, k, _), o(S, k, _), R), M;
                }
                function w(S, k, _) {
                    let O = S.getValue(), R = [];
                    b(O) && R.push(v(S, k, _));
                    let { type: M, exportKind: H, declaration: P } = O;
                    return R.push("export"), (O.default || M === "ExportDefaultDeclaration") && R.push(" default"), m(O, g.Dangling) && (R.push(" ", C(S, k, !0)), f(O) && R.push(l)), P ? R.push(" ", _("declaration")) : R.push(H === "type" ? " type" : "", d(S, k, _), D(S, k, _), o(S, k, _)), E(O, k) && R.push(";"), R;
                }
                function I(S, k, _) {
                    let O = S.getValue(), R = k.semi ? ";" : "", M = [], { exportKind: H, exported: P } = O;
                    return M.push("export"), H === "type" && M.push(" type"), M.push(" *"), P && M.push(" as ", _("exported")), M.push(D(S, k, _), o(S, k, _), R), M;
                }
                function E(S, k) {
                    if (!k.semi) return !1;
                    let { type: _, declaration: O } = S, R = S.default || _ === "ExportDefaultDeclaration";
                    if (!O) return !0;
                    let { type: M } = O;
                    return !!(R && M !== "ClassDeclaration" && M !== "FunctionDeclaration" && M !== "TSInterfaceDeclaration" && M !== "DeclareClass" && M !== "DeclareFunction" && M !== "TSDeclareFunction" && M !== "EnumDeclaration");
                }
                function D(S, k, _) {
                    let O = S.getValue();
                    if (!O.source) return "";
                    let R = [];
                    return y(O, k) || R.push(" from"), R.push(" ", _("source")), R;
                }
                function d(S, k, _) {
                    let O = S.getValue();
                    if (y(O, k)) return "";
                    let R = [
                        " "
                    ];
                    if (t(O.specifiers)) {
                        let M = [], H = [];
                        S.each(()=>{
                            let P = S.getValue().type;
                            if (P === "ExportNamespaceSpecifier" || P === "ExportDefaultSpecifier" || P === "ImportNamespaceSpecifier" || P === "ImportDefaultSpecifier") M.push(_());
                            else if (P === "ExportSpecifier" || P === "ImportSpecifier") H.push(_());
                            else throw new Error("Unknown specifier type ".concat(JSON.stringify(P)));
                        }, "specifiers"), R.push(u(", ", M)), H.length > 0 && (M.length > 0 && R.push(", "), H.length > 1 || M.length > 0 || O.specifiers.some((G)=>m(G)) ? R.push(i([
                            "{",
                            r([
                                k.bracketSpacing ? a : s,
                                u([
                                    ",",
                                    a
                                ], H)
                            ]),
                            c(p(k) ? "," : ""),
                            k.bracketSpacing ? a : s,
                            "}"
                        ])) : R.push([
                            "{",
                            k.bracketSpacing ? " " : "",
                            ...H,
                            k.bracketSpacing ? " " : "",
                            "}"
                        ]));
                    } else R.push("{}");
                    return R;
                }
                function y(S, k) {
                    let { type: _, importKind: O, source: R, specifiers: M } = S;
                    return _ !== "ImportDeclaration" || t(M) || O === "type" ? !1 : !/{\s*}/.test(k.originalText.slice(T(S), T(R)));
                }
                function o(S, k, _) {
                    let O = S.getNode();
                    return t(O.assertions) ? [
                        " assert {",
                        k.bracketSpacing ? " " : "",
                        u(", ", S.map(_, "assertions")),
                        k.bracketSpacing ? " " : "",
                        "}"
                    ] : "";
                }
                function x(S, k, _) {
                    let O = S.getNode(), { type: R } = O, M = [], H = R === "ImportSpecifier" ? O.importKind : O.exportKind;
                    H && H !== "value" && M.push(H, " ");
                    let P = R.startsWith("Import"), G = P ? "imported" : "local", re = P ? "local" : "exported", $ = O[G], W = O[re], ee = "", U = "";
                    return R === "ExportNamespaceSpecifier" || R === "ImportNamespaceSpecifier" ? ee = "*" : $ && (ee = _(G)), W && !F(O) && (U = _(re)), M.push(ee, ee && U ? " as " : "", U), M;
                }
                function F(S) {
                    if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier") return !1;
                    let { local: k, [S.type === "ImportSpecifier" ? "imported" : "exported"]: _ } = S;
                    if (k.type !== _.type || !A(k, _)) return !1;
                    if (h(k)) return k.value === _.value && N(k) === N(_);
                    switch(k.type){
                        case "Identifier":
                            return k.name === _.name;
                        default:
                            return !1;
                    }
                }
                n.exports = {
                    printImportDeclaration: B,
                    printExportDeclaration: w,
                    printExportAllDeclaration: I,
                    printModuleSpecifier: x
                };
            }
        }), zn = Z({
            "src/language-js/print/object.js" (e, n) {
                "use strict";
                ae();
                var { printDanglingComments: t } = Qe(), { builders: { line: s, softline: i, group: r, indent: u, ifBreak: a, hardline: c } } = Le(), { getLast: l, hasNewlineInRange: C, hasNewline: m, isNonEmptyArray: g } = Ge(), { shouldPrintComma: p, hasComment: f, getComments: h, CommentCheckFlags: N, isNextLineEmpty: T } = Xe(), { locStart: A, locEnd: b } = nt(), { printOptionalToken: v, printTypeAnnotation: B } = ot(), { shouldHugFunctionParameters: w } = wr(), { shouldHugType: I } = _r(), { printHardlineAfterHeritage: E } = Yt();
                function D(d, y, o) {
                    let x = y.semi ? ";" : "", F = d.getValue(), S;
                    F.type === "TSTypeLiteral" ? S = "members" : F.type === "TSInterfaceBody" ? S = "body" : S = "properties";
                    let k = F.type === "ObjectTypeAnnotation", _ = [
                        S
                    ];
                    k && _.push("indexers", "callProperties", "internalSlots");
                    let O = _.map((V)=>F[V][0]).sort((V, oe)=>A(V) - A(oe))[0], R = d.getParentNode(0), M = k && R && (R.type === "InterfaceDeclaration" || R.type === "DeclareInterface" || R.type === "DeclareClass") && d.getName() === "body", H = F.type === "TSInterfaceBody" || M || F.type === "ObjectPattern" && R.type !== "FunctionDeclaration" && R.type !== "FunctionExpression" && R.type !== "ArrowFunctionExpression" && R.type !== "ObjectMethod" && R.type !== "ClassMethod" && R.type !== "ClassPrivateMethod" && R.type !== "AssignmentPattern" && R.type !== "CatchClause" && F.properties.some((V)=>V.value && (V.value.type === "ObjectPattern" || V.value.type === "ArrayPattern")) || F.type !== "ObjectPattern" && O && C(y.originalText, A(F), A(O)), P = M ? ";" : F.type === "TSInterfaceBody" || F.type === "TSTypeLiteral" ? a(x, ";") : ",", G = F.type === "RecordExpression" ? "#{" : F.exact ? "{|" : "{", re = F.exact ? "|}" : "}", $ = [];
                    for (let V of _)d.each((oe)=>{
                        let K = oe.getValue();
                        $.push({
                            node: K,
                            printed: o(),
                            loc: A(K)
                        });
                    }, V);
                    _.length > 1 && $.sort((V, oe)=>V.loc - oe.loc);
                    let W = [], ee = $.map((V)=>{
                        let oe = [
                            ...W,
                            r(V.printed)
                        ];
                        return W = [
                            P,
                            s
                        ], (V.node.type === "TSPropertySignature" || V.node.type === "TSMethodSignature" || V.node.type === "TSConstructSignatureDeclaration") && f(V.node, N.PrettierIgnore) && W.shift(), T(V.node, y) && W.push(c), oe;
                    });
                    if (F.inexact) {
                        let V;
                        if (f(F, N.Dangling)) {
                            let oe = f(F, N.Line);
                            V = [
                                t(d, y, !0),
                                oe || m(y.originalText, b(l(h(F)))) ? c : s,
                                "..."
                            ];
                        } else V = [
                            "..."
                        ];
                        ee.push([
                            ...W,
                            ...V
                        ]);
                    }
                    let U = l(F[S]), ne = !(F.inexact || U && U.type === "RestElement" || U && (U.type === "TSPropertySignature" || U.type === "TSCallSignatureDeclaration" || U.type === "TSMethodSignature" || U.type === "TSConstructSignatureDeclaration") && f(U, N.PrettierIgnore)), se;
                    if (ee.length === 0) {
                        if (!f(F, N.Dangling)) return [
                            G,
                            re,
                            B(d, y, o)
                        ];
                        se = r([
                            G,
                            t(d, y),
                            i,
                            re,
                            v(d),
                            B(d, y, o)
                        ]);
                    } else se = [
                        M && g(F.properties) ? E(R) : "",
                        G,
                        u([
                            y.bracketSpacing ? s : i,
                            ...ee
                        ]),
                        a(ne && (P !== "," || p(y)) ? P : ""),
                        y.bracketSpacing ? s : i,
                        re,
                        v(d),
                        B(d, y, o)
                    ];
                    return d.match((V)=>V.type === "ObjectPattern" && !V.decorators, (V, oe, K)=>w(V) && (oe === "params" || oe === "parameters" || oe === "this" || oe === "rest") && K === 0) || d.match(I, (V, oe)=>oe === "typeAnnotation", (V, oe)=>oe === "typeAnnotation", (V, oe, K)=>w(V) && (oe === "params" || oe === "parameters" || oe === "this" || oe === "rest") && K === 0) || !H && d.match((V)=>V.type === "ObjectPattern", (V)=>V.type === "AssignmentExpression" || V.type === "VariableDeclarator") ? se : r(se, {
                        shouldBreak: H
                    });
                }
                n.exports = {
                    printObject: D
                };
            }
        }), wm = Z({
            "src/language-js/print/flow.js" (e, n) {
                "use strict";
                ae();
                var t = Ut(), { printDanglingComments: s } = Qe(), { printString: i, printNumber: r } = Ge(), { builders: { hardline: u, softline: a, group: c, indent: l } } = Le(), { getParentExportDeclaration: C, isFunctionNotation: m, isGetterOrSetter: g, rawText: p, shouldPrintComma: f } = Xe(), { locStart: h, locEnd: N } = nt(), { printClass: T } = Yt(), { printOpaqueType: A, printTypeAlias: b, printIntersectionType: v, printUnionType: B, printFunctionType: w, printTupleType: I, printIndexedAccessType: E } = _r(), { printInterface: D } = ao(), { printTypeParameter: d, printTypeParameters: y } = Pr(), { printExportDeclaration: o, printExportAllDeclaration: x } = io(), { printArrayItems: F } = zt(), { printObject: S } = zn(), { printPropertyKey: k } = Kt(), { printOptionalToken: _, printTypeAnnotation: O, printRestSpread: R } = ot();
                function M(P, G, re) {
                    let $ = P.getValue(), W = G.semi ? ";" : "", ee = [];
                    switch($.type){
                        case "DeclareClass":
                            return H(P, T(P, G, re));
                        case "DeclareFunction":
                            return H(P, [
                                "function ",
                                re("id"),
                                $.predicate ? " " : "",
                                re("predicate"),
                                W
                            ]);
                        case "DeclareModule":
                            return H(P, [
                                "module ",
                                re("id"),
                                " ",
                                re("body")
                            ]);
                        case "DeclareModuleExports":
                            return H(P, [
                                "module.exports",
                                ": ",
                                re("typeAnnotation"),
                                W
                            ]);
                        case "DeclareVariable":
                            return H(P, [
                                "var ",
                                re("id"),
                                W
                            ]);
                        case "DeclareOpaqueType":
                            return H(P, A(P, G, re));
                        case "DeclareInterface":
                            return H(P, D(P, G, re));
                        case "DeclareTypeAlias":
                            return H(P, b(P, G, re));
                        case "DeclareExportDeclaration":
                            return H(P, o(P, G, re));
                        case "DeclareExportAllDeclaration":
                            return H(P, x(P, G, re));
                        case "OpaqueType":
                            return A(P, G, re);
                        case "TypeAlias":
                            return b(P, G, re);
                        case "IntersectionTypeAnnotation":
                            return v(P, G, re);
                        case "UnionTypeAnnotation":
                            return B(P, G, re);
                        case "FunctionTypeAnnotation":
                            return w(P, G, re);
                        case "TupleTypeAnnotation":
                            return I(P, G, re);
                        case "GenericTypeAnnotation":
                            return [
                                re("id"),
                                y(P, G, re, "typeParameters")
                            ];
                        case "IndexedAccessType":
                        case "OptionalIndexedAccessType":
                            return E(P, G, re);
                        case "TypeAnnotation":
                            return re("typeAnnotation");
                        case "TypeParameter":
                            return d(P, G, re);
                        case "TypeofTypeAnnotation":
                            return [
                                "typeof ",
                                re("argument")
                            ];
                        case "ExistsTypeAnnotation":
                            return "*";
                        case "EmptyTypeAnnotation":
                            return "empty";
                        case "MixedTypeAnnotation":
                            return "mixed";
                        case "ArrayTypeAnnotation":
                            return [
                                re("elementType"),
                                "[]"
                            ];
                        case "BooleanLiteralTypeAnnotation":
                            return String($.value);
                        case "EnumDeclaration":
                            return [
                                "enum ",
                                re("id"),
                                " ",
                                re("body")
                            ];
                        case "EnumBooleanBody":
                        case "EnumNumberBody":
                        case "EnumStringBody":
                        case "EnumSymbolBody":
                            if ($.type === "EnumSymbolBody" || $.explicitType) {
                                let U = null;
                                switch($.type){
                                    case "EnumBooleanBody":
                                        U = "boolean";
                                        break;
                                    case "EnumNumberBody":
                                        U = "number";
                                        break;
                                    case "EnumStringBody":
                                        U = "string";
                                        break;
                                    case "EnumSymbolBody":
                                        U = "symbol";
                                        break;
                                }
                                ee.push("of ", U, " ");
                            }
                            if ($.members.length === 0 && !$.hasUnknownMembers) ee.push(c([
                                "{",
                                s(P, G),
                                a,
                                "}"
                            ]));
                            else {
                                let U = $.members.length > 0 ? [
                                    u,
                                    F(P, G, "members", re),
                                    $.hasUnknownMembers || f(G) ? "," : ""
                                ] : [];
                                ee.push(c([
                                    "{",
                                    l([
                                        ...U,
                                        ...$.hasUnknownMembers ? [
                                            u,
                                            "..."
                                        ] : []
                                    ]),
                                    s(P, G, !0),
                                    u,
                                    "}"
                                ]));
                            }
                            return ee;
                        case "EnumBooleanMember":
                        case "EnumNumberMember":
                        case "EnumStringMember":
                            return [
                                re("id"),
                                " = ",
                                typeof $.init == "object" ? re("init") : String($.init)
                            ];
                        case "EnumDefaultedMember":
                            return re("id");
                        case "FunctionTypeParam":
                            {
                                let U = $.name ? re("name") : P.getParentNode().this === $ ? "this" : "";
                                return [
                                    U,
                                    _(P),
                                    U ? ": " : "",
                                    re("typeAnnotation")
                                ];
                            }
                        case "InterfaceDeclaration":
                        case "InterfaceTypeAnnotation":
                            return D(P, G, re);
                        case "ClassImplements":
                        case "InterfaceExtends":
                            return [
                                re("id"),
                                re("typeParameters")
                            ];
                        case "NullableTypeAnnotation":
                            return [
                                "?",
                                re("typeAnnotation")
                            ];
                        case "Variance":
                            {
                                let { kind: U } = $;
                                return t.ok(U === "plus" || U === "minus"), U === "plus" ? "+" : "-";
                            }
                        case "ObjectTypeCallProperty":
                            return $.static && ee.push("static "), ee.push(re("value")), ee;
                        case "ObjectTypeIndexer":
                            return [
                                $.static ? "static " : "",
                                $.variance ? re("variance") : "",
                                "[",
                                re("id"),
                                $.id ? ": " : "",
                                re("key"),
                                "]: ",
                                re("value")
                            ];
                        case "ObjectTypeProperty":
                            {
                                let U = "";
                                return $.proto ? U = "proto " : $.static && (U = "static "), [
                                    U,
                                    g($) ? $.kind + " " : "",
                                    $.variance ? re("variance") : "",
                                    k(P, G, re),
                                    _(P),
                                    m($) ? "" : ": ",
                                    re("value")
                                ];
                            }
                        case "ObjectTypeAnnotation":
                            return S(P, G, re);
                        case "ObjectTypeInternalSlot":
                            return [
                                $.static ? "static " : "",
                                "[[",
                                re("id"),
                                "]]",
                                _(P),
                                $.method ? "" : ": ",
                                re("value")
                            ];
                        case "ObjectTypeSpreadProperty":
                            return R(P, G, re);
                        case "QualifiedTypeofIdentifier":
                        case "QualifiedTypeIdentifier":
                            return [
                                re("qualification"),
                                ".",
                                re("id")
                            ];
                        case "StringLiteralTypeAnnotation":
                            return i(p($), G);
                        case "NumberLiteralTypeAnnotation":
                            t.strictEqual(typeof $.value, "number");
                        case "BigIntLiteralTypeAnnotation":
                            return $.extra ? r($.extra.raw) : r($.raw);
                        case "TypeCastExpression":
                            return [
                                "(",
                                re("expression"),
                                O(P, G, re),
                                ")"
                            ];
                        case "TypeParameterDeclaration":
                        case "TypeParameterInstantiation":
                            {
                                let U = y(P, G, re, "params");
                                if (G.parser === "flow") {
                                    let ne = h($), se = N($), V = G.originalText.lastIndexOf("/*", ne), oe = G.originalText.indexOf("*/", se);
                                    if (V !== -1 && oe !== -1) {
                                        let K = G.originalText.slice(V + 2, oe).trim();
                                        if (K.startsWith("::") && !K.includes("/*") && !K.includes("*/")) return [
                                            "/*:: ",
                                            U,
                                            " */"
                                        ];
                                    }
                                }
                                return U;
                            }
                        case "InferredPredicate":
                            return "%checks";
                        case "DeclaredPredicate":
                            return [
                                "%checks(",
                                re("value"),
                                ")"
                            ];
                        case "AnyTypeAnnotation":
                            return "any";
                        case "BooleanTypeAnnotation":
                            return "boolean";
                        case "BigIntTypeAnnotation":
                            return "bigint";
                        case "NullLiteralTypeAnnotation":
                            return "null";
                        case "NumberTypeAnnotation":
                            return "number";
                        case "SymbolTypeAnnotation":
                            return "symbol";
                        case "StringTypeAnnotation":
                            return "string";
                        case "VoidTypeAnnotation":
                            return "void";
                        case "ThisTypeAnnotation":
                            return "this";
                        case "Node":
                        case "Printable":
                        case "SourceLocation":
                        case "Position":
                        case "Statement":
                        case "Function":
                        case "Pattern":
                        case "Expression":
                        case "Declaration":
                        case "Specifier":
                        case "NamedSpecifier":
                        case "Comment":
                        case "MemberTypeAnnotation":
                        case "Type":
                            throw new Error("unprintable type: " + JSON.stringify($.type));
                    }
                }
                function H(P, G) {
                    let re = C(P);
                    return re ? (t.strictEqual(re.type, "DeclareExportDeclaration"), G) : [
                        "declare ",
                        G
                    ];
                }
                n.exports = {
                    printFlow: M
                };
            }
        }), _m = Z({
            "src/language-js/utils/is-ts-keyword-type.js" (e, n) {
                "use strict";
                ae();
                function t(s) {
                    let { type: i } = s;
                    return i.startsWith("TS") && i.endsWith("Keyword");
                }
                n.exports = t;
            }
        }), oo = Z({
            "src/language-js/print/ternary.js" (e, n) {
                "use strict";
                ae();
                var { hasNewlineInRange: t } = Ge(), { isJsxNode: s, getComments: i, isCallExpression: r, isMemberExpression: u } = Xe(), { locStart: a, locEnd: c } = nt(), l = Pt(), { builders: { line: C, softline: m, group: g, indent: p, align: f, ifBreak: h, dedent: N, breakParent: T } } = Le();
                function A(I) {
                    let E = [
                        I
                    ];
                    for(let D = 0; D < E.length; D++){
                        let d = E[D];
                        for (let y of [
                            "test",
                            "consequent",
                            "alternate"
                        ]){
                            let o = d[y];
                            if (s(o)) return !0;
                            o.type === "ConditionalExpression" && E.push(o);
                        }
                    }
                    return !1;
                }
                function b(I, E, D) {
                    let d = I.getValue(), y = d.type === "ConditionalExpression", o = y ? "alternate" : "falseType", x = I.getParentNode(), F = y ? D("test") : [
                        D("checkType"),
                        " ",
                        "extends",
                        " ",
                        D("extendsType")
                    ];
                    return x.type === d.type && x[o] === d ? f(2, F) : F;
                }
                var v = new Map([
                    [
                        "AssignmentExpression",
                        "right"
                    ],
                    [
                        "VariableDeclarator",
                        "init"
                    ],
                    [
                        "ReturnStatement",
                        "argument"
                    ],
                    [
                        "ThrowStatement",
                        "argument"
                    ],
                    [
                        "UnaryExpression",
                        "argument"
                    ],
                    [
                        "YieldExpression",
                        "argument"
                    ]
                ]);
                function B(I) {
                    let E = I.getValue();
                    if (E.type !== "ConditionalExpression") return !1;
                    let D, d = E;
                    for(let y = 0; !D; y++){
                        let o = I.getParentNode(y);
                        if (r(o) && o.callee === d || u(o) && o.object === d || o.type === "TSNonNullExpression" && o.expression === d) {
                            d = o;
                            continue;
                        }
                        o.type === "NewExpression" && o.callee === d || o.type === "TSAsExpression" && o.expression === d ? (D = I.getParentNode(y + 1), d = o) : D = o;
                    }
                    return d === E ? !1 : D[v.get(D.type)] === d;
                }
                function w(I, E, D) {
                    let d = I.getValue(), y = d.type === "ConditionalExpression", o = y ? "consequent" : "trueType", x = y ? "alternate" : "falseType", F = y ? [
                        "test"
                    ] : [
                        "checkType",
                        "extendsType"
                    ], S = d[o], k = d[x], _ = [], O = !1, R = I.getParentNode(), M = R.type === d.type && F.some((K)=>R[K] === d), H = R.type === d.type && !M, P, G, re = 0;
                    do G = P || d, P = I.getParentNode(re), re++;
                    while (P && P.type === d.type && F.every((K)=>P[K] !== G));
                    let $ = P || R, W = G;
                    if (y && (s(d[F[0]]) || s(S) || s(k) || A(W))) {
                        O = !0, H = !0;
                        let K = (q)=>[
                                h("("),
                                p([
                                    m,
                                    q
                                ]),
                                m,
                                h(")")
                            ], Ee = (q)=>q.type === "NullLiteral" || q.type === "Literal" && q.value === null || q.type === "Identifier" && q.name === "undefined";
                        _.push(" ? ", Ee(S) ? D(o) : K(D(o)), " : ", k.type === d.type || Ee(k) ? D(x) : K(D(x)));
                    } else {
                        let K = [
                            C,
                            "? ",
                            S.type === d.type ? h("", "(") : "",
                            f(2, D(o)),
                            S.type === d.type ? h("", ")") : "",
                            C,
                            ": ",
                            k.type === d.type ? D(x) : f(2, D(x))
                        ];
                        _.push(R.type !== d.type || R[x] === d || M ? K : E.useTabs ? N(p(K)) : f(Math.max(0, E.tabWidth - 2), K));
                    }
                    let U = [
                        ...F.map((K)=>i(d[K])),
                        i(S),
                        i(k)
                    ].flat().some((K)=>l(K) && t(E.originalText, a(K), c(K))), ne = (K)=>R === $ ? g(K, {
                            shouldBreak: U
                        }) : U ? [
                            K,
                            T
                        ] : K, se = !O && (u(R) || R.type === "NGPipeExpression" && R.left === d) && !R.computed, V = B(I), oe = ne([
                        b(I, E, D),
                        H ? _ : p(_),
                        y && se && !V ? m : ""
                    ]);
                    return M || V ? g([
                        p([
                            m,
                            oe
                        ]),
                        m
                    ]) : oe;
                }
                n.exports = {
                    printTernary: w
                };
            }
        }), co = Z({
            "src/language-js/print/statement.js" (e, n) {
                "use strict";
                ae();
                var { builders: { hardline: t } } = Le(), s = kt(), { getLeftSidePathName: i, hasNakedLeftSide: r, isJsxNode: u, isTheOnlyJsxElementInMarkdown: a, hasComment: c, CommentCheckFlags: l, isNextLineEmpty: C } = Xe(), { shouldPrintParamsWithoutParens: m } = Ir();
                function g(v, B, w, I) {
                    let E = v.getValue(), D = [], d = E.type === "ClassBody", y = p(E[I]);
                    return v.each((o, x, F)=>{
                        let S = o.getValue();
                        if (S.type === "EmptyStatement") return;
                        let k = w();
                        !B.semi && !d && !a(B, o) && f(o, B) ? c(S, l.Leading) ? D.push(w([], {
                            needsSemi: !0
                        })) : D.push(";", k) : D.push(k), !B.semi && d && A(S) && b(S, F[x + 1]) && D.push(";"), S !== y && (D.push(t), C(S, B) && D.push(t));
                    }, I), D;
                }
                function p(v) {
                    for(let B = v.length - 1; B >= 0; B--){
                        let w = v[B];
                        if (w.type !== "EmptyStatement") return w;
                    }
                }
                function f(v, B) {
                    return v.getNode().type !== "ExpressionStatement" ? !1 : v.call((I)=>h(I, B), "expression");
                }
                function h(v, B) {
                    let w = v.getValue();
                    switch(w.type){
                        case "ParenthesizedExpression":
                        case "TypeCastExpression":
                        case "ArrayExpression":
                        case "ArrayPattern":
                        case "TemplateLiteral":
                        case "TemplateElement":
                        case "RegExpLiteral":
                            return !0;
                        case "ArrowFunctionExpression":
                            if (!m(v, B)) return !0;
                            break;
                        case "UnaryExpression":
                            {
                                let { prefix: I, operator: E } = w;
                                if (I && (E === "+" || E === "-")) return !0;
                                break;
                            }
                        case "BindExpression":
                            if (!w.object) return !0;
                            break;
                        case "Literal":
                            if (w.regex) return !0;
                            break;
                        default:
                            if (u(w)) return !0;
                    }
                    return s(v, B) ? !0 : r(w) ? v.call((I)=>h(I, B), ...i(v, w)) : !1;
                }
                function N(v, B, w) {
                    return g(v, B, w, "body");
                }
                function T(v, B, w) {
                    return g(v, B, w, "consequent");
                }
                var A = (v)=>{
                    let { type: B } = v;
                    return B === "ClassProperty" || B === "PropertyDefinition" || B === "ClassPrivateProperty" || B === "ClassAccessorProperty";
                };
                function b(v, B) {
                    let w = v.key && v.key.name;
                    if ((w === "static" || w === "get" || w === "set") && !v.value && !v.typeAnnotation) return !0;
                    if (!B || B.static || B.accessibility) return !1;
                    if (!B.computed) {
                        let I = B.key && B.key.name;
                        if (I === "in" || I === "instanceof") return !0;
                    }
                    if (A(B) && B.variance && !B.static && !B.declare) return !0;
                    switch(B.type){
                        case "ClassProperty":
                        case "PropertyDefinition":
                        case "TSAbstractPropertyDefinition":
                            return B.computed;
                        case "MethodDefinition":
                        case "TSAbstractMethodDefinition":
                        case "ClassMethod":
                        case "ClassPrivateMethod":
                            {
                                if ((B.value ? B.value.async : B.async) || B.kind === "get" || B.kind === "set") return !1;
                                let E = B.value ? B.value.generator : B.generator;
                                return !!(B.computed || E);
                            }
                        case "TSIndexSignature":
                            return !0;
                    }
                    return !1;
                }
                n.exports = {
                    printBody: N,
                    printSwitchCaseConsequent: T
                };
            }
        }), lo = Z({
            "src/language-js/print/block.js" (e, n) {
                "use strict";
                ae();
                var { printDanglingComments: t } = Qe(), { isNonEmptyArray: s } = Ge(), { builders: { hardline: i, indent: r } } = Le(), { hasComment: u, CommentCheckFlags: a, isNextLineEmpty: c } = Xe(), { printHardlineAfterHeritage: l } = Yt(), { printBody: C } = co();
                function m(p, f, h) {
                    let N = p.getValue(), T = [];
                    if (N.type === "StaticBlock" && T.push("static "), N.type === "ClassBody" && s(N.body)) {
                        let b = p.getParentNode();
                        T.push(l(b));
                    }
                    T.push("{");
                    let A = g(p, f, h);
                    if (A) T.push(r([
                        i,
                        A
                    ]), i);
                    else {
                        let b = p.getParentNode(), v = p.getParentNode(1);
                        b.type === "ArrowFunctionExpression" || b.type === "FunctionExpression" || b.type === "FunctionDeclaration" || b.type === "ObjectMethod" || b.type === "ClassMethod" || b.type === "ClassPrivateMethod" || b.type === "ForStatement" || b.type === "WhileStatement" || b.type === "DoWhileStatement" || b.type === "DoExpression" || b.type === "CatchClause" && !v.finalizer || b.type === "TSModuleDeclaration" || b.type === "TSDeclareFunction" || N.type === "StaticBlock" || N.type === "ClassBody" || T.push(i);
                    }
                    return T.push("}"), T;
                }
                function g(p, f, h) {
                    let N = p.getValue(), T = s(N.directives), A = N.body.some((B)=>B.type !== "EmptyStatement"), b = u(N, a.Dangling);
                    if (!T && !A && !b) return "";
                    let v = [];
                    if (T && p.each((B, w, I)=>{
                        v.push(h()), (w < I.length - 1 || A || b) && (v.push(i), c(B.getValue(), f) && v.push(i));
                    }, "directives"), A && v.push(C(p, f, h)), b && v.push(t(p, f, !0)), N.type === "Program") {
                        let B = p.getParentNode();
                        (!B || B.type !== "ModuleExpression") && v.push(i);
                    }
                    return v;
                }
                n.exports = {
                    printBlock: m,
                    printBlockBody: g
                };
            }
        }), Pm = Z({
            "src/language-js/print/typescript.js" (e, n) {
                "use strict";
                ae();
                var { printDanglingComments: t } = Qe(), { hasNewlineInRange: s } = Ge(), { builders: { join: i, line: r, hardline: u, softline: a, group: c, indent: l, conditionalGroup: C, ifBreak: m } } = Le(), { isLiteral: g, getTypeScriptMappedTypeModifier: p, shouldPrintComma: f, isCallExpression: h, isMemberExpression: N } = Xe(), T = _m(), { locStart: A, locEnd: b } = nt(), { printOptionalToken: v, printTypeScriptModifiers: B } = ot(), { printTernary: w } = oo(), { printFunctionParameters: I, shouldGroupFunctionParameters: E } = wr(), { printTemplateLiteral: D } = It(), { printArrayItems: d } = zt(), { printObject: y } = zn(), { printClassProperty: o, printClassMethod: x } = Yt(), { printTypeParameter: F, printTypeParameters: S } = Pr(), { printPropertyKey: k } = Kt(), { printFunction: _, printMethodInternal: O } = Ir(), { printInterface: R } = ao(), { printBlock: M } = lo(), { printTypeAlias: H, printIntersectionType: P, printUnionType: G, printFunctionType: re, printTupleType: $, printIndexedAccessType: W } = _r();
                function ee(U, ne, se) {
                    let V = U.getValue();
                    if (!V.type.startsWith("TS")) return;
                    if (T(V)) return V.type.slice(2, -7).toLowerCase();
                    let oe = ne.semi ? ";" : "", K = [];
                    switch(V.type){
                        case "TSThisType":
                            return "this";
                        case "TSTypeAssertion":
                            {
                                let Ee = !(V.expression.type === "ArrayExpression" || V.expression.type === "ObjectExpression"), q = c([
                                    "<",
                                    l([
                                        a,
                                        se("typeAnnotation")
                                    ]),
                                    a,
                                    ">"
                                ]), le = [
                                    m("("),
                                    l([
                                        a,
                                        se("expression")
                                    ]),
                                    a,
                                    m(")")
                                ];
                                return Ee ? C([
                                    [
                                        q,
                                        se("expression")
                                    ],
                                    [
                                        q,
                                        c(le, {
                                            shouldBreak: !0
                                        })
                                    ],
                                    [
                                        q,
                                        se("expression")
                                    ]
                                ]) : c([
                                    q,
                                    se("expression")
                                ]);
                            }
                        case "TSDeclareFunction":
                            return _(U, se, ne);
                        case "TSExportAssignment":
                            return [
                                "export = ",
                                se("expression"),
                                oe
                            ];
                        case "TSModuleBlock":
                            return M(U, ne, se);
                        case "TSInterfaceBody":
                        case "TSTypeLiteral":
                            return y(U, ne, se);
                        case "TSTypeAliasDeclaration":
                            return H(U, ne, se);
                        case "TSQualifiedName":
                            return i(".", [
                                se("left"),
                                se("right")
                            ]);
                        case "TSAbstractMethodDefinition":
                        case "TSDeclareMethod":
                            return x(U, ne, se);
                        case "TSAbstractPropertyDefinition":
                            return o(U, ne, se);
                        case "TSInterfaceHeritage":
                        case "TSExpressionWithTypeArguments":
                            return K.push(se("expression")), V.typeParameters && K.push(se("typeParameters")), K;
                        case "TSTemplateLiteralType":
                            return D(U, se, ne);
                        case "TSNamedTupleMember":
                            return [
                                se("label"),
                                V.optional ? "?" : "",
                                ": ",
                                se("elementType")
                            ];
                        case "TSRestType":
                            return [
                                "...",
                                se("typeAnnotation")
                            ];
                        case "TSOptionalType":
                            return [
                                se("typeAnnotation"),
                                "?"
                            ];
                        case "TSInterfaceDeclaration":
                            return R(U, ne, se);
                        case "TSClassImplements":
                            return [
                                se("expression"),
                                se("typeParameters")
                            ];
                        case "TSTypeParameterDeclaration":
                        case "TSTypeParameterInstantiation":
                            return S(U, ne, se, "params");
                        case "TSTypeParameter":
                            return F(U, ne, se);
                        case "TSAsExpression":
                            {
                                K.push(se("expression"), " as ", se("typeAnnotation"));
                                let Ee = U.getParentNode();
                                return h(Ee) && Ee.callee === V || N(Ee) && Ee.object === V ? c([
                                    l([
                                        a,
                                        ...K
                                    ]),
                                    a
                                ]) : K;
                            }
                        case "TSArrayType":
                            return [
                                se("elementType"),
                                "[]"
                            ];
                        case "TSPropertySignature":
                            return V.readonly && K.push("readonly "), K.push(k(U, ne, se), v(U)), V.typeAnnotation && K.push(": ", se("typeAnnotation")), V.initializer && K.push(" = ", se("initializer")), K;
                        case "TSParameterProperty":
                            return V.accessibility && K.push(V.accessibility + " "), V.export && K.push("export "), V.static && K.push("static "), V.override && K.push("override "), V.readonly && K.push("readonly "), K.push(se("parameter")), K;
                        case "TSTypeQuery":
                            return [
                                "typeof ",
                                se("exprName")
                            ];
                        case "TSIndexSignature":
                            {
                                let Ee = U.getParentNode(), q = V.parameters.length > 1 ? m(f(ne) ? "," : "") : "", le = c([
                                    l([
                                        a,
                                        i([
                                            ", ",
                                            a
                                        ], U.map(se, "parameters"))
                                    ]),
                                    q,
                                    a
                                ]);
                                return [
                                    V.export ? "export " : "",
                                    V.accessibility ? [
                                        V.accessibility,
                                        " "
                                    ] : "",
                                    V.static ? "static " : "",
                                    V.readonly ? "readonly " : "",
                                    V.declare ? "declare " : "",
                                    "[",
                                    V.parameters ? le : "",
                                    V.typeAnnotation ? "]: " : "]",
                                    V.typeAnnotation ? se("typeAnnotation") : "",
                                    Ee.type === "ClassBody" ? oe : ""
                                ];
                            }
                        case "TSTypePredicate":
                            return [
                                V.asserts ? "asserts " : "",
                                se("parameterName"),
                                V.typeAnnotation ? [
                                    " is ",
                                    se("typeAnnotation")
                                ] : ""
                            ];
                        case "TSNonNullExpression":
                            return [
                                se("expression"),
                                "!"
                            ];
                        case "TSImportType":
                            return [
                                V.isTypeOf ? "typeof " : "",
                                "import(",
                                se(V.parameter ? "parameter" : "argument"),
                                ")",
                                V.qualifier ? [
                                    ".",
                                    se("qualifier")
                                ] : "",
                                S(U, ne, se, "typeParameters")
                            ];
                        case "TSLiteralType":
                            return se("literal");
                        case "TSIndexedAccessType":
                            return W(U, ne, se);
                        case "TSConstructSignatureDeclaration":
                        case "TSCallSignatureDeclaration":
                        case "TSConstructorType":
                            if (V.type === "TSConstructorType" && V.abstract && K.push("abstract "), V.type !== "TSCallSignatureDeclaration" && K.push("new "), K.push(c(I(U, se, ne, !1, !0))), V.returnType || V.typeAnnotation) {
                                let Ee = V.type === "TSConstructorType";
                                K.push(Ee ? " => " : ": ", se("returnType"), se("typeAnnotation"));
                            }
                            return K;
                        case "TSTypeOperator":
                            return [
                                V.operator,
                                " ",
                                se("typeAnnotation")
                            ];
                        case "TSMappedType":
                            {
                                let Ee = s(ne.originalText, A(V), b(V));
                                return c([
                                    "{",
                                    l([
                                        ne.bracketSpacing ? r : a,
                                        V.readonly ? [
                                            p(V.readonly, "readonly"),
                                            " "
                                        ] : "",
                                        B(U, ne, se),
                                        se("typeParameter"),
                                        V.optional ? p(V.optional, "?") : "",
                                        V.typeAnnotation ? ": " : "",
                                        se("typeAnnotation"),
                                        m(oe)
                                    ]),
                                    t(U, ne, !0),
                                    ne.bracketSpacing ? r : a,
                                    "}"
                                ], {
                                    shouldBreak: Ee
                                });
                            }
                        case "TSMethodSignature":
                            {
                                let Ee = V.kind && V.kind !== "method" ? "".concat(V.kind, " ") : "";
                                K.push(V.accessibility ? [
                                    V.accessibility,
                                    " "
                                ] : "", Ee, V.export ? "export " : "", V.static ? "static " : "", V.readonly ? "readonly " : "", V.abstract ? "abstract " : "", V.declare ? "declare " : "", V.computed ? "[" : "", se("key"), V.computed ? "]" : "", v(U));
                                let q = I(U, se, ne, !1, !0), le = V.returnType ? "returnType" : "typeAnnotation", ue = V[le], Q = ue ? se(le) : "", de = E(V, Q);
                                return K.push(de ? c(q) : q), ue && K.push(": ", c(Q)), c(K);
                            }
                        case "TSNamespaceExportDeclaration":
                            return K.push("export as namespace ", se("id")), ne.semi && K.push(";"), c(K);
                        case "TSEnumDeclaration":
                            return V.declare && K.push("declare "), V.modifiers && K.push(B(U, ne, se)), V.const && K.push("const "), K.push("enum ", se("id"), " "), V.members.length === 0 ? K.push(c([
                                "{",
                                t(U, ne),
                                a,
                                "}"
                            ])) : K.push(c([
                                "{",
                                l([
                                    u,
                                    d(U, ne, "members", se),
                                    f(ne, "es5") ? "," : ""
                                ]),
                                t(U, ne, !0),
                                u,
                                "}"
                            ])), K;
                        case "TSEnumMember":
                            return K.push(se("id")), V.initializer && K.push(" = ", se("initializer")), K;
                        case "TSImportEqualsDeclaration":
                            return V.isExport && K.push("export "), K.push("import "), V.importKind && V.importKind !== "value" && K.push(V.importKind, " "), K.push(se("id"), " = ", se("moduleReference")), ne.semi && K.push(";"), c(K);
                        case "TSExternalModuleReference":
                            return [
                                "require(",
                                se("expression"),
                                ")"
                            ];
                        case "TSModuleDeclaration":
                            {
                                let Ee = U.getParentNode(), q = g(V.id), le = Ee.type === "TSModuleDeclaration", ue = V.body && V.body.type === "TSModuleDeclaration";
                                if (le) K.push(".");
                                else {
                                    V.declare && K.push("declare "), K.push(B(U, ne, se));
                                    let Q = ne.originalText.slice(A(V), A(V.id));
                                    V.id.type === "Identifier" && V.id.name === "global" && !/namespace|module/.test(Q) || K.push(q || /(?:^|\s)module(?:\s|$)/.test(Q) ? "module " : "namespace ");
                                }
                                return K.push(se("id")), ue ? K.push(se("body")) : V.body ? K.push(" ", c(se("body"))) : K.push(oe), K;
                            }
                        case "TSConditionalType":
                            return w(U, ne, se);
                        case "TSInferType":
                            return [
                                "infer",
                                " ",
                                se("typeParameter")
                            ];
                        case "TSIntersectionType":
                            return P(U, ne, se);
                        case "TSUnionType":
                            return G(U, ne, se);
                        case "TSFunctionType":
                            return re(U, ne, se);
                        case "TSTupleType":
                            return $(U, ne, se);
                        case "TSTypeReference":
                            return [
                                se("typeName"),
                                S(U, ne, se, "typeParameters")
                            ];
                        case "TSTypeAnnotation":
                            return se("typeAnnotation");
                        case "TSEmptyBodyFunctionExpression":
                            return O(U, ne, se);
                        case "TSJSDocAllType":
                            return "*";
                        case "TSJSDocUnknownType":
                            return "?";
                        case "TSJSDocNullableType":
                            return [
                                "?",
                                se("typeAnnotation")
                            ];
                        case "TSJSDocNonNullableType":
                            return [
                                "!",
                                se("typeAnnotation")
                            ];
                        default:
                            throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(V.type), "."));
                    }
                }
                n.exports = {
                    printTypescript: ee
                };
            }
        }), Im = Z({
            "src/language-js/print/comment.js" (e, n) {
                "use strict";
                ae();
                var { hasNewline: t } = Ge(), { builders: { join: s, hardline: i }, utils: { replaceTextEndOfLine: r } } = Le(), { isLineComment: u } = Xe(), { locStart: a, locEnd: c } = nt(), l = Pt();
                function C(p, f) {
                    let h = p.getValue();
                    if (u(h)) return f.originalText.slice(a(h), c(h)).trimEnd();
                    if (l(h)) {
                        if (m(h)) {
                            let A = g(h);
                            return h.trailing && !t(f.originalText, a(h), {
                                backwards: !0
                            }) ? [
                                i,
                                A
                            ] : A;
                        }
                        let N = c(h), T = f.originalText.slice(N - 3, N) === "*-/";
                        return [
                            "/*",
                            r(h.value),
                            T ? "*-/" : "*/"
                        ];
                    }
                    throw new Error("Not a comment: " + JSON.stringify(h));
                }
                function m(p) {
                    let f = "*".concat(p.value, "*").split(`
`);
                    return f.length > 1 && f.every((h)=>h.trim()[0] === "*");
                }
                function g(p) {
                    let f = p.value.split(`
`);
                    return [
                        "/*",
                        s(i, f.map((h, N)=>N === 0 ? h.trimEnd() : " " + (N < f.length - 1 ? h.trim() : h.trimStart()))),
                        "*/"
                    ];
                }
                n.exports = {
                    printComment: C
                };
            }
        }), km = Z({
            "src/language-js/print/literal.js" (e, n) {
                "use strict";
                ae();
                var { printString: t, printNumber: s } = Ge();
                function i(a, c) {
                    let l = a.getNode();
                    switch(l.type){
                        case "RegExpLiteral":
                            return u(l);
                        case "BigIntLiteral":
                            return r(l.bigint || l.extra.raw);
                        case "NumericLiteral":
                            return s(l.extra.raw);
                        case "StringLiteral":
                            return t(l.extra.raw, c);
                        case "NullLiteral":
                            return "null";
                        case "BooleanLiteral":
                            return String(l.value);
                        case "DecimalLiteral":
                            return s(l.value) + "m";
                        case "Literal":
                            {
                                if (l.regex) return u(l.regex);
                                if (l.bigint) return r(l.raw);
                                if (l.decimal) return s(l.decimal) + "m";
                                let { value: C } = l;
                                return typeof C == "number" ? s(l.raw) : typeof C == "string" ? t(l.raw, c) : String(C);
                            }
                    }
                }
                function r(a) {
                    return a.toLowerCase();
                }
                function u(a) {
                    let { pattern: c, flags: l } = a;
                    return l = [
                        ...l
                    ].sort().join(""), "/".concat(c, "/").concat(l);
                }
                n.exports = {
                    printLiteral: i
                };
            }
        }), Lm = Z({
            "src/language-js/printer-estree.js" (e, n) {
                "use strict";
                ae();
                var { printDanglingComments: t } = Qe(), { hasNewline: s } = Ge(), { builders: { join: i, line: r, hardline: u, softline: a, group: c, indent: l }, utils: { replaceTextEndOfLine: C } } = Le(), m = ym(), g = hm(), { insertPragma: p } = eo(), f = to(), h = kt(), N = ro(), { hasFlowShorthandAnnotationComment: T, hasComment: A, CommentCheckFlags: b, isTheOnlyJsxElementInMarkdown: v, isLineComment: B, isNextLineEmpty: w, needsHardlineAfterDanglingComment: I, rawText: E, hasIgnoreComment: D, isCallExpression: d, isMemberExpression: y, markerForIfWithoutBlockAndSameLineComment: o } = Xe(), { locStart: x, locEnd: F } = nt(), S = Pt(), { printHtmlBinding: k, isVueEventBindingExpression: _ } = bm(), { printAngular: O } = Tm(), { printJsx: R, hasJsxIgnoreComment: M } = Bm(), { printFlow: H } = wm(), { printTypescript: P } = Pm(), { printOptionalToken: G, printBindExpressionCallee: re, printTypeAnnotation: $, adjustClause: W, printRestSpread: ee, printDefiniteToken: U } = ot(), { printImportDeclaration: ne, printExportDeclaration: se, printExportAllDeclaration: V, printModuleSpecifier: oe } = io(), { printTernary: K } = oo(), { printTemplateLiteral: Ee } = It(), { printArray: q } = zt(), { printObject: le } = zn(), { printClass: ue, printClassMethod: Q, printClassProperty: de } = Yt(), { printProperty: ge } = Kt(), { printFunction: ve, printArrowFunction: xe, printMethod: we, printReturnStatement: fe, printThrowStatement: pe } = Ir(), { printCallExpression: me } = so(), { printVariableDeclarator: ce, printAssignmentExpression: he } = Xt(), { printBinaryishExpression: J } = Jn(), { printSwitchCaseConsequent: ye } = co(), { printMemberExpression: X } = uo(), { printBlock: Y, printBlockBody: te } = lo(), { printComment: z } = Im(), { printLiteral: j } = km(), { printDecorators: Ce } = Un();
                function Ne(Te, _e, Fe, Ke) {
                    let Se = je(Te, _e, Fe, Ke);
                    if (!Se) return "";
                    let ze = Te.getValue(), { type: Be } = ze;
                    if (Be === "ClassMethod" || Be === "ClassPrivateMethod" || Be === "ClassProperty" || Be === "ClassAccessorProperty" || Be === "PropertyDefinition" || Be === "TSAbstractPropertyDefinition" || Be === "ClassPrivateProperty" || Be === "MethodDefinition" || Be === "TSAbstractMethodDefinition" || Be === "TSDeclareMethod") return Se;
                    let Ie = [
                        Se
                    ], Ve = Ce(Te, _e, Fe), Ae = ze.type === "ClassExpression" && Ve;
                    if (Ve && (Ie = [
                        ...Ve,
                        Se
                    ], !Ae)) return c(Ie);
                    if (!h(Te, _e)) return Ke && Ke.needsSemi && Ie.unshift(";"), Ie.length === 1 && Ie[0] === Se ? Se : Ie;
                    if (Ae && (Ie = [
                        l([
                            r,
                            ...Ie
                        ])
                    ]), Ie.unshift("("), Ke && Ke.needsSemi && Ie.unshift(";"), T(ze)) {
                        let [Pe] = ze.trailingComments;
                        Ie.push(" /*", Pe.value.trimStart(), "*/"), Pe.printed = !0;
                    }
                    return Ae && Ie.push(r), Ie.push(")"), Ie;
                }
                function je(Te, _e, Fe, Ke) {
                    let Se = Te.getValue(), ze = _e.semi ? ";" : "";
                    if (!Se) return "";
                    if (typeof Se == "string") return Se;
                    for (let Ie of [
                        j,
                        k,
                        O,
                        R,
                        H,
                        P
                    ]){
                        let Ve = Ie(Te, _e, Fe);
                        if (typeof Ve < "u") return Ve;
                    }
                    let Be = [];
                    switch(Se.type){
                        case "JsExpressionRoot":
                            return Fe("node");
                        case "JsonRoot":
                            return [
                                Fe("node"),
                                u
                            ];
                        case "File":
                            return Se.program && Se.program.interpreter && Be.push(Fe([
                                "program",
                                "interpreter"
                            ])), Be.push(Fe("program")), Be;
                        case "Program":
                            return te(Te, _e, Fe);
                        case "EmptyStatement":
                            return "";
                        case "ExpressionStatement":
                            {
                                if (Se.directive) return [
                                    Ue(Se.expression, _e),
                                    ze
                                ];
                                if (_e.parser === "__vue_event_binding") {
                                    let Ve = Te.getParentNode();
                                    if (Ve.type === "Program" && Ve.body.length === 1 && Ve.body[0] === Se) return [
                                        Fe("expression"),
                                        _(Se.expression) ? ";" : ""
                                    ];
                                }
                                let Ie = t(Te, _e, !0, (Ve)=>{
                                    let { marker: Ae } = Ve;
                                    return Ae === o;
                                });
                                return [
                                    Fe("expression"),
                                    v(_e, Te) ? "" : ze,
                                    Ie ? [
                                        " ",
                                        Ie
                                    ] : ""
                                ];
                            }
                        case "ParenthesizedExpression":
                            return !A(Se.expression) && (Se.expression.type === "ObjectExpression" || Se.expression.type === "ArrayExpression") ? [
                                "(",
                                Fe("expression"),
                                ")"
                            ] : c([
                                "(",
                                l([
                                    a,
                                    Fe("expression")
                                ]),
                                a,
                                ")"
                            ]);
                        case "AssignmentExpression":
                            return he(Te, _e, Fe);
                        case "VariableDeclarator":
                            return ce(Te, _e, Fe);
                        case "BinaryExpression":
                        case "LogicalExpression":
                            return J(Te, _e, Fe);
                        case "AssignmentPattern":
                            return [
                                Fe("left"),
                                " = ",
                                Fe("right")
                            ];
                        case "OptionalMemberExpression":
                        case "MemberExpression":
                            return X(Te, _e, Fe);
                        case "MetaProperty":
                            return [
                                Fe("meta"),
                                ".",
                                Fe("property")
                            ];
                        case "BindExpression":
                            return Se.object && Be.push(Fe("object")), Be.push(c(l([
                                a,
                                re(Te, _e, Fe)
                            ]))), Be;
                        case "Identifier":
                            return [
                                Se.name,
                                G(Te),
                                U(Te),
                                $(Te, _e, Fe)
                            ];
                        case "V8IntrinsicIdentifier":
                            return [
                                "%",
                                Se.name
                            ];
                        case "SpreadElement":
                        case "SpreadElementPattern":
                        case "SpreadProperty":
                        case "SpreadPropertyPattern":
                        case "RestElement":
                            return ee(Te, _e, Fe);
                        case "FunctionDeclaration":
                        case "FunctionExpression":
                            return ve(Te, Fe, _e, Ke);
                        case "ArrowFunctionExpression":
                            return xe(Te, _e, Fe, Ke);
                        case "YieldExpression":
                            return Be.push("yield"), Se.delegate && Be.push("*"), Se.argument && Be.push(" ", Fe("argument")), Be;
                        case "AwaitExpression":
                            if (Be.push("await"), Se.argument) {
                                Be.push(" ", Fe("argument"));
                                let Ie = Te.getParentNode();
                                if (d(Ie) && Ie.callee === Se || y(Ie) && Ie.object === Se) {
                                    Be = [
                                        l([
                                            a,
                                            ...Be
                                        ]),
                                        a
                                    ];
                                    let Ve = Te.findAncestor((Ae)=>Ae.type === "AwaitExpression" || Ae.type === "BlockStatement");
                                    if (!Ve || Ve.type !== "AwaitExpression") return c(Be);
                                }
                            }
                            return Be;
                        case "ExportDefaultDeclaration":
                        case "ExportNamedDeclaration":
                            return se(Te, _e, Fe);
                        case "ExportAllDeclaration":
                            return V(Te, _e, Fe);
                        case "ImportDeclaration":
                            return ne(Te, _e, Fe);
                        case "ImportSpecifier":
                        case "ExportSpecifier":
                        case "ImportNamespaceSpecifier":
                        case "ExportNamespaceSpecifier":
                        case "ImportDefaultSpecifier":
                        case "ExportDefaultSpecifier":
                            return oe(Te, _e, Fe);
                        case "ImportAttribute":
                            return [
                                Fe("key"),
                                ": ",
                                Fe("value")
                            ];
                        case "Import":
                            return "import";
                        case "BlockStatement":
                        case "StaticBlock":
                        case "ClassBody":
                            return Y(Te, _e, Fe);
                        case "ThrowStatement":
                            return pe(Te, _e, Fe);
                        case "ReturnStatement":
                            return fe(Te, _e, Fe);
                        case "NewExpression":
                        case "ImportExpression":
                        case "OptionalCallExpression":
                        case "CallExpression":
                            return me(Te, _e, Fe);
                        case "ObjectExpression":
                        case "ObjectPattern":
                        case "RecordExpression":
                            return le(Te, _e, Fe);
                        case "ObjectProperty":
                        case "Property":
                            return Se.method || Se.kind === "get" || Se.kind === "set" ? we(Te, _e, Fe) : ge(Te, _e, Fe);
                        case "ObjectMethod":
                            return we(Te, _e, Fe);
                        case "Decorator":
                            return [
                                "@",
                                Fe("expression")
                            ];
                        case "ArrayExpression":
                        case "ArrayPattern":
                        case "TupleExpression":
                            return q(Te, _e, Fe);
                        case "SequenceExpression":
                            {
                                let Ie = Te.getParentNode(0);
                                if (Ie.type === "ExpressionStatement" || Ie.type === "ForStatement") {
                                    let Ve = [];
                                    return Te.each((Ae, Oe)=>{
                                        Oe === 0 ? Ve.push(Fe()) : Ve.push(",", l([
                                            r,
                                            Fe()
                                        ]));
                                    }, "expressions"), c(Ve);
                                }
                                return c(i([
                                    ",",
                                    r
                                ], Te.map(Fe, "expressions")));
                            }
                        case "ThisExpression":
                            return "this";
                        case "Super":
                            return "super";
                        case "Directive":
                            return [
                                Fe("value"),
                                ze
                            ];
                        case "DirectiveLiteral":
                            return Ue(Se, _e);
                        case "UnaryExpression":
                            return Be.push(Se.operator), /[a-z]$/.test(Se.operator) && Be.push(" "), A(Se.argument) ? Be.push(c([
                                "(",
                                l([
                                    a,
                                    Fe("argument")
                                ]),
                                a,
                                ")"
                            ])) : Be.push(Fe("argument")), Be;
                        case "UpdateExpression":
                            return Be.push(Fe("argument"), Se.operator), Se.prefix && Be.reverse(), Be;
                        case "ConditionalExpression":
                            return K(Te, _e, Fe);
                        case "VariableDeclaration":
                            {
                                let Ie = Te.map(Fe, "declarations"), Ve = Te.getParentNode(), Ae = Ve.type === "ForStatement" || Ve.type === "ForInStatement" || Ve.type === "ForOfStatement", Oe = Se.declarations.some((ie)=>ie.init), Pe;
                                return Ie.length === 1 && !A(Se.declarations[0]) ? Pe = Ie[0] : Ie.length > 0 && (Pe = l(Ie[0])), Be = [
                                    Se.declare ? "declare " : "",
                                    Se.kind,
                                    Pe ? [
                                        " ",
                                        Pe
                                    ] : "",
                                    l(Ie.slice(1).map((ie)=>[
                                            ",",
                                            Oe && !Ae ? u : r,
                                            ie
                                        ]))
                                ], Ae && Ve.body !== Se || Be.push(ze), c(Be);
                            }
                        case "WithStatement":
                            return c([
                                "with (",
                                Fe("object"),
                                ")",
                                W(Se.body, Fe("body"))
                            ]);
                        case "IfStatement":
                            {
                                let Ie = W(Se.consequent, Fe("consequent")), Ve = c([
                                    "if (",
                                    c([
                                        l([
                                            a,
                                            Fe("test")
                                        ]),
                                        a
                                    ]),
                                    ")",
                                    Ie
                                ]);
                                if (Be.push(Ve), Se.alternate) {
                                    let Ae = A(Se.consequent, b.Trailing | b.Line) || I(Se), Oe = Se.consequent.type === "BlockStatement" && !Ae;
                                    Be.push(Oe ? " " : u), A(Se, b.Dangling) && Be.push(t(Te, _e, !0), Ae ? u : " "), Be.push("else", c(W(Se.alternate, Fe("alternate"), Se.alternate.type === "IfStatement")));
                                }
                                return Be;
                            }
                        case "ForStatement":
                            {
                                let Ie = W(Se.body, Fe("body")), Ve = t(Te, _e, !0), Ae = Ve ? [
                                    Ve,
                                    a
                                ] : "";
                                return !Se.init && !Se.test && !Se.update ? [
                                    Ae,
                                    c([
                                        "for (;;)",
                                        Ie
                                    ])
                                ] : [
                                    Ae,
                                    c([
                                        "for (",
                                        c([
                                            l([
                                                a,
                                                Fe("init"),
                                                ";",
                                                r,
                                                Fe("test"),
                                                ";",
                                                r,
                                                Fe("update")
                                            ]),
                                            a
                                        ]),
                                        ")",
                                        Ie
                                    ])
                                ];
                            }
                        case "WhileStatement":
                            return c([
                                "while (",
                                c([
                                    l([
                                        a,
                                        Fe("test")
                                    ]),
                                    a
                                ]),
                                ")",
                                W(Se.body, Fe("body"))
                            ]);
                        case "ForInStatement":
                            return c([
                                "for (",
                                Fe("left"),
                                " in ",
                                Fe("right"),
                                ")",
                                W(Se.body, Fe("body"))
                            ]);
                        case "ForOfStatement":
                            return c([
                                "for",
                                Se.await ? " await" : "",
                                " (",
                                Fe("left"),
                                " of ",
                                Fe("right"),
                                ")",
                                W(Se.body, Fe("body"))
                            ]);
                        case "DoWhileStatement":
                            {
                                let Ie = W(Se.body, Fe("body"));
                                return Be = [
                                    c([
                                        "do",
                                        Ie
                                    ])
                                ], Se.body.type === "BlockStatement" ? Be.push(" ") : Be.push(u), Be.push("while (", c([
                                    l([
                                        a,
                                        Fe("test")
                                    ]),
                                    a
                                ]), ")", ze), Be;
                            }
                        case "DoExpression":
                            return [
                                Se.async ? "async " : "",
                                "do ",
                                Fe("body")
                            ];
                        case "BreakStatement":
                            return Be.push("break"), Se.label && Be.push(" ", Fe("label")), Be.push(ze), Be;
                        case "ContinueStatement":
                            return Be.push("continue"), Se.label && Be.push(" ", Fe("label")), Be.push(ze), Be;
                        case "LabeledStatement":
                            return Se.body.type === "EmptyStatement" ? [
                                Fe("label"),
                                ":;"
                            ] : [
                                Fe("label"),
                                ": ",
                                Fe("body")
                            ];
                        case "TryStatement":
                            return [
                                "try ",
                                Fe("block"),
                                Se.handler ? [
                                    " ",
                                    Fe("handler")
                                ] : "",
                                Se.finalizer ? [
                                    " finally ",
                                    Fe("finalizer")
                                ] : ""
                            ];
                        case "CatchClause":
                            if (Se.param) {
                                let Ie = A(Se.param, (Ae)=>!S(Ae) || Ae.leading && s(_e.originalText, F(Ae)) || Ae.trailing && s(_e.originalText, x(Ae), {
                                        backwards: !0
                                    })), Ve = Fe("param");
                                return [
                                    "catch ",
                                    Ie ? [
                                        "(",
                                        l([
                                            a,
                                            Ve
                                        ]),
                                        a,
                                        ") "
                                    ] : [
                                        "(",
                                        Ve,
                                        ") "
                                    ],
                                    Fe("body")
                                ];
                            }
                            return [
                                "catch ",
                                Fe("body")
                            ];
                        case "SwitchStatement":
                            return [
                                c([
                                    "switch (",
                                    l([
                                        a,
                                        Fe("discriminant")
                                    ]),
                                    a,
                                    ")"
                                ]),
                                " {",
                                Se.cases.length > 0 ? l([
                                    u,
                                    i(u, Te.map((Ie, Ve, Ae)=>{
                                        let Oe = Ie.getValue();
                                        return [
                                            Fe(),
                                            Ve !== Ae.length - 1 && w(Oe, _e) ? u : ""
                                        ];
                                    }, "cases"))
                                ]) : "",
                                u,
                                "}"
                            ];
                        case "SwitchCase":
                            {
                                Se.test ? Be.push("case ", Fe("test"), ":") : Be.push("default:"), A(Se, b.Dangling) && Be.push(" ", t(Te, _e, !0));
                                let Ie = Se.consequent.filter((Ve)=>Ve.type !== "EmptyStatement");
                                if (Ie.length > 0) {
                                    let Ve = ye(Te, _e, Fe);
                                    Be.push(Ie.length === 1 && Ie[0].type === "BlockStatement" ? [
                                        " ",
                                        Ve
                                    ] : l([
                                        u,
                                        Ve
                                    ]));
                                }
                                return Be;
                            }
                        case "DebuggerStatement":
                            return [
                                "debugger",
                                ze
                            ];
                        case "ClassDeclaration":
                        case "ClassExpression":
                            return ue(Te, _e, Fe);
                        case "ClassMethod":
                        case "ClassPrivateMethod":
                        case "MethodDefinition":
                            return Q(Te, _e, Fe);
                        case "ClassProperty":
                        case "PropertyDefinition":
                        case "ClassPrivateProperty":
                        case "ClassAccessorProperty":
                            return de(Te, _e, Fe);
                        case "TemplateElement":
                            return C(Se.value.raw);
                        case "TemplateLiteral":
                            return Ee(Te, Fe, _e);
                        case "TaggedTemplateExpression":
                            return [
                                Fe("tag"),
                                Fe("typeParameters"),
                                Fe("quasi")
                            ];
                        case "PrivateIdentifier":
                            return [
                                "#",
                                Fe("name")
                            ];
                        case "PrivateName":
                            return [
                                "#",
                                Fe("id")
                            ];
                        case "InterpreterDirective":
                            return Be.push("#!", Se.value, u), w(Se, _e) && Be.push(u), Be;
                        case "TopicReference":
                            return "%";
                        case "ArgumentPlaceholder":
                            return "?";
                        case "ModuleExpression":
                            {
                                Be.push("module {");
                                let Ie = Fe("body");
                                return Ie && Be.push(l([
                                    u,
                                    Ie
                                ]), u), Be.push("}"), Be;
                            }
                        default:
                            throw new Error("unknown type: " + JSON.stringify(Se.type));
                    }
                }
                function Ue(Te, _e) {
                    let Fe = E(Te), Ke = Fe.slice(1, -1);
                    if (Ke.includes('"') || Ke.includes("'")) return Fe;
                    let Se = _e.singleQuote ? "'" : '"';
                    return Se + Ke + Se;
                }
                function tt(Te) {
                    return Te.type && !S(Te) && !B(Te) && Te.type !== "EmptyStatement" && Te.type !== "TemplateElement" && Te.type !== "Import" && Te.type !== "TSEmptyBodyFunctionExpression";
                }
                n.exports = {
                    preprocess: N,
                    print: Ne,
                    embed: m,
                    insertPragma: p,
                    massageAstNode: g,
                    hasPrettierIgnore (Te) {
                        return D(Te) || M(Te);
                    },
                    willPrintOwnComments: f.willPrintOwnComments,
                    canAttachComment: tt,
                    printComment: z,
                    isBlockComment: S,
                    handleComments: {
                        avoidAstMutation: !0,
                        ownLine: f.handleOwnLineComment,
                        endOfLine: f.handleEndOfLineComment,
                        remaining: f.handleRemainingComment
                    },
                    getCommentChildNodes: f.getCommentChildNodes
                };
            }
        }), Om = Z({
            "src/language-js/printer-estree-json.js" (e, n) {
                "use strict";
                ae();
                var { builders: { hardline: t, indent: s, join: i } } = Le(), r = ro();
                function u(l, C, m) {
                    let g = l.getValue();
                    switch(g.type){
                        case "JsonRoot":
                            return [
                                m("node"),
                                t
                            ];
                        case "ArrayExpression":
                            {
                                if (g.elements.length === 0) return "[]";
                                let p = l.map(()=>l.getValue() === null ? "null" : m(), "elements");
                                return [
                                    "[",
                                    s([
                                        t,
                                        i([
                                            ",",
                                            t
                                        ], p)
                                    ]),
                                    t,
                                    "]"
                                ];
                            }
                        case "ObjectExpression":
                            return g.properties.length === 0 ? "{}" : [
                                "{",
                                s([
                                    t,
                                    i([
                                        ",",
                                        t
                                    ], l.map(m, "properties"))
                                ]),
                                t,
                                "}"
                            ];
                        case "ObjectProperty":
                            return [
                                m("key"),
                                ": ",
                                m("value")
                            ];
                        case "UnaryExpression":
                            return [
                                g.operator === "+" ? "" : g.operator,
                                m("argument")
                            ];
                        case "NullLiteral":
                            return "null";
                        case "BooleanLiteral":
                            return g.value ? "true" : "false";
                        case "StringLiteral":
                        case "NumericLiteral":
                            return JSON.stringify(g.value);
                        case "Identifier":
                            {
                                let p = l.getParentNode();
                                return p && p.type === "ObjectProperty" && p.key === g ? JSON.stringify(g.name) : g.name;
                            }
                        case "TemplateLiteral":
                            return m([
                                "quasis",
                                0
                            ]);
                        case "TemplateElement":
                            return JSON.stringify(g.value.cooked);
                        default:
                            throw new Error("unknown type: " + JSON.stringify(g.type));
                    }
                }
                var a = new Set([
                    "start",
                    "end",
                    "extra",
                    "loc",
                    "comments",
                    "leadingComments",
                    "trailingComments",
                    "innerComments",
                    "errors",
                    "range",
                    "tokens"
                ]);
                function c(l, C) {
                    let { type: m } = l;
                    if (m === "ObjectProperty" && l.key.type === "Identifier") {
                        C.key = {
                            type: "StringLiteral",
                            value: l.key.name
                        };
                        return;
                    }
                    if (m === "UnaryExpression" && l.operator === "+") return C.argument;
                    if (m === "ArrayExpression") {
                        for (let [g, p] of l.elements.entries())p === null && C.elements.splice(g, 0, {
                            type: "NullLiteral"
                        });
                        return;
                    }
                    if (m === "TemplateLiteral") return {
                        type: "StringLiteral",
                        value: l.quasis[0].value.cooked
                    };
                }
                c.ignoredProperties = a, n.exports = {
                    preprocess: r,
                    print: u,
                    massageAstNode: c
                };
            }
        }), Lt = Z({
            "src/common/common-options.js" (e, n) {
                "use strict";
                ae();
                var t = "Common";
                n.exports = {
                    bracketSpacing: {
                        since: "0.0.0",
                        category: t,
                        type: "boolean",
                        default: !0,
                        description: "Print spaces between brackets.",
                        oppositeDescription: "Do not print spaces between brackets."
                    },
                    singleQuote: {
                        since: "0.0.0",
                        category: t,
                        type: "boolean",
                        default: !1,
                        description: "Use single quotes instead of double quotes."
                    },
                    proseWrap: {
                        since: "1.8.2",
                        category: t,
                        type: "choice",
                        default: [
                            {
                                since: "1.8.2",
                                value: !0
                            },
                            {
                                since: "1.9.0",
                                value: "preserve"
                            }
                        ],
                        description: "How to wrap prose.",
                        choices: [
                            {
                                since: "1.9.0",
                                value: "always",
                                description: "Wrap prose if it exceeds the print width."
                            },
                            {
                                since: "1.9.0",
                                value: "never",
                                description: "Do not wrap prose."
                            },
                            {
                                since: "1.9.0",
                                value: "preserve",
                                description: "Wrap prose as-is."
                            }
                        ]
                    },
                    bracketSameLine: {
                        since: "2.4.0",
                        category: t,
                        type: "boolean",
                        default: !1,
                        description: "Put > of opening tags on the last line instead of on a new line."
                    },
                    singleAttributePerLine: {
                        since: "2.6.0",
                        category: t,
                        type: "boolean",
                        default: !1,
                        description: "Enforce single attribute per line in HTML, Vue and JSX."
                    }
                };
            }
        }), jm = Z({
            "src/language-js/options.js" (e, n) {
                "use strict";
                ae();
                var t = Lt(), s = "JavaScript";
                n.exports = {
                    arrowParens: {
                        since: "1.9.0",
                        category: s,
                        type: "choice",
                        default: [
                            {
                                since: "1.9.0",
                                value: "avoid"
                            },
                            {
                                since: "2.0.0",
                                value: "always"
                            }
                        ],
                        description: "Include parentheses around a sole arrow function parameter.",
                        choices: [
                            {
                                value: "always",
                                description: "Always include parens. Example: `(x) => x`"
                            },
                            {
                                value: "avoid",
                                description: "Omit parens when possible. Example: `x => x`"
                            }
                        ]
                    },
                    bracketSameLine: t.bracketSameLine,
                    bracketSpacing: t.bracketSpacing,
                    jsxBracketSameLine: {
                        since: "0.17.0",
                        category: s,
                        type: "boolean",
                        description: "Put > on the last line instead of at a new line.",
                        deprecated: "2.4.0"
                    },
                    semi: {
                        since: "1.0.0",
                        category: s,
                        type: "boolean",
                        default: !0,
                        description: "Print semicolons.",
                        oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
                    },
                    singleQuote: t.singleQuote,
                    jsxSingleQuote: {
                        since: "1.15.0",
                        category: s,
                        type: "boolean",
                        default: !1,
                        description: "Use single quotes in JSX."
                    },
                    quoteProps: {
                        since: "1.17.0",
                        category: s,
                        type: "choice",
                        default: "as-needed",
                        description: "Change when properties in objects are quoted.",
                        choices: [
                            {
                                value: "as-needed",
                                description: "Only add quotes around object properties where required."
                            },
                            {
                                value: "consistent",
                                description: "If at least one property in an object requires quotes, quote all properties."
                            },
                            {
                                value: "preserve",
                                description: "Respect the input use of quotes in object properties."
                            }
                        ]
                    },
                    trailingComma: {
                        since: "0.0.0",
                        category: s,
                        type: "choice",
                        default: [
                            {
                                since: "0.0.0",
                                value: !1
                            },
                            {
                                since: "0.19.0",
                                value: "none"
                            },
                            {
                                since: "2.0.0",
                                value: "es5"
                            }
                        ],
                        description: "Print trailing commas wherever possible when multi-line.",
                        choices: [
                            {
                                value: "es5",
                                description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
                            },
                            {
                                value: "none",
                                description: "No trailing commas."
                            },
                            {
                                value: "all",
                                description: "Trailing commas wherever possible (including function arguments)."
                            }
                        ]
                    },
                    singleAttributePerLine: t.singleAttributePerLine
                };
            }
        }), qm = Z({
            "src/language-js/parse/parsers.js" () {
                ae();
            }
        }), Fn = Z({
            "node_modules/linguist-languages/data/JavaScript.json" (e, n) {
                n.exports = {
                    name: "JavaScript",
                    type: "programming",
                    tmScope: "source.js",
                    aceMode: "javascript",
                    codemirrorMode: "javascript",
                    codemirrorMimeType: "text/javascript",
                    color: "#f1e05a",
                    aliases: [
                        "js",
                        "node"
                    ],
                    extensions: [
                        ".js",
                        "._js",
                        ".bones",
                        ".cjs",
                        ".es",
                        ".es6",
                        ".frag",
                        ".gs",
                        ".jake",
                        ".jsb",
                        ".jscad",
                        ".jsfl",
                        ".jsm",
                        ".jss",
                        ".jsx",
                        ".mjs",
                        ".njs",
                        ".pac",
                        ".sjs",
                        ".ssjs",
                        ".xsjs",
                        ".xsjslib"
                    ],
                    filenames: [
                        "Jakefile"
                    ],
                    interpreters: [
                        "chakra",
                        "d8",
                        "gjs",
                        "js",
                        "node",
                        "nodejs",
                        "qjs",
                        "rhino",
                        "v8",
                        "v8-shell"
                    ],
                    languageId: 183
                };
            }
        }), Mm = Z({
            "node_modules/linguist-languages/data/TypeScript.json" (e, n) {
                n.exports = {
                    name: "TypeScript",
                    type: "programming",
                    color: "#2b7489",
                    aliases: [
                        "ts"
                    ],
                    interpreters: [
                        "deno",
                        "ts-node"
                    ],
                    extensions: [
                        ".ts"
                    ],
                    tmScope: "source.ts",
                    aceMode: "typescript",
                    codemirrorMode: "javascript",
                    codemirrorMimeType: "application/typescript",
                    languageId: 378
                };
            }
        }), Rm = Z({
            "node_modules/linguist-languages/data/TSX.json" (e, n) {
                n.exports = {
                    name: "TSX",
                    type: "programming",
                    group: "TypeScript",
                    extensions: [
                        ".tsx"
                    ],
                    tmScope: "source.tsx",
                    aceMode: "javascript",
                    codemirrorMode: "jsx",
                    codemirrorMimeType: "text/jsx",
                    languageId: 94901924
                };
            }
        }), mi = Z({
            "node_modules/linguist-languages/data/JSON.json" (e, n) {
                n.exports = {
                    name: "JSON",
                    type: "data",
                    tmScope: "source.json",
                    aceMode: "json",
                    codemirrorMode: "javascript",
                    codemirrorMimeType: "application/json",
                    extensions: [
                        ".json",
                        ".avsc",
                        ".geojson",
                        ".gltf",
                        ".har",
                        ".ice",
                        ".JSON-tmLanguage",
                        ".jsonl",
                        ".mcmeta",
                        ".tfstate",
                        ".tfstate.backup",
                        ".topojson",
                        ".webapp",
                        ".webmanifest",
                        ".yy",
                        ".yyp"
                    ],
                    filenames: [
                        ".arcconfig",
                        ".htmlhintrc",
                        ".imgbotconfig",
                        ".tern-config",
                        ".tern-project",
                        ".watchmanconfig",
                        "Pipfile.lock",
                        "composer.lock",
                        "mcmod.info"
                    ],
                    languageId: 174
                };
            }
        }), Vm = Z({
            "node_modules/linguist-languages/data/JSON with Comments.json" (e, n) {
                n.exports = {
                    name: "JSON with Comments",
                    type: "data",
                    group: "JSON",
                    tmScope: "source.js",
                    aceMode: "javascript",
                    codemirrorMode: "javascript",
                    codemirrorMimeType: "text/javascript",
                    aliases: [
                        "jsonc"
                    ],
                    extensions: [
                        ".jsonc",
                        ".sublime-build",
                        ".sublime-commands",
                        ".sublime-completions",
                        ".sublime-keymap",
                        ".sublime-macro",
                        ".sublime-menu",
                        ".sublime-mousemap",
                        ".sublime-project",
                        ".sublime-settings",
                        ".sublime-theme",
                        ".sublime-workspace",
                        ".sublime_metrics",
                        ".sublime_session"
                    ],
                    filenames: [
                        ".babelrc",
                        ".eslintrc.json",
                        ".jscsrc",
                        ".jshintrc",
                        ".jslintrc",
                        "api-extractor.json",
                        "devcontainer.json",
                        "jsconfig.json",
                        "language-configuration.json",
                        "tsconfig.json",
                        "tslint.json"
                    ],
                    languageId: 423
                };
            }
        }), Wm = Z({
            "node_modules/linguist-languages/data/JSON5.json" (e, n) {
                n.exports = {
                    name: "JSON5",
                    type: "data",
                    extensions: [
                        ".json5"
                    ],
                    tmScope: "source.js",
                    aceMode: "javascript",
                    codemirrorMode: "javascript",
                    codemirrorMimeType: "application/json",
                    languageId: 175
                };
            }
        }), $m = Z({
            "src/language-js/index.js" (e, n) {
                "use strict";
                ae();
                var t = bt(), s = Lm(), i = Om(), r = jm(), u = qm(), a = [
                    t(Fn(), (l)=>({
                            since: "0.0.0",
                            parsers: [
                                "babel",
                                "acorn",
                                "espree",
                                "meriyah",
                                "babel-flow",
                                "babel-ts",
                                "flow",
                                "typescript"
                            ],
                            vscodeLanguageIds: [
                                "javascript",
                                "mongo"
                            ],
                            interpreters: [
                                ...l.interpreters,
                                "zx"
                            ],
                            extensions: [
                                ...l.extensions.filter((C)=>C !== ".jsx"),
                                ".wxs"
                            ]
                        })),
                    t(Fn(), ()=>({
                            name: "Flow",
                            since: "0.0.0",
                            parsers: [
                                "flow",
                                "babel-flow"
                            ],
                            vscodeLanguageIds: [
                                "javascript"
                            ],
                            aliases: [],
                            filenames: [],
                            extensions: [
                                ".js.flow"
                            ]
                        })),
                    t(Fn(), ()=>({
                            name: "JSX",
                            since: "0.0.0",
                            parsers: [
                                "babel",
                                "babel-flow",
                                "babel-ts",
                                "flow",
                                "typescript",
                                "espree",
                                "meriyah"
                            ],
                            vscodeLanguageIds: [
                                "javascriptreact"
                            ],
                            aliases: void 0,
                            filenames: void 0,
                            extensions: [
                                ".jsx"
                            ],
                            group: "JavaScript",
                            interpreters: void 0,
                            tmScope: "source.js.jsx",
                            aceMode: "javascript",
                            codemirrorMode: "jsx",
                            codemirrorMimeType: "text/jsx",
                            color: void 0
                        })),
                    t(Mm(), (l)=>({
                            since: "1.4.0",
                            parsers: [
                                "typescript",
                                "babel-ts"
                            ],
                            vscodeLanguageIds: [
                                "typescript"
                            ],
                            extensions: [
                                ...l.extensions,
                                ".mts",
                                ".cts"
                            ]
                        })),
                    t(Rm(), ()=>({
                            since: "1.4.0",
                            parsers: [
                                "typescript",
                                "babel-ts"
                            ],
                            vscodeLanguageIds: [
                                "typescriptreact"
                            ]
                        })),
                    t(mi(), ()=>({
                            name: "JSON.stringify",
                            since: "1.13.0",
                            parsers: [
                                "json-stringify"
                            ],
                            vscodeLanguageIds: [
                                "json"
                            ],
                            extensions: [],
                            filenames: [
                                "package.json",
                                "package-lock.json",
                                "composer.json"
                            ]
                        })),
                    t(mi(), (l)=>({
                            since: "1.5.0",
                            parsers: [
                                "json"
                            ],
                            vscodeLanguageIds: [
                                "json"
                            ],
                            extensions: l.extensions.filter((C)=>C !== ".jsonl")
                        })),
                    t(Vm(), (l)=>({
                            since: "1.5.0",
                            parsers: [
                                "json"
                            ],
                            vscodeLanguageIds: [
                                "jsonc"
                            ],
                            filenames: [
                                ...l.filenames,
                                ".eslintrc",
                                ".swcrc"
                            ]
                        })),
                    t(Wm(), ()=>({
                            since: "1.13.0",
                            parsers: [
                                "json5"
                            ],
                            vscodeLanguageIds: [
                                "json5"
                            ]
                        }))
                ], c = {
                    estree: s,
                    "estree-json": i
                };
                n.exports = {
                    languages: a,
                    options: r,
                    printers: c,
                    parsers: u
                };
            }
        }), Hm = Z({
            "src/language-css/clean.js" (e, n) {
                "use strict";
                ae();
                var { isFrontMatterNode: t } = Ge(), s = st(), i = new Set([
                    "raw",
                    "raws",
                    "sourceIndex",
                    "source",
                    "before",
                    "after",
                    "trailingComma"
                ]);
                function r(a, c, l) {
                    if (t(a) && a.lang === "yaml" && delete c.value, a.type === "css-comment" && l.type === "css-root" && l.nodes.length > 0 && ((l.nodes[0] === a || t(l.nodes[0]) && l.nodes[1] === a) && (delete c.text, /^\*\s*@(?:format|prettier)\s*$/.test(a.text)) || l.type === "css-root" && s(l.nodes) === a)) return null;
                    if (a.type === "value-root" && delete c.text, (a.type === "media-query" || a.type === "media-query-list" || a.type === "media-feature-expression") && delete c.value, a.type === "css-rule" && delete c.params, a.type === "selector-combinator" && (c.value = c.value.replace(/\s+/g, " ")), a.type === "media-feature" && (c.value = c.value.replace(/ /g, "")), (a.type === "value-word" && (a.isColor && a.isHex || [
                        "initial",
                        "inherit",
                        "unset",
                        "revert"
                    ].includes(c.value.replace().toLowerCase())) || a.type === "media-feature" || a.type === "selector-root-invalid" || a.type === "selector-pseudo") && (c.value = c.value.toLowerCase()), a.type === "css-decl" && (c.prop = c.prop.toLowerCase()), (a.type === "css-atrule" || a.type === "css-import") && (c.name = c.name.toLowerCase()), a.type === "value-number" && (c.unit = c.unit.toLowerCase()), (a.type === "media-feature" || a.type === "media-keyword" || a.type === "media-type" || a.type === "media-unknown" || a.type === "media-url" || a.type === "media-value" || a.type === "selector-attribute" || a.type === "selector-string" || a.type === "selector-class" || a.type === "selector-combinator" || a.type === "value-string") && c.value && (c.value = u(c.value)), a.type === "selector-attribute" && (c.attribute = c.attribute.trim(), c.namespace && typeof c.namespace == "string" && (c.namespace = c.namespace.trim(), c.namespace.length === 0 && (c.namespace = !0)), c.value && (c.value = c.value.trim().replace(/^["']|["']$/g, ""), delete c.quoted)), (a.type === "media-value" || a.type === "media-type" || a.type === "value-number" || a.type === "selector-root-invalid" || a.type === "selector-class" || a.type === "selector-combinator" || a.type === "selector-tag") && c.value && (c.value = c.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (C, m, g)=>{
                        let p = Number(m);
                        return Number.isNaN(p) ? C : p + g.toLowerCase();
                    })), a.type === "selector-tag") {
                        let C = a.value.toLowerCase();
                        [
                            "from",
                            "to"
                        ].includes(C) && (c.value = C);
                    }
                    if (a.type === "css-atrule" && a.name.toLowerCase() === "supports" && delete c.value, a.type === "selector-unknown" && delete c.value, a.type === "value-comma_group") {
                        let C = a.groups.findIndex((m)=>m.type === "value-number" && m.unit === "...");
                        C !== -1 && (c.groups[C].unit = "", c.groups.splice(C + 1, 0, {
                            type: "value-word",
                            value: "...",
                            isColor: !1,
                            isHex: !1
                        }));
                    }
                }
                r.ignoredProperties = i;
                function u(a) {
                    return a.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
                }
                n.exports = r;
            }
        }), Xn = Z({
            "src/utils/front-matter/print.js" (e, n) {
                "use strict";
                ae();
                var { builders: { hardline: t, markAsRoot: s } } = Le();
                function i(r, u) {
                    if (r.lang === "yaml") {
                        let a = r.value.trim(), c = a ? u(a, {
                            parser: "yaml"
                        }, {
                            stripTrailingHardline: !0
                        }) : "";
                        return s([
                            r.startDelimiter,
                            t,
                            c,
                            c ? t : "",
                            r.endDelimiter
                        ]);
                    }
                }
                n.exports = i;
            }
        }), Gm = Z({
            "src/language-css/embed.js" (e, n) {
                "use strict";
                ae();
                var { builders: { hardline: t } } = Le(), s = Xn();
                function i(r, u, a) {
                    let c = r.getValue();
                    if (c.type === "front-matter") {
                        let l = s(c, a);
                        return l ? [
                            l,
                            t
                        ] : "";
                    }
                }
                n.exports = i;
            }
        }), po = Z({
            "src/utils/front-matter/parse.js" (e, n) {
                "use strict";
                ae();
                var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
                function s(i) {
                    let r = i.match(t);
                    if (!r) return {
                        content: i
                    };
                    let { startDelimiter: u, language: a, value: c = "", endDelimiter: l } = r.groups, C = a.trim() || "yaml";
                    if (u === "+++" && (C = "toml"), C !== "yaml" && u !== l) return {
                        content: i
                    };
                    let [m] = r;
                    return {
                        frontMatter: {
                            type: "front-matter",
                            lang: C,
                            value: c,
                            startDelimiter: u,
                            endDelimiter: l,
                            raw: m.replace(/\n$/, "")
                        },
                        content: m.replace(/[^\n]/g, " ") + i.slice(m.length)
                    };
                }
                n.exports = s;
            }
        }), Jm = Z({
            "src/language-css/pragma.js" (e, n) {
                "use strict";
                ae();
                var t = eo(), s = po();
                function i(u) {
                    return t.hasPragma(s(u).content);
                }
                function r(u) {
                    let { frontMatter: a, content: c } = s(u);
                    return (a ? a.raw + `

` : "") + t.insertPragma(c);
                }
                n.exports = {
                    hasPragma: i,
                    insertPragma: r
                };
            }
        }), Um = Z({
            "src/language-css/utils/index.js" (e, n) {
                "use strict";
                ae();
                var t = new Set([
                    "red",
                    "green",
                    "blue",
                    "alpha",
                    "a",
                    "rgb",
                    "hue",
                    "h",
                    "saturation",
                    "s",
                    "lightness",
                    "l",
                    "whiteness",
                    "w",
                    "blackness",
                    "b",
                    "tint",
                    "shade",
                    "blend",
                    "blenda",
                    "contrast",
                    "hsl",
                    "hsla",
                    "hwb",
                    "hwba"
                ]);
                function s(q, le) {
                    let ue = Array.isArray(le) ? le : [
                        le
                    ], Q = -1, de;
                    for(; de = q.getParentNode(++Q);)if (ue.includes(de.type)) return Q;
                    return -1;
                }
                function i(q, le) {
                    let ue = s(q, le);
                    return ue === -1 ? null : q.getParentNode(ue);
                }
                function r(q) {
                    let le = i(q, "css-decl");
                    return le && le.prop && le.prop.toLowerCase();
                }
                function u(q) {
                    return [
                        "initial",
                        "inherit",
                        "unset",
                        "revert"
                    ].includes(q.toLowerCase());
                }
                function a(q, le) {
                    let ue = i(q, "css-atrule");
                    return ue && ue.name && ue.name.toLowerCase().endsWith("keyframes") && [
                        "from",
                        "to"
                    ].includes(le.toLowerCase());
                }
                function c(q) {
                    return q.includes("$") || q.includes("@") || q.includes("#") || q.startsWith("%") || q.startsWith("--") || q.startsWith(":--") || q.includes("(") && q.includes(")") ? q : q.toLowerCase();
                }
                function l(q, le) {
                    let ue = i(q, "value-func");
                    return ue && ue.value && ue.value.toLowerCase() === le;
                }
                function C(q) {
                    let le = i(q, "css-rule");
                    return le && le.raws && le.raws.selector && (le.raws.selector.startsWith(":import") || le.raws.selector.startsWith(":export"));
                }
                function m(q, le) {
                    let ue = Array.isArray(le) ? le : [
                        le
                    ], Q = i(q, "css-atrule");
                    return Q && ue.includes(Q.name.toLowerCase());
                }
                function g(q) {
                    let le = q.getValue(), ue = i(q, "css-atrule");
                    return ue && ue.name === "import" && le.groups[0].value === "url" && le.groups.length === 2;
                }
                function p(q) {
                    return q.type === "value-func" && q.value.toLowerCase() === "url";
                }
                function f(q, le) {
                    let ue = q.getParentNode();
                    if (!ue) return !1;
                    let { nodes: Q } = ue;
                    return Q && Q.indexOf(le) === Q.length - 1;
                }
                function h(q) {
                    return q.selector ? typeof q.selector == "string" && /^@.+:.*$/.test(q.selector) || q.selector.value && /^@.+:.*$/.test(q.selector.value) : !1;
                }
                function N(q) {
                    return q.type === "value-word" && [
                        "from",
                        "through",
                        "end"
                    ].includes(q.value);
                }
                function T(q) {
                    return q.type === "value-word" && [
                        "and",
                        "or",
                        "not"
                    ].includes(q.value);
                }
                function A(q) {
                    return q.type === "value-word" && q.value === "in";
                }
                function b(q) {
                    return q.type === "value-operator" && q.value === "*";
                }
                function v(q) {
                    return q.type === "value-operator" && q.value === "/";
                }
                function B(q) {
                    return q.type === "value-operator" && q.value === "+";
                }
                function w(q) {
                    return q.type === "value-operator" && q.value === "-";
                }
                function I(q) {
                    return q.type === "value-operator" && q.value === "%";
                }
                function E(q) {
                    return b(q) || v(q) || B(q) || w(q) || I(q);
                }
                function D(q) {
                    return q.type === "value-word" && [
                        "==",
                        "!="
                    ].includes(q.value);
                }
                function d(q) {
                    return q.type === "value-word" && [
                        "<",
                        ">",
                        "<=",
                        ">="
                    ].includes(q.value);
                }
                function y(q) {
                    return q.type === "css-atrule" && [
                        "if",
                        "else",
                        "for",
                        "each",
                        "while"
                    ].includes(q.name);
                }
                function o(q) {
                    return q.raws && q.raws.params && /^\(\s*\)$/.test(q.raws.params);
                }
                function x(q) {
                    return q.name.startsWith("prettier-placeholder");
                }
                function F(q) {
                    return q.prop.startsWith("@prettier-placeholder");
                }
                function S(q, le) {
                    return q.value === "$$" && q.type === "value-func" && le && le.type === "value-word" && !le.raws.before;
                }
                function k(q) {
                    return q.value && q.value.type === "value-root" && q.value.group && q.value.group.type === "value-value" && q.prop.toLowerCase() === "composes";
                }
                function _(q) {
                    return q.value && q.value.group && q.value.group.group && q.value.group.group.type === "value-paren_group" && q.value.group.group.open !== null && q.value.group.group.close !== null;
                }
                function O(q) {
                    return q.raws && q.raws.before === "";
                }
                function R(q) {
                    return q.type === "value-comma_group" && q.groups && q.groups[1] && q.groups[1].type === "value-colon";
                }
                function M(q) {
                    return q.type === "value-paren_group" && q.groups && q.groups[0] && R(q.groups[0]);
                }
                function H(q) {
                    let le = q.getValue();
                    if (le.groups.length === 0) return !1;
                    let ue = q.getParentNode(1);
                    if (!M(le) && !(ue && M(ue))) return !1;
                    let Q = i(q, "css-decl");
                    return !!(Q && Q.prop && Q.prop.startsWith("$") || M(ue) || ue.type === "value-func");
                }
                function P(q) {
                    return q.type === "value-comment" && q.inline;
                }
                function G(q) {
                    return q.type === "value-word" && q.value === "#";
                }
                function re(q) {
                    return q.type === "value-word" && q.value === "{";
                }
                function $(q) {
                    return q.type === "value-word" && q.value === "}";
                }
                function W(q) {
                    return [
                        "value-word",
                        "value-atword"
                    ].includes(q.type);
                }
                function ee(q) {
                    return q && q.type === "value-colon";
                }
                function U(q, le) {
                    if (!R(le)) return !1;
                    let { groups: ue } = le, Q = ue.indexOf(q);
                    return Q === -1 ? !1 : ee(ue[Q + 1]);
                }
                function ne(q) {
                    return q.value && [
                        "not",
                        "and",
                        "or"
                    ].includes(q.value.toLowerCase());
                }
                function se(q) {
                    return q.type !== "value-func" ? !1 : t.has(q.value.toLowerCase());
                }
                function V(q) {
                    return /\/\//.test(q.split(/[\n\r]/).pop());
                }
                function oe(q) {
                    return q && q.type === "value-atword" && q.value.startsWith("prettier-placeholder-");
                }
                function K(q, le) {
                    if (!q.open || q.open.value !== "(" || !q.close || q.close.value !== ")" || q.groups.some((ue)=>ue.type !== "value-comma_group")) return !1;
                    if (le.type === "value-comma_group") {
                        let ue = le.groups.indexOf(q) - 1, Q = le.groups[ue];
                        if (Q && Q.type === "value-word" && Q.value === "with") return !0;
                    }
                    return !1;
                }
                function Ee(q) {
                    return q.type === "value-paren_group" && q.open && q.open.value === "(" && q.close && q.close.value === ")";
                }
                n.exports = {
                    getAncestorCounter: s,
                    getAncestorNode: i,
                    getPropOfDeclNode: r,
                    maybeToLowerCase: c,
                    insideValueFunctionNode: l,
                    insideICSSRuleNode: C,
                    insideAtRuleNode: m,
                    insideURLFunctionInImportAtRuleNode: g,
                    isKeyframeAtRuleKeywords: a,
                    isWideKeywords: u,
                    isLastNode: f,
                    isSCSSControlDirectiveNode: y,
                    isDetachedRulesetDeclarationNode: h,
                    isRelationalOperatorNode: d,
                    isEqualityOperatorNode: D,
                    isMultiplicationNode: b,
                    isDivisionNode: v,
                    isAdditionNode: B,
                    isSubtractionNode: w,
                    isModuloNode: I,
                    isMathOperatorNode: E,
                    isEachKeywordNode: A,
                    isForKeywordNode: N,
                    isURLFunctionNode: p,
                    isIfElseKeywordNode: T,
                    hasComposesNode: k,
                    hasParensAroundNode: _,
                    hasEmptyRawBefore: O,
                    isDetachedRulesetCallNode: o,
                    isTemplatePlaceholderNode: x,
                    isTemplatePropNode: F,
                    isPostcssSimpleVarNode: S,
                    isKeyValuePairNode: R,
                    isKeyValuePairInParenGroupNode: M,
                    isKeyInValuePairNode: U,
                    isSCSSMapItemNode: H,
                    isInlineValueCommentNode: P,
                    isHashNode: G,
                    isLeftCurlyBraceNode: re,
                    isRightCurlyBraceNode: $,
                    isWordNode: W,
                    isColonNode: ee,
                    isMediaAndSupportsKeywords: ne,
                    isColorAdjusterFuncNode: se,
                    lastLineHasInlineComment: V,
                    isAtWordPlaceholderNode: oe,
                    isConfigurationNode: K,
                    isParenGroupNode: Ee
                };
            }
        }), zm = Z({
            "src/utils/line-column-to-index.js" (e, n) {
                "use strict";
                ae(), n.exports = function(t, s) {
                    let i = 0;
                    for(let r = 0; r < t.line - 1; ++r)i = s.indexOf(`
`, i) + 1;
                    return i + t.column;
                };
            }
        }), Xm = Z({
            "src/language-css/loc.js" (e, n) {
                "use strict";
                ae();
                var { skipEverythingButNewLine: t } = Tr(), s = st(), i = zm();
                function r(p, f) {
                    return typeof p.sourceIndex == "number" ? p.sourceIndex : p.source ? i(p.source.start, f) - 1 : null;
                }
                function u(p, f) {
                    if (p.type === "css-comment" && p.inline) return t(f, p.source.startOffset);
                    let h = p.nodes && s(p.nodes);
                    return h && p.source && !p.source.end && (p = h), p.source && p.source.end ? i(p.source.end, f) : null;
                }
                function a(p, f) {
                    p.source && (p.source.startOffset = r(p, f), p.source.endOffset = u(p, f));
                    for(let h in p){
                        let N = p[h];
                        h === "source" || !N || typeof N != "object" || (N.type === "value-root" || N.type === "value-unknown" ? c(N, l(p), N.text || N.value) : a(N, f));
                    }
                }
                function c(p, f, h) {
                    p.source && (p.source.startOffset = r(p, h) + f, p.source.endOffset = u(p, h) + f);
                    for(let N in p){
                        let T = p[N];
                        N === "source" || !T || typeof T != "object" || c(T, f, h);
                    }
                }
                function l(p) {
                    let f = p.source.startOffset;
                    return typeof p.prop == "string" && (f += p.prop.length), p.type === "css-atrule" && typeof p.name == "string" && (f += 1 + p.name.length + p.raws.afterName.match(/^\s*:?\s*/)[0].length), p.type !== "css-atrule" && p.raws && typeof p.raws.between == "string" && (f += p.raws.between.length), f;
                }
                function C(p) {
                    let f = "initial", h = "initial", N, T = !1, A = [];
                    for(let b = 0; b < p.length; b++){
                        let v = p[b];
                        switch(f){
                            case "initial":
                                if (v === "'") {
                                    f = "single-quotes";
                                    continue;
                                }
                                if (v === '"') {
                                    f = "double-quotes";
                                    continue;
                                }
                                if ((v === "u" || v === "U") && p.slice(b, b + 4).toLowerCase() === "url(") {
                                    f = "url", b += 3;
                                    continue;
                                }
                                if (v === "*" && p[b - 1] === "/") {
                                    f = "comment-block";
                                    continue;
                                }
                                if (v === "/" && p[b - 1] === "/") {
                                    f = "comment-inline", N = b - 1;
                                    continue;
                                }
                                continue;
                            case "single-quotes":
                                if (v === "'" && p[b - 1] !== "\\" && (f = h, h = "initial"), v === `
` || v === "\r") return p;
                                continue;
                            case "double-quotes":
                                if (v === '"' && p[b - 1] !== "\\" && (f = h, h = "initial"), v === `
` || v === "\r") return p;
                                continue;
                            case "url":
                                if (v === ")" && (f = "initial"), v === `
` || v === "\r") return p;
                                if (v === "'") {
                                    f = "single-quotes", h = "url";
                                    continue;
                                }
                                if (v === '"') {
                                    f = "double-quotes", h = "url";
                                    continue;
                                }
                                continue;
                            case "comment-block":
                                v === "/" && p[b - 1] === "*" && (f = "initial");
                                continue;
                            case "comment-inline":
                                (v === '"' || v === "'" || v === "*") && (T = !0), (v === `
` || v === "\r") && (T && A.push([
                                    N,
                                    b
                                ]), f = "initial", T = !1);
                                continue;
                        }
                    }
                    for (let [b, v] of A)p = p.slice(0, b) + p.slice(b, v).replace(/["'*]/g, " ") + p.slice(v);
                    return p;
                }
                function m(p) {
                    return p.source.startOffset;
                }
                function g(p) {
                    return p.source.endOffset;
                }
                n.exports = {
                    locStart: m,
                    locEnd: g,
                    calculateLoc: a,
                    replaceQuotesInInlineComments: C
                };
            }
        }), Km = Z({
            "src/language-css/utils/is-less-parser.js" (e, n) {
                "use strict";
                ae();
                function t(s) {
                    return s.parser === "css" || s.parser === "less";
                }
                n.exports = t;
            }
        }), Ym = Z({
            "src/language-css/utils/is-scss.js" (e, n) {
                "use strict";
                ae();
                function t(s, i) {
                    return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(i);
                }
                n.exports = t;
            }
        }), Qm = Z({
            "src/language-css/utils/css-units.evaluate.js" (e, n) {
                n.exports = {
                    em: "em",
                    rem: "rem",
                    ex: "ex",
                    rex: "rex",
                    cap: "cap",
                    rcap: "rcap",
                    ch: "ch",
                    rch: "rch",
                    ic: "ic",
                    ric: "ric",
                    lh: "lh",
                    rlh: "rlh",
                    vw: "vw",
                    vh: "vh",
                    vi: "vi",
                    vb: "vb",
                    vmin: "vmin",
                    vmax: "vmax",
                    cm: "cm",
                    mm: "mm",
                    q: "Q",
                    in: "in",
                    pt: "pt",
                    pc: "pc",
                    px: "px",
                    deg: "deg",
                    grad: "grad",
                    rad: "rad",
                    turn: "turn",
                    s: "s",
                    ms: "ms",
                    hz: "Hz",
                    khz: "kHz",
                    dpi: "dpi",
                    dpcm: "dpcm",
                    dppx: "dppx",
                    x: "x"
                };
            }
        }), Zm = Z({
            "src/language-css/utils/print-unit.js" (e, n) {
                "use strict";
                ae();
                var t = Qm();
                function s(i) {
                    let r = i.toLowerCase();
                    return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : i;
                }
                n.exports = s;
            }
        }), ed = Z({
            "src/language-css/printer-postcss.js" (e, n) {
                "use strict";
                ae();
                var t = st(), { printNumber: s, printString: i, hasNewline: r, isFrontMatterNode: u, isNextLineEmpty: a, isNonEmptyArray: c } = Ge(), { builders: { join: l, line: C, hardline: m, softline: g, group: p, fill: f, indent: h, dedent: N, ifBreak: T, breakParent: A }, utils: { removeLines: b, getDocParts: v } } = Le(), B = Hm(), w = Gm(), { insertPragma: I } = Jm(), { getAncestorNode: E, getPropOfDeclNode: D, maybeToLowerCase: d, insideValueFunctionNode: y, insideICSSRuleNode: o, insideAtRuleNode: x, insideURLFunctionInImportAtRuleNode: F, isKeyframeAtRuleKeywords: S, isWideKeywords: k, isLastNode: _, isSCSSControlDirectiveNode: O, isDetachedRulesetDeclarationNode: R, isRelationalOperatorNode: M, isEqualityOperatorNode: H, isMultiplicationNode: P, isDivisionNode: G, isAdditionNode: re, isSubtractionNode: $, isMathOperatorNode: W, isEachKeywordNode: ee, isForKeywordNode: U, isURLFunctionNode: ne, isIfElseKeywordNode: se, hasComposesNode: V, hasParensAroundNode: oe, hasEmptyRawBefore: K, isKeyValuePairNode: Ee, isKeyInValuePairNode: q, isDetachedRulesetCallNode: le, isTemplatePlaceholderNode: ue, isTemplatePropNode: Q, isPostcssSimpleVarNode: de, isSCSSMapItemNode: ge, isInlineValueCommentNode: ve, isHashNode: xe, isLeftCurlyBraceNode: we, isRightCurlyBraceNode: fe, isWordNode: pe, isColonNode: me, isMediaAndSupportsKeywords: ce, isColorAdjusterFuncNode: he, lastLineHasInlineComment: J, isAtWordPlaceholderNode: ye, isConfigurationNode: X, isParenGroupNode: Y } = Um(), { locStart: te, locEnd: z } = Xm(), j = Km(), Ce = Ym(), Ne = Zm();
                function je(Ae) {
                    return Ae.trailingComma === "es5" || Ae.trailingComma === "all";
                }
                function Ue(Ae, Oe, Pe) {
                    let ie = Ae.getValue();
                    if (!ie) return "";
                    if (typeof ie == "string") return ie;
                    switch(ie.type){
                        case "front-matter":
                            return [
                                ie.raw,
                                m
                            ];
                        case "css-root":
                            {
                                let Me = tt(Ae, Oe, Pe), qe = ie.raws.after.trim();
                                return [
                                    Me,
                                    qe ? " ".concat(qe) : "",
                                    v(Me).length > 0 ? m : ""
                                ];
                            }
                        case "css-comment":
                            {
                                let Me = ie.inline || ie.raws.inline, qe = Oe.originalText.slice(te(ie), z(ie));
                                return Me ? qe.trimEnd() : qe;
                            }
                        case "css-rule":
                            return [
                                Pe("selector"),
                                ie.important ? " !important" : "",
                                ie.nodes ? [
                                    ie.selector && ie.selector.type === "selector-unknown" && J(ie.selector.value) ? C : " ",
                                    "{",
                                    ie.nodes.length > 0 ? h([
                                        m,
                                        tt(Ae, Oe, Pe)
                                    ]) : "",
                                    m,
                                    "}",
                                    R(ie) ? ";" : ""
                                ] : ";"
                            ];
                        case "css-decl":
                            {
                                let Me = Ae.getParentNode(), { between: qe } = ie.raws, Je = qe.trim(), rt = Je === ":", Ze = V(ie) ? b(Pe("value")) : Pe("value");
                                return !rt && J(Je) && (Ze = h([
                                    m,
                                    N(Ze)
                                ])), [
                                    ie.raws.before.replace(/[\s;]/g, ""),
                                    o(Ae) ? ie.prop : d(ie.prop),
                                    Je.startsWith("//") ? " " : "",
                                    Je,
                                    ie.extend ? "" : " ",
                                    j(Oe) && ie.extend && ie.selector ? [
                                        "extend(",
                                        Pe("selector"),
                                        ")"
                                    ] : "",
                                    Ze,
                                    ie.raws.important ? ie.raws.important.replace(/\s*!\s*important/i, " !important") : ie.important ? " !important" : "",
                                    ie.raws.scssDefault ? ie.raws.scssDefault.replace(/\s*!default/i, " !default") : ie.scssDefault ? " !default" : "",
                                    ie.raws.scssGlobal ? ie.raws.scssGlobal.replace(/\s*!global/i, " !global") : ie.scssGlobal ? " !global" : "",
                                    ie.nodes ? [
                                        " {",
                                        h([
                                            g,
                                            tt(Ae, Oe, Pe)
                                        ]),
                                        g,
                                        "}"
                                    ] : Q(ie) && !Me.raws.semicolon && Oe.originalText[z(ie) - 1] !== ";" ? "" : Oe.__isHTMLStyleAttribute && _(Ae, ie) ? T(";") : ";"
                                ];
                            }
                        case "css-atrule":
                            {
                                let Me = Ae.getParentNode(), qe = ue(ie) && !Me.raws.semicolon && Oe.originalText[z(ie) - 1] !== ";";
                                if (j(Oe)) {
                                    if (ie.mixin) return [
                                        Pe("selector"),
                                        ie.important ? " !important" : "",
                                        qe ? "" : ";"
                                    ];
                                    if (ie.function) return [
                                        ie.name,
                                        Pe("params"),
                                        qe ? "" : ";"
                                    ];
                                    if (ie.variable) return [
                                        "@",
                                        ie.name,
                                        ": ",
                                        ie.value ? Pe("value") : "",
                                        ie.raws.between.trim() ? ie.raws.between.trim() + " " : "",
                                        ie.nodes ? [
                                            "{",
                                            h([
                                                ie.nodes.length > 0 ? g : "",
                                                tt(Ae, Oe, Pe)
                                            ]),
                                            g,
                                            "}"
                                        ] : "",
                                        qe ? "" : ";"
                                    ];
                                }
                                return [
                                    "@",
                                    le(ie) || ie.name.endsWith(":") ? ie.name : d(ie.name),
                                    ie.params ? [
                                        le(ie) ? "" : ue(ie) ? ie.raws.afterName === "" ? "" : ie.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ie.raws.afterName) ? [
                                            m,
                                            m
                                        ] : /^\s*\n/.test(ie.raws.afterName) ? m : " " : " ",
                                        Pe("params")
                                    ] : "",
                                    ie.selector ? h([
                                        " ",
                                        Pe("selector")
                                    ]) : "",
                                    ie.value ? p([
                                        " ",
                                        Pe("value"),
                                        O(ie) ? oe(ie) ? " " : C : ""
                                    ]) : ie.name === "else" ? " " : "",
                                    ie.nodes ? [
                                        O(ie) ? "" : ie.selector && !ie.selector.nodes && typeof ie.selector.value == "string" && J(ie.selector.value) || !ie.selector && typeof ie.params == "string" && J(ie.params) ? C : " ",
                                        "{",
                                        h([
                                            ie.nodes.length > 0 ? g : "",
                                            tt(Ae, Oe, Pe)
                                        ]),
                                        g,
                                        "}"
                                    ] : qe ? "" : ";"
                                ];
                            }
                        case "media-query-list":
                            {
                                let Me = [];
                                return Ae.each((qe)=>{
                                    let Je = qe.getValue();
                                    Je.type === "media-query" && Je.value === "" || Me.push(Pe());
                                }, "nodes"), p(h(l(C, Me)));
                            }
                        case "media-query":
                            return [
                                l(" ", Ae.map(Pe, "nodes")),
                                _(Ae, ie) ? "" : ","
                            ];
                        case "media-type":
                            return Ie(ze(ie.value, Oe));
                        case "media-feature-expression":
                            return ie.nodes ? [
                                "(",
                                ...Ae.map(Pe, "nodes"),
                                ")"
                            ] : ie.value;
                        case "media-feature":
                            return d(ze(ie.value.replace(/ +/g, " "), Oe));
                        case "media-colon":
                            return [
                                ie.value,
                                " "
                            ];
                        case "media-value":
                            return Ie(ze(ie.value, Oe));
                        case "media-keyword":
                            return ze(ie.value, Oe);
                        case "media-url":
                            return ze(ie.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), Oe);
                        case "media-unknown":
                            return ie.value;
                        case "selector-root":
                            return p([
                                x(Ae, "custom-selector") ? [
                                    E(Ae, "css-atrule").customSelector,
                                    C
                                ] : "",
                                l([
                                    ",",
                                    x(Ae, [
                                        "extend",
                                        "custom-selector",
                                        "nest"
                                    ]) ? C : m
                                ], Ae.map(Pe, "nodes"))
                            ]);
                        case "selector-selector":
                            return p(h(Ae.map(Pe, "nodes")));
                        case "selector-comment":
                            return ie.value;
                        case "selector-string":
                            return ze(ie.value, Oe);
                        case "selector-tag":
                            {
                                let Me = Ae.getParentNode(), qe = Me && Me.nodes.indexOf(ie), Je = qe && Me.nodes[qe - 1];
                                return [
                                    ie.namespace ? [
                                        ie.namespace === !0 ? "" : ie.namespace.trim(),
                                        "|"
                                    ] : "",
                                    Je.type === "selector-nesting" ? ie.value : Ie(S(Ae, ie.value) ? ie.value.toLowerCase() : ie.value)
                                ];
                            }
                        case "selector-id":
                            return [
                                "#",
                                ie.value
                            ];
                        case "selector-class":
                            return [
                                ".",
                                Ie(ze(ie.value, Oe))
                            ];
                        case "selector-attribute":
                            return [
                                "[",
                                ie.namespace ? [
                                    ie.namespace === !0 ? "" : ie.namespace.trim(),
                                    "|"
                                ] : "",
                                ie.attribute.trim(),
                                ie.operator ? ie.operator : "",
                                ie.value ? Be(ze(ie.value.trim(), Oe), Oe) : "",
                                ie.insensitive ? " i" : "",
                                "]"
                            ];
                        case "selector-combinator":
                            {
                                if (ie.value === "+" || ie.value === ">" || ie.value === "~" || ie.value === ">>>") {
                                    let Je = Ae.getParentNode();
                                    return [
                                        Je.type === "selector-selector" && Je.nodes[0] === ie ? "" : C,
                                        ie.value,
                                        _(Ae, ie) ? "" : " "
                                    ];
                                }
                                let Me = ie.value.trim().startsWith("(") ? C : "", qe = Ie(ze(ie.value.trim(), Oe)) || C;
                                return [
                                    Me,
                                    qe
                                ];
                            }
                        case "selector-universal":
                            return [
                                ie.namespace ? [
                                    ie.namespace === !0 ? "" : ie.namespace.trim(),
                                    "|"
                                ] : "",
                                ie.value
                            ];
                        case "selector-pseudo":
                            return [
                                d(ie.value),
                                c(ie.nodes) ? [
                                    "(",
                                    l(", ", Ae.map(Pe, "nodes")),
                                    ")"
                                ] : ""
                            ];
                        case "selector-nesting":
                            return ie.value;
                        case "selector-unknown":
                            {
                                let Me = E(Ae, "css-rule");
                                if (Me && Me.isSCSSNesterProperty) return Ie(ze(d(ie.value), Oe));
                                let qe = Ae.getParentNode();
                                if (qe.raws && qe.raws.selector) {
                                    let rt = te(qe), Ze = rt + qe.raws.selector.length;
                                    return Oe.originalText.slice(rt, Ze).trim();
                                }
                                let Je = Ae.getParentNode(1);
                                if (qe.type === "value-paren_group" && Je && Je.type === "value-func" && Je.value === "selector") {
                                    let rt = z(qe.open) + 1, Ze = te(qe.close), ct = Oe.originalText.slice(rt, Ze).trim();
                                    return J(ct) ? [
                                        A,
                                        ct
                                    ] : ct;
                                }
                                return ie.value;
                            }
                        case "value-value":
                        case "value-root":
                            return Pe("group");
                        case "value-comment":
                            return Oe.originalText.slice(te(ie), z(ie));
                        case "value-comma_group":
                            {
                                let Me = Ae.getParentNode(), qe = Ae.getParentNode(1), Je = D(Ae), rt = Je && Me.type === "value-value" && (Je === "grid" || Je.startsWith("grid-template")), Ze = E(Ae, "css-atrule"), ct = Ze && O(Ze), qt = ie.groups.some((ut)=>ve(ut)), L = Ae.map(Pe, "groups"), De = [], ke = y(Ae, "url"), We = !1, $e = !1;
                                for(let ut = 0; ut < ie.groups.length; ++ut){
                                    De.push(L[ut]);
                                    let et = ie.groups[ut - 1], Re = ie.groups[ut], He = ie.groups[ut + 1], Zt = ie.groups[ut + 2];
                                    if (ke) {
                                        (He && re(He) || re(Re)) && De.push(" ");
                                        continue;
                                    }
                                    if (x(Ae, "forward") && Re.type === "value-word" && Re.value && et !== void 0 && et.type === "value-word" && et.value === "as" && He.type === "value-operator" && He.value === "*" || !He || Re.type === "value-word" && Re.value.endsWith("-") && ye(He)) continue;
                                    let ho = Re.type === "value-string" && Re.value.startsWith("#{"), Co = We && He.type === "value-string" && He.value.endsWith("}");
                                    if (ho || Co) {
                                        We = !We;
                                        continue;
                                    }
                                    if (We || me(Re) || me(He) || Re.type === "value-atword" && Re.value === "" || Re.value === "~" || Re.value && Re.value.includes("\\") && He && He.type !== "value-comment" || et && et.value && et.value.indexOf("\\") === et.value.length - 1 && Re.type === "value-operator" && Re.value === "/" || Re.value === "\\" || de(Re, He) || xe(Re) || we(Re) || fe(He) || we(He) && K(He) || fe(Re) && K(He) || Re.value === "--" && xe(He)) continue;
                                    let Qn = W(Re), Zn = W(He);
                                    if ((Qn && xe(He) || Zn && fe(Re)) && K(He) || !et && G(Re) || y(Ae, "calc") && (re(Re) || re(He) || $(Re) || $(He)) && K(He)) continue;
                                    let Eo = (re(Re) || $(Re)) && ut === 0 && (He.type === "value-number" || He.isHex) && qe && he(qe) && !K(He), eu = Zt && Zt.type === "value-func" || Zt && pe(Zt) || Re.type === "value-func" || pe(Re), tu = He.type === "value-func" || pe(He) || et && et.type === "value-func" || et && pe(et);
                                    if (!(!(P(He) || P(Re)) && !y(Ae, "calc") && !Eo && (G(He) && !eu || G(Re) && !tu || re(He) && !eu || re(Re) && !tu || $(He) || $(Re)) && (K(He) || Qn && (!et || et && W(et))))) {
                                        if (ve(Re)) {
                                            if (Me.type === "value-paren_group") {
                                                De.push(N(m));
                                                continue;
                                            }
                                            De.push(m);
                                            continue;
                                        }
                                        if (ct && (H(He) || M(He) || se(He) || ee(Re) || U(Re))) {
                                            De.push(" ");
                                            continue;
                                        }
                                        if (Ze && Ze.name.toLowerCase() === "namespace") {
                                            De.push(" ");
                                            continue;
                                        }
                                        if (rt) {
                                            Re.source && He.source && Re.source.start.line !== He.source.start.line ? (De.push(m), $e = !0) : De.push(" ");
                                            continue;
                                        }
                                        if (Zn) {
                                            De.push(" ");
                                            continue;
                                        }
                                        if (!(He && He.value === "...") && !(ye(Re) && ye(He) && z(Re) === te(He))) {
                                            if (ye(Re) && Y(He) && z(Re) === te(He.open)) {
                                                De.push(g);
                                                continue;
                                            }
                                            if (Re.value === "with" && Y(He)) {
                                                De.push(" ");
                                                continue;
                                            }
                                            De.push(C);
                                        }
                                    }
                                }
                                return qt && De.push(A), $e && De.unshift(m), ct ? p(h(De)) : F(Ae) ? p(f(De)) : p(h(f(De)));
                            }
                        case "value-paren_group":
                            {
                                let Me = Ae.getParentNode();
                                if (Me && ne(Me) && (ie.groups.length === 1 || ie.groups.length > 0 && ie.groups[0].type === "value-comma_group" && ie.groups[0].groups.length > 0 && ie.groups[0].groups[0].type === "value-word" && ie.groups[0].groups[0].value.startsWith("data:"))) return [
                                    ie.open ? Pe("open") : "",
                                    l(",", Ae.map(Pe, "groups")),
                                    ie.close ? Pe("close") : ""
                                ];
                                if (!ie.open) {
                                    let ke = Ae.map(Pe, "groups"), We = [];
                                    for(let $e = 0; $e < ke.length; $e++)$e !== 0 && We.push([
                                        ",",
                                        C
                                    ]), We.push(ke[$e]);
                                    return p(h(f(We)));
                                }
                                let qe = ge(Ae), Je = t(ie.groups), rt = Je && Je.type === "value-comment", Ze = q(ie, Me), ct = X(ie, Me), qt = ct || qe && !Ze, L = ct || Ze, De = p([
                                    ie.open ? Pe("open") : "",
                                    h([
                                        g,
                                        l([
                                            C
                                        ], Ae.map((ke, We)=>{
                                            let $e = ke.getValue(), ut = We === ie.groups.length - 1, et = [
                                                Pe(),
                                                ut ? "" : ","
                                            ];
                                            if (Ee($e) && $e.type === "value-comma_group" && $e.groups && $e.groups[0].type !== "value-paren_group" && $e.groups[2] && $e.groups[2].type === "value-paren_group") {
                                                let Re = v(et[0].contents.contents);
                                                return Re[1] = p(Re[1]), p(N(et));
                                            }
                                            if (!ut && $e.type === "value-comma_group" && c($e.groups)) {
                                                let Re = t($e.groups);
                                                Re.source && a(Oe.originalText, Re, z) && et.push(m);
                                            }
                                            return et;
                                        }, "groups"))
                                    ]),
                                    T(!rt && Ce(Oe.parser, Oe.originalText) && qe && je(Oe) ? "," : ""),
                                    g,
                                    ie.close ? Pe("close") : ""
                                ], {
                                    shouldBreak: qt
                                });
                                return L ? N(De) : De;
                            }
                        case "value-func":
                            return [
                                ie.value,
                                x(Ae, "supports") && ce(ie) ? " " : "",
                                Pe("group")
                            ];
                        case "value-paren":
                            return ie.value;
                        case "value-number":
                            return [
                                Ve(ie.value),
                                Ne(ie.unit)
                            ];
                        case "value-operator":
                            return ie.value;
                        case "value-word":
                            return ie.isColor && ie.isHex || k(ie.value) ? ie.value.toLowerCase() : ie.value;
                        case "value-colon":
                            {
                                let Me = Ae.getParentNode(), qe = Me && Me.groups.indexOf(ie), Je = qe && Me.groups[qe - 1];
                                return [
                                    ie.value,
                                    Je && typeof Je.value == "string" && t(Je.value) === "\\" || y(Ae, "url") ? "" : C
                                ];
                            }
                        case "value-comma":
                            return [
                                ie.value,
                                " "
                            ];
                        case "value-string":
                            return i(ie.raws.quote + ie.value + ie.raws.quote, Oe);
                        case "value-atword":
                            return [
                                "@",
                                ie.value
                            ];
                        case "value-unicode-range":
                            return ie.value;
                        case "value-unknown":
                            return ie.value;
                        default:
                            throw new Error("Unknown postcss type ".concat(JSON.stringify(ie.type)));
                    }
                }
                function tt(Ae, Oe, Pe) {
                    let ie = [];
                    return Ae.each((Me, qe, Je)=>{
                        let rt = Je[qe - 1];
                        if (rt && rt.type === "css-comment" && rt.text.trim() === "prettier-ignore") {
                            let Ze = Me.getValue();
                            ie.push(Oe.originalText.slice(te(Ze), z(Ze)));
                        } else ie.push(Pe());
                        qe !== Je.length - 1 && (Je[qe + 1].type === "css-comment" && !r(Oe.originalText, te(Je[qe + 1]), {
                            backwards: !0
                        }) && !u(Je[qe]) || Je[qe + 1].type === "css-atrule" && Je[qe + 1].name === "else" && Je[qe].type !== "css-comment" ? ie.push(" ") : (ie.push(Oe.__isHTMLStyleAttribute ? C : m), a(Oe.originalText, Me.getValue(), z) && !u(Je[qe]) && ie.push(m)));
                    }, "nodes"), ie;
                }
                var Te = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, _e = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, Fe = /[A-Za-z]+/g, Ke = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Se = new RegExp(Te.source + "|(".concat(Ke.source, ")?(").concat(_e.source, ")(").concat(Fe.source, ")?"), "g");
                function ze(Ae, Oe) {
                    return Ae.replace(Te, (Pe)=>i(Pe, Oe));
                }
                function Be(Ae, Oe) {
                    let Pe = Oe.singleQuote ? "'" : '"';
                    return Ae.includes('"') || Ae.includes("'") ? Ae : Pe + Ae + Pe;
                }
                function Ie(Ae) {
                    return Ae.replace(Se, (Oe, Pe, ie, Me, qe)=>!ie && Me ? Ve(Me) + d(qe || "") : Oe);
                }
                function Ve(Ae) {
                    return s(Ae).replace(/\.0(?=$|e)/, "");
                }
                n.exports = {
                    print: Ue,
                    embed: w,
                    insertPragma: I,
                    massageAstNode: B
                };
            }
        }), td = Z({
            "src/language-css/options.js" (e, n) {
                "use strict";
                ae();
                var t = Lt();
                n.exports = {
                    singleQuote: t.singleQuote
                };
            }
        }), rd = Z({
            "src/language-css/parsers.js" () {
                ae();
            }
        }), nd = Z({
            "node_modules/linguist-languages/data/CSS.json" (e, n) {
                n.exports = {
                    name: "CSS",
                    type: "markup",
                    tmScope: "source.css",
                    aceMode: "css",
                    codemirrorMode: "css",
                    codemirrorMimeType: "text/css",
                    color: "#563d7c",
                    extensions: [
                        ".css"
                    ],
                    languageId: 50
                };
            }
        }), ud = Z({
            "node_modules/linguist-languages/data/PostCSS.json" (e, n) {
                n.exports = {
                    name: "PostCSS",
                    type: "markup",
                    tmScope: "source.postcss",
                    group: "CSS",
                    extensions: [
                        ".pcss",
                        ".postcss"
                    ],
                    aceMode: "text",
                    languageId: 262764437
                };
            }
        }), sd = Z({
            "node_modules/linguist-languages/data/Less.json" (e, n) {
                n.exports = {
                    name: "Less",
                    type: "markup",
                    color: "#1d365d",
                    extensions: [
                        ".less"
                    ],
                    tmScope: "source.css.less",
                    aceMode: "less",
                    codemirrorMode: "css",
                    codemirrorMimeType: "text/css",
                    languageId: 198
                };
            }
        }), ad = Z({
            "node_modules/linguist-languages/data/SCSS.json" (e, n) {
                n.exports = {
                    name: "SCSS",
                    type: "markup",
                    color: "#c6538c",
                    tmScope: "source.css.scss",
                    aceMode: "scss",
                    codemirrorMode: "css",
                    codemirrorMimeType: "text/x-scss",
                    extensions: [
                        ".scss"
                    ],
                    languageId: 329
                };
            }
        }), id = Z({
            "src/language-css/index.js" (e, n) {
                "use strict";
                ae();
                var t = bt(), s = ed(), i = td(), r = rd(), u = [
                    t(nd(), (c)=>({
                            since: "1.4.0",
                            parsers: [
                                "css"
                            ],
                            vscodeLanguageIds: [
                                "css"
                            ],
                            extensions: [
                                ...c.extensions,
                                ".wxss"
                            ]
                        })),
                    t(ud(), ()=>({
                            since: "1.4.0",
                            parsers: [
                                "css"
                            ],
                            vscodeLanguageIds: [
                                "postcss"
                            ]
                        })),
                    t(sd(), ()=>({
                            since: "1.4.0",
                            parsers: [
                                "less"
                            ],
                            vscodeLanguageIds: [
                                "less"
                            ]
                        })),
                    t(ad(), ()=>({
                            since: "1.4.0",
                            parsers: [
                                "scss"
                            ],
                            vscodeLanguageIds: [
                                "scss"
                            ]
                        }))
                ], a = {
                    postcss: s
                };
                n.exports = {
                    languages: u,
                    options: i,
                    printers: a,
                    parsers: r
                };
            }
        }), od = Z({
            "src/language-handlebars/loc.js" (e, n) {
                "use strict";
                ae();
                function t(i) {
                    return i.loc.start.offset;
                }
                function s(i) {
                    return i.loc.end.offset;
                }
                n.exports = {
                    locStart: t,
                    locEnd: s
                };
            }
        }), cd = Z({
            "src/language-handlebars/clean.js" (e, n) {
                "use strict";
                ae();
                function t(s, i) {
                    if (s.type === "TextNode") {
                        let r = s.chars.trim();
                        if (!r) return null;
                        i.chars = r.replace(/[\t\n\f\r ]+/g, " ");
                    }
                    s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete i.value;
                }
                t.ignoredProperties = new Set([
                    "loc",
                    "selfClosing"
                ]), n.exports = t;
            }
        }), ld = Z({
            "vendors/html-void-elements.json" (e, n) {
                n.exports = {
                    htmlVoidElements: [
                        "area",
                        "base",
                        "basefont",
                        "bgsound",
                        "br",
                        "col",
                        "command",
                        "embed",
                        "frame",
                        "hr",
                        "image",
                        "img",
                        "input",
                        "isindex",
                        "keygen",
                        "link",
                        "menuitem",
                        "meta",
                        "nextid",
                        "param",
                        "source",
                        "track",
                        "wbr"
                    ]
                };
            }
        }), pd = Z({
            "src/language-handlebars/utils.js" (e, n) {
                "use strict";
                ae();
                var { htmlVoidElements: t } = ld(), s = st();
                function i(b) {
                    let v = b.getValue(), B = b.getParentNode(0);
                    return !!(m(b, [
                        "ElementNode"
                    ]) && s(B.children) === v || m(b, [
                        "Block"
                    ]) && s(B.body) === v);
                }
                function r(b) {
                    return b.toUpperCase() === b;
                }
                function u(b) {
                    return C(b, [
                        "ElementNode"
                    ]) && typeof b.tag == "string" && b.tag[0] !== ":" && (r(b.tag[0]) || b.tag.includes("."));
                }
                var a = new Set(t);
                function c(b) {
                    return u(b) && b.children.every((v)=>l(v)) || a.has(b.tag);
                }
                function l(b) {
                    return C(b, [
                        "TextNode"
                    ]) && !/\S/.test(b.chars);
                }
                function C(b, v) {
                    return b && v.includes(b.type);
                }
                function m(b, v) {
                    let B = b.getParentNode(0);
                    return C(B, v);
                }
                function g(b, v) {
                    let B = h(b);
                    return C(B, v);
                }
                function p(b, v) {
                    let B = N(b);
                    return C(B, v);
                }
                function f(b, v) {
                    let B = b.getValue(), w = b.getParentNode(0) || {}, I = w.children || w.body || w.parts || [], E = I.indexOf(B);
                    return E !== -1 && I[E + v];
                }
                function h(b) {
                    let v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                    return f(b, -v);
                }
                function N(b) {
                    return f(b, 1);
                }
                function T(b) {
                    return C(b, [
                        "MustacheCommentStatement"
                    ]) && typeof b.value == "string" && b.value.trim() === "prettier-ignore";
                }
                function A(b) {
                    let v = b.getValue(), B = h(b, 2);
                    return T(v) || T(B);
                }
                n.exports = {
                    getNextNode: N,
                    getPreviousNode: h,
                    hasPrettierIgnore: A,
                    isLastNodeOfSiblings: i,
                    isNextNodeOfSomeType: p,
                    isNodeOfSomeType: C,
                    isParentOfSomeType: m,
                    isPreviousNodeOfSomeType: g,
                    isVoid: c,
                    isWhitespaceNode: l
                };
            }
        }), fd = Z({
            "src/language-handlebars/printer-glimmer.js" (e, n) {
                "use strict";
                ae();
                var { builders: { dedent: t, fill: s, group: i, hardline: r, ifBreak: u, indent: a, join: c, line: l, softline: C }, utils: { getDocParts: m, replaceTextEndOfLine: g } } = Le(), { getPreferredQuote: p, isNonEmptyArray: f } = Ge(), { locStart: h, locEnd: N } = od(), T = cd(), { getNextNode: A, getPreviousNode: b, hasPrettierIgnore: v, isLastNodeOfSiblings: B, isNextNodeOfSomeType: w, isNodeOfSomeType: I, isParentOfSomeType: E, isPreviousNodeOfSomeType: D, isVoid: d, isWhitespaceNode: y } = pd(), o = 2;
                function x(J, ye, X) {
                    let Y = J.getValue();
                    if (!Y) return "";
                    if (v(J)) return ye.originalText.slice(h(Y), N(Y));
                    let te = ye.singleQuote ? "'" : '"';
                    switch(Y.type){
                        case "Block":
                        case "Program":
                        case "Template":
                            return i(J.map(X, "body"));
                        case "ElementNode":
                            {
                                let z = i(S(J, X)), j = ye.htmlWhitespaceSensitivity === "ignore" && w(J, [
                                    "ElementNode"
                                ]) ? C : "";
                                if (d(Y)) return [
                                    z,
                                    j
                                ];
                                let Ce = [
                                    "</",
                                    Y.tag,
                                    ">"
                                ];
                                return Y.children.length === 0 ? [
                                    z,
                                    a(Ce),
                                    j
                                ] : ye.htmlWhitespaceSensitivity === "ignore" ? [
                                    z,
                                    a(k(J, ye, X)),
                                    r,
                                    a(Ce),
                                    j
                                ] : [
                                    z,
                                    a(i(k(J, ye, X))),
                                    a(Ce),
                                    j
                                ];
                            }
                        case "BlockStatement":
                            {
                                let z = J.getParentNode(1);
                                return z && z.inverse && z.inverse.body.length === 1 && z.inverse.body[0] === Y && z.inverse.body[0].path.parts[0] === "if" ? [
                                    U(J, X),
                                    K(J, X, ye),
                                    Ee(J, X, ye)
                                ] : [
                                    W(J, X),
                                    i([
                                        K(J, X, ye),
                                        Ee(J, X, ye),
                                        ne(J, X, ye)
                                    ])
                                ];
                            }
                        case "ElementModifierStatement":
                            return i([
                                "{{",
                                pe(J, X),
                                "}}"
                            ]);
                        case "MustacheStatement":
                            return i([
                                O(Y),
                                pe(J, X),
                                R(Y)
                            ]);
                        case "SubExpression":
                            return i([
                                "(",
                                fe(J, X),
                                C,
                                ")"
                            ]);
                        case "AttrNode":
                            {
                                let z = Y.value.type === "TextNode";
                                if (z && Y.value.chars === "" && h(Y.value) === N(Y.value)) return Y.name;
                                let Ce = z ? p(Y.value.chars, te).quote : Y.value.type === "ConcatStatement" ? p(Y.value.parts.filter((je)=>je.type === "TextNode").map((je)=>je.chars).join(""), te).quote : "", Ne = X("value");
                                return [
                                    Y.name,
                                    "=",
                                    Ce,
                                    Y.name === "class" && Ce ? i(a(Ne)) : Ne,
                                    Ce
                                ];
                            }
                        case "ConcatStatement":
                            return J.map(X, "parts");
                        case "Hash":
                            return c(l, J.map(X, "pairs"));
                        case "HashPair":
                            return [
                                Y.key,
                                "=",
                                X("value")
                            ];
                        case "TextNode":
                            {
                                let z = Y.chars.replace(/{{/g, "\\{{"), j = ue(J);
                                if (j) {
                                    if (j === "class") {
                                        let Se = z.trim().split(/\s+/).join(" "), ze = !1, Be = !1;
                                        return E(J, [
                                            "ConcatStatement"
                                        ]) && (D(J, [
                                            "MustacheStatement"
                                        ]) && /^\s/.test(z) && (ze = !0), w(J, [
                                            "MustacheStatement"
                                        ]) && /\s$/.test(z) && Se !== "" && (Be = !0)), [
                                            ze ? l : "",
                                            Se,
                                            Be ? l : ""
                                        ];
                                    }
                                    return g(z);
                                }
                                let Ne = /^[\t\n\f\r ]*$/.test(z), je = !b(J), Ue = !A(J);
                                if (ye.htmlWhitespaceSensitivity !== "ignore") {
                                    let Se = /^[\t\n\f\r ]*/, ze = /[\t\n\f\r ]*$/, Be = Ue && E(J, [
                                        "Template"
                                    ]), Ie = je && E(J, [
                                        "Template"
                                    ]);
                                    if (Ne) {
                                        if (Ie || Be) return "";
                                        let ie = [
                                            l
                                        ], Me = Q(z);
                                        return Me && (ie = ve(Me)), B(J) && (ie = ie.map((qe)=>t(qe))), ie;
                                    }
                                    let [Ve] = z.match(Se), [Ae] = z.match(ze), Oe = [];
                                    if (Ve) {
                                        Oe = [
                                            l
                                        ];
                                        let ie = Q(Ve);
                                        ie && (Oe = ve(ie)), z = z.replace(Se, "");
                                    }
                                    let Pe = [];
                                    if (Ae) {
                                        if (!Be) {
                                            Pe = [
                                                l
                                            ];
                                            let ie = Q(Ae);
                                            ie && (Pe = ve(ie)), B(J) && (Pe = Pe.map((Me)=>t(Me)));
                                        }
                                        z = z.replace(ze, "");
                                    }
                                    return [
                                        ...Oe,
                                        s(q(z)),
                                        ...Pe
                                    ];
                                }
                                let tt = Q(z), Te = de(z), _e = ge(z);
                                if ((je || Ue) && Ne && E(J, [
                                    "Block",
                                    "ElementNode",
                                    "Template"
                                ])) return "";
                                Ne && tt ? (Te = Math.min(tt, o), _e = 0) : (w(J, [
                                    "BlockStatement",
                                    "ElementNode"
                                ]) && (_e = Math.max(_e, 1)), D(J, [
                                    "BlockStatement",
                                    "ElementNode"
                                ]) && (Te = Math.max(Te, 1)));
                                let Fe = "", Ke = "";
                                return _e === 0 && w(J, [
                                    "MustacheStatement"
                                ]) && (Ke = " "), Te === 0 && D(J, [
                                    "MustacheStatement"
                                ]) && (Fe = " "), je && (Te = 0, Fe = ""), Ue && (_e = 0, Ke = ""), z = z.replace(/^[\t\n\f\r ]+/g, Fe).replace(/[\t\n\f\r ]+$/, Ke), [
                                    ...ve(Te),
                                    s(q(z)),
                                    ...ve(_e)
                                ];
                            }
                        case "MustacheCommentStatement":
                            {
                                let z = h(Y), j = N(Y), Ce = ye.originalText.charAt(z + 2) === "~", Ne = ye.originalText.charAt(j - 3) === "~", je = Y.value.includes("}}") ? "--" : "";
                                return [
                                    "{{",
                                    Ce ? "~" : "",
                                    "!",
                                    je,
                                    Y.value,
                                    je,
                                    Ne ? "~" : "",
                                    "}}"
                                ];
                            }
                        case "PathExpression":
                            return Y.original;
                        case "BooleanLiteral":
                            return String(Y.value);
                        case "CommentStatement":
                            return [
                                "<!--",
                                Y.value,
                                "-->"
                            ];
                        case "StringLiteral":
                            if (we(J)) {
                                let z = ye.singleQuote ? '"' : "'";
                                return xe(Y.value, z);
                            }
                            return xe(Y.value, te);
                        case "NumberLiteral":
                            return String(Y.value);
                        case "UndefinedLiteral":
                            return "undefined";
                        case "NullLiteral":
                            return "null";
                        default:
                            throw new Error("unknown glimmer type: " + JSON.stringify(Y.type));
                    }
                }
                function F(J, ye) {
                    return h(J) - h(ye);
                }
                function S(J, ye) {
                    let X = J.getValue(), Y = [
                        "attributes",
                        "modifiers",
                        "comments"
                    ].filter((z)=>f(X[z])), te = Y.flatMap((z)=>X[z]).sort(F);
                    for (let z of Y)J.each((j)=>{
                        let Ce = te.indexOf(j.getValue());
                        te.splice(Ce, 1, [
                            l,
                            ye()
                        ]);
                    }, z);
                    return f(X.blockParams) && te.push(l, he(X)), [
                        "<",
                        X.tag,
                        a(te),
                        _(X)
                    ];
                }
                function k(J, ye, X) {
                    let te = J.getValue().children.every((z)=>y(z));
                    return ye.htmlWhitespaceSensitivity === "ignore" && te ? "" : J.map((z, j)=>{
                        let Ce = X();
                        return j === 0 && ye.htmlWhitespaceSensitivity === "ignore" ? [
                            C,
                            Ce
                        ] : Ce;
                    }, "children");
                }
                function _(J) {
                    return d(J) ? u([
                        C,
                        "/>"
                    ], [
                        " />",
                        C
                    ]) : u([
                        C,
                        ">"
                    ], ">");
                }
                function O(J) {
                    let ye = J.escaped === !1 ? "{{{" : "{{", X = J.strip && J.strip.open ? "~" : "";
                    return [
                        ye,
                        X
                    ];
                }
                function R(J) {
                    let ye = J.escaped === !1 ? "}}}" : "}}";
                    return [
                        J.strip && J.strip.close ? "~" : "",
                        ye
                    ];
                }
                function M(J) {
                    let ye = O(J), X = J.openStrip.open ? "~" : "";
                    return [
                        ye,
                        X,
                        "#"
                    ];
                }
                function H(J) {
                    let ye = R(J);
                    return [
                        J.openStrip.close ? "~" : "",
                        ye
                    ];
                }
                function P(J) {
                    let ye = O(J), X = J.closeStrip.open ? "~" : "";
                    return [
                        ye,
                        X,
                        "/"
                    ];
                }
                function G(J) {
                    let ye = R(J);
                    return [
                        J.closeStrip.close ? "~" : "",
                        ye
                    ];
                }
                function re(J) {
                    let ye = O(J), X = J.inverseStrip.open ? "~" : "";
                    return [
                        ye,
                        X
                    ];
                }
                function $(J) {
                    let ye = R(J);
                    return [
                        J.inverseStrip.close ? "~" : "",
                        ye
                    ];
                }
                function W(J, ye) {
                    let X = J.getValue(), Y = M(X), te = H(X), z = [
                        me(J, ye)
                    ], j = ce(J, ye);
                    if (j && z.push(l, j), f(X.program.blockParams)) {
                        let Ce = he(X.program);
                        z.push(l, Ce);
                    }
                    return i([
                        Y,
                        a(z),
                        C,
                        te
                    ]);
                }
                function ee(J, ye) {
                    return [
                        ye.htmlWhitespaceSensitivity === "ignore" ? r : "",
                        re(J),
                        "else",
                        $(J)
                    ];
                }
                function U(J, ye) {
                    let X = J.getParentNode(1);
                    return [
                        re(X),
                        "else if ",
                        ce(J, ye),
                        $(X)
                    ];
                }
                function ne(J, ye, X) {
                    let Y = J.getValue();
                    return X.htmlWhitespaceSensitivity === "ignore" ? [
                        se(Y) ? C : r,
                        P(Y),
                        ye("path"),
                        G(Y)
                    ] : [
                        P(Y),
                        ye("path"),
                        G(Y)
                    ];
                }
                function se(J) {
                    return I(J, [
                        "BlockStatement"
                    ]) && J.program.body.every((ye)=>y(ye));
                }
                function V(J) {
                    return oe(J) && J.inverse.body.length === 1 && I(J.inverse.body[0], [
                        "BlockStatement"
                    ]) && J.inverse.body[0].path.parts[0] === "if";
                }
                function oe(J) {
                    return I(J, [
                        "BlockStatement"
                    ]) && J.inverse;
                }
                function K(J, ye, X) {
                    let Y = J.getValue();
                    if (se(Y)) return "";
                    let te = ye("program");
                    return X.htmlWhitespaceSensitivity === "ignore" ? a([
                        r,
                        te
                    ]) : a(te);
                }
                function Ee(J, ye, X) {
                    let Y = J.getValue(), te = ye("inverse"), z = X.htmlWhitespaceSensitivity === "ignore" ? [
                        r,
                        te
                    ] : te;
                    return V(Y) ? z : oe(Y) ? [
                        ee(Y, X),
                        a(z)
                    ] : "";
                }
                function q(J) {
                    return m(c(l, le(J)));
                }
                function le(J) {
                    return J.split(/[\t\n\f\r ]+/);
                }
                function ue(J) {
                    for(let ye = 0; ye < 2; ye++){
                        let X = J.getParentNode(ye);
                        if (X && X.type === "AttrNode") return X.name.toLowerCase();
                    }
                }
                function Q(J) {
                    return J = typeof J == "string" ? J : "", J.split(`
`).length - 1;
                }
                function de(J) {
                    J = typeof J == "string" ? J : "";
                    let ye = (J.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
                    return Q(ye);
                }
                function ge(J) {
                    J = typeof J == "string" ? J : "";
                    let ye = (J.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
                    return Q(ye);
                }
                function ve() {
                    let J = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                    return Array.from({
                        length: Math.min(J, o)
                    }).fill(r);
                }
                function xe(J, ye) {
                    let { quote: X, regex: Y } = p(J, ye);
                    return [
                        X,
                        J.replace(Y, "\\".concat(X)),
                        X
                    ];
                }
                function we(J) {
                    let ye = 0, X = J.getParentNode(ye);
                    for(; X && I(X, [
                        "SubExpression"
                    ]);)ye++, X = J.getParentNode(ye);
                    return !!(X && I(J.getParentNode(ye + 1), [
                        "ConcatStatement"
                    ]) && I(J.getParentNode(ye + 2), [
                        "AttrNode"
                    ]));
                }
                function fe(J, ye) {
                    let X = me(J, ye), Y = ce(J, ye);
                    return Y ? a([
                        X,
                        l,
                        i(Y)
                    ]) : X;
                }
                function pe(J, ye) {
                    let X = me(J, ye), Y = ce(J, ye);
                    return Y ? [
                        a([
                            X,
                            l,
                            Y
                        ]),
                        C
                    ] : X;
                }
                function me(J, ye) {
                    return ye("path");
                }
                function ce(J, ye) {
                    let X = J.getValue(), Y = [];
                    if (X.params.length > 0) {
                        let te = J.map(ye, "params");
                        Y.push(...te);
                    }
                    if (X.hash && X.hash.pairs.length > 0) {
                        let te = ye("hash");
                        Y.push(te);
                    }
                    return Y.length === 0 ? "" : c(l, Y);
                }
                function he(J) {
                    return [
                        "as |",
                        J.blockParams.join(" "),
                        "|"
                    ];
                }
                n.exports = {
                    print: x,
                    massageAstNode: T
                };
            }
        }), Dd = Z({
            "src/language-handlebars/parsers.js" () {
                ae();
            }
        }), md = Z({
            "node_modules/linguist-languages/data/Handlebars.json" (e, n) {
                n.exports = {
                    name: "Handlebars",
                    type: "markup",
                    color: "#f7931e",
                    aliases: [
                        "hbs",
                        "htmlbars"
                    ],
                    extensions: [
                        ".handlebars",
                        ".hbs"
                    ],
                    tmScope: "text.html.handlebars",
                    aceMode: "handlebars",
                    languageId: 155
                };
            }
        }), dd = Z({
            "src/language-handlebars/index.js" (e, n) {
                "use strict";
                ae();
                var t = bt(), s = fd(), i = Dd(), r = [
                    t(md(), ()=>({
                            since: "2.3.0",
                            parsers: [
                                "glimmer"
                            ],
                            vscodeLanguageIds: [
                                "handlebars"
                            ]
                        }))
                ], u = {
                    glimmer: s
                };
                n.exports = {
                    languages: r,
                    printers: u,
                    parsers: i
                };
            }
        }), gd = Z({
            "src/language-graphql/pragma.js" (e, n) {
                "use strict";
                ae();
                function t(i) {
                    return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(i);
                }
                function s(i) {
                    return `# @format

` + i;
                }
                n.exports = {
                    hasPragma: t,
                    insertPragma: s
                };
            }
        }), yd = Z({
            "src/language-graphql/loc.js" (e, n) {
                "use strict";
                ae();
                function t(i) {
                    return typeof i.start == "number" ? i.start : i.loc && i.loc.start;
                }
                function s(i) {
                    return typeof i.end == "number" ? i.end : i.loc && i.loc.end;
                }
                n.exports = {
                    locStart: t,
                    locEnd: s
                };
            }
        }), hd = Z({
            "src/language-graphql/printer-graphql.js" (e, n) {
                "use strict";
                ae();
                var { builders: { join: t, hardline: s, line: i, softline: r, group: u, indent: a, ifBreak: c } } = Le(), { isNextLineEmpty: l, isNonEmptyArray: C } = Ge(), { insertPragma: m } = gd(), { locStart: g, locEnd: p } = yd();
                function f(w, I, E) {
                    let D = w.getValue();
                    if (!D) return "";
                    if (typeof D == "string") return D;
                    switch(D.kind){
                        case "Document":
                            {
                                let d = [];
                                return w.each((y, o, x)=>{
                                    d.push(E()), o !== x.length - 1 && (d.push(s), l(I.originalText, y.getValue(), p) && d.push(s));
                                }, "definitions"), [
                                    ...d,
                                    s
                                ];
                            }
                        case "OperationDefinition":
                            {
                                let d = I.originalText[g(D)] !== "{", y = Boolean(D.name);
                                return [
                                    d ? D.operation : "",
                                    d && y ? [
                                        " ",
                                        E("name")
                                    ] : "",
                                    d && !y && C(D.variableDefinitions) ? " " : "",
                                    C(D.variableDefinitions) ? u([
                                        "(",
                                        a([
                                            r,
                                            t([
                                                c("", ", "),
                                                r
                                            ], w.map(E, "variableDefinitions"))
                                        ]),
                                        r,
                                        ")"
                                    ]) : "",
                                    h(w, E, D),
                                    D.selectionSet ? !d && !y ? "" : " " : "",
                                    E("selectionSet")
                                ];
                            }
                        case "FragmentDefinition":
                            return [
                                "fragment ",
                                E("name"),
                                C(D.variableDefinitions) ? u([
                                    "(",
                                    a([
                                        r,
                                        t([
                                            c("", ", "),
                                            r
                                        ], w.map(E, "variableDefinitions"))
                                    ]),
                                    r,
                                    ")"
                                ]) : "",
                                " on ",
                                E("typeCondition"),
                                h(w, E, D),
                                " ",
                                E("selectionSet")
                            ];
                        case "SelectionSet":
                            return [
                                "{",
                                a([
                                    s,
                                    t(s, N(w, I, E, "selections"))
                                ]),
                                s,
                                "}"
                            ];
                        case "Field":
                            return u([
                                D.alias ? [
                                    E("alias"),
                                    ": "
                                ] : "",
                                E("name"),
                                D.arguments.length > 0 ? u([
                                    "(",
                                    a([
                                        r,
                                        t([
                                            c("", ", "),
                                            r
                                        ], N(w, I, E, "arguments"))
                                    ]),
                                    r,
                                    ")"
                                ]) : "",
                                h(w, E, D),
                                D.selectionSet ? " " : "",
                                E("selectionSet")
                            ]);
                        case "Name":
                            return D.value;
                        case "StringValue":
                            return D.block ? [
                                '"""',
                                s,
                                t(s, D.value.replace(/"""/g, "\\$&").split(`
`)),
                                s,
                                '"""'
                            ] : [
                                '"',
                                D.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"),
                                '"'
                            ];
                        case "IntValue":
                        case "FloatValue":
                        case "EnumValue":
                            return D.value;
                        case "BooleanValue":
                            return D.value ? "true" : "false";
                        case "NullValue":
                            return "null";
                        case "Variable":
                            return [
                                "$",
                                E("name")
                            ];
                        case "ListValue":
                            return u([
                                "[",
                                a([
                                    r,
                                    t([
                                        c("", ", "),
                                        r
                                    ], w.map(E, "values"))
                                ]),
                                r,
                                "]"
                            ]);
                        case "ObjectValue":
                            return u([
                                "{",
                                I.bracketSpacing && D.fields.length > 0 ? " " : "",
                                a([
                                    r,
                                    t([
                                        c("", ", "),
                                        r
                                    ], w.map(E, "fields"))
                                ]),
                                r,
                                c("", I.bracketSpacing && D.fields.length > 0 ? " " : ""),
                                "}"
                            ]);
                        case "ObjectField":
                        case "Argument":
                            return [
                                E("name"),
                                ": ",
                                E("value")
                            ];
                        case "Directive":
                            return [
                                "@",
                                E("name"),
                                D.arguments.length > 0 ? u([
                                    "(",
                                    a([
                                        r,
                                        t([
                                            c("", ", "),
                                            r
                                        ], N(w, I, E, "arguments"))
                                    ]),
                                    r,
                                    ")"
                                ]) : ""
                            ];
                        case "NamedType":
                            return E("name");
                        case "VariableDefinition":
                            return [
                                E("variable"),
                                ": ",
                                E("type"),
                                D.defaultValue ? [
                                    " = ",
                                    E("defaultValue")
                                ] : "",
                                h(w, E, D)
                            ];
                        case "ObjectTypeExtension":
                        case "ObjectTypeDefinition":
                            return [
                                E("description"),
                                D.description ? s : "",
                                D.kind === "ObjectTypeExtension" ? "extend " : "",
                                "type ",
                                E("name"),
                                D.interfaces.length > 0 ? [
                                    " implements ",
                                    ...b(w, I, E)
                                ] : "",
                                h(w, E, D),
                                D.fields.length > 0 ? [
                                    " {",
                                    a([
                                        s,
                                        t(s, N(w, I, E, "fields"))
                                    ]),
                                    s,
                                    "}"
                                ] : ""
                            ];
                        case "FieldDefinition":
                            return [
                                E("description"),
                                D.description ? s : "",
                                E("name"),
                                D.arguments.length > 0 ? u([
                                    "(",
                                    a([
                                        r,
                                        t([
                                            c("", ", "),
                                            r
                                        ], N(w, I, E, "arguments"))
                                    ]),
                                    r,
                                    ")"
                                ]) : "",
                                ": ",
                                E("type"),
                                h(w, E, D)
                            ];
                        case "DirectiveDefinition":
                            return [
                                E("description"),
                                D.description ? s : "",
                                "directive ",
                                "@",
                                E("name"),
                                D.arguments.length > 0 ? u([
                                    "(",
                                    a([
                                        r,
                                        t([
                                            c("", ", "),
                                            r
                                        ], N(w, I, E, "arguments"))
                                    ]),
                                    r,
                                    ")"
                                ]) : "",
                                D.repeatable ? " repeatable" : "",
                                " on ",
                                t(" | ", w.map(E, "locations"))
                            ];
                        case "EnumTypeExtension":
                        case "EnumTypeDefinition":
                            return [
                                E("description"),
                                D.description ? s : "",
                                D.kind === "EnumTypeExtension" ? "extend " : "",
                                "enum ",
                                E("name"),
                                h(w, E, D),
                                D.values.length > 0 ? [
                                    " {",
                                    a([
                                        s,
                                        t(s, N(w, I, E, "values"))
                                    ]),
                                    s,
                                    "}"
                                ] : ""
                            ];
                        case "EnumValueDefinition":
                            return [
                                E("description"),
                                D.description ? s : "",
                                E("name"),
                                h(w, E, D)
                            ];
                        case "InputValueDefinition":
                            return [
                                E("description"),
                                D.description ? D.description.block ? s : i : "",
                                E("name"),
                                ": ",
                                E("type"),
                                D.defaultValue ? [
                                    " = ",
                                    E("defaultValue")
                                ] : "",
                                h(w, E, D)
                            ];
                        case "InputObjectTypeExtension":
                        case "InputObjectTypeDefinition":
                            return [
                                E("description"),
                                D.description ? s : "",
                                D.kind === "InputObjectTypeExtension" ? "extend " : "",
                                "input ",
                                E("name"),
                                h(w, E, D),
                                D.fields.length > 0 ? [
                                    " {",
                                    a([
                                        s,
                                        t(s, N(w, I, E, "fields"))
                                    ]),
                                    s,
                                    "}"
                                ] : ""
                            ];
                        case "SchemaDefinition":
                            return [
                                E("description"),
                                D.description ? s : "",
                                "schema",
                                h(w, E, D),
                                " {",
                                D.operationTypes.length > 0 ? a([
                                    s,
                                    t(s, N(w, I, E, "operationTypes"))
                                ]) : "",
                                s,
                                "}"
                            ];
                        case "OperationTypeDefinition":
                            return [
                                E("operation"),
                                ": ",
                                E("type")
                            ];
                        case "InterfaceTypeExtension":
                        case "InterfaceTypeDefinition":
                            return [
                                E("description"),
                                D.description ? s : "",
                                D.kind === "InterfaceTypeExtension" ? "extend " : "",
                                "interface ",
                                E("name"),
                                D.interfaces.length > 0 ? [
                                    " implements ",
                                    ...b(w, I, E)
                                ] : "",
                                h(w, E, D),
                                D.fields.length > 0 ? [
                                    " {",
                                    a([
                                        s,
                                        t(s, N(w, I, E, "fields"))
                                    ]),
                                    s,
                                    "}"
                                ] : ""
                            ];
                        case "FragmentSpread":
                            return [
                                "...",
                                E("name"),
                                h(w, E, D)
                            ];
                        case "InlineFragment":
                            return [
                                "...",
                                D.typeCondition ? [
                                    " on ",
                                    E("typeCondition")
                                ] : "",
                                h(w, E, D),
                                " ",
                                E("selectionSet")
                            ];
                        case "UnionTypeExtension":
                        case "UnionTypeDefinition":
                            return u([
                                E("description"),
                                D.description ? s : "",
                                u([
                                    D.kind === "UnionTypeExtension" ? "extend " : "",
                                    "union ",
                                    E("name"),
                                    h(w, E, D),
                                    D.types.length > 0 ? [
                                        " =",
                                        c("", " "),
                                        a([
                                            c([
                                                i,
                                                "  "
                                            ]),
                                            t([
                                                i,
                                                "| "
                                            ], w.map(E, "types"))
                                        ])
                                    ] : ""
                                ])
                            ]);
                        case "ScalarTypeExtension":
                        case "ScalarTypeDefinition":
                            return [
                                E("description"),
                                D.description ? s : "",
                                D.kind === "ScalarTypeExtension" ? "extend " : "",
                                "scalar ",
                                E("name"),
                                h(w, E, D)
                            ];
                        case "NonNullType":
                            return [
                                E("type"),
                                "!"
                            ];
                        case "ListType":
                            return [
                                "[",
                                E("type"),
                                "]"
                            ];
                        default:
                            throw new Error("unknown graphql type: " + JSON.stringify(D.kind));
                    }
                }
                function h(w, I, E) {
                    if (E.directives.length === 0) return "";
                    let D = t(i, w.map(I, "directives"));
                    return E.kind === "FragmentDefinition" || E.kind === "OperationDefinition" ? u([
                        i,
                        D
                    ]) : [
                        " ",
                        u(a([
                            r,
                            D
                        ]))
                    ];
                }
                function N(w, I, E, D) {
                    return w.map((d, y, o)=>{
                        let x = E();
                        return y < o.length - 1 && l(I.originalText, d.getValue(), p) ? [
                            x,
                            s
                        ] : x;
                    }, D);
                }
                function T(w) {
                    return w.kind && w.kind !== "Comment";
                }
                function A(w) {
                    let I = w.getValue();
                    if (I.kind === "Comment") return "#" + I.value.trimEnd();
                    throw new Error("Not a comment: " + JSON.stringify(I));
                }
                function b(w, I, E) {
                    let D = w.getNode(), d = [], { interfaces: y } = D, o = w.map((x)=>E(x), "interfaces");
                    for(let x = 0; x < y.length; x++){
                        let F = y[x];
                        d.push(o[x]);
                        let S = y[x + 1];
                        if (S) {
                            let k = I.originalText.slice(F.loc.end, S.loc.start), _ = k.includes("#"), O = k.replace(/#.*/g, "").trim();
                            d.push(O === "," ? "," : " &", _ ? i : " ");
                        }
                    }
                    return d;
                }
                function v() {}
                v.ignoredProperties = new Set([
                    "loc",
                    "comments"
                ]);
                function B(w) {
                    let I = w.getValue();
                    return I && Array.isArray(I.comments) && I.comments.some((E)=>E.value.trim() === "prettier-ignore");
                }
                n.exports = {
                    print: f,
                    massageAstNode: v,
                    hasPrettierIgnore: B,
                    insertPragma: m,
                    printComment: A,
                    canAttachComment: T
                };
            }
        }), Cd = Z({
            "src/language-graphql/options.js" (e, n) {
                "use strict";
                ae();
                var t = Lt();
                n.exports = {
                    bracketSpacing: t.bracketSpacing
                };
            }
        }), Ed = Z({
            "src/language-graphql/parsers.js" () {
                ae();
            }
        }), vd = Z({
            "node_modules/linguist-languages/data/GraphQL.json" (e, n) {
                n.exports = {
                    name: "GraphQL",
                    type: "data",
                    color: "#e10098",
                    extensions: [
                        ".graphql",
                        ".gql",
                        ".graphqls"
                    ],
                    tmScope: "source.graphql",
                    aceMode: "text",
                    languageId: 139
                };
            }
        }), Fd = Z({
            "src/language-graphql/index.js" (e, n) {
                "use strict";
                ae();
                var t = bt(), s = hd(), i = Cd(), r = Ed(), u = [
                    t(vd(), ()=>({
                            since: "1.5.0",
                            parsers: [
                                "graphql"
                            ],
                            vscodeLanguageIds: [
                                "graphql"
                            ]
                        }))
                ], a = {
                    graphql: s
                };
                n.exports = {
                    languages: u,
                    options: i,
                    printers: a,
                    parsers: r
                };
            }
        }), fo = Z({
            "src/language-markdown/loc.js" (e, n) {
                "use strict";
                ae();
                function t(i) {
                    return i.position.start.offset;
                }
                function s(i) {
                    return i.position.end.offset;
                }
                n.exports = {
                    locStart: t,
                    locEnd: s
                };
            }
        }), Ad = Z({
            "src/language-markdown/constants.evaluate.js" (e, n) {
                n.exports = {
                    cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\ud840-\ud868\ud86a-\ud86c\ud86f-\ud872\ud874-\ud879][\udc00-\udfff]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67]|\ud83c[\ude00\ude50-\ude51]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])(?:[\\ufe00-\\ufe0f]|\udb40[\udd00-\uddef])?",
                    kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",
                    punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\ud800[\udd00-\udd02\udf9f\udfd0]|\ud801[\udd6f]|\ud802[\udc57\udd1f\udd3f\ude50-\ude58\ude7f\udef0-\udef6\udf39-\udf3f\udf99-\udf9c]|\ud803[\udf55-\udf59]|\ud804[\udc47-\udc4d\udcbb-\udcbc\udcbe-\udcc1\udd40-\udd43\udd74-\udd75\uddc5-\uddc8\uddcd\udddb\udddd-\udddf\ude38-\ude3d\udea9]|\ud805[\udc4b-\udc4f\udc5b\udc5d\udcc6\uddc1-\uddd7\ude41-\ude43\ude60-\ude6c\udf3c-\udf3e]|\ud806[\udc3b\udde2\ude3f-\ude46\ude9a-\ude9c\ude9e-\udea2]|\ud807[\udc41-\udc45\udc70-\udc71\udef7-\udef8\udfff]|\ud809[\udc70-\udc74]|\ud81a[\ude6e-\ude6f\udef5\udf37-\udf3b\udf44]|\ud81b[\ude97-\ude9a\udfe2]|\ud82f[\udc9f]|\ud836[\ude87-\ude8b]|\ud83a[\udd5e-\udd5f]"
                };
            }
        }), Kn = Z({
            "src/language-markdown/utils.js" (e, n) {
                "use strict";
                ae();
                var { getLast: t } = Ge(), { locStart: s, locEnd: i } = fo(), { cjkPattern: r, kPattern: u, punctuationPattern: a } = Ad(), c = [
                    "liquidNode",
                    "inlineCode",
                    "emphasis",
                    "esComment",
                    "strong",
                    "delete",
                    "wikiLink",
                    "link",
                    "linkReference",
                    "image",
                    "imageReference",
                    "footnote",
                    "footnoteReference",
                    "sentence",
                    "whitespace",
                    "word",
                    "break",
                    "inlineMath"
                ], l = [
                    ...c,
                    "tableCell",
                    "paragraph",
                    "heading"
                ], C = new RegExp(u), m = new RegExp(a);
                function g(A, b) {
                    let v = "non-cjk", B = "cj-letter", w = "k-letter", I = "cjk-punctuation", E = [], D = (b.proseWrap === "preserve" ? A : A.replace(new RegExp("(".concat(r, `)
(`).concat(r, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
                    for (let [y, o] of D.entries()){
                        if (y % 2 === 1) {
                            E.push({
                                type: "whitespace",
                                value: /\n/.test(o) ? `
` : " "
                            });
                            continue;
                        }
                        if ((y === 0 || y === D.length - 1) && o === "") continue;
                        let x = o.split(new RegExp("(".concat(r, ")")));
                        for (let [F, S] of x.entries())if (!((F === 0 || F === x.length - 1) && S === "")) {
                            if (F % 2 === 0) {
                                S !== "" && d({
                                    type: "word",
                                    value: S,
                                    kind: v,
                                    hasLeadingPunctuation: m.test(S[0]),
                                    hasTrailingPunctuation: m.test(t(S))
                                });
                                continue;
                            }
                            d(m.test(S) ? {
                                type: "word",
                                value: S,
                                kind: I,
                                hasLeadingPunctuation: !0,
                                hasTrailingPunctuation: !0
                            } : {
                                type: "word",
                                value: S,
                                kind: C.test(S) ? w : B,
                                hasLeadingPunctuation: !1,
                                hasTrailingPunctuation: !1
                            });
                        }
                    }
                    return E;
                    function d(y) {
                        let o = t(E);
                        o && o.type === "word" && (o.kind === v && y.kind === B && !o.hasTrailingPunctuation || o.kind === B && y.kind === v && !y.hasLeadingPunctuation ? E.push({
                            type: "whitespace",
                            value: " "
                        }) : !x(v, I) && ![
                            o.value,
                            y.value
                        ].some((F)=>/\u3000/.test(F)) && E.push({
                            type: "whitespace",
                            value: ""
                        })), E.push(y);
                        function x(F, S) {
                            return o.kind === F && y.kind === S || o.kind === S && y.kind === F;
                        }
                    }
                }
                function p(A, b) {
                    let [, v, B, w] = b.slice(A.position.start.offset, A.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
                    return {
                        numberText: v,
                        marker: B,
                        leadingSpaces: w
                    };
                }
                function f(A, b) {
                    if (!A.ordered || A.children.length < 2) return !1;
                    let v = Number(p(A.children[0], b.originalText).numberText), B = Number(p(A.children[1], b.originalText).numberText);
                    if (v === 0 && A.children.length > 2) {
                        let w = Number(p(A.children[2], b.originalText).numberText);
                        return B === 1 && w === 1;
                    }
                    return B === 1;
                }
                function h(A, b) {
                    let { value: v } = A;
                    return A.position.end.offset === b.length && v.endsWith(`
`) && b.endsWith(`
`) ? v.slice(0, -1) : v;
                }
                function N(A, b) {
                    return function v(B, w, I) {
                        let E = Object.assign({}, b(B, w, I));
                        return E.children && (E.children = E.children.map((D, d)=>v(D, d, [
                                E,
                                ...I
                            ]))), E;
                    }(A, null, []);
                }
                function T(A) {
                    if (!A || A.type !== "link" || A.children.length !== 1) return !1;
                    let b = A.children[0];
                    return b && s(A) === s(b) && i(A) === i(b);
                }
                n.exports = {
                    mapAst: N,
                    splitText: g,
                    punctuationPattern: a,
                    getFencedCodeBlockValue: h,
                    getOrderedListItemInfo: p,
                    hasGitDiffFriendlyOrderedList: f,
                    INLINE_NODE_TYPES: c,
                    INLINE_NODE_WRAPPER_TYPES: l,
                    isAutolink: T
                };
            }
        }), Sd = Z({
            "src/language-markdown/embed.js" (e, n) {
                "use strict";
                ae();
                var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ge(), { builders: { hardline: i, markAsRoot: r }, utils: { replaceEndOfLine: u } } = Le(), a = Xn(), { getFencedCodeBlockValue: c } = Kn();
                function l(C, m, g, p) {
                    let f = C.getValue();
                    if (f.type === "code" && f.lang !== null) {
                        let h = t(f.lang, p);
                        if (h) {
                            let N = p.__inJsTemplate ? "~" : "`", T = N.repeat(Math.max(3, s(f.value, N) + 1)), A = {
                                parser: h
                            };
                            f.lang === "tsx" && (A.filepath = "dummy.tsx");
                            let b = g(c(f, p.originalText), A, {
                                stripTrailingHardline: !0
                            });
                            return r([
                                T,
                                f.lang,
                                f.meta ? " " + f.meta : "",
                                i,
                                u(b),
                                i,
                                T
                            ]);
                        }
                    }
                    switch(f.type){
                        case "front-matter":
                            return a(f, g);
                        case "importExport":
                            return [
                                g(f.value, {
                                    parser: "babel"
                                }, {
                                    stripTrailingHardline: !0
                                }),
                                i
                            ];
                        case "jsx":
                            return g("<$>".concat(f.value, "</$>"), {
                                parser: "__js_expression",
                                rootMarker: "mdx"
                            }, {
                                stripTrailingHardline: !0
                            });
                    }
                    return null;
                }
                n.exports = l;
            }
        }), Do = Z({
            "src/language-markdown/pragma.js" (e, n) {
                "use strict";
                ae();
                var t = po(), s = [
                    "format",
                    "prettier"
                ];
                function i(r) {
                    let u = "@(".concat(s.join("|"), ")"), a = new RegExp([
                        "<!--\\s*".concat(u, "\\s*-->"),
                        "{\\s*\\/\\*\\s*".concat(u, "\\s*\\*\\/\\s*}"),
                        `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*`.concat(u, `[^\\S
]*($|
)[\\s\\S]*
.*-->`)
                    ].join("|"), "m"), c = r.match(a);
                    return c && c.index === 0;
                }
                n.exports = {
                    startWithPragma: i,
                    hasPragma: (r)=>i(t(r).content.trimStart()),
                    insertPragma: (r)=>{
                        let u = t(r), a = "<!-- @".concat(s[0], " -->");
                        return u.frontMatter ? "".concat(u.frontMatter.raw, `

`).concat(a, `

`).concat(u.content) : "".concat(a, `

`).concat(u.content);
                    }
                };
            }
        }), xd = Z({
            "src/language-markdown/print-preprocess.js" (e, n) {
                "use strict";
                ae();
                var t = st(), { getOrderedListItemInfo: s, mapAst: i, splitText: r } = Kn(), u = /^.$/su;
                function a(T, A) {
                    return T = C(T, A), T = p(T), T = l(T), T = h(T, A), T = N(T, A), T = f(T, A), T = c(T), T = m(T), T;
                }
                function c(T) {
                    return i(T, (A)=>A.type !== "import" && A.type !== "export" ? A : Object.assign(Object.assign({}, A), {}, {
                            type: "importExport"
                        }));
                }
                function l(T) {
                    return i(T, (A)=>A.type !== "inlineCode" ? A : Object.assign(Object.assign({}, A), {}, {
                            value: A.value.replace(/\s+/g, " ")
                        }));
                }
                function C(T, A) {
                    return i(T, (b)=>b.type !== "text" || b.value === "*" || b.value === "_" || !u.test(b.value) || b.position.end.offset - b.position.start.offset === b.value.length ? b : Object.assign(Object.assign({}, b), {}, {
                            value: A.originalText.slice(b.position.start.offset, b.position.end.offset)
                        }));
                }
                function m(T) {
                    return g(T, (A, b)=>A.type === "importExport" && b.type === "importExport", (A, b)=>({
                            type: "importExport",
                            value: A.value + `

` + b.value,
                            position: {
                                start: A.position.start,
                                end: b.position.end
                            }
                        }));
                }
                function g(T, A, b) {
                    return i(T, (v)=>{
                        if (!v.children) return v;
                        let B = v.children.reduce((w, I)=>{
                            let E = t(w);
                            return E && A(E, I) ? w.splice(-1, 1, b(E, I)) : w.push(I), w;
                        }, []);
                        return Object.assign(Object.assign({}, v), {}, {
                            children: B
                        });
                    });
                }
                function p(T) {
                    return g(T, (A, b)=>A.type === "text" && b.type === "text", (A, b)=>({
                            type: "text",
                            value: A.value + b.value,
                            position: {
                                start: A.position.start,
                                end: b.position.end
                            }
                        }));
                }
                function f(T, A) {
                    return i(T, (b, v, B)=>{
                        let [w] = B;
                        if (b.type !== "text") return b;
                        let { value: I } = b;
                        return w.type === "paragraph" && (v === 0 && (I = I.trimStart()), v === w.children.length - 1 && (I = I.trimEnd())), {
                            type: "sentence",
                            position: b.position,
                            children: r(I, A)
                        };
                    });
                }
                function h(T, A) {
                    return i(T, (b, v, B)=>{
                        if (b.type === "code") {
                            let w = /^\n?(?: {4,}|\t)/.test(A.originalText.slice(b.position.start.offset, b.position.end.offset));
                            if (b.isIndented = w, w) for(let I = 0; I < B.length; I++){
                                let E = B[I];
                                if (E.hasIndentedCodeblock) break;
                                E.type === "list" && (E.hasIndentedCodeblock = !0);
                            }
                        }
                        return b;
                    });
                }
                function N(T, A) {
                    return i(T, (B, w, I)=>{
                        if (B.type === "list" && B.children.length > 0) {
                            for(let E = 0; E < I.length; E++){
                                let D = I[E];
                                if (D.type === "list" && !D.isAligned) return B.isAligned = !1, B;
                            }
                            B.isAligned = v(B);
                        }
                        return B;
                    });
                    function b(B) {
                        return B.children.length === 0 ? -1 : B.children[0].position.start.column - 1;
                    }
                    function v(B) {
                        if (!B.ordered) return !0;
                        let [w, I] = B.children;
                        if (s(w, A.originalText).leadingSpaces.length > 1) return !0;
                        let D = b(w);
                        if (D === -1) return !1;
                        if (B.children.length === 1) return D % A.tabWidth === 0;
                        let d = b(I);
                        return D !== d ? !1 : D % A.tabWidth === 0 ? !0 : s(I, A.originalText).leadingSpaces.length > 1;
                    }
                }
                n.exports = a;
            }
        }), bd = Z({
            "src/language-markdown/clean.js" (e, n) {
                "use strict";
                ae();
                var { isFrontMatterNode: t } = Ge(), { startWithPragma: s } = Do(), i = new Set([
                    "position",
                    "raw"
                ]);
                function r(u, a, c) {
                    if ((u.type === "front-matter" || u.type === "code" || u.type === "yaml" || u.type === "import" || u.type === "export" || u.type === "jsx") && delete a.value, u.type === "list" && delete a.isAligned, (u.type === "list" || u.type === "listItem") && (delete a.spread, delete a.loose), u.type === "text" || (u.type === "inlineCode" && (a.value = u.value.replace(/[\t\n ]+/g, " ")), u.type === "wikiLink" && (a.value = u.value.trim().replace(/[\t\n]+/g, " ")), (u.type === "definition" || u.type === "linkReference") && (a.label = u.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), (u.type === "definition" || u.type === "link" || u.type === "image") && u.title && (a.title = u.title.replace(/\\(["')])/g, "$1")), c && c.type === "root" && c.children.length > 0 && (c.children[0] === u || t(c.children[0]) && c.children[1] === u) && u.type === "html" && s(u.value))) return null;
                }
                r.ignoredProperties = i, n.exports = r;
            }
        }), Td = Z({
            "src/language-markdown/printer-markdown.js" (e, n) {
                "use strict";
                ae();
                var { getLast: t, getMinNotPresentContinuousCount: s, getMaxContinuousCount: i, getStringWidth: r, isNonEmptyArray: u } = Ge(), { builders: { breakParent: a, join: c, line: l, literalline: C, markAsRoot: m, hardline: g, softline: p, ifBreak: f, fill: h, align: N, indent: T, group: A, hardlineWithoutBreakParent: b }, utils: { normalizeDoc: v, replaceTextEndOfLine: B }, printer: { printDocToString: w } } = Le(), I = Sd(), { insertPragma: E } = Do(), { locStart: D, locEnd: d } = fo(), y = xd(), o = bd(), { getFencedCodeBlockValue: x, hasGitDiffFriendlyOrderedList: F, splitText: S, punctuationPattern: k, INLINE_NODE_TYPES: _, INLINE_NODE_WRAPPER_TYPES: O, isAutolink: R } = Kn(), M = new Set([
                    "importExport"
                ]), H = [
                    "heading",
                    "tableCell",
                    "link",
                    "wikiLink"
                ], P = new Set([
                    "listItem",
                    "definition",
                    "footnoteDefinition"
                ]);
                function G(fe, pe, me) {
                    let ce = fe.getValue();
                    if (de(fe)) return S(pe.originalText.slice(ce.position.start.offset, ce.position.end.offset), pe).map((he)=>he.type === "word" ? he.value : he.value === "" ? "" : se(fe, he.value, pe));
                    switch(ce.type){
                        case "front-matter":
                            return pe.originalText.slice(ce.position.start.offset, ce.position.end.offset);
                        case "root":
                            return ce.children.length === 0 ? "" : [
                                v(oe(fe, pe, me)),
                                M.has(Ee(ce).type) ? "" : g
                            ];
                        case "paragraph":
                            return K(fe, pe, me, {
                                postprocessor: h
                            });
                        case "sentence":
                            return K(fe, pe, me);
                        case "word":
                            {
                                let he = ce.value.replace(/\*/g, "\\$&").replace(new RegExp([
                                    "(^|".concat(k, ")(_+)"),
                                    "(_+)(".concat(k, "|$)")
                                ].join("|"), "g"), (X, Y, te, z, j)=>(te ? "".concat(Y).concat(te) : "".concat(z).concat(j)).replace(/_/g, "\\_")), J = (X, Y, te)=>X.type === "sentence" && te === 0, ye = (X, Y, te)=>R(X.children[te - 1]);
                                return he !== ce.value && (fe.match(void 0, J, ye) || fe.match(void 0, J, (X, Y, te)=>X.type === "emphasis" && te === 0, ye)) && (he = he.replace(/^(\\?[*_])+/, (X)=>X.replace(/\\/g, ""))), he;
                            }
                        case "whitespace":
                            {
                                let he = fe.getParentNode(), J = he.children.indexOf(ce), ye = he.children[J + 1], X = ye && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(ye.value) ? "never" : pe.proseWrap;
                                return se(fe, ce.value, {
                                    proseWrap: X
                                });
                            }
                        case "emphasis":
                            {
                                let he;
                                if (R(ce.children[0])) he = pe.originalText[ce.position.start.offset];
                                else {
                                    let J = fe.getParentNode(), ye = J.children.indexOf(ce), X = J.children[ye - 1], Y = J.children[ye + 1];
                                    he = X && X.type === "sentence" && X.children.length > 0 && t(X.children).type === "word" && !t(X.children).hasTrailingPunctuation || Y && Y.type === "sentence" && Y.children.length > 0 && Y.children[0].type === "word" && !Y.children[0].hasLeadingPunctuation || ne(fe, "emphasis") ? "*" : "_";
                                }
                                return [
                                    he,
                                    K(fe, pe, me),
                                    he
                                ];
                            }
                        case "strong":
                            return [
                                "**",
                                K(fe, pe, me),
                                "**"
                            ];
                        case "delete":
                            return [
                                "~~",
                                K(fe, pe, me),
                                "~~"
                            ];
                        case "inlineCode":
                            {
                                let he = s(ce.value, "`"), J = "`".repeat(he || 1), ye = he && !/^\s/.test(ce.value) ? " " : "";
                                return [
                                    J,
                                    ye,
                                    ce.value,
                                    ye,
                                    J
                                ];
                            }
                        case "wikiLink":
                            {
                                let he = "";
                                return pe.proseWrap === "preserve" ? he = ce.value : he = ce.value.replace(/[\t\n]+/g, " "), [
                                    "[[",
                                    he,
                                    "]]"
                                ];
                            }
                        case "link":
                            switch(pe.originalText[ce.position.start.offset]){
                                case "<":
                                    {
                                        let he = "mailto:", J = ce.url.startsWith(he) && pe.originalText.slice(ce.position.start.offset + 1, ce.position.start.offset + 1 + he.length) !== he ? ce.url.slice(he.length) : ce.url;
                                        return [
                                            "<",
                                            J,
                                            ">"
                                        ];
                                    }
                                case "[":
                                    return [
                                        "[",
                                        K(fe, pe, me),
                                        "](",
                                        ge(ce.url, ")"),
                                        ve(ce.title, pe),
                                        ")"
                                    ];
                                default:
                                    return pe.originalText.slice(ce.position.start.offset, ce.position.end.offset);
                            }
                        case "image":
                            return [
                                "![",
                                ce.alt || "",
                                "](",
                                ge(ce.url, ")"),
                                ve(ce.title, pe),
                                ")"
                            ];
                        case "blockquote":
                            return [
                                "> ",
                                N("> ", K(fe, pe, me))
                            ];
                        case "heading":
                            return [
                                "#".repeat(ce.depth) + " ",
                                K(fe, pe, me)
                            ];
                        case "code":
                            {
                                if (ce.isIndented) {
                                    let ye = " ".repeat(4);
                                    return N(ye, [
                                        ye,
                                        ...B(ce.value, g)
                                    ]);
                                }
                                let he = pe.__inJsTemplate ? "~" : "`", J = he.repeat(Math.max(3, i(ce.value, he) + 1));
                                return [
                                    J,
                                    ce.lang || "",
                                    ce.meta ? " " + ce.meta : "",
                                    g,
                                    ...B(x(ce, pe.originalText), g),
                                    g,
                                    J
                                ];
                            }
                        case "html":
                            {
                                let he = fe.getParentNode(), J = he.type === "root" && t(he.children) === ce ? ce.value.trimEnd() : ce.value, ye = /^<!--.*-->$/s.test(J);
                                return B(J, ye ? g : m(C));
                            }
                        case "list":
                            {
                                let he = W(ce, fe.getParentNode()), J = F(ce, pe);
                                return K(fe, pe, me, {
                                    processor: (ye, X)=>{
                                        let Y = z(), te = ye.getValue();
                                        if (te.children.length === 2 && te.children[1].type === "html" && te.children[0].position.start.column !== te.children[1].position.start.column) return [
                                            Y,
                                            re(ye, pe, me, Y)
                                        ];
                                        return [
                                            Y,
                                            N(" ".repeat(Y.length), re(ye, pe, me, Y))
                                        ];
                                        function z() {
                                            let j = ce.ordered ? (X === 0 ? ce.start : J ? 1 : ce.start + X) + (he % 2 === 0 ? ". " : ") ") : he % 2 === 0 ? "- " : "* ";
                                            return ce.isAligned || ce.hasIndentedCodeblock ? $(j, pe) : j;
                                        }
                                    }
                                });
                            }
                        case "thematicBreak":
                            {
                                let he = U(fe, "list");
                                return he === -1 ? "---" : W(fe.getParentNode(he), fe.getParentNode(he + 1)) % 2 === 0 ? "***" : "---";
                            }
                        case "linkReference":
                            return [
                                "[",
                                K(fe, pe, me),
                                "]",
                                ce.referenceType === "full" ? [
                                    "[",
                                    ce.identifier,
                                    "]"
                                ] : ce.referenceType === "collapsed" ? "[]" : ""
                            ];
                        case "imageReference":
                            switch(ce.referenceType){
                                case "full":
                                    return [
                                        "![",
                                        ce.alt || "",
                                        "][",
                                        ce.identifier,
                                        "]"
                                    ];
                                default:
                                    return [
                                        "![",
                                        ce.alt,
                                        "]",
                                        ce.referenceType === "collapsed" ? "[]" : ""
                                    ];
                            }
                        case "definition":
                            {
                                let he = pe.proseWrap === "always" ? l : " ";
                                return A([
                                    "[",
                                    ce.identifier,
                                    "]:",
                                    T([
                                        he,
                                        ge(ce.url),
                                        ce.title === null ? "" : [
                                            he,
                                            ve(ce.title, pe, !1)
                                        ]
                                    ])
                                ]);
                            }
                        case "footnote":
                            return [
                                "[^",
                                K(fe, pe, me),
                                "]"
                            ];
                        case "footnoteReference":
                            return [
                                "[^",
                                ce.identifier,
                                "]"
                            ];
                        case "footnoteDefinition":
                            {
                                let he = fe.getParentNode().children[fe.getName() + 1], J = ce.children.length === 1 && ce.children[0].type === "paragraph" && (pe.proseWrap === "never" || pe.proseWrap === "preserve" && ce.children[0].position.start.line === ce.children[0].position.end.line);
                                return [
                                    "[^",
                                    ce.identifier,
                                    "]: ",
                                    J ? K(fe, pe, me) : A([
                                        N(" ".repeat(4), K(fe, pe, me, {
                                            processor: (ye, X)=>X === 0 ? A([
                                                    p,
                                                    me()
                                                ]) : me()
                                        })),
                                        he && he.type === "footnoteDefinition" ? p : ""
                                    ])
                                ];
                            }
                        case "table":
                            return V(fe, pe, me);
                        case "tableCell":
                            return K(fe, pe, me);
                        case "break":
                            return /\s/.test(pe.originalText[ce.position.start.offset]) ? [
                                "  ",
                                m(C)
                            ] : [
                                "\\",
                                g
                            ];
                        case "liquidNode":
                            return B(ce.value, g);
                        case "importExport":
                            return [
                                ce.value,
                                g
                            ];
                        case "esComment":
                            return [
                                "{/* ",
                                ce.value,
                                " */}"
                            ];
                        case "jsx":
                            return ce.value;
                        case "math":
                            return [
                                "$$",
                                g,
                                ce.value ? [
                                    ...B(ce.value, g),
                                    g
                                ] : "",
                                "$$"
                            ];
                        case "inlineMath":
                            return pe.originalText.slice(D(ce), d(ce));
                        case "tableRow":
                        case "listItem":
                        default:
                            throw new Error("Unknown markdown type ".concat(JSON.stringify(ce.type)));
                    }
                }
                function re(fe, pe, me, ce) {
                    let he = fe.getValue(), J = he.checked === null ? "" : he.checked ? "[x] " : "[ ] ";
                    return [
                        J,
                        K(fe, pe, me, {
                            processor: (ye, X)=>{
                                if (X === 0 && ye.getValue().type !== "list") return N(" ".repeat(J.length), me());
                                let Y = " ".repeat(xe(pe.tabWidth - ce.length, 0, 3));
                                return [
                                    Y,
                                    N(Y, me())
                                ];
                            }
                        })
                    ];
                }
                function $(fe, pe) {
                    let me = ce();
                    return fe + " ".repeat(me >= 4 ? 0 : me);
                    function ce() {
                        let he = fe.length % pe.tabWidth;
                        return he === 0 ? 0 : pe.tabWidth - he;
                    }
                }
                function W(fe, pe) {
                    return ee(fe, pe, (me)=>me.ordered === fe.ordered);
                }
                function ee(fe, pe, me) {
                    let ce = -1;
                    for (let he of pe.children)if (he.type === fe.type && me(he) ? ce++ : ce = -1, he === fe) return ce;
                }
                function U(fe, pe) {
                    let me = Array.isArray(pe) ? pe : [
                        pe
                    ], ce = -1, he;
                    for(; he = fe.getParentNode(++ce);)if (me.includes(he.type)) return ce;
                    return -1;
                }
                function ne(fe, pe) {
                    let me = U(fe, pe);
                    return me === -1 ? null : fe.getParentNode(me);
                }
                function se(fe, pe, me) {
                    if (me.proseWrap === "preserve" && pe === `
`) return g;
                    let ce = me.proseWrap === "always" && !ne(fe, H);
                    return pe !== "" ? ce ? l : " " : ce ? p : "";
                }
                function V(fe, pe, me) {
                    let ce = fe.getValue(), he = [], J = fe.map((j)=>j.map((Ce, Ne)=>{
                            let je = w(me(), pe).formatted, Ue = r(je);
                            return he[Ne] = Math.max(he[Ne] || 3, Ue), {
                                text: je,
                                width: Ue
                            };
                        }, "children"), "children"), ye = Y(!1);
                    if (pe.proseWrap !== "never") return [
                        a,
                        ye
                    ];
                    let X = Y(!0);
                    return [
                        a,
                        A(f(X, ye))
                    ];
                    function Y(j) {
                        let Ce = [
                            z(J[0], j),
                            te(j)
                        ];
                        return J.length > 1 && Ce.push(c(b, J.slice(1).map((Ne)=>z(Ne, j)))), c(b, Ce);
                    }
                    function te(j) {
                        let Ce = he.map((Ne, je)=>{
                            let Ue = ce.align[je], tt = Ue === "center" || Ue === "left" ? ":" : "-", Te = Ue === "center" || Ue === "right" ? ":" : "-", _e = j ? "-" : "-".repeat(Ne - 2);
                            return "".concat(tt).concat(_e).concat(Te);
                        });
                        return "| ".concat(Ce.join(" | "), " |");
                    }
                    function z(j, Ce) {
                        let Ne = j.map((je, Ue)=>{
                            let { text: tt, width: Te } = je;
                            if (Ce) return tt;
                            let _e = he[Ue] - Te, Fe = ce.align[Ue], Ke = 0;
                            Fe === "right" ? Ke = _e : Fe === "center" && (Ke = Math.floor(_e / 2));
                            let Se = _e - Ke;
                            return "".concat(" ".repeat(Ke)).concat(tt).concat(" ".repeat(Se));
                        });
                        return "| ".concat(Ne.join(" | "), " |");
                    }
                }
                function oe(fe, pe, me) {
                    let ce = [], he = null, { children: J } = fe.getValue();
                    for (let [ye, X] of J.entries())switch(q(X)){
                        case "start":
                            he === null && (he = {
                                index: ye,
                                offset: X.position.end.offset
                            });
                            break;
                        case "end":
                            he !== null && (ce.push({
                                start: he,
                                end: {
                                    index: ye,
                                    offset: X.position.start.offset
                                }
                            }), he = null);
                            break;
                        default:
                            break;
                    }
                    return K(fe, pe, me, {
                        processor: (ye, X)=>{
                            if (ce.length > 0) {
                                let Y = ce[0];
                                if (X === Y.start.index) return [
                                    J[Y.start.index].value,
                                    pe.originalText.slice(Y.start.offset, Y.end.offset),
                                    J[Y.end.index].value
                                ];
                                if (Y.start.index < X && X < Y.end.index) return !1;
                                if (X === Y.end.index) return ce.shift(), !1;
                            }
                            return me();
                        }
                    });
                }
                function K(fe, pe, me) {
                    let ce = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: he } = ce, J = ce.processor || (()=>me()), ye = fe.getValue(), X = [], Y;
                    return fe.each((te, z)=>{
                        let j = te.getValue(), Ce = J(te, z);
                        if (Ce !== !1) {
                            let Ne = {
                                parts: X,
                                prevNode: Y,
                                parentNode: ye,
                                options: pe
                            };
                            le(j, Ne) && (X.push(g), Y && M.has(Y.type) || (ue(j, Ne) || Q(j, Ne)) && X.push(g), Q(j, Ne) && X.push(g)), X.push(Ce), Y = j;
                        }
                    }, "children"), he ? he(X) : X;
                }
                function Ee(fe) {
                    let pe = fe;
                    for(; u(pe.children);)pe = t(pe.children);
                    return pe;
                }
                function q(fe) {
                    let pe;
                    if (fe.type === "html") pe = fe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
                    else {
                        let me;
                        fe.type === "esComment" ? me = fe : fe.type === "paragraph" && fe.children.length === 1 && fe.children[0].type === "esComment" && (me = fe.children[0]), me && (pe = me.value.match(/^prettier-ignore(?:-(start|end))?$/));
                    }
                    return pe ? pe[1] ? pe[1] : "next" : !1;
                }
                function le(fe, pe) {
                    let me = pe.parts.length === 0, ce = _.includes(fe.type), he = fe.type === "html" && O.includes(pe.parentNode.type);
                    return !me && !ce && !he;
                }
                function ue(fe, pe) {
                    let ce = (pe.prevNode && pe.prevNode.type) === fe.type && P.has(fe.type), he = pe.parentNode.type === "listItem" && !pe.parentNode.loose, J = pe.prevNode && pe.prevNode.type === "listItem" && pe.prevNode.loose, ye = q(pe.prevNode) === "next", X = fe.type === "html" && pe.prevNode && pe.prevNode.type === "html" && pe.prevNode.position.end.line + 1 === fe.position.start.line, Y = fe.type === "html" && pe.parentNode.type === "listItem" && pe.prevNode && pe.prevNode.type === "paragraph" && pe.prevNode.position.end.line + 1 === fe.position.start.line;
                    return J || !(ce || he || ye || X || Y);
                }
                function Q(fe, pe) {
                    let me = pe.prevNode && pe.prevNode.type === "list", ce = fe.type === "code" && fe.isIndented;
                    return me && ce;
                }
                function de(fe) {
                    let pe = ne(fe, [
                        "linkReference",
                        "imageReference"
                    ]);
                    return pe && (pe.type !== "linkReference" || pe.referenceType !== "full");
                }
                function ge(fe) {
                    let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], me = [
                        " ",
                        ...Array.isArray(pe) ? pe : [
                            pe
                        ]
                    ];
                    return new RegExp(me.map((ce)=>"\\".concat(ce)).join("|")).test(fe) ? "<".concat(fe, ">") : fe;
                }
                function ve(fe, pe) {
                    let me = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
                    if (!fe) return "";
                    if (me) return " " + ve(fe, pe, !1);
                    if (fe = fe.replace(/\\(["')])/g, "$1"), fe.includes('"') && fe.includes("'") && !fe.includes(")")) return "(".concat(fe, ")");
                    let ce = fe.split("'").length - 1, he = fe.split('"').length - 1, J = ce > he ? '"' : he > ce || pe.singleQuote ? "'" : '"';
                    return fe = fe.replace(/\\/, "\\\\"), fe = fe.replace(new RegExp("(".concat(J, ")"), "g"), "\\$1"), "".concat(J).concat(fe).concat(J);
                }
                function xe(fe, pe, me) {
                    return fe < pe ? pe : fe > me ? me : fe;
                }
                function we(fe) {
                    let pe = Number(fe.getName());
                    if (pe === 0) return !1;
                    let me = fe.getParentNode().children[pe - 1];
                    return q(me) === "next";
                }
                n.exports = {
                    preprocess: y,
                    print: G,
                    embed: I,
                    massageAstNode: o,
                    hasPrettierIgnore: we,
                    insertPragma: E
                };
            }
        }), Bd = Z({
            "src/language-markdown/options.js" (e, n) {
                "use strict";
                ae();
                var t = Lt();
                n.exports = {
                    proseWrap: t.proseWrap,
                    singleQuote: t.singleQuote
                };
            }
        }), Nd = Z({
            "src/language-markdown/parsers.js" () {
                ae();
            }
        }), di = Z({
            "node_modules/linguist-languages/data/Markdown.json" (e, n) {
                n.exports = {
                    name: "Markdown",
                    type: "prose",
                    color: "#083fa1",
                    aliases: [
                        "pandoc"
                    ],
                    aceMode: "markdown",
                    codemirrorMode: "gfm",
                    codemirrorMimeType: "text/x-gfm",
                    wrap: !0,
                    extensions: [
                        ".md",
                        ".markdown",
                        ".mdown",
                        ".mdwn",
                        ".mdx",
                        ".mkd",
                        ".mkdn",
                        ".mkdown",
                        ".ronn",
                        ".scd",
                        ".workbook"
                    ],
                    filenames: [
                        "contents.lr"
                    ],
                    tmScope: "source.gfm",
                    languageId: 222
                };
            }
        }), wd = Z({
            "src/language-markdown/index.js" (e, n) {
                "use strict";
                ae();
                var t = bt(), s = Td(), i = Bd(), r = Nd(), u = [
                    t(di(), (c)=>({
                            since: "1.8.0",
                            parsers: [
                                "markdown"
                            ],
                            vscodeLanguageIds: [
                                "markdown"
                            ],
                            filenames: [
                                ...c.filenames,
                                "README"
                            ],
                            extensions: c.extensions.filter((l)=>l !== ".mdx")
                        })),
                    t(di(), ()=>({
                            name: "MDX",
                            since: "1.15.0",
                            parsers: [
                                "mdx"
                            ],
                            vscodeLanguageIds: [
                                "mdx"
                            ],
                            filenames: [],
                            extensions: [
                                ".mdx"
                            ]
                        }))
                ], a = {
                    mdast: s
                };
                n.exports = {
                    languages: u,
                    options: i,
                    printers: a,
                    parsers: r
                };
            }
        }), _d = Z({
            "src/language-html/clean.js" (e, n) {
                "use strict";
                ae();
                var { isFrontMatterNode: t } = Ge(), s = new Set([
                    "sourceSpan",
                    "startSourceSpan",
                    "endSourceSpan",
                    "nameSpan",
                    "valueSpan",
                    "parent"
                ]);
                function i(r, u) {
                    if (r.type === "text" || r.type === "comment" || t(r) || r.type === "yaml" || r.type === "toml") return null;
                    r.type === "attribute" && delete u.value, r.type === "docType" && delete u.value;
                }
                i.ignoredProperties = s, n.exports = i;
            }
        }), Pd = Z({
            "src/language-html/constants.evaluate.js" (e, n) {
                n.exports = {
                    CSS_DISPLAY_TAGS: {
                        area: "none",
                        base: "none",
                        basefont: "none",
                        datalist: "none",
                        head: "none",
                        link: "none",
                        meta: "none",
                        noembed: "none",
                        noframes: "none",
                        param: "block",
                        rp: "none",
                        script: "block",
                        source: "block",
                        style: "none",
                        template: "inline",
                        track: "block",
                        title: "none",
                        html: "block",
                        body: "block",
                        address: "block",
                        blockquote: "block",
                        center: "block",
                        div: "block",
                        figure: "block",
                        figcaption: "block",
                        footer: "block",
                        form: "block",
                        header: "block",
                        hr: "block",
                        legend: "block",
                        listing: "block",
                        main: "block",
                        p: "block",
                        plaintext: "block",
                        pre: "block",
                        xmp: "block",
                        slot: "contents",
                        ruby: "ruby",
                        rt: "ruby-text",
                        article: "block",
                        aside: "block",
                        h1: "block",
                        h2: "block",
                        h3: "block",
                        h4: "block",
                        h5: "block",
                        h6: "block",
                        hgroup: "block",
                        nav: "block",
                        section: "block",
                        dir: "block",
                        dd: "block",
                        dl: "block",
                        dt: "block",
                        ol: "block",
                        ul: "block",
                        li: "list-item",
                        table: "table",
                        caption: "table-caption",
                        colgroup: "table-column-group",
                        col: "table-column",
                        thead: "table-header-group",
                        tbody: "table-row-group",
                        tfoot: "table-footer-group",
                        tr: "table-row",
                        td: "table-cell",
                        th: "table-cell",
                        fieldset: "block",
                        button: "inline-block",
                        details: "block",
                        summary: "block",
                        dialog: "block",
                        meter: "inline-block",
                        progress: "inline-block",
                        object: "inline-block",
                        video: "inline-block",
                        audio: "inline-block",
                        select: "inline-block",
                        option: "block",
                        optgroup: "block"
                    },
                    CSS_DISPLAY_DEFAULT: "inline",
                    CSS_WHITE_SPACE_TAGS: {
                        listing: "pre",
                        plaintext: "pre",
                        pre: "pre",
                        xmp: "pre",
                        nobr: "nowrap",
                        table: "initial",
                        textarea: "pre-wrap"
                    },
                    CSS_WHITE_SPACE_DEFAULT: "normal"
                };
            }
        }), Id = Z({
            "src/language-html/utils/is-unknown-namespace.js" (e, n) {
                "use strict";
                ae();
                function t(s) {
                    return s.type === "element" && !s.hasExplicitNamespace && ![
                        "html",
                        "svg"
                    ].includes(s.namespace);
                }
                n.exports = t;
            }
        }), Ot = Z({
            "src/language-html/utils/index.js" (e, n) {
                "use strict";
                ae();
                var { inferParserByLanguage: t, isFrontMatterNode: s } = Ge(), { builders: { line: i, hardline: r, join: u }, utils: { getDocParts: a, replaceTextEndOfLine: c } } = Le(), { CSS_DISPLAY_TAGS: l, CSS_DISPLAY_DEFAULT: C, CSS_WHITE_SPACE_TAGS: m, CSS_WHITE_SPACE_DEFAULT: g } = Pd(), p = Id(), f = new Set([
                    "	",
                    `
`,
                    "\f",
                    "\r",
                    " "
                ]), h = (j)=>j.replace(/^[\t\n\f\r ]+/, ""), N = (j)=>j.replace(/[\t\n\f\r ]+$/, ""), T = (j)=>h(N(j)), A = (j)=>j.replace(/^[\t\f\r ]*\n/g, ""), b = (j)=>A(N(j)), v = (j)=>j.split(/[\t\n\f\r ]+/), B = (j)=>j.match(/^[\t\n\f\r ]*/)[0], w = (j)=>{
                    let [, Ce, Ne, je] = j.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
                    return {
                        leadingWhitespace: Ce,
                        trailingWhitespace: je,
                        text: Ne
                    };
                }, I = (j)=>/[\t\n\f\r ]/.test(j);
                function E(j, Ce) {
                    return !!(j.type === "ieConditionalComment" && j.lastChild && !j.lastChild.isSelfClosing && !j.lastChild.endSourceSpan || j.type === "ieConditionalComment" && !j.complete || de(j) && j.children.some((Ne)=>Ne.type !== "text" && Ne.type !== "interpolation") || X(j, Ce) && !o(j) && j.type !== "interpolation");
                }
                function D(j) {
                    return j.type === "attribute" || !j.parent || !j.prev ? !1 : d(j.prev);
                }
                function d(j) {
                    return j.type === "comment" && j.value.trim() === "prettier-ignore";
                }
                function y(j) {
                    return j.type === "text" || j.type === "comment";
                }
                function o(j) {
                    return j.type === "element" && (j.fullName === "script" || j.fullName === "style" || j.fullName === "svg:style" || p(j) && (j.name === "script" || j.name === "style"));
                }
                function x(j) {
                    return j.children && !o(j);
                }
                function F(j) {
                    return o(j) || j.type === "interpolation" || S(j);
                }
                function S(j) {
                    return we(j).startsWith("pre");
                }
                function k(j, Ce) {
                    let Ne = je();
                    if (Ne && !j.prev && j.parent && j.parent.tagDefinition && j.parent.tagDefinition.ignoreFirstLf) return j.type === "interpolation";
                    return Ne;
                    function je() {
                        return s(j) ? !1 : (j.type === "text" || j.type === "interpolation") && j.prev && (j.prev.type === "text" || j.prev.type === "interpolation") ? !0 : !j.parent || j.parent.cssDisplay === "none" ? !1 : de(j.parent) ? !0 : !(!j.prev && (j.parent.type === "root" || de(j) && j.parent || o(j.parent) || J(j.parent, Ce) || !Ee(j.parent.cssDisplay)) || j.prev && !ue(j.prev.cssDisplay));
                    }
                }
                function _(j, Ce) {
                    return s(j) ? !1 : (j.type === "text" || j.type === "interpolation") && j.next && (j.next.type === "text" || j.next.type === "interpolation") ? !0 : !j.parent || j.parent.cssDisplay === "none" ? !1 : de(j.parent) ? !0 : !(!j.next && (j.parent.type === "root" || de(j) && j.parent || o(j.parent) || J(j.parent, Ce) || !q(j.parent.cssDisplay)) || j.next && !le(j.next.cssDisplay));
                }
                function O(j) {
                    return Q(j.cssDisplay) && !o(j);
                }
                function R(j) {
                    return s(j) || j.next && j.sourceSpan.end && j.sourceSpan.end.line + 1 < j.next.sourceSpan.start.line;
                }
                function M(j) {
                    return H(j) || j.type === "element" && j.children.length > 0 && ([
                        "body",
                        "script",
                        "style"
                    ].includes(j.name) || j.children.some((Ce)=>ne(Ce))) || j.firstChild && j.firstChild === j.lastChild && j.firstChild.type !== "text" && $(j.firstChild) && (!j.lastChild.isTrailingSpaceSensitive || W(j.lastChild));
                }
                function H(j) {
                    return j.type === "element" && j.children.length > 0 && ([
                        "html",
                        "head",
                        "ul",
                        "ol",
                        "select"
                    ].includes(j.name) || j.cssDisplay.startsWith("table") && j.cssDisplay !== "table-cell");
                }
                function P(j) {
                    return ee(j) || j.prev && G(j.prev) || re(j);
                }
                function G(j) {
                    return ee(j) || j.type === "element" && j.fullName === "br" || re(j);
                }
                function re(j) {
                    return $(j) && W(j);
                }
                function $(j) {
                    return j.hasLeadingSpaces && (j.prev ? j.prev.sourceSpan.end.line < j.sourceSpan.start.line : j.parent.type === "root" || j.parent.startSourceSpan.end.line < j.sourceSpan.start.line);
                }
                function W(j) {
                    return j.hasTrailingSpaces && (j.next ? j.next.sourceSpan.start.line > j.sourceSpan.end.line : j.parent.type === "root" || j.parent.endSourceSpan && j.parent.endSourceSpan.start.line > j.sourceSpan.end.line);
                }
                function ee(j) {
                    switch(j.type){
                        case "ieConditionalComment":
                        case "comment":
                        case "directive":
                            return !0;
                        case "element":
                            return [
                                "script",
                                "select"
                            ].includes(j.name);
                    }
                    return !1;
                }
                function U(j) {
                    return j.lastChild ? U(j.lastChild) : j;
                }
                function ne(j) {
                    return j.children && j.children.some((Ce)=>Ce.type !== "text");
                }
                function se(j) {
                    let { type: Ce, lang: Ne } = j.attrMap;
                    if (Ce === "module" || Ce === "text/javascript" || Ce === "text/babel" || Ce === "application/javascript" || Ne === "jsx") return "babel";
                    if (Ce === "application/x-typescript" || Ne === "ts" || Ne === "tsx") return "typescript";
                    if (Ce === "text/markdown") return "markdown";
                    if (Ce === "text/html") return "html";
                    if (Ce && (Ce.endsWith("json") || Ce.endsWith("importmap"))) return "json";
                    if (Ce === "text/x-handlebars-template") return "glimmer";
                }
                function V(j) {
                    let { lang: Ce } = j.attrMap;
                    if (!Ce || Ce === "postcss" || Ce === "css") return "css";
                    if (Ce === "scss") return "scss";
                    if (Ce === "less") return "less";
                }
                function oe(j, Ce) {
                    if (j.name === "script" && !j.attrMap.src) return !j.attrMap.lang && !j.attrMap.type ? "babel" : se(j);
                    if (j.name === "style") return V(j);
                    if (Ce && X(j, Ce)) return se(j) || !("src" in j.attrMap) && t(j.attrMap.lang, Ce);
                }
                function K(j) {
                    return j === "block" || j === "list-item" || j.startsWith("table");
                }
                function Ee(j) {
                    return !K(j) && j !== "inline-block";
                }
                function q(j) {
                    return !K(j) && j !== "inline-block";
                }
                function le(j) {
                    return !K(j);
                }
                function ue(j) {
                    return !K(j);
                }
                function Q(j) {
                    return !K(j) && j !== "inline-block";
                }
                function de(j) {
                    return we(j).startsWith("pre");
                }
                function ge(j, Ce) {
                    let Ne = 0;
                    for(let je = j.stack.length - 1; je >= 0; je--){
                        let Ue = j.stack[je];
                        Ue && typeof Ue == "object" && !Array.isArray(Ue) && Ce(Ue) && Ne++;
                    }
                    return Ne;
                }
                function ve(j, Ce) {
                    let Ne = j;
                    for(; Ne;){
                        if (Ce(Ne)) return !0;
                        Ne = Ne.parent;
                    }
                    return !1;
                }
                function xe(j, Ce) {
                    if (j.prev && j.prev.type === "comment") {
                        let je = j.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
                        if (je) return je[1];
                    }
                    let Ne = !1;
                    if (j.type === "element" && j.namespace === "svg") {
                        if (ve(j, (je)=>je.fullName === "svg:foreignObject")) Ne = !0;
                        else return j.name === "svg" ? "inline-block" : "block";
                    }
                    switch(Ce.htmlWhitespaceSensitivity){
                        case "strict":
                            return "inline";
                        case "ignore":
                            return "block";
                        default:
                            return Ce.parser === "vue" && j.parent && j.parent.type === "root" ? "block" : j.type === "element" && (!j.namespace || Ne || p(j)) && l[j.name] || C;
                    }
                }
                function we(j) {
                    return j.type === "element" && (!j.namespace || p(j)) && m[j.name] || g;
                }
                function fe(j) {
                    let Ce = Number.POSITIVE_INFINITY;
                    for (let Ne of j.split(`
`)){
                        if (Ne.length === 0) continue;
                        if (!f.has(Ne[0])) return 0;
                        let je = B(Ne).length;
                        Ne.length !== je && je < Ce && (Ce = je);
                    }
                    return Ce === Number.POSITIVE_INFINITY ? 0 : Ce;
                }
                function pe(j) {
                    let Ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fe(j);
                    return Ce === 0 ? j : j.split(`
`).map((Ne)=>Ne.slice(Ce)).join(`
`);
                }
                function me(j, Ce) {
                    let Ne = 0;
                    for(let je = 0; je < j.length; je++)j[je] === Ce && Ne++;
                    return Ne;
                }
                function ce(j) {
                    return j.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                }
                var he = new Set([
                    "template",
                    "style",
                    "script"
                ]);
                function J(j, Ce) {
                    return ye(j, Ce) && !he.has(j.fullName);
                }
                function ye(j, Ce) {
                    return Ce.parser === "vue" && j.type === "element" && j.parent.type === "root" && j.fullName.toLowerCase() !== "html";
                }
                function X(j, Ce) {
                    return ye(j, Ce) && (J(j, Ce) || j.attrMap.lang && j.attrMap.lang !== "html");
                }
                function Y(j) {
                    let Ce = j.fullName;
                    return Ce.charAt(0) === "#" || Ce === "slot-scope" || Ce === "v-slot" || Ce.startsWith("v-slot:");
                }
                function te(j, Ce) {
                    let Ne = j.parent;
                    if (!ye(Ne, Ce)) return !1;
                    let je = Ne.fullName, Ue = j.fullName;
                    return je === "script" && Ue === "setup" || je === "style" && Ue === "vars";
                }
                function z(j) {
                    let Ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : j.value;
                    return j.parent.isWhitespaceSensitive ? j.parent.isIndentationSensitive ? c(Ce) : c(pe(b(Ce)), r) : a(u(i, v(Ce)));
                }
                n.exports = {
                    htmlTrim: T,
                    htmlTrimPreserveIndentation: b,
                    hasHtmlWhitespace: I,
                    getLeadingAndTrailingHtmlWhitespace: w,
                    canHaveInterpolation: x,
                    countChars: me,
                    countParents: ge,
                    dedentString: pe,
                    forceBreakChildren: H,
                    forceBreakContent: M,
                    forceNextEmptyLine: R,
                    getLastDescendant: U,
                    getNodeCssStyleDisplay: xe,
                    getNodeCssStyleWhiteSpace: we,
                    hasPrettierIgnore: D,
                    inferScriptParser: oe,
                    isVueCustomBlock: J,
                    isVueNonHtmlBlock: X,
                    isVueSlotAttribute: Y,
                    isVueSfcBindingsAttribute: te,
                    isDanglingSpaceSensitiveNode: O,
                    isIndentationSensitiveNode: S,
                    isLeadingSpaceSensitiveNode: k,
                    isPreLikeNode: de,
                    isScriptLikeTag: o,
                    isTextLikeNode: y,
                    isTrailingSpaceSensitiveNode: _,
                    isWhitespaceSensitiveNode: F,
                    isUnknownNamespace: p,
                    preferHardlineAsLeadingSpaces: P,
                    preferHardlineAsTrailingSpaces: G,
                    shouldPreserveContent: E,
                    unescapeQuoteEntities: ce,
                    getTextValueParts: z
                };
            }
        }), kd = Z({
            "node_modules/angular-html-parser/lib/compiler/src/chars.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
                function n(a) {
                    return a >= e.$TAB && a <= e.$SPACE || a == e.$NBSP;
                }
                e.isWhitespace = n;
                function t(a) {
                    return e.$0 <= a && a <= e.$9;
                }
                e.isDigit = t;
                function s(a) {
                    return a >= e.$a && a <= e.$z || a >= e.$A && a <= e.$Z;
                }
                e.isAsciiLetter = s;
                function i(a) {
                    return a >= e.$a && a <= e.$f || a >= e.$A && a <= e.$F || t(a);
                }
                e.isAsciiHexDigit = i;
                function r(a) {
                    return a === e.$LF || a === e.$CR;
                }
                e.isNewLine = r;
                function u(a) {
                    return e.$0 <= a && a <= e.$7;
                }
                e.isOctalDigit = u;
            }
        }), Ld = Z({
            "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = class {
                    constructor(s, i, r){
                        this.filePath = s, this.name = i, this.members = r;
                    }
                    assertNoMembers() {
                        if (this.members.length) throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
                    }
                };
                e.StaticSymbol = n;
                var t = class {
                    constructor(){
                        this.cache = new Map;
                    }
                    get(s, i, r) {
                        r = r || [];
                        let u = r.length ? ".".concat(r.join(".")) : "", a = '"'.concat(s, '".').concat(i).concat(u), c = this.cache.get(a);
                        return c || (c = new n(s, i, r), this.cache.set(a, c)), c;
                    }
                };
                e.StaticSymbolCache = t;
            }
        }), Od = Z({
            "node_modules/angular-html-parser/lib/compiler/src/util.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = /-+([a-z0-9])/g;
                function t(o) {
                    return o.replace(n, function() {
                        for(var x = arguments.length, F = new Array(x), S = 0; S < x; S++)F[S] = arguments[S];
                        return F[1].toUpperCase();
                    });
                }
                e.dashCaseToCamelCase = t;
                function s(o, x) {
                    return r(o, ":", x);
                }
                e.splitAtColon = s;
                function i(o, x) {
                    return r(o, ".", x);
                }
                e.splitAtPeriod = i;
                function r(o, x, F) {
                    let S = o.indexOf(x);
                    return S == -1 ? F : [
                        o.slice(0, S).trim(),
                        o.slice(S + 1).trim()
                    ];
                }
                function u(o, x, F) {
                    return Array.isArray(o) ? x.visitArray(o, F) : A(o) ? x.visitStringMap(o, F) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? x.visitPrimitive(o, F) : x.visitOther(o, F);
                }
                e.visitValue = u;
                function a(o) {
                    return o != null;
                }
                e.isDefined = a;
                function c(o) {
                    return o === void 0 ? null : o;
                }
                e.noUndefined = c;
                var l = class {
                    visitArray(o, x) {
                        return o.map((F)=>u(F, this, x));
                    }
                    visitStringMap(o, x) {
                        let F = {};
                        return Object.keys(o).forEach((S)=>{
                            F[S] = u(o[S], this, x);
                        }), F;
                    }
                    visitPrimitive(o, x) {
                        return o;
                    }
                    visitOther(o, x) {
                        return o;
                    }
                };
                e.ValueTransformer = l, e.SyncAsync = {
                    assertSync: (o)=>{
                        if (w(o)) throw new Error("Illegal state: value cannot be a promise");
                        return o;
                    },
                    then: (o, x)=>w(o) ? o.then(x) : x(o),
                    all: (o)=>o.some(w) ? Promise.all(o) : o
                };
                function C(o) {
                    throw new Error("Internal Error: ".concat(o));
                }
                e.error = C;
                function m(o, x) {
                    let F = Error(o);
                    return F[g] = !0, x && (F[p] = x), F;
                }
                e.syntaxError = m;
                var g = "ngSyntaxError", p = "ngParseErrors";
                function f(o) {
                    return o[g];
                }
                e.isSyntaxError = f;
                function h(o) {
                    return o[p] || [];
                }
                e.getParseErrors = h;
                function N(o) {
                    return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
                }
                e.escapeRegExp = N;
                var T = Object.getPrototypeOf({});
                function A(o) {
                    return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === T;
                }
                function b(o) {
                    let x = "";
                    for(let F = 0; F < o.length; F++){
                        let S = o.charCodeAt(F);
                        if (S >= 55296 && S <= 56319 && o.length > F + 1) {
                            let k = o.charCodeAt(F + 1);
                            k >= 56320 && k <= 57343 && (F++, S = (S - 55296 << 10) + k - 56320 + 65536);
                        }
                        S <= 127 ? x += String.fromCharCode(S) : S <= 2047 ? x += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? x += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (x += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
                    }
                    return x;
                }
                e.utf8Encode = b;
                function v(o) {
                    if (typeof o == "string") return o;
                    if (o instanceof Array) return "[" + o.map(v).join(", ") + "]";
                    if (o == null) return "" + o;
                    if (o.overriddenName) return "".concat(o.overriddenName);
                    if (o.name) return "".concat(o.name);
                    if (!o.toString) return "object";
                    let x = o.toString();
                    if (x == null) return "" + x;
                    let F = x.indexOf(`
`);
                    return F === -1 ? x : x.substring(0, F);
                }
                e.stringify = v;
                function B(o) {
                    return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
                }
                e.resolveForwardRef = B;
                function w(o) {
                    return !!o && typeof o.then == "function";
                }
                e.isPromise = w;
                var I = class {
                    constructor(o){
                        this.full = o;
                        let x = o.split(".");
                        this.major = x[0], this.minor = x[1], this.patch = x.slice(2).join(".");
                    }
                };
                e.Version = I;
                var E = typeof window < "u" && window, D = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, d = typeof globalThis < "u" && globalThis, y = d || E || D;
                e.global = y;
            }
        }), jd = Z({
            "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = Ld(), t = Od(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
                function i(F) {
                    return F.replace(/\W/g, "_");
                }
                e.sanitizeIdentifier = i;
                var r = 0;
                function u(F) {
                    if (!F || !F.reference) return null;
                    let S = F.reference;
                    if (S instanceof n.StaticSymbol) return S.name;
                    if (S.__anonymousType) return S.__anonymousType;
                    let k = t.stringify(S);
                    return k.indexOf("(") >= 0 ? (k = "anonymous_".concat(r++), S.__anonymousType = k) : k = i(k), k;
                }
                e.identifierName = u;
                function a(F) {
                    let S = F.reference;
                    return S instanceof n.StaticSymbol ? S.filePath : "./".concat(t.stringify(S));
                }
                e.identifierModuleUrl = a;
                function c(F, S) {
                    return "View_".concat(u({
                        reference: F
                    }), "_").concat(S);
                }
                e.viewClassName = c;
                function l(F) {
                    return "RenderType_".concat(u({
                        reference: F
                    }));
                }
                e.rendererTypeName = l;
                function C(F) {
                    return "HostView_".concat(u({
                        reference: F
                    }));
                }
                e.hostViewClassName = C;
                function m(F) {
                    return "".concat(u({
                        reference: F
                    }), "NgFactory");
                }
                e.componentFactoryName = m;
                var g;
                (function(F) {
                    F[F.Pipe = 0] = "Pipe", F[F.Directive = 1] = "Directive", F[F.NgModule = 2] = "NgModule", F[F.Injectable = 3] = "Injectable";
                })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
                function p(F) {
                    return F.value != null ? i(F.value) : u(F.identifier);
                }
                e.tokenName = p;
                function f(F) {
                    return F.identifier != null ? F.identifier.reference : F.value;
                }
                e.tokenReference = f;
                var h = class {
                    constructor(){
                        let { moduleUrl: F, styles: S, styleUrls: k } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                        this.moduleUrl = F || null, this.styles = w(S), this.styleUrls = w(k);
                    }
                };
                e.CompileStylesheetMetadata = h;
                var N = class {
                    constructor(F){
                        let { encapsulation: S, template: k, templateUrl: _, htmlAst: O, styles: R, styleUrls: M, externalStylesheets: H, animations: P, ngContentSelectors: G, interpolation: re, isInline: $, preserveWhitespaces: W } = F;
                        if (this.encapsulation = S, this.template = k, this.templateUrl = _, this.htmlAst = O, this.styles = w(R), this.styleUrls = w(M), this.externalStylesheets = w(H), this.animations = P ? E(P) : [], this.ngContentSelectors = G || [], re && re.length != 2) throw new Error("'interpolation' should have a start and an end symbol.");
                        this.interpolation = re, this.isInline = $, this.preserveWhitespaces = W;
                    }
                    toSummary() {
                        return {
                            ngContentSelectors: this.ngContentSelectors,
                            encapsulation: this.encapsulation,
                            styles: this.styles,
                            animations: this.animations
                        };
                    }
                };
                e.CompileTemplateMetadata = N;
                var T = class {
                    static create(F) {
                        let { isHost: S, type: k, isComponent: _, selector: O, exportAs: R, changeDetection: M, inputs: H, outputs: P, host: G, providers: re, viewProviders: $, queries: W, guards: ee, viewQueries: U, entryComponents: ne, template: se, componentViewType: V, rendererType: oe, componentFactory: K } = F, Ee = {}, q = {}, le = {};
                        G != null && Object.keys(G).forEach((de)=>{
                            let ge = G[de], ve = de.match(s);
                            ve === null ? le[de] = ge : ve[1] != null ? q[ve[1]] = ge : ve[2] != null && (Ee[ve[2]] = ge);
                        });
                        let ue = {};
                        H != null && H.forEach((de)=>{
                            let ge = t.splitAtColon(de, [
                                de,
                                de
                            ]);
                            ue[ge[0]] = ge[1];
                        });
                        let Q = {};
                        return P != null && P.forEach((de)=>{
                            let ge = t.splitAtColon(de, [
                                de,
                                de
                            ]);
                            Q[ge[0]] = ge[1];
                        }), new T({
                            isHost: S,
                            type: k,
                            isComponent: !!_,
                            selector: O,
                            exportAs: R,
                            changeDetection: M,
                            inputs: ue,
                            outputs: Q,
                            hostListeners: Ee,
                            hostProperties: q,
                            hostAttributes: le,
                            providers: re,
                            viewProviders: $,
                            queries: W,
                            guards: ee,
                            viewQueries: U,
                            entryComponents: ne,
                            template: se,
                            componentViewType: V,
                            rendererType: oe,
                            componentFactory: K
                        });
                    }
                    constructor(F){
                        let { isHost: S, type: k, isComponent: _, selector: O, exportAs: R, changeDetection: M, inputs: H, outputs: P, hostListeners: G, hostProperties: re, hostAttributes: $, providers: W, viewProviders: ee, queries: U, guards: ne, viewQueries: se, entryComponents: V, template: oe, componentViewType: K, rendererType: Ee, componentFactory: q } = F;
                        this.isHost = !!S, this.type = k, this.isComponent = _, this.selector = O, this.exportAs = R, this.changeDetection = M, this.inputs = H, this.outputs = P, this.hostListeners = G, this.hostProperties = re, this.hostAttributes = $, this.providers = w(W), this.viewProviders = w(ee), this.queries = w(U), this.guards = ne, this.viewQueries = w(se), this.entryComponents = w(V), this.template = oe, this.componentViewType = K, this.rendererType = Ee, this.componentFactory = q;
                    }
                    toSummary() {
                        return {
                            summaryKind: g.Directive,
                            type: this.type,
                            isComponent: this.isComponent,
                            selector: this.selector,
                            exportAs: this.exportAs,
                            inputs: this.inputs,
                            outputs: this.outputs,
                            hostListeners: this.hostListeners,
                            hostProperties: this.hostProperties,
                            hostAttributes: this.hostAttributes,
                            providers: this.providers,
                            viewProviders: this.viewProviders,
                            queries: this.queries,
                            guards: this.guards,
                            viewQueries: this.viewQueries,
                            entryComponents: this.entryComponents,
                            changeDetection: this.changeDetection,
                            template: this.template && this.template.toSummary(),
                            componentViewType: this.componentViewType,
                            rendererType: this.rendererType,
                            componentFactory: this.componentFactory
                        };
                    }
                };
                e.CompileDirectiveMetadata = T;
                var A = class {
                    constructor(F){
                        let { type: S, name: k, pure: _ } = F;
                        this.type = S, this.name = k, this.pure = !!_;
                    }
                    toSummary() {
                        return {
                            summaryKind: g.Pipe,
                            type: this.type,
                            name: this.name,
                            pure: this.pure
                        };
                    }
                };
                e.CompilePipeMetadata = A;
                var b = class {
                };
                e.CompileShallowModuleMetadata = b;
                var v = class {
                    constructor(F){
                        let { type: S, providers: k, declaredDirectives: _, exportedDirectives: O, declaredPipes: R, exportedPipes: M, entryComponents: H, bootstrapComponents: P, importedModules: G, exportedModules: re, schemas: $, transitiveModule: W, id: ee } = F;
                        this.type = S || null, this.declaredDirectives = w(_), this.exportedDirectives = w(O), this.declaredPipes = w(R), this.exportedPipes = w(M), this.providers = w(k), this.entryComponents = w(H), this.bootstrapComponents = w(P), this.importedModules = w(G), this.exportedModules = w(re), this.schemas = w($), this.id = ee || null, this.transitiveModule = W || null;
                    }
                    toSummary() {
                        let F = this.transitiveModule;
                        return {
                            summaryKind: g.NgModule,
                            type: this.type,
                            entryComponents: F.entryComponents,
                            providers: F.providers,
                            modules: F.modules,
                            exportedDirectives: F.exportedDirectives,
                            exportedPipes: F.exportedPipes
                        };
                    }
                };
                e.CompileNgModuleMetadata = v;
                var B = class {
                    constructor(){
                        this.directivesSet = new Set, this.directives = [], this.exportedDirectivesSet = new Set, this.exportedDirectives = [], this.pipesSet = new Set, this.pipes = [], this.exportedPipesSet = new Set, this.exportedPipes = [], this.modulesSet = new Set, this.modules = [], this.entryComponentsSet = new Set, this.entryComponents = [], this.providers = [];
                    }
                    addProvider(F, S) {
                        this.providers.push({
                            provider: F,
                            module: S
                        });
                    }
                    addDirective(F) {
                        this.directivesSet.has(F.reference) || (this.directivesSet.add(F.reference), this.directives.push(F));
                    }
                    addExportedDirective(F) {
                        this.exportedDirectivesSet.has(F.reference) || (this.exportedDirectivesSet.add(F.reference), this.exportedDirectives.push(F));
                    }
                    addPipe(F) {
                        this.pipesSet.has(F.reference) || (this.pipesSet.add(F.reference), this.pipes.push(F));
                    }
                    addExportedPipe(F) {
                        this.exportedPipesSet.has(F.reference) || (this.exportedPipesSet.add(F.reference), this.exportedPipes.push(F));
                    }
                    addModule(F) {
                        this.modulesSet.has(F.reference) || (this.modulesSet.add(F.reference), this.modules.push(F));
                    }
                    addEntryComponent(F) {
                        this.entryComponentsSet.has(F.componentType) || (this.entryComponentsSet.add(F.componentType), this.entryComponents.push(F));
                    }
                };
                e.TransitiveCompileNgModuleMetadata = B;
                function w(F) {
                    return F || [];
                }
                var I = class {
                    constructor(F, S){
                        let { useClass: k, useValue: _, useExisting: O, useFactory: R, deps: M, multi: H } = S;
                        this.token = F, this.useClass = k || null, this.useValue = _, this.useExisting = O, this.useFactory = R || null, this.dependencies = M || null, this.multi = !!H;
                    }
                };
                e.ProviderMeta = I;
                function E(F) {
                    return F.reduce((S, k)=>{
                        let _ = Array.isArray(k) ? E(k) : k;
                        return S.concat(_);
                    }, []);
                }
                e.flatten = E;
                function D(F) {
                    return F.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
                }
                function d(F, S, k) {
                    let _;
                    return k.isInline ? S.type.reference instanceof n.StaticSymbol ? _ = "".concat(S.type.reference.filePath, ".").concat(S.type.reference.name, ".html") : _ = "".concat(u(F), "/").concat(u(S.type), ".html") : _ = k.templateUrl, S.type.reference instanceof n.StaticSymbol ? _ : D(_);
                }
                e.templateSourceUrl = d;
                function y(F, S) {
                    let k = F.moduleUrl.split(/\/\\/g), _ = k[k.length - 1];
                    return D("css/".concat(S).concat(_, ".ngstyle.js"));
                }
                e.sharedStylesheetJitUrl = y;
                function o(F) {
                    return D("".concat(u(F.type), "/module.ngfactory.js"));
                }
                e.ngModuleJitUrl = o;
                function x(F, S) {
                    return D("".concat(u(F), "/").concat(u(S.type), ".ngfactory.js"));
                }
                e.templateJitUrl = x;
            }
        }), qd = Z({
            "node_modules/angular-html-parser/lib/compiler/src/parse_util.js" (e) {
                "use strict";
                ae(), Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var n = kd(), t = jd(), s = class {
                    constructor(C, m, g, p){
                        this.file = C, this.offset = m, this.line = g, this.col = p;
                    }
                    toString() {
                        return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
                    }
                    moveBy(C) {
                        let m = this.file.content, g = m.length, p = this.offset, f = this.line, h = this.col;
                        for(; p > 0 && C < 0;)if (p--, C++, m.charCodeAt(p) == n.$LF) {
                            f--;
                            let T = m.substr(0, p - 1).lastIndexOf(String.fromCharCode(n.$LF));
                            h = T > 0 ? p - T : p;
                        } else h--;
                        for(; p < g && C > 0;){
                            let N = m.charCodeAt(p);
                            p++, C--, N == n.$LF ? (f++, h = 0) : h++;
                        }
                        return new s(this.file, p, f, h);
                    }
                    getContext(C, m) {
                        let g = this.file.content, p = this.offset;
                        if (p != null) {
                            p > g.length - 1 && (p = g.length - 1);
                            let f = p, h = 0, N = 0;
                            for(; h < C && p > 0 && (p--, h++, !(g[p] == `
` && ++N == m)););
                            for(h = 0, N = 0; h < C && f < g.length - 1 && (f++, h++, !(g[f] == `
` && ++N == m)););
                            return {
                                before: g.substring(p, this.offset),
                                after: g.substring(this.offset, f + 1)
                            };
                        }
                        return null;
                    }
                };
                e.ParseLocation = s;
                var i = class {
                    constructor(C, m){
                        this.content = C, this.url = m;
                    }
                };
                e.ParseSourceFile = i;
                var r = class {
                    constructor(C, m){
                        let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                        this.start = C, this.end = m, this.details = g;
                    }
                    toString() {
                        return this.start.file.content.substring(this.start.offset, this.end.offset);
                    }
                };
                e.ParseSourceSpan = r, e.EMPTY_PARSE_LOCATION = new s(new i("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new r(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
                var u;
                (function(C) {
                    C[C.WARNING = 0] = "WARNING", C[C.ERROR = 1] = "ERROR";
                })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
                var a = class {
                    constructor(C, m){
                        let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
                        this.span = C, this.msg = m, this.level = g;
                    }
                    contextualMessage() {
                        let C = this.span.start.getContext(100, 3);
                        return C ? "".concat(this.msg, ' ("').concat(C.before, "[").concat(u[this.level], " ->]").concat(C.after, '")') : this.msg;
                    }
                    toString() {
                        let C = this.span.details ? ", ".concat(this.span.details) : "";
                        return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(C);
                    }
                };
                e.ParseError = a;
                function c(C, m) {
                    let g = t.identifierModuleUrl(m), p = g != null ? "in ".concat(C, " ").concat(t.identifierName(m), " in ").concat(g) : "in ".concat(C, " ").concat(t.identifierName(m)), f = new i("", p);
                    return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
                }
                e.typeSourceSpan = c;
                function l(C, m, g) {
                    let p = "in ".concat(C, " ").concat(m, " in ").concat(g), f = new i("", p);
                    return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
                }
                e.r3JitTypeSourceSpan = l;
            }
        }), Md = Z({
            "src/language-html/print-preprocess.js" (e, n) {
                "use strict";
                ae();
                var { ParseSourceSpan: t } = qd(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: i, hasHtmlWhitespace: r, canHaveInterpolation: u, getNodeCssStyleDisplay: a, isDanglingSpaceSensitiveNode: c, isIndentationSensitiveNode: l, isLeadingSpaceSensitiveNode: C, isTrailingSpaceSensitiveNode: m, isWhitespaceSensitiveNode: g } = Ot(), p = [
                    h,
                    N,
                    A,
                    v,
                    B,
                    E,
                    w,
                    I,
                    D,
                    b
                ];
                function f(d, y) {
                    for (let o of p)o(d, y);
                    return d;
                }
                function h(d) {
                    d.walk((y)=>{
                        if (y.type === "element" && y.tagDefinition.ignoreFirstLf && y.children.length > 0 && y.children[0].type === "text" && y.children[0].value[0] === `
`) {
                            let o = y.children[0];
                            o.value.length === 1 ? y.removeChild(o) : o.value = o.value.slice(1);
                        }
                    });
                }
                function N(d) {
                    let y = (o)=>o.type === "element" && o.prev && o.prev.type === "ieConditionalStartComment" && o.prev.sourceSpan.end.offset === o.startSourceSpan.start.offset && o.firstChild && o.firstChild.type === "ieConditionalEndComment" && o.firstChild.sourceSpan.start.offset === o.startSourceSpan.end.offset;
                    d.walk((o)=>{
                        if (o.children) for(let x = 0; x < o.children.length; x++){
                            let F = o.children[x];
                            if (!y(F)) continue;
                            let S = F.prev, k = F.firstChild;
                            o.removeChild(S), x--;
                            let _ = new t(S.sourceSpan.start, k.sourceSpan.end), O = new t(_.start, F.sourceSpan.end);
                            F.condition = S.condition, F.sourceSpan = O, F.startSourceSpan = _, F.removeChild(k);
                        }
                    });
                }
                function T(d, y, o) {
                    d.walk((x)=>{
                        if (x.children) for(let F = 0; F < x.children.length; F++){
                            let S = x.children[F];
                            if (S.type !== "text" && !y(S)) continue;
                            S.type !== "text" && (S.type = "text", S.value = o(S));
                            let k = S.prev;
                            !k || k.type !== "text" || (k.value += S.value, k.sourceSpan = new t(k.sourceSpan.start, S.sourceSpan.end), x.removeChild(S), F--);
                        }
                    });
                }
                function A(d) {
                    return T(d, (y)=>y.type === "cdata", (y)=>"<![CDATA[".concat(y.value, "]]>"));
                }
                function b(d) {
                    let y = (o)=>o.type === "element" && o.attrs.length === 0 && o.children.length === 1 && o.firstChild.type === "text" && !r(o.children[0].value) && !o.firstChild.hasLeadingSpaces && !o.firstChild.hasTrailingSpaces && o.isLeadingSpaceSensitive && !o.hasLeadingSpaces && o.isTrailingSpaceSensitive && !o.hasTrailingSpaces && o.prev && o.prev.type === "text" && o.next && o.next.type === "text";
                    d.walk((o)=>{
                        if (o.children) for(let x = 0; x < o.children.length; x++){
                            let F = o.children[x];
                            if (!y(F)) continue;
                            let S = F.prev, k = F.next;
                            S.value += "<".concat(F.rawName, ">") + F.firstChild.value + "</".concat(F.rawName, ">") + k.value, S.sourceSpan = new t(S.sourceSpan.start, k.sourceSpan.end), S.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, S.hasTrailingSpaces = k.hasTrailingSpaces, o.removeChild(F), x--, o.removeChild(k);
                        }
                    });
                }
                function v(d, y) {
                    if (y.parser === "html") return;
                    let o = /{{(.+?)}}/s;
                    d.walk((x)=>{
                        if (!!u(x)) for (let F of x.children){
                            if (F.type !== "text") continue;
                            let S = F.sourceSpan.start, k = null, _ = F.value.split(o);
                            for(let O = 0; O < _.length; O++, S = k){
                                let R = _[O];
                                if (O % 2 === 0) {
                                    k = S.moveBy(R.length), R.length > 0 && x.insertChildBefore(F, {
                                        type: "text",
                                        value: R,
                                        sourceSpan: new t(S, k)
                                    });
                                    continue;
                                }
                                k = S.moveBy(R.length + 4), x.insertChildBefore(F, {
                                    type: "interpolation",
                                    sourceSpan: new t(S, k),
                                    children: R.length === 0 ? [] : [
                                        {
                                            type: "text",
                                            value: R,
                                            sourceSpan: new t(S.moveBy(2), k.moveBy(-2))
                                        }
                                    ]
                                });
                            }
                            x.removeChild(F);
                        }
                    });
                }
                function B(d) {
                    d.walk((y)=>{
                        if (!y.children) return;
                        if (y.children.length === 0 || y.children.length === 1 && y.children[0].type === "text" && s(y.children[0].value).length === 0) {
                            y.hasDanglingSpaces = y.children.length > 0, y.children = [];
                            return;
                        }
                        let o = g(y), x = l(y);
                        if (!o) for(let F = 0; F < y.children.length; F++){
                            let S = y.children[F];
                            if (S.type !== "text") continue;
                            let { leadingWhitespace: k, text: _, trailingWhitespace: O } = i(S.value), R = S.prev, M = S.next;
                            _ ? (S.value = _, S.sourceSpan = new t(S.sourceSpan.start.moveBy(k.length), S.sourceSpan.end.moveBy(-O.length)), k && (R && (R.hasTrailingSpaces = !0), S.hasLeadingSpaces = !0), O && (S.hasTrailingSpaces = !0, M && (M.hasLeadingSpaces = !0))) : (y.removeChild(S), F--, (k || O) && (R && (R.hasTrailingSpaces = !0), M && (M.hasLeadingSpaces = !0)));
                        }
                        y.isWhitespaceSensitive = o, y.isIndentationSensitive = x;
                    });
                }
                function w(d) {
                    d.walk((y)=>{
                        y.isSelfClosing = !y.children || y.type === "element" && (y.tagDefinition.isVoid || y.startSourceSpan === y.endSourceSpan);
                    });
                }
                function I(d, y) {
                    d.walk((o)=>{
                        o.type === "element" && (o.hasHtmComponentClosingTag = o.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(y.originalText.slice(o.endSourceSpan.start.offset, o.endSourceSpan.end.offset)));
                    });
                }
                function E(d, y) {
                    d.walk((o)=>{
                        o.cssDisplay = a(o, y);
                    });
                }
                function D(d, y) {
                    d.walk((o)=>{
                        let { children: x } = o;
                        if (!!x) {
                            if (x.length === 0) {
                                o.isDanglingSpaceSensitive = c(o);
                                return;
                            }
                            for (let F of x)F.isLeadingSpaceSensitive = C(F, y), F.isTrailingSpaceSensitive = m(F, y);
                            for(let F = 0; F < x.length; F++){
                                let S = x[F];
                                S.isLeadingSpaceSensitive = (F === 0 || S.prev.isTrailingSpaceSensitive) && S.isLeadingSpaceSensitive, S.isTrailingSpaceSensitive = (F === x.length - 1 || S.next.isLeadingSpaceSensitive) && S.isTrailingSpaceSensitive;
                            }
                        }
                    });
                }
                n.exports = f;
            }
        }), Rd = Z({
            "src/language-html/pragma.js" (e, n) {
                "use strict";
                ae();
                function t(i) {
                    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(i);
                }
                function s(i) {
                    return `<!-- @format -->

` + i.replace(/^\s*\n/, "");
                }
                n.exports = {
                    hasPragma: t,
                    insertPragma: s
                };
            }
        }), Yn = Z({
            "src/language-html/loc.js" (e, n) {
                "use strict";
                ae();
                function t(i) {
                    return i.sourceSpan.start.offset;
                }
                function s(i) {
                    return i.sourceSpan.end.offset;
                }
                n.exports = {
                    locStart: t,
                    locEnd: s
                };
            }
        }), Qt = Z({
            "src/language-html/print/tag.js" (e, n) {
                "use strict";
                ae();
                var t = Ut(), { isNonEmptyArray: s } = Ge(), { builders: { indent: i, join: r, line: u, softline: a, hardline: c }, utils: { replaceTextEndOfLine: l } } = Le(), { locStart: C, locEnd: m } = Yn(), { isTextLikeNode: g, getLastDescendant: p, isPreLikeNode: f, hasPrettierIgnore: h, shouldPreserveContent: N } = Ot();
                function T(P, G) {
                    return [
                        P.isSelfClosing ? "" : A(P, G),
                        b(P, G)
                    ];
                }
                function A(P, G) {
                    return P.lastChild && y(P.lastChild) ? "" : [
                        v(P, G),
                        w(P, G)
                    ];
                }
                function b(P, G) {
                    return (P.next ? D(P.next) : d(P.parent)) ? "" : [
                        I(P, G),
                        B(P, G)
                    ];
                }
                function v(P, G) {
                    return d(P) ? I(P.lastChild, G) : "";
                }
                function B(P, G) {
                    return y(P) ? w(P.parent, G) : o(P) ? M(P.next) : "";
                }
                function w(P, G) {
                    if (t(!P.isSelfClosing), E(P, G)) return "";
                    switch(P.type){
                        case "ieConditionalComment":
                            return "<!";
                        case "element":
                            if (P.hasHtmComponentClosingTag) return "<//";
                        default:
                            return "</".concat(P.rawName);
                    }
                }
                function I(P, G) {
                    if (E(P, G)) return "";
                    switch(P.type){
                        case "ieConditionalComment":
                        case "ieConditionalEndComment":
                            return "[endif]-->";
                        case "ieConditionalStartComment":
                            return "]><!-->";
                        case "interpolation":
                            return "}}";
                        case "element":
                            if (P.isSelfClosing) return "/>";
                        default:
                            return ">";
                    }
                }
                function E(P, G) {
                    return !P.isSelfClosing && !P.endSourceSpan && (h(P) || N(P.parent, G));
                }
                function D(P) {
                    return P.prev && P.prev.type !== "docType" && !g(P.prev) && P.isLeadingSpaceSensitive && !P.hasLeadingSpaces;
                }
                function d(P) {
                    return P.lastChild && P.lastChild.isTrailingSpaceSensitive && !P.lastChild.hasTrailingSpaces && !g(p(P.lastChild)) && !f(P);
                }
                function y(P) {
                    return !P.next && !P.hasTrailingSpaces && P.isTrailingSpaceSensitive && g(p(P));
                }
                function o(P) {
                    return P.next && !g(P.next) && g(P) && P.isTrailingSpaceSensitive && !P.hasTrailingSpaces;
                }
                function x(P) {
                    let G = P.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
                    return G ? G[1] ? G[1].split(/\s+/) : !0 : !1;
                }
                function F(P) {
                    return !P.prev && P.isLeadingSpaceSensitive && !P.hasLeadingSpaces;
                }
                function S(P, G, re) {
                    let $ = P.getValue();
                    if (!s($.attrs)) return $.isSelfClosing ? " " : "";
                    let W = $.prev && $.prev.type === "comment" && x($.prev.value), ee = typeof W == "boolean" ? ()=>W : Array.isArray(W) ? (oe)=>W.includes(oe.rawName) : ()=>!1, U = P.map((oe)=>{
                        let K = oe.getValue();
                        return ee(K) ? l(G.originalText.slice(C(K), m(K))) : re();
                    }, "attrs"), ne = $.type === "element" && $.fullName === "script" && $.attrs.length === 1 && $.attrs[0].fullName === "src" && $.children.length === 0, se = G.singleAttributePerLine && $.attrs.length > 1 ? c : u, V = [
                        i([
                            ne ? " " : u,
                            r(se, U)
                        ])
                    ];
                    return $.firstChild && F($.firstChild) || $.isSelfClosing && d($.parent) || ne ? V.push($.isSelfClosing ? " " : "") : V.push(G.bracketSameLine ? $.isSelfClosing ? " " : "" : $.isSelfClosing ? u : a), V;
                }
                function k(P) {
                    return P.firstChild && F(P.firstChild) ? "" : H(P);
                }
                function _(P, G, re) {
                    let $ = P.getValue();
                    return [
                        O($, G),
                        S(P, G, re),
                        $.isSelfClosing ? "" : k($)
                    ];
                }
                function O(P, G) {
                    return P.prev && o(P.prev) ? "" : [
                        R(P, G),
                        M(P)
                    ];
                }
                function R(P, G) {
                    return F(P) ? H(P.parent) : D(P) ? I(P.prev, G) : "";
                }
                function M(P) {
                    switch(P.type){
                        case "ieConditionalComment":
                        case "ieConditionalStartComment":
                            return "<!--[if ".concat(P.condition);
                        case "ieConditionalEndComment":
                            return "<!--<!";
                        case "interpolation":
                            return "{{";
                        case "docType":
                            return "<!DOCTYPE";
                        case "element":
                            if (P.condition) return "<!--[if ".concat(P.condition, "]><!--><").concat(P.rawName);
                        default:
                            return "<".concat(P.rawName);
                    }
                }
                function H(P) {
                    switch(t(!P.isSelfClosing), P.type){
                        case "ieConditionalComment":
                            return "]>";
                        case "element":
                            if (P.condition) return "><!--<![endif]-->";
                        default:
                            return ">";
                    }
                }
                n.exports = {
                    printClosingTag: T,
                    printClosingTagStart: A,
                    printClosingTagStartMarker: w,
                    printClosingTagEndMarker: I,
                    printClosingTagSuffix: B,
                    printClosingTagEnd: b,
                    needsToBorrowLastChildClosingTagEndMarker: d,
                    needsToBorrowParentClosingTagStartMarker: y,
                    needsToBorrowPrevClosingTagEndMarker: D,
                    printOpeningTag: _,
                    printOpeningTagStart: O,
                    printOpeningTagPrefix: R,
                    printOpeningTagStartMarker: M,
                    printOpeningTagEndMarker: H,
                    needsToBorrowNextOpeningTagStartMarker: o,
                    needsToBorrowParentOpeningTagEndMarker: F
                };
            }
        }), Vd = Z({
            "node_modules/parse-srcset/src/parse-srcset.js" (e, n) {
                ae(), function(t, s) {
                    typeof define == "function" && define.amd ? define([], s) : typeof n == "object" && n.exports ? n.exports = s() : t.parseSrcset = s();
                }(e, function() {
                    return function(t, s) {
                        var i = s && s.logger || console;
                        function r(I) {
                            return I === " " || I === "	" || I === `
` || I === "\f" || I === "\r";
                        }
                        function u(I) {
                            var E, D = I.exec(t.substring(b));
                            if (D) return E = D[0], b += E.length, E;
                        }
                        for(var a = t.length, c = /^[ \t\n\r\u000c]+/, l = /^[, \t\n\r\u000c]+/, C = /^[^ \t\n\r\u000c]+/, m = /[,]+$/, g = /^\d+$/, p = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, h, N, T, A, b = 0, v = [];;){
                            if (u(l), b >= a) return v;
                            f = u(C), h = [], f.slice(-1) === "," ? (f = f.replace(m, ""), w()) : B();
                        }
                        function B() {
                            for(u(c), N = "", T = "in descriptor";;){
                                if (A = t.charAt(b), T === "in descriptor") {
                                    if (r(A)) N && (h.push(N), N = "", T = "after descriptor");
                                    else if (A === ",") {
                                        b += 1, N && h.push(N), w();
                                        return;
                                    } else if (A === "(") N = N + A, T = "in parens";
                                    else if (A === "") {
                                        N && h.push(N), w();
                                        return;
                                    } else N = N + A;
                                } else if (T === "in parens") {
                                    if (A === ")") N = N + A, T = "in descriptor";
                                    else if (A === "") {
                                        h.push(N), w();
                                        return;
                                    } else N = N + A;
                                } else if (T === "after descriptor" && !r(A)) {
                                    if (A === "") {
                                        w();
                                        return;
                                    } else T = "in descriptor", b -= 1;
                                }
                                b += 1;
                            }
                        }
                        function w() {
                            var I = !1, E, D, d, y, o = {}, x, F, S, k, _;
                            for(y = 0; y < h.length; y++)x = h[y], F = x[x.length - 1], S = x.substring(0, x.length - 1), k = parseInt(S, 10), _ = parseFloat(S), g.test(S) && F === "w" ? ((E || D) && (I = !0), k === 0 ? I = !0 : E = k) : p.test(S) && F === "x" ? ((E || D || d) && (I = !0), _ < 0 ? I = !0 : D = _) : g.test(S) && F === "h" ? ((d || D) && (I = !0), k === 0 ? I = !0 : d = k) : I = !0;
                            I ? i && i.error && i.error("Invalid srcset descriptor found in '" + t + "' at '" + x + "'.") : (o.url = f, E && (o.w = E), D && (o.d = D), d && (o.h = d), v.push(o));
                        }
                    };
                });
            }
        }), Wd = Z({
            "src/language-html/syntax-attribute.js" (e, n) {
                "use strict";
                ae();
                var t = Vd(), { builders: { ifBreak: s, join: i, line: r } } = Le();
                function u(c) {
                    let l = t(c, {
                        logger: {
                            error (B) {
                                throw new Error(B);
                            }
                        }
                    }), C = l.some((B)=>{
                        let { w } = B;
                        return w;
                    }), m = l.some((B)=>{
                        let { h: w } = B;
                        return w;
                    }), g = l.some((B)=>{
                        let { d: w } = B;
                        return w;
                    });
                    if (C + m + g > 1) throw new Error("Mixed descriptor in srcset is not supported");
                    let p = C ? "w" : m ? "h" : "d", f = C ? "w" : m ? "h" : "x", h = (B)=>Math.max(...B), N = l.map((B)=>B.url), T = h(N.map((B)=>B.length)), A = l.map((B)=>B[p]).map((B)=>B ? B.toString() : ""), b = A.map((B)=>{
                        let w = B.indexOf(".");
                        return w === -1 ? B.length : w;
                    }), v = h(b);
                    return i([
                        ",",
                        r
                    ], N.map((B, w)=>{
                        let I = [
                            B
                        ], E = A[w];
                        if (E) {
                            let D = T - B.length + 1, d = v - b[w], y = " ".repeat(D + d);
                            I.push(s(y, " "), E + f);
                        }
                        return I;
                    }));
                }
                function a(c) {
                    return c.trim().split(/\s+/).join(" ");
                }
                n.exports = {
                    printImgSrcset: u,
                    printClassNames: a
                };
            }
        }), $d = Z({
            "src/language-html/syntax-vue.js" (e, n) {
                "use strict";
                ae();
                var { builders: { group: t } } = Le();
                function s(a, c) {
                    let { left: l, operator: C, right: m } = i(a);
                    return [
                        t(c("function _(".concat(l, ") {}"), {
                            parser: "babel",
                            __isVueForBindingLeft: !0
                        })),
                        " ",
                        C,
                        " ",
                        c(m, {
                            parser: "__js_expression"
                        }, {
                            stripTrailingHardline: !0
                        })
                    ];
                }
                function i(a) {
                    let c = /(.*?)\s+(in|of)\s+(.*)/s, l = /,([^,\]}]*)(?:,([^,\]}]*))?$/, C = /^\(|\)$/g, m = a.match(c);
                    if (!m) return;
                    let g = {};
                    if (g.for = m[3].trim(), !g.for) return;
                    let p = m[1].trim().replace(C, ""), f = p.match(l);
                    f ? (g.alias = p.replace(l, ""), g.iterator1 = f[1].trim(), f[2] && (g.iterator2 = f[2].trim())) : g.alias = p;
                    let h = [
                        g.alias,
                        g.iterator1,
                        g.iterator2
                    ];
                    if (!h.some((N, T)=>!N && (T === 0 || h.slice(T + 1).some(Boolean)))) return {
                        left: h.filter(Boolean).join(","),
                        operator: m[2],
                        right: g.for
                    };
                }
                function r(a, c) {
                    return c("function _(".concat(a, ") {}"), {
                        parser: "babel",
                        __isVueBindings: !0
                    });
                }
                function u(a) {
                    let c = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, l = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, C = a.trim();
                    return c.test(C) || l.test(C);
                }
                n.exports = {
                    isVueEventBindingExpression: u,
                    printVueFor: s,
                    printVueBindings: r
                };
            }
        }), mo = Z({
            "src/language-html/get-node-content.js" (e, n) {
                "use strict";
                ae();
                var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: i, printClosingTagEndMarker: r, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: a } = Qt();
                function c(l, C) {
                    let m = l.startSourceSpan.end.offset;
                    l.firstChild && u(l.firstChild) && (m -= a(l).length);
                    let g = l.endSourceSpan.start.offset;
                    return l.lastChild && t(l.lastChild) ? g += s(l, C).length : i(l) && (g -= r(l.lastChild, C).length), C.originalText.slice(m, g);
                }
                n.exports = c;
            }
        }), Hd = Z({
            "src/language-html/embed.js" (e, n) {
                "use strict";
                ae();
                var { builders: { breakParent: t, group: s, hardline: i, indent: r, line: u, fill: a, softline: c }, utils: { mapDoc: l, replaceTextEndOfLine: C } } = Le(), m = Xn(), { printClosingTag: g, printClosingTagSuffix: p, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: h, printOpeningTag: N } = Qt(), { printImgSrcset: T, printClassNames: A } = Wd(), { printVueFor: b, printVueBindings: v, isVueEventBindingExpression: B } = $d(), { isScriptLikeTag: w, isVueNonHtmlBlock: I, inferScriptParser: E, htmlTrimPreserveIndentation: D, dedentString: d, unescapeQuoteEntities: y, isVueSlotAttribute: o, isVueSfcBindingsAttribute: x, getTextValueParts: F } = Ot(), S = mo();
                function k(O, R, M) {
                    let H = (ne)=>new RegExp(ne.join("|")).test(O.fullName), P = ()=>y(O.value), G = !1, re = (ne, se)=>{
                        let V = ne.type === "NGRoot" ? ne.node.type === "NGMicrosyntax" && ne.node.body.length === 1 && ne.node.body[0].type === "NGMicrosyntaxExpression" ? ne.node.body[0].expression : ne.node : ne.type === "JsExpressionRoot" ? ne.node : ne;
                        V && (V.type === "ObjectExpression" || V.type === "ArrayExpression" || se.parser === "__vue_expression" && (V.type === "TemplateLiteral" || V.type === "StringLiteral")) && (G = !0);
                    }, $ = (ne)=>s(ne), W = function(ne) {
                        let se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
                        return s([
                            r([
                                c,
                                ne
                            ]),
                            se ? c : ""
                        ]);
                    }, ee = (ne)=>G ? $(ne) : W(ne), U = (ne, se)=>R(ne, Object.assign({
                            __onHtmlBindingRoot: re,
                            __embeddedInHtml: !0
                        }, se));
                    if (O.fullName === "srcset" && (O.parent.fullName === "img" || O.parent.fullName === "source")) return W(T(P()));
                    if (O.fullName === "class" && !M.parentParser) {
                        let ne = P();
                        if (!ne.includes("{{")) return A(ne);
                    }
                    if (O.fullName === "style" && !M.parentParser) {
                        let ne = P();
                        if (!ne.includes("{{")) return W(U(ne, {
                            parser: "css",
                            __isHTMLStyleAttribute: !0
                        }));
                    }
                    if (M.parser === "vue") {
                        if (O.fullName === "v-for") return b(P(), U);
                        if (o(O) || x(O, M)) return v(P(), U);
                        let ne = [
                            "^@",
                            "^v-on:"
                        ], se = [
                            "^:",
                            "^v-bind:"
                        ], V = [
                            "^v-"
                        ];
                        if (H(ne)) {
                            let oe = P();
                            return ee(U(oe, {
                                parser: B(oe) ? "__js_expression" : "__vue_event_binding"
                            }));
                        }
                        if (H(se)) return ee(U(P(), {
                            parser: "__vue_expression"
                        }));
                        if (H(V)) return ee(U(P(), {
                            parser: "__js_expression"
                        }));
                    }
                    if (M.parser === "angular") {
                        let ne = (le, ue)=>U(le, Object.assign(Object.assign({}, ue), {}, {
                                trailingComma: "none"
                            })), se = [
                            "^\\*"
                        ], V = [
                            "^\\(.+\\)$",
                            "^on-"
                        ], oe = [
                            "^\\[.+\\]$",
                            "^bind(on)?-",
                            "^ng-(if|show|hide|class|style)$"
                        ], K = [
                            "^i18n(-.+)?$"
                        ];
                        if (H(V)) return ee(ne(P(), {
                            parser: "__ng_action"
                        }));
                        if (H(oe)) return ee(ne(P(), {
                            parser: "__ng_binding"
                        }));
                        if (H(K)) {
                            let le = P().trim();
                            return W(a(F(O, le)), !le.includes("@@"));
                        }
                        if (H(se)) return ee(ne(P(), {
                            parser: "__ng_directive"
                        }));
                        let Ee = /{{(.+?)}}/s, q = P();
                        if (Ee.test(q)) {
                            let le = [];
                            for (let [ue, Q] of q.split(Ee).entries())if (ue % 2 === 0) le.push(C(Q));
                            else try {
                                le.push(s([
                                    "{{",
                                    r([
                                        u,
                                        ne(Q, {
                                            parser: "__ng_interpolation",
                                            __isInHtmlInterpolation: !0
                                        })
                                    ]),
                                    u,
                                    "}}"
                                ]));
                            } catch  {
                                le.push("{{", C(Q), "}}");
                            }
                            return s(le);
                        }
                    }
                    return null;
                }
                function _(O, R, M, H) {
                    let P = O.getValue();
                    switch(P.type){
                        case "element":
                            if (w(P) || P.type === "interpolation") return;
                            if (!P.isSelfClosing && I(P, H)) {
                                let G = E(P, H);
                                if (!G) return;
                                let re = S(P, H), $ = /^\s*$/.test(re), W = "";
                                return $ || (W = M(D(re), {
                                    parser: G,
                                    __embeddedInHtml: !0
                                }, {
                                    stripTrailingHardline: !0
                                }), $ = W === ""), [
                                    h(P, H),
                                    s(N(O, H, R)),
                                    $ ? "" : i,
                                    W,
                                    $ ? "" : i,
                                    g(P, H),
                                    p(P, H)
                                ];
                            }
                            break;
                        case "text":
                            if (w(P.parent)) {
                                let G = E(P.parent);
                                if (G) {
                                    let re = G === "markdown" ? d(P.value.replace(/^[^\S\n]*\n/, "")) : P.value, $ = {
                                        parser: G,
                                        __embeddedInHtml: !0
                                    };
                                    if (H.parser === "html" && G === "babel") {
                                        let W = "script", { attrMap: ee } = P.parent;
                                        ee && (ee.type === "module" || ee.type === "text/babel" && ee["data-type"] === "module") && (W = "module"), $.__babelSourceType = W;
                                    }
                                    return [
                                        t,
                                        h(P, H),
                                        M(re, $, {
                                            stripTrailingHardline: !0
                                        }),
                                        p(P, H)
                                    ];
                                }
                            } else if (P.parent.type === "interpolation") {
                                let G = {
                                    __isInHtmlInterpolation: !0,
                                    __embeddedInHtml: !0
                                };
                                return H.parser === "angular" ? (G.parser = "__ng_interpolation", G.trailingComma = "none") : H.parser === "vue" ? G.parser = "__vue_expression" : G.parser = "__js_expression", [
                                    r([
                                        u,
                                        M(P.value, G, {
                                            stripTrailingHardline: !0
                                        })
                                    ]),
                                    P.parent.next && f(P.parent.next) ? " " : u
                                ];
                            }
                            break;
                        case "attribute":
                            {
                                if (!P.value) break;
                                if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(H.originalText.slice(P.valueSpan.start.offset, P.valueSpan.end.offset))) return [
                                    P.rawName,
                                    "=",
                                    P.value
                                ];
                                if (H.parser === "lwc" && /^{.*}$/s.test(H.originalText.slice(P.valueSpan.start.offset, P.valueSpan.end.offset))) return [
                                    P.rawName,
                                    "=",
                                    P.value
                                ];
                                let G = k(P, (re, $)=>M(re, Object.assign({
                                        __isInHtmlAttribute: !0,
                                        __embeddedInHtml: !0
                                    }, $), {
                                        stripTrailingHardline: !0
                                    }), H);
                                if (G) return [
                                    P.rawName,
                                    '="',
                                    s(l(G, (re)=>typeof re == "string" ? re.replace(/"/g, "&quot;") : re)),
                                    '"'
                                ];
                                break;
                            }
                        case "front-matter":
                            return m(P, M);
                    }
                }
                n.exports = _;
            }
        }), go = Z({
            "src/language-html/print/children.js" (e, n) {
                "use strict";
                ae();
                var { builders: { breakParent: t, group: s, ifBreak: i, line: r, softline: u, hardline: a }, utils: { replaceTextEndOfLine: c } } = Le(), { locStart: l, locEnd: C } = Yn(), { forceBreakChildren: m, forceNextEmptyLine: g, isTextLikeNode: p, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: h } = Ot(), { printOpeningTagPrefix: N, needsToBorrowNextOpeningTagStartMarker: T, printOpeningTagStartMarker: A, needsToBorrowPrevClosingTagEndMarker: b, printClosingTagEndMarker: v, printClosingTagSuffix: B, needsToBorrowParentClosingTagStartMarker: w } = Qt();
                function I(d, y, o) {
                    let x = d.getValue();
                    return f(x) ? [
                        N(x, y),
                        ...c(y.originalText.slice(l(x) + (x.prev && T(x.prev) ? A(x).length : 0), C(x) - (x.next && b(x.next) ? v(x, y).length : 0))),
                        B(x, y)
                    ] : o();
                }
                function E(d, y) {
                    return p(d) && p(y) ? d.isTrailingSpaceSensitive ? d.hasTrailingSpaces ? h(y) ? a : r : "" : h(y) ? a : u : T(d) && (f(y) || y.firstChild || y.isSelfClosing || y.type === "element" && y.attrs.length > 0) || d.type === "element" && d.isSelfClosing && b(y) ? "" : !y.isLeadingSpaceSensitive || h(y) || b(y) && d.lastChild && w(d.lastChild) && d.lastChild.lastChild && w(d.lastChild.lastChild) ? a : y.hasLeadingSpaces ? r : u;
                }
                function D(d, y, o) {
                    let x = d.getValue();
                    if (m(x)) return [
                        t,
                        ...d.map((S)=>{
                            let k = S.getValue(), _ = k.prev ? E(k.prev, k) : "";
                            return [
                                _ ? [
                                    _,
                                    g(k.prev) ? a : ""
                                ] : "",
                                I(S, y, o)
                            ];
                        }, "children")
                    ];
                    let F = x.children.map(()=>Symbol(""));
                    return d.map((S, k)=>{
                        let _ = S.getValue();
                        if (p(_)) {
                            if (_.prev && p(_.prev)) {
                                let re = E(_.prev, _);
                                if (re) return g(_.prev) ? [
                                    a,
                                    a,
                                    I(S, y, o)
                                ] : [
                                    re,
                                    I(S, y, o)
                                ];
                            }
                            return I(S, y, o);
                        }
                        let O = [], R = [], M = [], H = [], P = _.prev ? E(_.prev, _) : "", G = _.next ? E(_, _.next) : "";
                        return P && (g(_.prev) ? O.push(a, a) : P === a ? O.push(a) : p(_.prev) ? R.push(P) : R.push(i("", u, {
                            groupId: F[k - 1]
                        }))), G && (g(_) ? p(_.next) && H.push(a, a) : G === a ? p(_.next) && H.push(a) : M.push(G)), [
                            ...O,
                            s([
                                ...R,
                                s([
                                    I(S, y, o),
                                    ...M
                                ], {
                                    id: F[k]
                                })
                            ]),
                            ...H
                        ];
                    }, "children");
                }
                n.exports = {
                    printChildren: D
                };
            }
        }), Gd = Z({
            "src/language-html/print/element.js" (e, n) {
                "use strict";
                ae();
                var { builders: { breakParent: t, dedentToRoot: s, group: i, ifBreak: r, indentIfBreak: u, indent: a, line: c, softline: l }, utils: { replaceTextEndOfLine: C } } = Le(), m = mo(), { shouldPreserveContent: g, isScriptLikeTag: p, isVueCustomBlock: f, countParents: h, forceBreakContent: N } = Ot(), { printOpeningTagPrefix: T, printOpeningTag: A, printClosingTagSuffix: b, printClosingTag: v, needsToBorrowPrevClosingTagEndMarker: B, needsToBorrowLastChildClosingTagEndMarker: w } = Qt(), { printChildren: I } = go();
                function E(D, d, y) {
                    let o = D.getValue();
                    if (g(o, d)) return [
                        T(o, d),
                        i(A(D, d, y)),
                        ...C(m(o, d)),
                        ...v(o, d),
                        b(o, d)
                    ];
                    let x = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, F = Symbol("element-attr-group-id"), S = (R)=>i([
                            i(A(D, d, y), {
                                id: F
                            }),
                            R,
                            v(o, d)
                        ]), k = (R)=>x ? u(R, {
                            groupId: F
                        }) : (p(o) || f(o, d)) && o.parent.type === "root" && d.parser === "vue" && !d.vueIndentScriptAndStyle ? R : a(R), _ = ()=>x ? r(l, "", {
                            groupId: F
                        }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? c : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(l) : l, O = ()=>(o.next ? B(o.next) : w(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : x ? r(l, "", {
                            groupId: F
                        }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? c : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(d.tabWidth * h(D, (M)=>M.parent && M.parent.type !== "root"), "}$")).test(o.lastChild.value) ? "" : l;
                    return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? c : "") : S([
                        N(o) ? t : "",
                        k([
                            _(),
                            I(D, d, y)
                        ]),
                        O()
                    ]);
                }
                n.exports = {
                    printElement: E
                };
            }
        }), Jd = Z({
            "src/language-html/printer-html.js" (e, n) {
                "use strict";
                ae();
                var { builders: { fill: t, group: s, hardline: i, literalline: r }, utils: { cleanDoc: u, getDocParts: a, isConcat: c, replaceTextEndOfLine: l } } = Le(), C = _d(), { countChars: m, unescapeQuoteEntities: g, getTextValueParts: p } = Ot(), f = Md(), { insertPragma: h } = Rd(), { locStart: N, locEnd: T } = Yn(), A = Hd(), { printClosingTagSuffix: b, printClosingTagEnd: v, printOpeningTagPrefix: B, printOpeningTagStart: w } = Qt(), { printElement: I } = Gd(), { printChildren: E } = go();
                function D(d, y, o) {
                    let x = d.getValue();
                    switch(x.type){
                        case "front-matter":
                            return l(x.raw);
                        case "root":
                            return y.__onHtmlRoot && y.__onHtmlRoot(x), [
                                s(E(d, y, o)),
                                i
                            ];
                        case "element":
                        case "ieConditionalComment":
                            return I(d, y, o);
                        case "ieConditionalStartComment":
                        case "ieConditionalEndComment":
                            return [
                                w(x),
                                v(x)
                            ];
                        case "interpolation":
                            return [
                                w(x, y),
                                ...d.map(o, "children"),
                                v(x, y)
                            ];
                        case "text":
                            {
                                if (x.parent.type === "interpolation") {
                                    let S = /\n[^\S\n]*$/, k = S.test(x.value), _ = k ? x.value.replace(S, "") : x.value;
                                    return [
                                        ...l(_),
                                        k ? i : ""
                                    ];
                                }
                                let F = u([
                                    B(x, y),
                                    ...p(x),
                                    b(x, y)
                                ]);
                                return c(F) || F.type === "fill" ? t(a(F)) : F;
                            }
                        case "docType":
                            return [
                                s([
                                    w(x, y),
                                    " ",
                                    x.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")
                                ]),
                                v(x, y)
                            ];
                        case "comment":
                            return [
                                B(x, y),
                                ...l(y.originalText.slice(N(x), T(x)), r),
                                b(x, y)
                            ];
                        case "attribute":
                            {
                                if (x.value === null) return x.rawName;
                                let F = g(x.value), S = m(F, "'"), k = m(F, '"'), _ = S < k ? "'" : '"';
                                return [
                                    x.rawName,
                                    "=",
                                    _,
                                    ...l(_ === '"' ? F.replace(/"/g, "&quot;") : F.replace(/'/g, "&apos;")),
                                    _
                                ];
                            }
                        default:
                            throw new Error("Unexpected node type ".concat(x.type));
                    }
                }
                n.exports = {
                    preprocess: f,
                    print: D,
                    insertPragma: h,
                    massageAstNode: C,
                    embed: A
                };
            }
        }), Ud = Z({
            "src/language-html/options.js" (e, n) {
                "use strict";
                ae();
                var t = Lt(), s = "HTML";
                n.exports = {
                    bracketSameLine: t.bracketSameLine,
                    htmlWhitespaceSensitivity: {
                        since: "1.15.0",
                        category: s,
                        type: "choice",
                        default: "css",
                        description: "How to handle whitespaces in HTML.",
                        choices: [
                            {
                                value: "css",
                                description: "Respect the default value of CSS display property."
                            },
                            {
                                value: "strict",
                                description: "Whitespaces are considered sensitive."
                            },
                            {
                                value: "ignore",
                                description: "Whitespaces are considered insensitive."
                            }
                        ]
                    },
                    singleAttributePerLine: t.singleAttributePerLine,
                    vueIndentScriptAndStyle: {
                        since: "1.19.0",
                        category: s,
                        type: "boolean",
                        default: !1,
                        description: "Indent script and style tags in Vue files."
                    }
                };
            }
        }), zd = Z({
            "src/language-html/parsers.js" () {
                ae();
            }
        }), An = Z({
            "node_modules/linguist-languages/data/HTML.json" (e, n) {
                n.exports = {
                    name: "HTML",
                    type: "markup",
                    tmScope: "text.html.basic",
                    aceMode: "html",
                    codemirrorMode: "htmlmixed",
                    codemirrorMimeType: "text/html",
                    color: "#e34c26",
                    aliases: [
                        "xhtml"
                    ],
                    extensions: [
                        ".html",
                        ".htm",
                        ".html.hl",
                        ".inc",
                        ".xht",
                        ".xhtml"
                    ],
                    languageId: 146
                };
            }
        }), Xd = Z({
            "node_modules/linguist-languages/data/Vue.json" (e, n) {
                n.exports = {
                    name: "Vue",
                    type: "markup",
                    color: "#41b883",
                    extensions: [
                        ".vue"
                    ],
                    tmScope: "text.html.vue",
                    aceMode: "html",
                    languageId: 391
                };
            }
        }), Kd = Z({
            "src/language-html/index.js" (e, n) {
                "use strict";
                ae();
                var t = bt(), s = Jd(), i = Ud(), r = zd(), u = [
                    t(An(), ()=>({
                            name: "Angular",
                            since: "1.15.0",
                            parsers: [
                                "angular"
                            ],
                            vscodeLanguageIds: [
                                "html"
                            ],
                            extensions: [
                                ".component.html"
                            ],
                            filenames: []
                        })),
                    t(An(), (c)=>({
                            since: "1.15.0",
                            parsers: [
                                "html"
                            ],
                            vscodeLanguageIds: [
                                "html"
                            ],
                            extensions: [
                                ...c.extensions,
                                ".mjml"
                            ]
                        })),
                    t(An(), ()=>({
                            name: "Lightning Web Components",
                            since: "1.17.0",
                            parsers: [
                                "lwc"
                            ],
                            vscodeLanguageIds: [
                                "html"
                            ],
                            extensions: [],
                            filenames: []
                        })),
                    t(Xd(), ()=>({
                            since: "1.10.0",
                            parsers: [
                                "vue"
                            ],
                            vscodeLanguageIds: [
                                "vue"
                            ]
                        }))
                ], a = {
                    html: s
                };
                n.exports = {
                    languages: u,
                    printers: a,
                    options: i,
                    parsers: r
                };
            }
        }), Yd = Z({
            "src/language-yaml/pragma.js" (e, n) {
                "use strict";
                ae();
                function t(r) {
                    return /^\s*@(?:prettier|format)\s*$/.test(r);
                }
                function s(r) {
                    return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(r);
                }
                function i(r) {
                    return `# @format

`.concat(r);
                }
                n.exports = {
                    isPragma: t,
                    hasPragma: s,
                    insertPragma: i
                };
            }
        }), Qd = Z({
            "src/language-yaml/loc.js" (e, n) {
                "use strict";
                ae();
                function t(i) {
                    return i.position.start.offset;
                }
                function s(i) {
                    return i.position.end.offset;
                }
                n.exports = {
                    locStart: t,
                    locEnd: s
                };
            }
        }), Zd = Z({
            "src/language-yaml/embed.js" (e, n) {
                "use strict";
                ae();
                function t(s, i, r, u) {
                    if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(u.filepath)) return r(u.originalText, Object.assign(Object.assign({}, u), {}, {
                        parser: "json"
                    }));
                }
                n.exports = t;
            }
        }), jt = Z({
            "src/language-yaml/utils.js" (e, n) {
                "use strict";
                ae();
                var { getLast: t, isNonEmptyArray: s } = Ge();
                function i(E, D) {
                    let d = 0, y = E.stack.length - 1;
                    for(let o = 0; o < y; o++){
                        let x = E.stack[o];
                        r(x) && D(x) && d++;
                    }
                    return d;
                }
                function r(E, D) {
                    return E && typeof E.type == "string" && (!D || D.includes(E.type));
                }
                function u(E, D, d) {
                    return D("children" in E ? Object.assign(Object.assign({}, E), {}, {
                        children: E.children.map((y)=>u(y, D, E))
                    }) : E, d);
                }
                function a(E, D, d) {
                    Object.defineProperty(E, D, {
                        get: d,
                        enumerable: !1
                    });
                }
                function c(E, D) {
                    let d = 0, y = D.length;
                    for(let o = E.position.end.offset - 1; o < y; o++){
                        let x = D[o];
                        if (x === `
` && d++, d === 1 && /\S/.test(x)) return !1;
                        if (d === 2) return !0;
                    }
                    return !1;
                }
                function l(E) {
                    switch(E.getValue().type){
                        case "tag":
                        case "anchor":
                        case "comment":
                            return !1;
                    }
                    let d = E.stack.length;
                    for(let y = 1; y < d; y++){
                        let o = E.stack[y], x = E.stack[y - 1];
                        if (Array.isArray(x) && typeof o == "number" && o !== x.length - 1) return !1;
                    }
                    return !0;
                }
                function C(E) {
                    return s(E.children) ? C(t(E.children)) : E;
                }
                function m(E) {
                    return E.value.trim() === "prettier-ignore";
                }
                function g(E) {
                    let D = E.getValue();
                    if (D.type === "documentBody") {
                        let d = E.getParentNode();
                        return b(d.head) && m(t(d.head.endComments));
                    }
                    return h(D) && m(t(D.leadingComments));
                }
                function p(E) {
                    return !s(E.children) && !f(E);
                }
                function f(E) {
                    return h(E) || N(E) || T(E) || A(E) || b(E);
                }
                function h(E) {
                    return E && s(E.leadingComments);
                }
                function N(E) {
                    return E && s(E.middleComments);
                }
                function T(E) {
                    return E && E.indicatorComment;
                }
                function A(E) {
                    return E && E.trailingComment;
                }
                function b(E) {
                    return E && s(E.endComments);
                }
                function v(E) {
                    let D = [], d;
                    for (let y of E.split(/( +)/))y !== " " ? d === " " ? D.push(y) : D.push((D.pop() || "") + y) : d === void 0 && D.unshift(""), d = y;
                    return d === " " && D.push((D.pop() || "") + " "), D[0] === "" && (D.shift(), D.unshift(" " + (D.shift() || ""))), D;
                }
                function B(E, D, d) {
                    let y = D.split(`
`).map((o, x, F)=>x === 0 && x === F.length - 1 ? o : x !== 0 && x !== F.length - 1 ? o.trim() : x === 0 ? o.trimEnd() : o.trimStart());
                    return d.proseWrap === "preserve" ? y.map((o)=>o.length === 0 ? [] : [
                            o
                        ]) : y.map((o)=>o.length === 0 ? [] : v(o)).reduce((o, x, F)=>F !== 0 && y[F - 1].length > 0 && x.length > 0 && !(E === "quoteDouble" && t(t(o)).endsWith("\\")) ? [
                            ...o.slice(0, -1),
                            [
                                ...t(o),
                                ...x
                            ]
                        ] : [
                            ...o,
                            x
                        ], []).map((o)=>d.proseWrap === "never" ? [
                            o.join(" ")
                        ] : o);
                }
                function w(E, D) {
                    let { parentIndent: d, isLastDescendant: y, options: o } = D, x = E.position.start.line === E.position.end.line ? "" : o.originalText.slice(E.position.start.offset, E.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], F;
                    if (E.indent === null) {
                        let _ = x.match(/^(?<leadingSpace> *)[^\n\r ]/m);
                        F = _ ? _.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
                    } else F = E.indent - 1 + d;
                    let S = x.split(`
`).map((_)=>_.slice(F));
                    if (o.proseWrap === "preserve" || E.type === "blockLiteral") return k(S.map((_)=>_.length === 0 ? [] : [
                            _
                        ]));
                    return k(S.map((_)=>_.length === 0 ? [] : v(_)).reduce((_, O, R)=>R !== 0 && S[R - 1].length > 0 && O.length > 0 && !/^\s/.test(O[0]) && !/^\s|\s$/.test(t(_)) ? [
                            ..._.slice(0, -1),
                            [
                                ...t(_),
                                ...O
                            ]
                        ] : [
                            ..._,
                            O
                        ], []).map((_)=>_.reduce((O, R)=>O.length > 0 && /\s$/.test(t(O)) ? [
                                ...O.slice(0, -1),
                                t(O) + " " + R
                            ] : [
                                ...O,
                                R
                            ], [])).map((_)=>o.proseWrap === "never" ? [
                            _.join(" ")
                        ] : _));
                    function k(_) {
                        if (E.chomping === "keep") return t(_).length === 0 ? _.slice(0, -1) : _;
                        let O = 0;
                        for(let R = _.length - 1; R >= 0 && _[R].length === 0; R--)O++;
                        return O === 0 ? _ : O >= 2 && !y ? _.slice(0, -(O - 1)) : _.slice(0, -O);
                    }
                }
                function I(E) {
                    if (!E) return !0;
                    switch(E.type){
                        case "plain":
                        case "quoteDouble":
                        case "quoteSingle":
                        case "alias":
                        case "flowMapping":
                        case "flowSequence":
                            return !0;
                        default:
                            return !1;
                    }
                }
                n.exports = {
                    getLast: t,
                    getAncestorCount: i,
                    isNode: r,
                    isEmptyNode: p,
                    isInlineNode: I,
                    mapNode: u,
                    defineShortcut: a,
                    isNextLineEmpty: c,
                    isLastDescendantNode: l,
                    getBlockValueLineContents: w,
                    getFlowScalarLineContents: B,
                    getLastDescendantNode: C,
                    hasPrettierIgnore: g,
                    hasLeadingComments: h,
                    hasMiddleComments: N,
                    hasIndicatorComment: T,
                    hasTrailingComment: A,
                    hasEndComments: b
                };
            }
        }), eg = Z({
            "src/language-yaml/print-preprocess.js" (e, n) {
                "use strict";
                ae();
                var { defineShortcut: t, mapNode: s } = jt();
                function i(u) {
                    return s(u, r);
                }
                function r(u) {
                    switch(u.type){
                        case "document":
                            t(u, "head", ()=>u.children[0]), t(u, "body", ()=>u.children[1]);
                            break;
                        case "documentBody":
                        case "sequenceItem":
                        case "flowSequenceItem":
                        case "mappingKey":
                        case "mappingValue":
                            t(u, "content", ()=>u.children[0]);
                            break;
                        case "mappingItem":
                        case "flowMappingItem":
                            t(u, "key", ()=>u.children[0]), t(u, "value", ()=>u.children[1]);
                            break;
                    }
                    return u;
                }
                n.exports = i;
            }
        }), kr = Z({
            "src/language-yaml/print/misc.js" (e, n) {
                "use strict";
                ae();
                var { builders: { softline: t, align: s } } = Le(), { hasEndComments: i, isNextLineEmpty: r, isNode: u } = jt(), a = new WeakMap;
                function c(m, g) {
                    let p = m.getValue(), f = m.stack[0], h;
                    return a.has(f) ? h = a.get(f) : (h = new Set, a.set(f, h)), !h.has(p.position.end.line) && (h.add(p.position.end.line), r(p, g) && !l(m.getParentNode())) ? t : "";
                }
                function l(m) {
                    return i(m) && !u(m, [
                        "documentHead",
                        "documentBody",
                        "flowMapping",
                        "flowSequence"
                    ]);
                }
                function C(m, g) {
                    return s(" ".repeat(m), g);
                }
                n.exports = {
                    alignWithSpaces: C,
                    shouldPrintEndComments: l,
                    printNextEmptyLine: c
                };
            }
        }), tg = Z({
            "src/language-yaml/print/flow-mapping-sequence.js" (e, n) {
                "use strict";
                ae();
                var { builders: { ifBreak: t, line: s, softline: i, hardline: r, join: u } } = Le(), { isEmptyNode: a, getLast: c, hasEndComments: l } = jt(), { printNextEmptyLine: C, alignWithSpaces: m } = kr();
                function g(f, h, N) {
                    let T = f.getValue(), A = T.type === "flowMapping", b = A ? "{" : "[", v = A ? "}" : "]", B = i;
                    A && T.children.length > 0 && N.bracketSpacing && (B = s);
                    let w = c(T.children), I = w && w.type === "flowMappingItem" && a(w.key) && a(w.value);
                    return [
                        b,
                        m(N.tabWidth, [
                            B,
                            p(f, h, N),
                            N.trailingComma === "none" ? "" : t(","),
                            l(T) ? [
                                r,
                                u(r, f.map(h, "endComments"))
                            ] : ""
                        ]),
                        I ? "" : B,
                        v
                    ];
                }
                function p(f, h, N) {
                    let T = f.getValue();
                    return f.map((b, v)=>[
                            h(),
                            v === T.children.length - 1 ? "" : [
                                ",",
                                s,
                                T.children[v].position.start.line !== T.children[v + 1].position.start.line ? C(b, N.originalText) : ""
                            ]
                        ], "children");
                }
                n.exports = {
                    printFlowMapping: g,
                    printFlowSequence: g
                };
            }
        }), rg = Z({
            "src/language-yaml/print/mapping-item.js" (e, n) {
                "use strict";
                ae();
                var { builders: { conditionalGroup: t, group: s, hardline: i, ifBreak: r, join: u, line: a } } = Le(), { hasLeadingComments: c, hasMiddleComments: l, hasTrailingComment: C, hasEndComments: m, isNode: g, isEmptyNode: p, isInlineNode: f } = jt(), { alignWithSpaces: h } = kr();
                function N(v, B, w, I, E) {
                    let { key: D, value: d } = v, y = p(D), o = p(d);
                    if (y && o) return ": ";
                    let x = I("key"), F = A(v) ? " " : "";
                    if (o) return v.type === "flowMappingItem" && B.type === "flowMapping" ? x : v.type === "mappingItem" && T(D.content, E) && !C(D.content) && (!B.tag || B.tag.value !== "tag:yaml.org,2002:set") ? [
                        x,
                        F,
                        ":"
                    ] : [
                        "? ",
                        h(2, x)
                    ];
                    let S = I("value");
                    if (y) return [
                        ": ",
                        h(2, S)
                    ];
                    if (c(d) || !f(D.content)) return [
                        "? ",
                        h(2, x),
                        i,
                        u("", w.map(I, "value", "leadingComments").map((H)=>[
                                H,
                                i
                            ])),
                        ": ",
                        h(2, S)
                    ];
                    if (b(D.content) && !c(D.content) && !l(D.content) && !C(D.content) && !m(D) && !c(d.content) && !l(d.content) && !m(d) && T(d.content, E)) return [
                        x,
                        F,
                        ": ",
                        S
                    ];
                    let k = Symbol("mappingKey"), _ = s([
                        r("? "),
                        s(h(2, x), {
                            id: k
                        })
                    ]), O = [
                        i,
                        ": ",
                        h(2, S)
                    ], R = [
                        F,
                        ":"
                    ];
                    c(d.content) || m(d) && d.content && !g(d.content, [
                        "mapping",
                        "sequence"
                    ]) || B.type === "mapping" && C(D.content) && f(d.content) || g(d.content, [
                        "mapping",
                        "sequence"
                    ]) && d.content.tag === null && d.content.anchor === null ? R.push(i) : d.content && R.push(a), R.push(S);
                    let M = h(E.tabWidth, R);
                    return T(D.content, E) && !c(D.content) && !l(D.content) && !m(D) ? t([
                        [
                            x,
                            M
                        ]
                    ]) : t([
                        [
                            _,
                            r(O, M, {
                                groupId: k
                            })
                        ]
                    ]);
                }
                function T(v, B) {
                    if (!v) return !0;
                    switch(v.type){
                        case "plain":
                        case "quoteSingle":
                        case "quoteDouble":
                            break;
                        case "alias":
                            return !0;
                        default:
                            return !1;
                    }
                    if (B.proseWrap === "preserve") return v.position.start.line === v.position.end.line;
                    if (/\\$/m.test(B.originalText.slice(v.position.start.offset, v.position.end.offset))) return !1;
                    switch(B.proseWrap){
                        case "never":
                            return !v.value.includes(`
`);
                        case "always":
                            return !/[\n ]/.test(v.value);
                        default:
                            return !1;
                    }
                }
                function A(v) {
                    return v.key.content && v.key.content.type === "alias";
                }
                function b(v) {
                    if (!v) return !0;
                    switch(v.type){
                        case "plain":
                        case "quoteDouble":
                        case "quoteSingle":
                            return v.position.start.line === v.position.end.line;
                        case "alias":
                            return !0;
                        default:
                            return !1;
                    }
                }
                n.exports = N;
            }
        }), ng = Z({
            "src/language-yaml/print/block.js" (e, n) {
                "use strict";
                ae();
                var { builders: { dedent: t, dedentToRoot: s, fill: i, hardline: r, join: u, line: a, literalline: c, markAsRoot: l }, utils: { getDocParts: C } } = Le(), { getAncestorCount: m, getBlockValueLineContents: g, hasIndicatorComment: p, isLastDescendantNode: f, isNode: h } = jt(), { alignWithSpaces: N } = kr();
                function T(A, b, v) {
                    let B = A.getValue(), w = m(A, (y)=>h(y, [
                            "sequence",
                            "mapping"
                        ])), I = f(A), E = [
                        B.type === "blockFolded" ? ">" : "|"
                    ];
                    B.indent !== null && E.push(B.indent.toString()), B.chomping !== "clip" && E.push(B.chomping === "keep" ? "+" : "-"), p(B) && E.push(" ", b("indicatorComment"));
                    let D = g(B, {
                        parentIndent: w,
                        isLastDescendant: I,
                        options: v
                    }), d = [];
                    for (let [y, o] of D.entries())y === 0 && d.push(r), d.push(i(C(u(a, o)))), y !== D.length - 1 ? d.push(o.length === 0 ? r : l(c)) : B.chomping === "keep" && I && d.push(s(o.length === 0 ? r : c));
                    return B.indent === null ? E.push(t(N(v.tabWidth, d))) : E.push(s(N(B.indent - 1 + w, d))), E;
                }
                n.exports = T;
            }
        }), ug = Z({
            "src/language-yaml/printer-yaml.js" (e, n) {
                "use strict";
                ae();
                var { builders: { breakParent: t, fill: s, group: i, hardline: r, join: u, line: a, lineSuffix: c, literalline: l }, utils: { getDocParts: C, replaceTextEndOfLine: m } } = Le(), { isPreviousLineEmpty: g } = Ge(), { insertPragma: p, isPragma: f } = Yd(), { locStart: h } = Qd(), N = Zd(), { getFlowScalarLineContents: T, getLastDescendantNode: A, hasLeadingComments: b, hasMiddleComments: v, hasTrailingComment: B, hasEndComments: w, hasPrettierIgnore: I, isLastDescendantNode: E, isNode: D, isInlineNode: d } = jt(), y = eg(), { alignWithSpaces: o, printNextEmptyLine: x, shouldPrintEndComments: F } = kr(), { printFlowMapping: S, printFlowSequence: k } = tg(), _ = rg(), O = ng();
                function R(W, ee, U) {
                    let ne = W.getValue(), se = [];
                    ne.type !== "mappingValue" && b(ne) && se.push([
                        u(r, W.map(U, "leadingComments")),
                        r
                    ]);
                    let { tag: V, anchor: oe } = ne;
                    V && se.push(U("tag")), V && oe && se.push(" "), oe && se.push(U("anchor"));
                    let K = "";
                    D(ne, [
                        "mapping",
                        "sequence",
                        "comment",
                        "directive",
                        "mappingItem",
                        "sequenceItem"
                    ]) && !E(W) && (K = x(W, ee.originalText)), (V || oe) && (D(ne, [
                        "sequence",
                        "mapping"
                    ]) && !v(ne) ? se.push(r) : se.push(" ")), v(ne) && se.push([
                        ne.middleComments.length === 1 ? "" : r,
                        u(r, W.map(U, "middleComments")),
                        r
                    ]);
                    let Ee = W.getParentNode();
                    return I(W) ? se.push(m(ee.originalText.slice(ne.position.start.offset, ne.position.end.offset).trimEnd(), l)) : se.push(i(M(ne, Ee, W, ee, U))), B(ne) && !D(ne, [
                        "document",
                        "documentHead"
                    ]) && se.push(c([
                        ne.type === "mappingValue" && !ne.content ? "" : " ",
                        Ee.type === "mappingKey" && W.getParentNode(2).type === "mapping" && d(ne) ? "" : t,
                        U("trailingComment")
                    ])), F(ne) && se.push(o(ne.type === "sequenceItem" ? 2 : 0, [
                        r,
                        u(r, W.map((q)=>[
                                g(ee.originalText, q.getValue(), h) ? r : "",
                                U()
                            ], "endComments"))
                    ])), se.push(K), se;
                }
                function M(W, ee, U, ne, se) {
                    switch(W.type){
                        case "root":
                            {
                                let { children: V } = W, oe = [];
                                U.each((Ee, q)=>{
                                    let le = V[q], ue = V[q + 1];
                                    q !== 0 && oe.push(r), oe.push(se()), P(le, ue) ? (oe.push(r, "..."), B(le) && oe.push(" ", se("trailingComment"))) : ue && !B(ue.head) && oe.push(r, "---");
                                }, "children");
                                let K = A(W);
                                return (!D(K, [
                                    "blockLiteral",
                                    "blockFolded"
                                ]) || K.chomping !== "keep") && oe.push(r), oe;
                            }
                        case "document":
                            {
                                let V = ee.children[U.getName() + 1], oe = [];
                                return G(W, V, ee, ne) === "head" && ((W.head.children.length > 0 || W.head.endComments.length > 0) && oe.push(se("head")), B(W.head) ? oe.push([
                                    "---",
                                    " ",
                                    se([
                                        "head",
                                        "trailingComment"
                                    ])
                                ]) : oe.push("---")), H(W) && oe.push(se("body")), u(r, oe);
                            }
                        case "documentHead":
                            return u(r, [
                                ...U.map(se, "children"),
                                ...U.map(se, "endComments")
                            ]);
                        case "documentBody":
                            {
                                let { children: V, endComments: oe } = W, K = "";
                                if (V.length > 0 && oe.length > 0) {
                                    let Ee = A(W);
                                    D(Ee, [
                                        "blockFolded",
                                        "blockLiteral"
                                    ]) ? Ee.chomping !== "keep" && (K = [
                                        r,
                                        r
                                    ]) : K = r;
                                }
                                return [
                                    u(r, U.map(se, "children")),
                                    K,
                                    u(r, U.map(se, "endComments"))
                                ];
                            }
                        case "directive":
                            return [
                                "%",
                                u(" ", [
                                    W.name,
                                    ...W.parameters
                                ])
                            ];
                        case "comment":
                            return [
                                "#",
                                W.value
                            ];
                        case "alias":
                            return [
                                "*",
                                W.value
                            ];
                        case "tag":
                            return ne.originalText.slice(W.position.start.offset, W.position.end.offset);
                        case "anchor":
                            return [
                                "&",
                                W.value
                            ];
                        case "plain":
                            return re(W.type, ne.originalText.slice(W.position.start.offset, W.position.end.offset), ne);
                        case "quoteDouble":
                        case "quoteSingle":
                            {
                                let V = "'", oe = '"', K = ne.originalText.slice(W.position.start.offset + 1, W.position.end.offset - 1);
                                if (W.type === "quoteSingle" && K.includes("\\") || W.type === "quoteDouble" && /\\[^"]/.test(K)) {
                                    let q = W.type === "quoteDouble" ? oe : V;
                                    return [
                                        q,
                                        re(W.type, K, ne),
                                        q
                                    ];
                                }
                                if (K.includes(oe)) return [
                                    V,
                                    re(W.type, W.type === "quoteDouble" ? K.replace(/\\"/g, oe).replace(/'/g, V.repeat(2)) : K, ne),
                                    V
                                ];
                                if (K.includes(V)) return [
                                    oe,
                                    re(W.type, W.type === "quoteSingle" ? K.replace(/''/g, V) : K, ne),
                                    oe
                                ];
                                let Ee = ne.singleQuote ? V : oe;
                                return [
                                    Ee,
                                    re(W.type, K, ne),
                                    Ee
                                ];
                            }
                        case "blockFolded":
                        case "blockLiteral":
                            return O(U, se, ne);
                        case "mapping":
                        case "sequence":
                            return u(r, U.map(se, "children"));
                        case "sequenceItem":
                            return [
                                "- ",
                                o(2, W.content ? se("content") : "")
                            ];
                        case "mappingKey":
                        case "mappingValue":
                            return W.content ? se("content") : "";
                        case "mappingItem":
                        case "flowMappingItem":
                            return _(W, ee, U, se, ne);
                        case "flowMapping":
                            return S(U, se, ne);
                        case "flowSequence":
                            return k(U, se, ne);
                        case "flowSequenceItem":
                            return se("content");
                        default:
                            throw new Error("Unexpected node type ".concat(W.type));
                    }
                }
                function H(W) {
                    return W.body.children.length > 0 || w(W.body);
                }
                function P(W, ee) {
                    return B(W) || ee && (ee.head.children.length > 0 || w(ee.head));
                }
                function G(W, ee, U, ne) {
                    return U.children[0] === W && /---(?:\s|$)/.test(ne.originalText.slice(h(W), h(W) + 4)) || W.head.children.length > 0 || w(W.head) || B(W.head) ? "head" : P(W, ee) ? !1 : ee ? "root" : !1;
                }
                function re(W, ee, U) {
                    let ne = T(W, ee, U);
                    return u(r, ne.map((se)=>s(C(u(a, se)))));
                }
                function $(W, ee) {
                    if (D(ee)) switch(delete ee.position, ee.type){
                        case "comment":
                            if (f(ee.value)) return null;
                            break;
                        case "quoteDouble":
                        case "quoteSingle":
                            ee.type = "quote";
                            break;
                    }
                }
                n.exports = {
                    preprocess: y,
                    embed: N,
                    print: R,
                    massageAstNode: $,
                    insertPragma: p
                };
            }
        }), sg = Z({
            "src/language-yaml/options.js" (e, n) {
                "use strict";
                ae();
                var t = Lt();
                n.exports = {
                    bracketSpacing: t.bracketSpacing,
                    singleQuote: t.singleQuote,
                    proseWrap: t.proseWrap
                };
            }
        }), ag = Z({
            "src/language-yaml/parsers.js" () {
                ae();
            }
        }), ig = Z({
            "node_modules/linguist-languages/data/YAML.json" (e, n) {
                n.exports = {
                    name: "YAML",
                    type: "data",
                    color: "#cb171e",
                    tmScope: "source.yaml",
                    aliases: [
                        "yml"
                    ],
                    extensions: [
                        ".yml",
                        ".mir",
                        ".reek",
                        ".rviz",
                        ".sublime-syntax",
                        ".syntax",
                        ".yaml",
                        ".yaml-tmlanguage",
                        ".yaml.sed",
                        ".yml.mysql"
                    ],
                    filenames: [
                        ".clang-format",
                        ".clang-tidy",
                        ".gemrc",
                        "glide.lock",
                        "yarn.lock"
                    ],
                    aceMode: "yaml",
                    codemirrorMode: "yaml",
                    codemirrorMimeType: "text/x-yaml",
                    languageId: 407
                };
            }
        }), og = Z({
            "src/language-yaml/index.js" (e, n) {
                "use strict";
                ae();
                var t = bt(), s = ug(), i = sg(), r = ag(), u = [
                    t(ig(), (a)=>({
                            since: "1.14.0",
                            parsers: [
                                "yaml"
                            ],
                            vscodeLanguageIds: [
                                "yaml",
                                "ansible",
                                "home-assistant"
                            ],
                            filenames: [
                                ...a.filenames.filter((c)=>c !== "yarn.lock"),
                                ".prettierrc",
                                ".stylelintrc"
                            ]
                        }))
                ];
                n.exports = {
                    languages: u,
                    printers: {
                        yaml: s
                    },
                    options: i,
                    parsers: r
                };
            }
        }), cg = Z({
            "src/languages.js" (e, n) {
                "use strict";
                ae(), n.exports = [
                    $m(),
                    id(),
                    dd(),
                    Fd(),
                    wd(),
                    Kd(),
                    og()
                ];
            }
        });
        ae();
        var { version: lg } = gi(), _t = om(), { getSupportInfo: pg } = Mn(), fg = cm(), Dg = cg(), mg = Le();
        function St(e) {
            let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return function() {
                for(var t = arguments.length, s = new Array(t), i = 0; i < t; i++)s[i] = arguments[i];
                let r = s[n] || {}, u = r.plugins || [];
                return s[n] = Object.assign(Object.assign({}, r), {}, {
                    plugins: [
                        ...Dg,
                        ...Array.isArray(u) ? u : Object.values(u)
                    ]
                }), e(...s);
            };
        }
        var Sn = St(_t.formatWithCursor);
        yo.exports = {
            formatWithCursor: Sn,
            format (e, n) {
                return Sn(e, n).formatted;
            },
            check (e, n) {
                let { formatted: t } = Sn(e, n);
                return t === e;
            },
            doc: mg,
            getSupportInfo: St(pg, 0),
            version: lg,
            util: fg,
            __debug: {
                parse: St(_t.parse),
                formatAST: St(_t.formatAST),
                formatDoc: St(_t.formatDoc),
                printToDoc: St(_t.printToDoc),
                printDocToString: St(_t.printDocToString)
            }
        };
    });
    "use strict";
    return dg();
});

},{}],"cxSZo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _headerDefault.default));
var _header = require("./Header");
parcelHelpers.exportAll(_header, exports);
var _headerDefault = parcelHelpers.interopDefault(_header);

},{"./Header":"8iwn3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8iwn3":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$a077 = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$a077.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxDevRuntime = require("react/jsx-dev-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
function Header() {
    return /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("header", {
        children: /*#__PURE__*/ (0, _jsxDevRuntime.jsxDEV)("h1", {
            children: "Word Game - Husna"
        }, void 0, false, {
            fileName: "src/components/Header/Header.js",
            lineNumber: 6,
            columnNumber: 7
        }, this)
    }, void 0, false, {
        fileName: "src/components/Header/Header.js",
        lineNumber: 5,
        columnNumber: 5
    }, this);
}
_c = Header;
exports.default = Header;
var _c;
$RefreshReg$(_c, "Header");

  $parcel$ReactRefreshHelpers$a077.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-dev-runtime":"iTorj","react":"21dqq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"km3Ru"}],"8XPx9":[function() {},{}],"lW6qc":[function() {},{}]},["farZc","1xC6H","8lqZg"], "8lqZg", "parcelRequire2844")

//# sourceMappingURL=index.975ef6c8.js.map
